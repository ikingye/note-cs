'use strict';(function(){const indexCfg={cache:true};indexCfg.doc={id:'id',field:['title','content'],store:['title','href'],};const index=FlexSearch.create('balance',indexCfg);window.bookSearchIndex=index;index.add({'id':0,'href':'/note-cs/docs/domain/cc/container/docker/image/alpine/','title':"alpine",'content':"alpine 安装 telnet apk add busybox-extras\n"});index.add({'id':1,'href':'/note-cs/docs/domain/cc/container/docker/','title':"Docker",'content':"Docker 基础 docker 资源  docker container ls：默认只列出正在运行的容器，-a 选项会列出包括停止的所有容器。 docker image ls：列出镜像信息，-a 选项会列出 intermediate 镜像 (就是其它镜像依赖的层)。 docker volume ls：列出数据卷。 docker network ls：列出 network。 docker info：显示系统级别的信息，比如容器和镜像的数量等。  清理 docker 资源 删除那些已停止的容器、dangling 镜像、未被容器引用的 network 和构建过程中的 cache\ndocker system prune # 默认不会删除那些未被任何容器引用的数据卷，需要使用 --volumes 进行删除 docker system prune --volumes # 直接删除，没有确认过程 docker system prune --all --force --volumes docker container prune # 删除所有退出状态的容器 docker volume prune # 删除未被使用的数据卷 docker image prune # 删除 dangling 或所有未被使用的镜像 docker container rm $(docker container ls -a -q) # 删除容器 docker image rm $(docker image ls -a -q) # 删除镜像 docker volume rm $(docker volume ls -q) # 删除数据卷 docker network rm $(docker network ls -q) # 删除 network # 列出所有容器 docker container ls -a -q # 停止所有容器 docker container stop $(docker container ls -a -q) # 删除所有资源 docker container stop $(docker container ls -a -q) \u0026amp;\u0026amp; docker system prune --all --force --volumns 参考：\n 如何快速清理 docker 资源  "});index.add({'id':2,'href':'/note-cs/docs/domain/cc/container/docker/quick/','title':"Docker 快速上手",'content':"Docker 快速上手 安装 MacOS 下载: https://download.docker.com/mac/stable/Docker.dmgLinux Windows  镜像加速 阿里云 获取你的加速地址：https://cr.console.aliyun.com/undefined/instances/mirrors\n针对安装了 Docker for Mac 的用户，您可以参考以下配置步骤： 右键点击桌面顶栏的 docker 图标，选择 Preferences ，在 Daemon 标签（Docker 17.03 之前版本为 Advanced 标签）下的 Registry mirrors 列表中将 https://pjuig8sx.mirror.aliyuncs.com 加到 \u0026ldquo;registry-mirrors\u0026rdquo; 的数组里，点击 Apply \u0026amp; Restart 按钮，等待 Docker 重启并应用配置的镜像加速器。\n"});index.add({'id':3,'href':'/note-cs/docs/others/tool/dev/github/','title':"GitHub",'content':"GitHub 设置代理 git config --global http.proxy \u0026#34;http://127.0.0.1:8081\u0026#34; git config --global https.proxy \u0026#34;http://127.0.0.1:8081\u0026#34; # socks5 代理（如 Shadowsocks） git config --global http.proxy \u0026#34;socks5://127.0.0.1:1080\u0026#34; git config --global https.proxy \u0026#34;socks5://127.0.0.1:1080\u0026#34; # 取消代理 git config --global --unset http.proxy git config --global --unset https.proxy  学习 Github Github Learning Lab Introduction to GitHub  Github 工具 cli/cli  GitHub’s official command line tool https://cli.github.com\ngithub/hub  A command-line tool that makes git easier to use with GitHub. https://hub.github.com/\n 开源库 素材 / 规范 徽章 shields.io 如：\n参考：\n  用 [Substats] 和 Shields.io 为你的个人主页定制动态数据小牌子\nspencerwooo/Substats    Github star 历史 timqian/star-history  https://star-history.t9t.io/\nvesoft-inc/github-statistics  A react static app for displaying github repo statistiscs like Star History, Fork History and more.\nhttps://vesoft-inc.github.io/github-statistics/\nantonmedv/spark  \nseladb/startrack-js  GitHub star history and stats - based on JavaScript only!\nhttps://seladb.github.io/StarTrack-js/\nelliotreborn/github-stars  技术栈的 star 趋势数据\n Github PR 统计 开源相关工作岗位 t9tio/open-source-jobs A list of Open Source projects offering jobs. https://oo.t9t.io/organizations\n 角落标志 tholman/github-corners  http://tholman.com/github-corners/\n如：  GitHub Apps  Run persistently and can react to events quickly. Work great when persistent data is needed. Work best with API requests that aren\u0026rsquo;t time consuming. Run on a server or compute infrastructure that you provide.  参考：\n Strengths of GitHub Actions and GitHub Apps  Mergify Stop merging your pull requests manually.\nWe save your time by automatically merging, commenting, rebasing, updating, labeling, backporting, closing, assigning, your pull requests.\nMergifyio/mergify-engine  Engine for Mergify https://mergify.io\nNetlify [wei/pull] Pull Keep your forks up-to-date via automated PRs\nwei/pull probot/weekly-digest  自动生成周报到 issue\nGitHub Actions  Provide automation that can perform continuous integration and continuous deployment. Can run directly on runner machines or in Docker containers. Can include access to a clone of your repository, enabling deployment and publishing tools, code formatters, and command line tools to access your code. Don\u0026rsquo;t require you to deploy code or serve an app. Have a simple interface to create and use secrets, which enables actions to interact with third-party services without needing to store the credentials of the person using the action.   Github 工具开发 webhook NetEaseGame/git-webhook  使用 Python Flask + SQLAchemy + Celery + Redis + React 开发的用于迅速搭建并使用 WebHook 进行自动化部署和运维，支持 Github / GitLab / Gogs / GitOsc。 https://webhook.hust.cc/\n若觉得 git-webhook 部署依然比较复杂，可以尝试更为简洁的 cli 版本 hustcc/webhookit  github-webhook-handler  Node.js web handler / middleware for processing GitHub Webhooks\n go-playground/webhooks  Webhook receiver for GitHub, Bitbucket, GitLab, Gogs\n hustcc/webhookit  Simple git webhook cli tool for automation tasks, bind git webhook to action.\n gorda/issue-man   Building apps 参考：\n Building apps  Building actions 参考：\n Building actions  "});index.add({'id':4,'href':'/note-cs/docs/book/basic/pl/go-in-action/zh/','title':"Go 语言实战",'content':"Go 语言实战 \n译者 李兆海，多年专注于后端分布式网络服务开发，曾使用过多个流行后端技术和相关架构实践，是 Go 语言和 Docker 的早期使用者和推广者，《第 1 本 Docker 书》的译者。作为项目技术负责人，成功开发了百万用户级直播系统。\n"});index.add({'id':5,'href':'/note-cs/docs/direction/fe/html/','title':"HTML",'content':"HTML "});index.add({'id':6,'href':'/note-cs/docs/basic/os/linux/','title':"Linux",'content':"Linux 见：Linux 学习笔记\n"});index.add({'id':7,'href':'/note-cs/docs/basic/db/mysql/basic/quick-start/','title':"Quick Start",'content':"Quick Start Mysql Client /etc/my.cnf\nMysql Server "});index.add({'id':8,'href':'/note-cs/docs/book/others/practical-vim/zh/','title':"Vim 实用技巧（第 2 版）",'content':"Vim 实用技巧（第 2 版） \n译者 杨源 / 车文隆\n"});index.add({'id':9,'href':'/note-cs/docs/others/tool/dev/vscode/','title':"VSCode",'content':"VSCode 推荐插件 PicGo/vs-picgo https://github.com/PicGo/vs-picgo\nformat autopep8 设置每行最大长度\n\u0026quot;python.formatting.autopep8Args\u0026quot;: [ \u0026quot;--max-line-length=200\u0026quot; ] 教程  帮你高效使用 VS Code 的秘诀  Q\u0026amp;A Could not create temporary directory: Permission denied sudo chown -R $USER ~/Library/Caches/* "});index.add({'id':10,'href':'/note-cs/docs/basic/db/mysql/basic/practice/','title':"实践",'content':"实践 问答 Mysql 不指定 ip 与指定本地 ip，有什么区别？ "});index.add({'id':11,'href':'/note-cs/docs/basic/db/postgresql/basic/practice/','title':"实践",'content':"PostgreSQL 实践 "});index.add({'id':12,'href':'/note-cs/docs/basic/pl/c/basic/practice/','title':"实践",'content':"实践 "});index.add({'id':13,'href':'/note-cs/docs/basic/pl/javascript/basic/practice/','title':"实践",'content':"实践 "});index.add({'id':14,'href':'/note-cs/docs/basic/pl/objective-c/basic/practice/','title':"实践",'content':"实践 "});index.add({'id':15,'href':'/note-cs/docs/direction/be/platform/nodejs/basic/practice/','title':"实践",'content':"实践 "});index.add({'id':16,'href':'/note-cs/docs/direction/client/android/basic/practice/','title':"实践",'content':"实践 "});index.add({'id':17,'href':'/note-cs/docs/direction/client/ios/basic/practice/','title':"实践",'content':"实践 "});index.add({'id':18,'href':'/note-cs/docs/direction/client/xiaochengxu/basic/practice/','title':"实践",'content':"实践 "});index.add({'id':19,'href':'/note-cs/docs/direction/fe/frame/angular/basic/practice/','title':"实践",'content':"实践 "});index.add({'id':20,'href':'/note-cs/docs/direction/fe/frame/react/basic/practice/','title':"实践",'content':"实践 "});index.add({'id':21,'href':'/note-cs/docs/direction/fe/frame/vue/basic/practice/','title':"实践",'content':"实践 "});index.add({'id':22,'href':'/note-cs/docs/basic/db/postgresql/basic/quick-start/','title':"快速上手",'content':"PostgreSQL 快速上手 安装 MacOS  安装：brew install postgresql 启动：brew services start postgresql 创建用户名数据库：createdb  基础命令 登录 PostgreSQL 控制台：psql psql -U [user] -d [database] -h [host] -p [port]\n默认 psql\nuser：当前mac用户 database：用户同名数据库 主机：localhost 端口号：5432，postgresql的默认端口是5432 \\l 使用 \\l 命令列出所有的数据库，看到已存在用户同名数据库、postgres 数据库。 但是 postgres 数据库的所有者是当前用户，没有 postgres 用户。\n 创建 postgres 用户：CREATE USER postgres WITH PASSWORD 'password'; 删除默认生成的 postgres 数据库：DROP DATABASE postgres; 创建属于 postgres 用户的 postgres 数据库：CREATE DATABASE postgres OWNER postgres; 将数据库所有权限赋予 postgres 用户：GRANT ALL PRIVILEGES ON DATABASE postgres to postgres; 给 postgres 用户添加创建数据库的属性：ALTER ROLE postgres CREATEDB;  常用控制台命令 \\password：设置当前登录用户的密码 \\h：查看SQL命令的解释，比如\\h select。 \\?：查看psql命令列表。 \\l：列出所有数据库。 \\c [database_name]：连接其他数据库。 \\d：列出当前数据库的所有表格。 \\d [table_name]：列出某一张表格的结构。 \\du：列出所有用户。 \\e：打开文本编辑器。 \\conninfo：列出当前数据库和连接的信息。 \\password [user]: 修改用户密码 \\q：退出 查询 \\x 类似 mysql 的 \\G\n# \\x Expanded display is on. # \\x Expanded display is off. 参考：\n Display select results vertically in psql, as is done by MySQL\u0026rsquo;s \\G   权限 GRANT GRANT on the database is not what you need. Grant on the tables directly.\nGranting privileges on the database mostly is used to grant or revoke connect privileges. This allows you to specify who may do stuff in the database if they have sufficient other permissions.\nGRANT ALL PRIVILEGES ON TABLE side_adzone TO jerry; 参考：\n Permission denied for relation  "});index.add({'id':23,'href':'/note-cs/docs/basic/db/mysql/basic/practice/optimize/','title':"性能优化",'content':"Mysql 性能优化 存储引擎 使用 Innodb 存储引擎 没有特殊要求（即 Innodb 无法满足的功能如：列存储，存储空间数据等）的情况下，所有表必须使用 Innodb 存储引擎（MySQL5.5 之前默认使用 Myisam，5.6 以后默认的为 Innodb）。\nInnodb 支持事务，支持行级锁，更好的恢复性，高并发下性能更好。\n 编码 统一使用 UTF8 库和表的字符集统一使用 UTF8\n 表 控制单表数据量的大小 建议在 500 万以内。500 万并不是 MySQL 数据库的限制，过大会造成修改表结构，备份，恢复都会有很大的问题。\n可以用历史数据归档（应用于日志数据），分库分表（应用于业务数据）等手段来控制数据量大小\n谨慎使用 MySQL 分区表 分区表在物理上表现为多个文件，在逻辑上表现为一个表；\n谨慎选择分区键，跨分区查询效率可能更低；\n建议采用物理分表的方式管理大数据。\n冷热数据分离，减小表的宽度  MySQL 限制每个表最多存储 4096 列，并且每一行数据的大小不能超过 65535 字节。\n 减少磁盘 IO, 保证热数据的内存缓存命中率（表越宽，把表装载进内存缓冲池时所占用的内存也就越大，也会消耗更多的 IO）；\n更有效的利用缓存，避免读入无用的冷数据；\n经常一起使用的列放到一个表中（避免更多的关联操作）。\n优先选择小的数据类型 列的字段越大，建立索引时所需要的空间也就越大，这样一页中所能存储的索引节点的数量也就越少也越少，在遍历时所需要的 IO 次数也就越多，索引的性能也就越差。\n如：\n 将 IP 地址转换成整形数据 对于非负型的数据 (如自增 ID, 整型 IP) 来说，要优先使用无符号整型来存储  列定义为 NOT NULL 索引 NULL 列需要额外的空间来保存，所以要占用更多的空间。\n进行比较和计算时要对 NULL 值做特别的处理。\n 索引 限制每张表上的索引数量 建议单张表索引不超过 5 个 索引并不是越多越好！索引可以提高效率同样可以降低效率。\n索引可以增加查询效率，但同样也会降低插入和更新的效率，甚至有些情况下会降低查询效率。\n因为 MySQL 优化器在选择如何优化查询时，会根据统一信息，对每一个可以用到的索引来进行评估，以生成出一个最好的执行计划，如果同时有很多个索引都可以用于查询，就会增加 MySQL 优化器生成执行计划的时间，同样会降低查询性能。\n必须有个主键 Innodb 是一种索引组织表：数据的存储的逻辑顺序和索引的顺序是相同的。每个表都可以有多个索引，但是表的存储顺序只能有一种。\nInnodb 是按照主键索引的顺序来组织表的\n 不要使用更新频繁的列作为主键，不适用多列主键（相当于联合索引） 不要使用 UUID,MD5,HASH, 字符串列作为主键（无法保证数据的顺序增长） 主键建议使用自增 ID 值   开发 避免数据类型的隐式转换 避免使用双 % 号的查询条件 联合索引 在定义联合索引时，如果 a 列要用到范围查找的话，就要把 a 列放到联合索引的右侧。\n一个 SQL 只能利用到复合索引中的一列进行范围查询。如：有 a,b,c 列的联合索引，在查询条件中有 a 列的范围查询，则在 b,c 列上的索引将不会被用到。\n使用 left join 替代 not in 操作 使用 left join 或 not exists 来优化 not in 操作，因为 not in 也通常会使用索引失效。\n 参考  MySQL 高性能优化规范建议  "});index.add({'id':24,'href':'/note-cs/docs/basic/db/mysql/appendix/tutorial/','title':"教程",'content':"教程 基础 进阶 高阶 "});index.add({'id':25,'href':'/note-cs/docs/basic/db/postgresql/appendix/tutorial/','title':"教程",'content':"教程 基础 进阶 高阶 "});index.add({'id':26,'href':'/note-cs/docs/basic/db/redis/appendix/tutorial/','title':"教程",'content':"教程 基础 进阶 高阶 "});index.add({'id':27,'href':'/note-cs/docs/basic/os/android/appendix/tutorial/','title':"教程",'content':"教程 基础 进阶 高阶 "});index.add({'id':28,'href':'/note-cs/docs/basic/os/ios/appendix/tutorial/','title':"教程",'content':"教程 基础 进阶 高阶 "});index.add({'id':29,'href':'/note-cs/docs/basic/os/macos/appendix/tutorial/','title':"教程",'content':"教程 基础 进阶 高阶 "});index.add({'id':30,'href':'/note-cs/docs/basic/os/unix/appendix/tutorial/','title':"教程",'content':"教程 基础 进阶 高阶 "});index.add({'id':31,'href':'/note-cs/docs/basic/os/windows/appendix/tutorial/','title':"教程",'content':"教程 基础 进阶 高阶 "});index.add({'id':32,'href':'/note-cs/docs/basic/pl/c/appendix/tutorial/','title':"教程",'content':"教程 基础  learn c in y minutes  进阶 高阶 "});index.add({'id':33,'href':'/note-cs/docs/basic/pl/cpp/appendix/tutorial/','title':"教程",'content':"教程 基础  learn c++ in y minutes   C++ 后台开发有哪些练基础的开源项目？  yedf/handy     进阶 高阶 "});index.add({'id':34,'href':'/note-cs/docs/basic/pl/csharp/appendix/tutorial/','title':"教程",'content':"教程 基础 进阶 高阶 "});index.add({'id':35,'href':'/note-cs/docs/basic/pl/javascript/appendix/turorial/','title':"教程",'content':"教程 基础 ruanyf/jstraining  全栈工程师培训材料，帮助学习者掌握 JavaScript 全栈开发的基本知识，承担简单 Web 应用的前后端开发。\n一共四讲，适合两天的训练营。\ndenysdovhan/wtfjs  A list of funny and tricky JavaScript examples\nnefe/You-Dont-Need-jQuery  使用原生方法实现 jQuery API 功能（暂时只支持 IE10 以上浏览器）。\n 进阶  高阶 "});index.add({'id':36,'href':'/note-cs/docs/basic/pl/kotlin/appendix/tutorial/','title':"教程",'content':"教程 基础 进阶 高阶 "});index.add({'id':37,'href':'/note-cs/docs/basic/pl/lua/appendix/tutorial/','title':"教程",'content':"教程 基础 进阶 高阶 "});index.add({'id':38,'href':'/note-cs/docs/basic/pl/objective-c/appendix/tutorial/','title':"教程",'content':"教程 基础 进阶 高阶 "});index.add({'id':39,'href':'/note-cs/docs/basic/pl/php/appendix/tutorial/','title':"教程",'content':"教程 基础 进阶 高阶 "});index.add({'id':40,'href':'/note-cs/docs/basic/pl/ruby/appendix/tutorial/','title':"教程",'content':"教程 基础 进阶 高阶 "});index.add({'id':41,'href':'/note-cs/docs/basic/pl/rust/appendix/tutorial/','title':"教程",'content':"教程 经典 The Rust Programming Language The most comprehensive resource for learning Rust, but a bit theoretical sometimes. You will be using this along with Rustlings!\nRust by Example Learn Rust by solving little exercises! It\u0026rsquo;s almost like rustlings, but online.\nrust-lang/rustlings  Small exercises to get you used to reading and writing Rust code!\n 基础 进阶 高阶 "});index.add({'id':42,'href':'/note-cs/docs/basic/pl/scala/appendix/tutorial/','title':"教程",'content':"教程 基础 进阶 高阶 "});index.add({'id':43,'href':'/note-cs/docs/basic/pl/swift/appendix/tutorial/','title':"教程",'content':"教程 基础 进阶 高阶 "});index.add({'id':44,'href':'/note-cs/docs/direction/be/platform/nodejs/appendix/tutorial/','title':"教程",'content':"教程 基础 进阶 高阶 "});index.add({'id':45,'href':'/note-cs/docs/direction/client/android/appendix/tutorial/','title':"教程",'content':"教程 基础 进阶 高阶 "});index.add({'id':46,'href':'/note-cs/docs/direction/client/ios/appendix/tutorial/','title':"教程",'content':"教程 基础 进阶 高阶 "});index.add({'id':47,'href':'/note-cs/docs/direction/client/xiaochengxu/appendix/tutorial/','title':"教程",'content':"教程 基础 进阶 高阶 "});index.add({'id':48,'href':'/note-cs/docs/direction/embedded/appendix/tutorial/','title':"教程",'content':"教程 基础 进阶 高阶 "});index.add({'id':49,'href':'/note-cs/docs/direction/fe/frame/angular/appendix/tutorial/','title':"教程",'content':"教程 基础 进阶 高阶 "});index.add({'id':50,'href':'/note-cs/docs/direction/fe/frame/react/appendix/tutorial/','title':"教程",'content':"教程 基础 进阶 高阶 "});index.add({'id':51,'href':'/note-cs/docs/direction/fe/frame/vue/appendix/tutorial/','title':"教程",'content':"教程 基础 进阶 高阶 "});index.add({'id':52,'href':'/note-cs/docs/direction/security/appendix/tutorial/','title':"教程",'content':"教程 基础 进阶 高阶 "});index.add({'id':53,'href':'/note-cs/docs/domain/cc/knative/appendix/tutorial/','title':"教程",'content':"教程 基础 Getting Started with Knative - Building Modern Serverless Workloads on Kubernetes Getting Started with Knative 是一本由 Pivotal 公司赞助 O’Reilly 出品的免费电子书\n社区翻译版本：Knative 入门 —— 构建基于 Kubernetes 的现代化 Serverless 应用\n进阶 高阶 "});index.add({'id':54,'href':'/note-cs/docs/basic/pl/csharp/basic/lib/std/','title':"标准库",'content':"标准库 "});index.add({'id':55,'href':'/note-cs/docs/basic/pl/cpp/basic/practice/spec/baidu/','title':"百度",'content':"百度 C++ 编程规范 "});index.add({'id':56,'href':'/note-cs/docs/basic/pl/javascript/basic/practice/spec/baidu/','title':"百度",'content':"百度 JavaScript 编码规范 1 前言\n2 代码风格\n2.1 文件\n2.2 结构\n2.2.1 缩进\n2.2.2 空格\n2.2.3 换行\n2.2.4 语句\n2.3 命名\n2.4 注释\n2.4.1 单行注释\n2.4.2 多行注释\n2.4.3 文档化注释\n2.4.4 类型定义\n2.4.5 文件注释\n2.4.6 命名空间注释\n2.4.7 类注释\n2.4.8 函数/方法注释\n2.4.9 事件注释\n2.4.10 常量注释\n2.4.11 复杂类型注释\n2.4.12 AMD 模块注释\n2.4.13 细节注释\n3 语言特性\n3.1 变量\n3.2 条件\n3.3 循环\n3.4 类型\n3.4.1 类型检测\n3.4.2 类型转换\n3.5 字符串\n3.6 对象\n3.7 数组\n3.8 函数\n3.8.1 函数长度\n3.8.2 参数设计\n3.8.3 闭包\n3.8.4 空函数\n3.9 面向对象\n3.10 动态特性\n3.10.1 eval\n3.10.2 动态执行代码\n3.10.3 with\n3.10.4 delete\n3.10.5 对象属性\n4 浏览器环境\n4.1 模块化\n4.1.1 AMD\n4.1.2 define\n4.1.3 require\n4.2 DOM\n4.2.1 元素获取\n4.2.2 样式获取\n4.2.3 样式设置\n4.2.4 DOM 操作\n4.2.5 DOM 事件\n1 前言 JavaScript 在百度一直有着广泛的应用，特别是在浏览器端的行为管理。本文档的目标是使 JavaScript 代码风格保持一致，容易被理解和被维护。\n虽然本文档是针对 JavaScript 设计的，但是在使用各种 JavaScript 的预编译语言时(如 TypeScript 等)时，适用的部分也应尽量遵循本文档的约定。\n任何问题或建议，欢迎跟我们讨论: fe-styleguide@baidu.com\n2 代码风格 2.1 文件 [建议] JavaScript 文件使用无 BOM 的 UTF-8 编码。 解释：\nUTF-8 编码具有更广泛的适应性。BOM 在使用程序或工具处理文件时可能造成不必要的干扰。\n[建议] 在文件结尾处，保留一个空行。 2.2 结构 2.2.1 缩进 [强制] 使用 4 个空格做为一个缩进层级，不允许使用 2 个空格 或 tab 字符。 [强制] switch 下的 case 和 default 必须增加一个缩进层级。 示例：\n// good switch (variable) { case \u0026#34;1\u0026#34;: // do...  break; case \u0026#34;2\u0026#34;: // do...  break; default: // do... } // bad switch (variable) { case \u0026#34;1\u0026#34;: // do...  break; case \u0026#34;2\u0026#34;: // do...  break; default: // do... } 2.2.2 空格 [强制] 二元运算符两侧必须有一个空格，一元运算符与操作对象之间不允许有空格。 示例：\nvar a = !arr.length; a++; a = b + c; [强制] 用作代码块起始的左花括号 { 前必须有一个空格。 示例：\n// good if (condition) { } while (condition) {} function funcName() {} // bad if (condition) { } while (condition) {} function funcName() {} [强制] if / else / for / while / function / switch / do / try / catch / finally 关键字后，必须有一个空格。 示例：\n// good if (condition) { } while (condition) {} (function() {})(); // bad if (condition) { } while (condition) {} (function() {})(); [强制] 在对象创建时，属性中的 : 之后必须有空格，: 之前不允许有空格。 示例：\n// good var obj = { a: 1, b: 2, c: 3 }; // bad var obj = { a: 1, b: 2, c: 3 }; [强制] 函数声明、具名函数表达式、函数调用中，函数名和 ( 之间不允许有空格。 示例：\n// good function funcName() {} var funcName = function funcName() {}; funcName(); // bad function funcName() {} var funcName = function funcName() {}; funcName(); [强制] , 和 ; 前不允许有空格。如果不位于行尾，, 和 ; 后必须跟一个空格。 示例：\n// good callFunc(a, b); // bad callFunc(a, b); [强制] 在函数调用、函数声明、括号表达式、属性访问、if / for / while / switch / catch 等语句中，() 和 [] 内紧贴括号部分不允许有空格。 示例：\n// good  callFunc(param1, param2, param3); save(this.list[this.indexes[i]]); needIncream \u0026amp;\u0026amp; (variable += increament); if (num \u0026gt; list.length) { } while (len--) {} // bad  callFunc(param1, param2, param3); save(this.list[this.indexes[i]]); needIncreament \u0026amp;\u0026amp; (variable += increament); if (num \u0026gt; list.length) { } while (len--) {} [强制] 单行声明的数组与对象，如果包含元素，{} 和 [] 内紧贴括号部分不允许包含空格。 解释：\n声明包含元素的数组与对象，只有当内部元素的形式较为简单时，才允许写在一行。元素复杂的情况，还是应该换行书写。\n示例：\n// good var arr1 = []; var arr2 = [1, 2, 3]; var obj1 = {}; var obj2 = { name: \u0026#34;obj\u0026#34; }; var obj3 = { name: \u0026#34;obj\u0026#34;, age: 20, sex: 1 }; // bad var arr1 = []; var arr2 = [1, 2, 3]; var obj1 = {}; var obj2 = { name: \u0026#34;obj\u0026#34; }; var obj3 = { name: \u0026#34;obj\u0026#34;, age: 20, sex: 1 }; [强制] 行尾不得有多余的空格。 2.2.3 换行 [强制] 每个独立语句结束后必须换行。 [强制] 每行不得超过 120 个字符。 解释：\n超长的不可分割的代码允许例外，比如复杂的正则表达式。长字符串不在例外之列。\n[强制] 运算符处换行时，运算符必须在新行的行首。 示例：\n// good if ( (user.isAuthenticated() \u0026amp;\u0026amp; user.isInRole(\u0026#34;admin\u0026#34;) \u0026amp;\u0026amp; user.hasAuthority(\u0026#34;add-admin\u0026#34;)) || user.hasAuthority(\u0026#34;delete-admin\u0026#34;) ) { // Code } var result = number1 + number2 + number3 + number4 + number5; // bad if ( (user.isAuthenticated() \u0026amp;\u0026amp; user.isInRole(\u0026#34;admin\u0026#34;) \u0026amp;\u0026amp; user.hasAuthority(\u0026#34;add-admin\u0026#34;)) || user.hasAuthority(\u0026#34;delete-admin\u0026#34;) ) { // Code } var result = number1 + number2 + number3 + number4 + number5; [强制] 在函数声明、函数表达式、函数调用、对象创建、数组创建、for 语句等场景中，不允许在 , 或 ; 前换行。 示例：\n// good var obj = { a: 1, b: 2, c: 3 }; foo(aVeryVeryLongArgument, anotherVeryLongArgument, callback); // bad var obj = { a: 1, b: 2, c: 3 }; foo(aVeryVeryLongArgument, anotherVeryLongArgument, callback); [建议] 不同行为或逻辑的语句集，使用空行隔开，更易阅读。 示例：\n// 仅为按逻辑换行的示例，不代表setStyle的最优实现 function setStyle(element, property, value) { if (element == null) { return; } element.style[property] = value; } [建议] 在语句的行长度超过 120 时，根据逻辑条件合理缩进。 示例：\n// 较复杂的逻辑条件组合，将每个条件独立一行，逻辑运算符放置在行首进行分隔，或将部分逻辑按逻辑组合进行分隔。 // 建议最终将右括号 ) 与左大括号 { 放在独立一行，保证与 `if` 内语句块能容易视觉辨识。 if ( (user.isAuthenticated() \u0026amp;\u0026amp; user.isInRole(\u0026#34;admin\u0026#34;) \u0026amp;\u0026amp; user.hasAuthority(\u0026#34;add-admin\u0026#34;)) || user.hasAuthority(\u0026#34;delete-admin\u0026#34;) ) { // Code } // 按一定长度截断字符串，并使用 + 运算符进行连接。 // 分隔字符串尽量按语义进行，如不要在一个完整的名词中间断开。 // 特别的，对于 HTML 片段的拼接，通过缩进，保持和 HTML 相同的结构。 var html = \u0026#34;\u0026#34; + // 此处用一个空字符串，以便整个 HTML 片段都在新行严格对齐  \u0026#34;\u0026lt;article\u0026gt;\u0026#34; + \u0026#34;\u0026lt;h1\u0026gt;Title here\u0026lt;/h1\u0026gt;\u0026#34; + \u0026#34;\u0026lt;p\u0026gt;This is a paragraph\u0026lt;/p\u0026gt;\u0026#34; + \u0026#34;\u0026lt;footer\u0026gt;Complete\u0026lt;/footer\u0026gt;\u0026#34; + \u0026#34;\u0026lt;/article\u0026gt;\u0026#34;; // 也可使用数组来进行拼接，相对 `+` 更容易调整缩进。 var html = [ \u0026#34;\u0026lt;article\u0026gt;\u0026#34;, \u0026#34;\u0026lt;h1\u0026gt;Title here\u0026lt;/h1\u0026gt;\u0026#34;, \u0026#34;\u0026lt;p\u0026gt;This is a paragraph\u0026lt;/p\u0026gt;\u0026#34;, \u0026#34;\u0026lt;footer\u0026gt;Complete\u0026lt;/footer\u0026gt;\u0026#34;, \u0026#34;\u0026lt;/article\u0026gt;\u0026#34; ]; html = html.join(\u0026#34;\u0026#34;); // 当参数过多时，将每个参数独立写在一行上，并将结束的右括号 ) 独立一行。 // 所有参数必须增加一个缩进。 foo(aVeryVeryLongArgument, anotherVeryLongArgument, callback); // 也可以按逻辑对参数进行组合。 // 最经典的是 baidu.format 函数，调用时将参数分为“模板”和“数据”两块 baidu.format(dateFormatTemplate, year, month, date, hour, minute, second); // 当函数调用时，如果有一个或以上参数跨越多行，应当每一个参数独立一行。 // 这通常出现在匿名函数或者对象初始化等作为参数时，如 `setTimeout` 函数等。 setTimeout(function() { alert(\u0026#34;hello\u0026#34;); }, 200); order.data.read( \u0026#34;id=\u0026#34; + me.model.id, function(data) { me.attchToModel(data.result); callback(); }, 300 ); // 链式调用较长时采用缩进进行调整。 $(\u0026#34;#items\u0026#34;) .find(\u0026#34;.selected\u0026#34;) .highlight() .end(); // 三元运算符由3部分组成，因此其换行应当根据每个部分的长度不同，形成不同的情况。 var result = thisIsAVeryVeryLongCondition ? resultA : resultB; var result = condition ? thisIsAVeryVeryLongResult : resultB; // 数组和对象初始化的混用，严格按照每个对象的 `{` 和结束 `}` 在独立一行的风格书写。 var array = [ { // ...  }, { // ...  } ]; [建议] 对于 if...else...、try...catch...finally 等语句，推荐使用在 } 号后添加一个换行 的风格，使代码层次结构更清晰，阅读性更好。 示例：\nif (condition) { // some statements; } else { // some statements; } try { // some statements; } catch (ex) { // some statements; } 2.2.4 语句 [强制] 不得省略语句结束的分号。 [强制] 在 if / else / for / do / while 语句中，即使只有一行，也不得省略块 {...}。 示例：\n// good if (condition) { callFunc(); } // bad if (condition) callFunc(); if (condition) callFunc(); [强制] 函数定义结束不允许添加分号。 示例：\n// good function funcName() {} // bad function funcName() {} // 如果是函数表达式，分号是不允许省略的。 var funcName = function() {}; [强制] IIFE 必须在函数表达式外添加 (，非 IIFE 不得在函数表达式外添加 (。 解释：\nIIFE = Immediately-Invoked Function Expression.\n额外的 ( 能够让代码在阅读的一开始就能判断函数是否立即被调用，进而明白接下来代码的用途。而不是一直拖到底部才恍然大悟。\n示例：\n// good var task = (function() { // Code  return result; })(); var func = function() {}; // bad var task = (function() { // Code  return result; })(); var func = function() {}; 2.3 命名 [强制] 变量 使用 Camel命名法。 示例：\nvar loadingModules = {}; [强制] 常量 使用 全部字母大写，单词间下划线分隔 的命名方式。 示例：\nvar HTML_ENTITY = {}; [强制] 函数 使用 Camel命名法。 示例：\nfunction stringFormat(source) {} [强制] 函数的 参数 使用 Camel命名法。 示例：\nfunction hear(theBells) {} [强制] 类 使用 Pascal命名法。 示例：\nfunction TextNode(options) {} [强制] 类的 方法 / 属性 使用 Camel命名法。 示例：\nfunction TextNode(value, engine) { this.value = value; this.engine = engine; } TextNode.prototype.clone = function() { return this; }; [强制] 枚举变量 使用 Pascal命名法，枚举的属性 使用 全部字母大写，单词间下划线分隔 的命名方式。 示例：\nvar TargetState = { READING: 1, READED: 2, APPLIED: 3, READY: 4 }; [强制] 命名空间 使用 Camel命名法。 示例：\nequipments.heavyWeapons = {}; [强制] 由多个单词组成的缩写词，在命名中，根据当前命名法和出现的位置，所有字母的大小写与首字母的大小写保持一致。 示例：\nfunction XMLParser() {} function insertHTML(element, html) {} var httpRequest = new HTTPRequest(); [强制] 类名 使用 名词。 示例：\nfunction Engine(options) {} [建议] 函数名 使用 动宾短语。 示例：\nfunction getStyle(element) {} [建议] boolean 类型的变量使用 is 或 has 开头。 示例：\nvar isReady = false; var hasMoreCommands = false; [建议] Promise对象 用 动宾短语的进行时 表达。 示例：\nvar loadingData = ajax.get(\u0026#34;url\u0026#34;); loadingData.then(callback); 2.4 注释 2.4.1 单行注释 [强制] 必须独占一行。// 后跟一个空格，缩进与下一行被注释说明的代码一致。 2.4.2 多行注释 [建议] 避免使用 /*...*/ 这样的多行注释。有多行注释内容时，使用多个单行注释。 2.4.3 文档化注释 [强制] 为了便于代码阅读和自文档化，以下内容必须包含以 /**...*/ 形式的块注释中。 解释：\n 文件 namespace 类 函数或方法 类属性 事件 全局变量 常量 AMD 模块  [强制] 文档注释前必须空一行。 [建议] 自文档化的文档说明 what，而不是 how。 2.4.4 类型定义 [强制] 类型定义都是以 { 开始, 以 } 结束。 解释：\n常用类型如：{string}, {number}, {boolean}, {Object}, {Function}, {RegExp}, {Array}, {Date}。\n类型不仅局限于内置的类型，也可以是自定义的类型。比如定义了一个类 Developer，就可以使用它来定义一个参数和返回值的类型。\n[强制] 对于基本类型 {string}, {number}, {boolean}，首字母必须小写。    类型定义 语法示例 解释     String {string} \u0026ndash;   Number {number} \u0026ndash;   Boolean {boolean} \u0026ndash;   Object {Object} \u0026ndash;   Function {Function} \u0026ndash;   RegExp {RegExp} \u0026ndash;   Array {Array} \u0026ndash;   Date {Date} \u0026ndash;   单一类型集合 {Array.\u0026lt;string\u0026gt;} string 类型的数组   多类型 {(number ｜ boolean)} 可能是 number 类型, 也可能是 boolean 类型   允许为 null {?number} 可能是 number, 也可能是 null   不允许为 null {!Object} Object 类型, 但不是 null   Function 类型 {function(number, boolean)} 函数, 形参类型   Function 带返回值 {function(number, boolean):string} 函数, 形参, 返回值类型   Promise Promise.\u0026lt;resolveType, rejectType\u0026gt; Promise，成功返回的数据类型，失败返回的错误类型   参数可选 @param {string=} name 可选参数, =为类型后缀   可变参数 @param {\u0026hellip;number} args 变长参数, \u0026hellip;为类型前缀   任意类型 {*} 任意类型   可选任意类型 @param {*=} name 可选参数，类型不限   可变任意类型 @param {\u0026hellip;*} args 变长参数，类型不限    2.4.5 文件注释 [强制] 文件顶部必须包含文件注释，用 @file 标识文件说明。 示例：\n/** * @file Describe the file */ [建议] 文件注释中可以用 @author 标识开发者信息。 解释：\n开发者信息能够体现开发人员对文件的贡献，并且能够让遇到问题或希望了解相关信息的人找到维护人。通常情况文件在被创建时标识的是创建者。随着项目的进展，越来越多的人加入，参与这个文件的开发，新的作者应该被加入 @author 标识。\n@author 标识具有多人时，原则是按照 责任 进行排序。通常的说就是如果有问题，就是找第一个人应该比找第二个人有效。比如文件的创建者由于各种原因，模块移交给了其他人或其他团队，后来因为新增需求，其他人在新增代码时，添加 @author 标识应该把自己的名字添加在创建人的前面。\n@author 中的名字不允许被删除。任何劳动成果都应该被尊重。\n业务项目中，一个文件可能被多人频繁修改，并且每个人的维护时间都可能不会很长，不建议为文件增加 @author 标识。通过版本控制系统追踪变更，按业务逻辑单元确定模块的维护责任人，通过文档与 wiki 跟踪和查询，是更好的责任管理方式。\n对于业务逻辑无关的技术型基础项目，特别是开源的公共项目，应使用 @author 标识。\n示例：\n/** * @file Describe the file * @author author-name(mail-name@domain.com) * author-name2(mail-name2@domain.com) */ 2.4.6 命名空间注释 [建议] 命名空间使用 @namespace 标识。 示例：\n/** * @namespace */ var util = {}; 2.4.7 类注释 [建议] 使用 @class 标记类或构造函数。 解释：\n对于使用对象 constructor 属性来定义的构造函数，可以使用 @constructor 来标记。\n示例：\n/** * 描述 * * @class */ function Developer() { // constructor body } [建议] 使用 @extends 标记类的继承信息。 示例：\n/** * 描述 * * @class * @extends Developer */ function Fronteer() { Developer.call(this); // constructor body } util.inherits(Fronteer, Developer); [强制] 使用包装方式扩展类成员时， 必须通过 @lends 进行重新指向。 解释：\n没有 @lends 标记将无法为该类生成包含扩展类成员的文档。\n示例：\n/** * 类描述 * * @class * @extends Developer */ function Fronteer() { Developer.call(this); // constructor body } util.extend( Fronteer.prototype, /** @lends Fronteer.prototype */ { getLevel: function() { // TODO  } } ); [强制] 类的属性或方法等成员信息不是 public 的，应使用 @protected 或 @private 标识可访问性。 解释：\n生成的文档中将有可访问性的标记，避免用户直接使用非 public 的属性或方法。\n示例：\n/** * 类描述 * * @class * @extends Developer */ var Fronteer = function() { Developer.call(this); /** * 属性描述 * * @type {string} * @private */ this.level = \u0026#34;T12\u0026#34;; // constructor body }; util.inherits(Fronteer, Developer); /** * 方法描述 * * @private * @return {string} 返回值描述 */ Fronteer.prototype.getLevel = function() {}; 2.4.8 函数/方法注释 [强制] 函数/方法注释必须包含函数说明，有参数和返回值时必须使用注释标识。 解释：\n当 return 关键字仅作退出函数/方法使用时，无须对返回值作注释标识。\n[强制] 参数和返回值注释必须包含类型信息，且不允许省略参数的说明。 [建议] 当函数是内部函数，外部不可访问时，可以使用 @inner 标识。 示例：\n/** * 函数描述 * * @param {string} p1 参数1的说明 * @param {string} p2 参数2的说明，比较长 * 那就换行了. * @param {number=} p3 参数3的说明（可选） * @return {Object} 返回值描述 */ function foo(p1, p2, p3) { var p3 = p3 || 10; return { p1: p1, p2: p2, p3: p3 }; } [强制] 对 Object 中各项的描述， 必须使用 @param 标识。 示例：\n/** * 函数描述 * * @param {Object} option 参数描述 * @param {string} option.url option项描述 * @param {string=} option.method option项描述，可选参数 */ function foo(option) { // TODO } [建议] 重写父类方法时， 应当添加 @override 标识。如果重写的形参个数、类型、顺序和返回值类型均未发生变化，可省略 @param、@return，仅用 @override 标识，否则仍应作完整注释。 解释：\n简而言之，当子类重写的方法能直接套用父类的方法注释时可省略对参数与返回值的注释。\n2.4.9 事件注释 [强制] 必须使用 @event 标识事件，事件参数的标识与方法描述的参数标识相同。 示例：\n/** * 值变更时触发 * * @event Select#change * @param {Object} e e描述 * @param {string} e.before before描述 * @param {string} e.after after描述 */ this.fire(\u0026#34;change\u0026#34;, { before: \u0026#34;foo\u0026#34;, after: \u0026#34;bar\u0026#34; }); [强制] 在会广播事件的函数前使用 @fires 标识广播的事件，在广播事件代码前使用 @event 标识事件。 [建议] 对于事件对象的注释，使用 @param 标识，生成文档时可读性更好。 示例：\n/** * 点击处理 * * @fires Select#change * @private */ Select.prototype.clickHandler = function() { /** * 值变更时触发 * * @event Select#change * @param {Object} e e描述 * @param {string} e.before before描述 * @param {string} e.after after描述 */ this.fire(\u0026#34;change\u0026#34;, { before: \u0026#34;foo\u0026#34;, after: \u0026#34;bar\u0026#34; }); }; 2.4.10 常量注释 [强制] 常量必须使用 @const 标记，并包含说明和类型信息。 示例：\n/** * 常量说明 * * @const * @type {string} */ var REQUEST_URL = \u0026#34;myurl.do\u0026#34;; 2.4.11 复杂类型注释 [建议] 对于类型未定义的复杂结构的注释，可以使用 @typedef 标识来定义。 示例：\n// `namespaceA~` 可以换成其它 namepaths 前缀，目的是为了生成文档中能显示 `@typedef` 定义的类型和链接。 /** * 服务器 * * @typedef {Object} namespaceA~Server * @property {string} host 主机 * @property {number} port 端口 */ /** * 服务器列表 * * @type {Array.\u0026lt;namespaceA~Server\u0026gt;} */ var servers = [ { host: \u0026#34;1.2.3.4\u0026#34;, port: 8080 }, { host: \u0026#34;1.2.3.5\u0026#34;, port: 8081 } ]; 2.4.12 AMD 模块注释 [强制] AMD 模块使用 @module 或 @exports 标识。 解释：\n@exports 与 @module 都可以用来标识模块，区别在于 @module 可以省略模块名称。而只使用 @exports 时在 namepaths 中可以省略 module: 前缀。\n示例：\ndefine(function(require) { /** * foo description * * @exports Foo */ var foo = { // TODO  }; /** * baz description * * @return {boolean} return description */ foo.baz = function() { // TODO  }; return foo; }); 也可以在 exports 变量前使用 @module 标识：\ndefine(function(require) { /** * module description. * * @module foo */ var exports = {}; /** * bar description * */ exports.bar = function() { // TODO  }; return exports; }); 如果直接使用 factory 的 exports 参数，还可以：\n/** * module description. * * @module */ define(function(require, exports) { /** * bar description * */ exports.bar = function() { // TODO  }; return exports; }); [强制] 对于已使用 @module 标识为 AMD 模块 的引用，在 namepaths 中必须增加 module: 作前缀。 解释：\nnamepaths 没有 module: 前缀时，生成的文档中将无法正确生成链接。\n示例：\n/** * 点击处理 * * @fires module:Select#change * @private */ Select.prototype.clickHandler = function() { /** * 值变更时触发 * * @event module:Select#change * @param {Object} e e描述 * @param {string} e.before before描述 * @param {string} e.after after描述 */ this.fire(\u0026#34;change\u0026#34;, { before: \u0026#34;foo\u0026#34;, after: \u0026#34;bar\u0026#34; }); }; [建议] 对于类定义的模块，可以使用 @alias 标识构建函数。 示例：\n/** * A module representing a jacket. * @module jacket */ define(function() { /** * @class * @alias module:jacket */ var Jacket = function() {}; return Jacket; }); [建议] 多模块定义时，可以使用 @exports 标识各个模块。 示例：\n// one module define(\u0026#34;html/utils\u0026#34;, /** * Utility functions to ease working with DOM elements. * @exports html/utils */ function() { var exports = {}; return exports; }); // another module define(\u0026#34;tag\u0026#34;, /** @exports tag */ function() { var exports = {}; return exports; }); [建议] 对于 exports 为 Object 的模块，可以使用@namespace标识。 解释：\n使用 @namespace 而不是 @module 或 @exports 时，对模块的引用可以省略 module: 前缀。\n[建议] 对于 exports 为类名的模块，使用 @class 和 @exports 标识。 示例：\n// 只使用 @class Bar 时，类方法和属性都必须增加 @name Bar#methodName 来标识，与 @exports 配合可以免除这一麻烦，并且在引用时可以省去 module: 前缀。 // 另外需要注意类名需要使用 var 定义的方式。  /** * Bar description * * @see foo * @exports Bar * @class */ var Bar = function() { // TODO }; /** * baz description * * @return {(string|Array)} return description */ Bar.prototype.baz = function() { // TODO }; 2.4.13 细节注释 对于内部实现、不容易理解的逻辑说明、摘要信息等，我们可能需要编写细节注释。\n[建议] 细节注释遵循单行注释的格式。说明必须换行时，每行是一个单行注释的起始。 示例：\nfunction foo(p1, p2, opt_p3) { // 这里对具体内部逻辑进行说明  // 说明太长需要换行  for (...) { .... } } [强制] 有时我们会使用一些特殊标记进行说明。特殊标记必须使用单行注释的形式。下面列举了一些常用标记： 解释：\n TODO: 有功能待实现。此时需要对将要实现的功能进行简单说明。 FIXME: 该处代码运行没问题，但可能由于时间赶或者其他原因，需要修正。此时需要对如何修正进行简单说明。 HACK: 为修正某些问题而写的不太好或者使用了某些诡异手段的代码。此时需要对思路或诡异手段进行描述。 XXX: 该处存在陷阱。此时需要对陷阱进行描述。  3 语言特性 3.1 变量 [强制] 变量、函数在使用前必须先定义。 解释：\n不通过 var 定义变量将导致变量污染全局环境。\n示例：\n// good var name = \u0026#34;MyName\u0026#34;; // bad name = \u0026#34;MyName\u0026#34;; 原则上不建议使用全局变量，对于已有的全局变量或第三方框架引入的全局变量，需要根据检查工具的语法标识。\n示例：\n/* globals jQuery */ var element = jQuery(\u0026#34;#element-id\u0026#34;); [强制] 每个 var 只能声明一个变量。 解释：\n一个 var 声明多个变量，容易导致较长的行长度，并且在修改时容易造成逗号和分号的混淆。\n示例：\n// good var hangModules = []; var missModules = []; var visited = {}; // bad var hangModules = [], missModules = [], visited = {}; [强制] 变量必须 即用即声明，不得在函数或其它形式的代码块起始位置统一声明所有变量。 解释：\n变量声明与使用的距离越远，出现的跨度越大，代码的阅读与维护成本越高。虽然 JavaScript 的变量是函数作用域，还是应该根据编程中的意图，缩小变量出现的距离空间。\n示例：\n// good function kv2List(source) { var list = []; for (var key in source) { if (source.hasOwnProperty(key)) { var item = { k: key, v: source[key] }; list.push(item); } } return list; } // bad function kv2List(source) { var list = []; var key; var item; for (key in source) { if (source.hasOwnProperty(key)) { item = { k: key, v: source[key] }; list.push(item); } } return list; } 3.2 条件 [强制] 在 Equality Expression 中使用类型严格的 ===。仅当判断 null 或 undefined 时，允许使用 == null。 解释：\n使用 === 可以避免等于判断中隐式的类型转换。\n示例：\n// good if (age === 30) { // ...... } // bad if (age == 30) { // ...... } [建议] 尽可能使用简洁的表达式。 示例：\n// 字符串为空  // good if (!name) { // ...... } // bad if (name === \u0026#34;\u0026#34;) { // ...... } // 字符串非空  // good if (name) { // ...... } // bad if (name !== \u0026#34;\u0026#34;) { // ...... } // 数组非空  // good if (collection.length) { // ...... } // bad if (collection.length \u0026gt; 0) { // ...... } // 布尔不成立  // good if (!notTrue) { // ...... } // bad if (notTrue === false) { // ...... } // null 或 undefined  // good if (noValue == null) { // ...... } // bad if (noValue === null || typeof noValue === \u0026#34;undefined\u0026#34;) { // ...... } [建议] 按执行频率排列分支的顺序。 解释：\n按执行频率排列分支的顺序好处是：\n 阅读的人容易找到最常见的情况，增加可读性。 提高执行效率。  [建议] 对于相同变量或表达式的多值条件，用 switch 代替 if。 示例：\n// good switch (typeof variable) { case \u0026#34;object\u0026#34;: // ......  break; case \u0026#34;number\u0026#34;: case \u0026#34;boolean\u0026#34;: case \u0026#34;string\u0026#34;: // ......  break; } // bad var type = typeof variable; if (type === \u0026#34;object\u0026#34;) { // ...... } else if (type === \u0026#34;number\u0026#34; || type === \u0026#34;boolean\u0026#34; || type === \u0026#34;string\u0026#34;) { // ...... } [建议] 如果函数或全局中的 else 块后没有任何语句，可以删除 else。 示例：\n// good function getName() { if (name) { return name; } return \u0026#34;unnamed\u0026#34;; } // bad function getName() { if (name) { return name; } else { return \u0026#34;unnamed\u0026#34;; } } 3.3 循环 [建议] 不要在循环体中包含函数表达式，事先将函数提取到循环体外。 解释：\n循环体中的函数表达式，运行过程中会生成循环次数个函数对象。\n示例：\n// good function clicker() { // ...... } for (var i = 0, len = elements.length; i \u0026lt; len; i++) { var element = elements[i]; addListener(element, \u0026#34;click\u0026#34;, clicker); } // bad for (var i = 0, len = elements.length; i \u0026lt; len; i++) { var element = elements[i]; addListener(element, \u0026#34;click\u0026#34;, function() {}); } [建议] 对循环内多次使用的不变值，在循环外用变量缓存。 示例：\n// good var width = wrap.offsetWidth + \u0026#34;px\u0026#34;; for (var i = 0, len = elements.length; i \u0026lt; len; i++) { var element = elements[i]; element.style.width = width; // ...... } // bad for (var i = 0, len = elements.length; i \u0026lt; len; i++) { var element = elements[i]; element.style.width = wrap.offsetWidth + \u0026#34;px\u0026#34;; // ...... } [建议] 对有序集合进行遍历时，缓存 length。 解释：\n虽然现代浏览器都对数组长度进行了缓存，但对于一些宿主对象和老旧浏览器的数组对象，在每次 length 访问时会动态计算元素个数，此时缓存 length 能有效提高程序性能。\n示例：\nfor (var i = 0, len = elements.length; i \u0026lt; len; i++) { var element = elements[i]; // ...... } [建议] 对有序集合进行顺序无关的遍历时，使用逆序遍历。 解释：\n逆序遍历可以节省变量，代码比较优化。\n示例：\nvar len = elements.length; while (len--) { var element = elements[len]; // ...... } 3.4 类型 3.4.1 类型检测 [建议] 类型检测优先使用 typeof。对象类型检测使用 instanceof。null 或 undefined 的检测使用 == null。 示例：\n// string typeof variable === \u0026#34;string\u0026#34;; // number typeof variable === \u0026#34;number\u0026#34;; // boolean typeof variable === \u0026#34;boolean\u0026#34;; // Function typeof variable === \u0026#34;function\u0026#34;; // Object typeof variable === \u0026#34;object\u0026#34;; // RegExp variable instanceof RegExp; // Array variable instanceof Array; // null variable === null; // null or undefined variable == null; // undefined typeof variable === \u0026#34;undefined\u0026#34;; 3.4.2 类型转换 [建议] 转换成 string 时，使用 + ''。 示例：\n// good num + \u0026#34;\u0026#34;; // bad new String(num); num.toString(); String(num); [建议] 转换成 number 时，通常使用 +。 示例：\n// good +str; // bad Number(str); [建议] string 转换成 number，要转换的字符串结尾包含非数字并期望忽略时，使用 parseInt。 示例：\nvar width = \u0026#34;200px\u0026#34;; parseInt(width, 10); [强制] 使用 parseInt 时，必须指定进制。 示例：\n// good parseInt(str, 10); // bad parseInt(str); [建议] 转换成 boolean 时，使用 !!。 示例：\nvar num = 3.14; !!num; [建议] number 去除小数点，使用 Math.floor / Math.round / Math.ceil，不使用 parseInt。 示例：\n// good var num = 3.14; Math.ceil(num); // bad var num = 3.14; parseInt(num, 10); 3.5 字符串 [强制] 字符串开头和结束使用单引号 '。 解释：\n 输入单引号不需要按住 shift，方便输入。 实际使用中，字符串经常用来拼接 HTML。为方便 HTML 中包含双引号而不需要转义写法。  示例：\nvar str = \u0026#34;我是一个字符串\u0026#34;; var html = \u0026#39;\u0026lt;div class=\u0026#34;cls\u0026#34;\u0026gt;拼接HTML可以省去双引号转义\u0026lt;/div\u0026gt;\u0026#39;; [建议] 使用 数组 或 + 拼接字符串。 解释：\n 使用 + 拼接字符串，如果拼接的全部是 StringLiteral，压缩工具可以对其进行自动合并的优化。所以，静态字符串建议使用 + 拼接。 在现代浏览器下，使用 + 拼接字符串，性能较数组的方式要高。 如需要兼顾老旧浏览器，应尽量使用数组拼接字符串。  示例：\n// 使用数组拼接字符串 var str = [ // 推荐换行开始并缩进开始第一个字符串, 对齐代码, 方便阅读.  \u0026#39;\u0026lt;ul\u0026gt;\u0026#39;, \u0026#39;\u0026lt;li\u0026gt;第一项\u0026lt;/li\u0026gt;\u0026#39;, \u0026#39;\u0026lt;li\u0026gt;第二项\u0026lt;/li\u0026gt;\u0026#39;, \u0026#39;\u0026lt;/ul\u0026gt;\u0026#39; ].join(\u0026#39;\u0026#39;); // 使用 `+` 拼接字符串 var str2 = \u0026#39;\u0026#39; // 建议第一个为空字符串, 第二个换行开始并缩进开始, 对齐代码, 方便阅读  + \u0026#39;\u0026lt;ul\u0026gt;\u0026#39;, + \u0026#39;\u0026lt;li\u0026gt;第一项\u0026lt;/li\u0026gt;\u0026#39;, + \u0026#39;\u0026lt;li\u0026gt;第二项\u0026lt;/li\u0026gt;\u0026#39;, + \u0026#39;\u0026lt;/ul\u0026gt;\u0026#39;; [建议] 使用字符串拼接的方式生成 HTML，需要根据语境进行合理的转义。 解释：\n在 JavaScript 中拼接，并且最终将输出到页面中的字符串，需要进行合理转义，以防止安全漏洞。下面的示例代码为场景说明，不能直接运行。\n示例：\n// HTML 转义 var str = \u0026#34;\u0026lt;p\u0026gt;\u0026#34; + htmlEncode(content) + \u0026#34;\u0026lt;/p\u0026gt;\u0026#34;; // HTML 转义 var str = \u0026#39;\u0026lt;input type=\u0026#34;text\u0026#34; value=\u0026#34;\u0026#39; + htmlEncode(value) + \u0026#39;\u0026#34;\u0026gt;\u0026#39;; // URL 转义 var str = \u0026#39;\u0026lt;a href=\u0026#34;/?key=\u0026#39; + htmlEncode(urlEncode(value)) + \u0026#39;\u0026#34;\u0026gt;link\u0026lt;/a\u0026gt;\u0026#39;; // JavaScript字符串 转义 + HTML 转义 var str = \u0026#34;\u0026lt;button onclick=\\\u0026#34;check(\u0026#39;\u0026#34; + htmlEncode(strLiteral(name)) + \u0026#34;\u0026#39;)\\\u0026#34;\u0026gt;提交\u0026lt;/button\u0026gt;\u0026#34;; [建议] 复杂的数据到视图字符串的转换过程，选用一种模板引擎。 解释：\n使用模板引擎有如下好处：\n 在开发过程中专注于数据，将视图生成的过程由另外一个层级维护，使程序逻辑结构更清晰。 优秀的模板引擎，通过模板编译技术和高质量的编译产物，能获得比手工拼接字符串更高的性能。 模板引擎能方便的对动态数据进行相应的转义，部分模板引擎默认进行 HTML 转义，安全性更好。   artTemplate: 体积较小，在所有环境下性能高，语法灵活。 dot.js: 体积小，在现代浏览器下性能高，语法灵活。 etpl: 体积较小，在所有环境下性能高，模板复用性高，语法灵活。 handlebars: 体积大，在所有环境下性能高，扩展性高。 hogon: 体积小，在现代浏览器下性能高。 nunjucks: 体积较大，性能一般，模板复用性高。  3.6 对象 [强制] 使用对象字面量 {} 创建新 Object。 示例：\n// good var obj = {}; // bad var obj = new Object(); [建议] 对象创建时，如果一个对象的所有 属性 均可以不添加引号，建议所有 属性 不添加引号。 示例：\nvar info = { name: \u0026#34;someone\u0026#34;, age: 28 }; [建议] 对象创建时，如果任何一个 属性 需要添加引号，则所有 属性 建议添加 '。 解释：\n如果属性不符合 Identifier 和 NumberLiteral 的形式，就需要以 StringLiteral 的形式提供。\n示例：\n// good var info = { name: \u0026#34;someone\u0026#34;, age: 28, \u0026#34;more-info\u0026#34;: \u0026#34;...\u0026#34; }; // bad var info = { name: \u0026#34;someone\u0026#34;, age: 28, \u0026#34;more-info\u0026#34;: \u0026#34;...\u0026#34; }; [强制] 不允许修改和扩展任何原生对象和宿主对象的原型。 示例：\n// 以下行为绝对禁止 String.prototype.trim = function() {}; [建议] 属性访问时，尽量使用 .。 解释：\n属性名符合 Identifier 的要求，就可以通过 . 来访问，否则就只能通过 [expr] 方式访问。\n通常在 JavaScript 中声明的对象，属性命名是使用 Camel 命名法，用 . 来访问更清晰简洁。部分特殊的属性（比如来自后端的 JSON ），可能采用不寻常的命名方式，可以通过 [expr] 方式访问。\n示例：\ninfo.age; info[\u0026#34;more-info\u0026#34;]; [建议] for in 遍历对象时, 使用 hasOwnProperty 过滤掉原型中的属性。 示例：\nvar newInfo = {}; for (var key in info) { if (info.hasOwnProperty(key)) { newInfo[key] = info[key]; } } 3.7 数组 [强制] 使用数组字面量 [] 创建新数组，除非想要创建的是指定长度的数组。 示例：\n// good var arr = []; // bad var arr = new Array(); [强制] 遍历数组不使用 for in。 解释：\n数组对象可能存在数字以外的属性, 这种情况下 for in 不会得到正确结果。\n示例：\nvar arr = [\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;]; // 这里仅作演示, 实际中应使用 Object 类型 arr.other = \u0026#34;other things\u0026#34;; // 正确的遍历方式 for (var i = 0, len = arr.length; i \u0026lt; len; i++) { console.log(i); } // 错误的遍历方式 for (var i in arr) { console.log(i); } [建议] 不因为性能的原因自己实现数组排序功能，尽量使用数组的 sort 方法。 解释：\n自己实现的常规排序算法，在性能上并不优于数组默认的 sort 方法。以下两种场景可以自己实现排序：\n 需要稳定的排序算法，达到严格一致的排序结果。 数据特点鲜明，适合使用桶排。  [建议] 清空数组使用 .length = 0。 3.8 函数 3.8.1 函数长度 [建议] 一个函数的长度控制在 50 行以内。 解释：\n将过多的逻辑单元混在一个大函数中，易导致难以维护。一个清晰易懂的函数应该完成单一的逻辑单元。复杂的操作应进一步抽取，通过函数的调用来体现流程。\n特定算法等不可分割的逻辑允许例外。\n示例：\nfunction syncViewStateOnUserAction() { if (x.checked) { y.checked = true; z.value = \u0026#34;\u0026#34;; } else { y.checked = false; } if (a.value) { warning.innerText = \u0026#34;\u0026#34;; submitButton.disabled = false; } else { warning.innerText = \u0026#34;Please enter it\u0026#34;; submitButton.disabled = true; } } // 直接阅读该函数会难以明确其主线逻辑，因此下方是一种更合理的表达方式：  function syncViewStateOnUserAction() { syncXStateToView(); checkAAvailability(); } function syncXStateToView() { y.checked = x.checked; if (x.checked) { z.value = \u0026#34;\u0026#34;; } } function checkAAvailability() { if (a.value) { clearWarnignForA(); } else { displayWarningForAMissing(); } } 3.8.2 参数设计 [建议] 一个函数的参数控制在 6 个以内。 解释：\n除去不定长参数以外，函数具备不同逻辑意义的参数建议控制在 6 个以内，过多参数会导致维护难度增大。\n某些情况下，如使用 AMD Loader 的 require 加载多个模块时，其 callback 可能会存在较多参数，因此对函数参数的个数不做强制限制。\n[建议] 通过 options 参数传递非数据输入型参数。 解释：\n有些函数的参数并不是作为算法的输入，而是对算法的某些分支条件判断之用，此类参数建议通过一个 options 参数传递。\n如下函数：\n/** * 移除某个元素 * * @param {Node} element 需要移除的元素 * @param {boolean} removeEventListeners 是否同时将所有注册在元素上的事件移除 */ function removeElement(element, removeEventListeners) { element.parent.removeChild(element); if (removeEventListeners) { element.clearEventListeners(); } } 可以转换为下面的签名：\n/** * 移除某个元素 * * @param {Node} element 需要移除的元素 * @param {Object} options 相关的逻辑配置 * @param {boolean} options.removeEventListeners 是否同时将所有注册在元素上的事件移除 */ function removeElement(element, options) { element.parent.removeChild(element); if (options.removeEventListeners) { element.clearEventListeners(); } } 这种模式有几个显著的优势：\n boolean 型的配置项具备名称，从调用的代码上更易理解其表达的逻辑意义。 当配置项有增长时，无需无休止地增加参数个数，不会出现 removeElement(element, true, false, false, 3) 这样难以理解的调用代码。 当部分配置参数可选时，多个参数的形式非常难处理重载逻辑，而使用一个 options 对象只需判断属性是否存在，实现得以简化。  3.8.3 闭包 [建议] 在适当的时候将闭包内大对象置为 null。 解释：\n在 JavaScript 中，无需特别的关键词就可以使用闭包，一个函数可以任意访问在其定义的作用域外的变量。需要注意的是，函数的作用域是静态的，即在定义时决定，与调用的时机和方式没有任何关系。\n闭包会阻止一些变量的垃圾回收，对于较老旧的 JavaScript 引擎，可能导致外部所有变量均无法回收。\n首先一个较为明确的结论是，以下内容会影响到闭包内变量的回收：\n 嵌套的函数中是否有使用该变量。 嵌套的函数中是否有 直接调用 eval。 是否使用了 with 表达式。  Chakra、V8 和 SpiderMonkey 将受以上因素的影响，表现出不尽相同又较为相似的回收策略，而 JScript.dll 和 Carakan 则完全没有这方面的优化，会完整保留整个 LexicalEnvironment 中的所有变量绑定，造成一定的内存消耗。\n由于对闭包内变量有回收优化策略的 Chakra、V8 和 SpiderMonkey 引擎的行为较为相似，因此可以总结如下，当返回一个函数 fn 时：\n 如果 fn 的 [[Scope]] 是 ObjectEnvironment（with 表达式生成 ObjectEnvironment，函数和 catch 表达式生成 DeclarativeEnvironment），则：  如果是 V8 引擎，则退出全过程。 如果是 SpiderMonkey，则处理该 ObjectEnvironment 的外层 LexicalEnvironment。   获取当前 LexicalEnvironment 下的所有类型为 Function 的对象，对于每一个 Function 对象，分析其 FunctionBody：  如果 FunctionBody 中含有 直接调用 eval，则退出全过程。 否则得到所有的 Identifier。 对于每一个 Identifier，设其为 name，根据查找变量引用的规则，从 LexicalEnvironment 中找出名称为 name 的绑定 binding。 对 binding 添加 notSwap 属性，其值为 true。   检查当前 LexicalEnvironment 中的每一个变量绑定，如果该绑定有 notSwap 属性且值为 true，则：  如果是 V8 引擎，删除该绑定。 如果是 SpiderMonkey，将该绑定的值设为 undefined，将删除 notSwap 属性。    对于 Chakra 引擎，暂无法得知是按 V8 的模式还是按 SpiderMonkey 的模式进行。\n如果有 非常庞大 的对象，且预计会在 老旧的引擎 中执行，则使用闭包时，注意将闭包不需要的对象置为空引用。\n[建议] 使用 IIFE 避免 Lift 效应。 解释：\n在引用函数外部变量时，函数执行时外部变量的值由运行时决定而非定义时，最典型的场景如下：\nvar tasks = []; for (var i = 0; i \u0026lt; 5; i++) { tasks[tasks.length] = function() { console.log(\u0026#34;Current cursor is at \u0026#34; + i); }; } var len = tasks.length; while (len--) { tasks[len](); } 以上代码对 tasks 中的函数的执行均会输出 Current cursor is at 5，往往不符合预期。\n此现象称为 Lift 效应 。解决的方式是通过额外加上一层闭包函数，将需要的外部变量作为参数传递来解除变量的绑定关系：\nvar tasks = []; for (var i = 0; i \u0026lt; 5; i++) { // 注意有一层额外的闭包  tasks[tasks.length] = (function(i) { return function() { console.log(\u0026#34;Current cursor is at \u0026#34; + i); }; })(i); } var len = tasks.length; while (len--) { tasks[len](); } 3.8.4 空函数 [建议] 空函数不使用 new Function() 的形式。 示例：\nvar emptyFunction = function() {}; [建议] 对于性能有高要求的场合，建议存在一个空函数的常量，供多处使用共享。 示例：\nvar EMPTY_FUNCTION = function() {}; function MyClass() {} MyClass.prototype.abstractMethod = EMPTY_FUNCTION; MyClass.prototype.hooks.before = EMPTY_FUNCTION; MyClass.prototype.hooks.after = EMPTY_FUNCTION; 3.9 面向对象 [强制] 类的继承方案，实现时需要修正 constructor。 解释：\n通常使用其他 library 的类继承方案都会进行 constructor 修正。如果是自己实现的类继承方案，需要进行 constructor 修正。\n示例：\n/** * 构建类之间的继承关系 * * @param {Function} subClass 子类函数 * @param {Function} superClass 父类函数 */ function inherits(subClass, superClass) { var F = new Function(); F.prototype = superClass.prototype; subClass.prototype = new F(); subClass.prototype.constructor = subClass; } [建议] 声明类时，保证 constructor 的正确性。 示例：\nfunction Animal(name) { this.name = name; } // 直接prototype等于对象时，需要修正constructor Animal.prototype = { constructor: Animal, jump: function() { alert(\u0026#34;animal \u0026#34; + this.name + \u0026#34; jump\u0026#34;); } }; // 这种方式扩展prototype则无需理会constructor Animal.prototype.jump = function() { alert(\u0026#34;animal \u0026#34; + this.name + \u0026#34; jump\u0026#34;); }; [建议] 属性在构造函数中声明，方法在原型中声明。 解释：\n原型对象的成员被所有实例共享，能节约内存占用。所以编码时我们应该遵守这样的原则：原型对象包含程序不会修改的成员，如方法函数或配置项。\nfunction TextNode(value, engine) { this.value = value; this.engine = engine; } TextNode.prototype.clone = function() { return this; }; [强制] 自定义事件的 事件名 必须全小写。 解释：\n在 JavaScript 广泛应用的浏览器环境，绝大多数 DOM 事件名称都是全小写的。为了遵循大多数 JavaScript 开发者的习惯，在设计自定义事件时，事件名也应该全小写。\n[强制] 自定义事件只能有一个 event 参数。如果事件需要传递较多信息，应仔细设计事件对象。 解释：\n一个事件对象的好处有：\n 顺序无关，避免事件监听者需要记忆参数顺序。 每个事件信息都可以根据需要提供或者不提供，更自由。 扩展方便，未来添加事件信息时，无需考虑会破坏监听器参数形式而无法向后兼容。  [建议] 设计自定义事件时，应考虑禁止默认行为。 解释：\n常见禁止默认行为的方式有两种：\n 事件监听函数中 return false。 事件对象中包含禁止默认行为的方法，如 preventDefault。  3.10 动态特性 3.10.1 eval [强制] 避免使用直接 eval 函数。 解释：\n直接 eval，指的是以函数方式调用 eval 的调用方法。直接 eval 调用执行代码的作用域为本地作用域，应当避免。\n如果有特殊情况需要使用直接 eval，需在代码中用详细的注释说明为何必须使用直接 eval，不能使用其它动态执行代码的方式，同时需要其他资深工程师进行 Code Review。\n[建议] 尽量避免使用 eval 函数。 3.10.2 动态执行代码 [建议] 使用 new Function 执行动态代码。 解释：\n通过 new Function 生成的函数作用域是全局使用域，不会影响当当前的本地作用域。如果有动态代码执行的需求，建议使用 new Function。\n示例：\nvar handler = new Function(\u0026#34;x\u0026#34;, \u0026#34;y\u0026#34;, \u0026#34;return x + y;\u0026#34;); var result = handler($(\u0026#34;#x\u0026#34;).val(), $(\u0026#34;#y\u0026#34;).val()); 3.10.3 with [建议] 尽量不要使用 with。 解释：\n使用 with 可能会增加代码的复杂度，不利于阅读和管理；也会对性能有影响。大多数使用 with 的场景都能使用其他方式较好的替代。所以，尽量不要使用 with。\n3.10.4 delete [建议] 减少 delete 的使用。 解释：\n如果没有特别的需求，减少或避免使用 delete。delete 的使用会破坏部分 JavaScript 引擎的性能优化。\n[建议] 处理 delete 可能产生的异常。 解释：\n对于有被遍历需求，且值 null 被认为具有业务逻辑意义的值的对象，移除某个属性必须使用 delete 操作。\n在严格模式或 IE 下使用 delete 时，不能被删除的属性会抛出异常，因此在不确定属性是否可以删除的情况下，建议添加 try-catch 块。\n示例：\ntry { delete o.x; } catch (deleteError) { o.x = null; } 3.10.5 对象属性 [建议] 避免修改外部传入的对象。 解释：\nJavaScript 因其脚本语言的动态特性，当一个对象未被 seal 或 freeze 时，可以任意添加、删除、修改属性值。\n但是随意地对 非自身控制的对象 进行修改，很容易造成代码在不可预知的情况下出现问题。因此，设计良好的组件、函数应该避免对外部传入的对象的修改。\n下面代码的 selectNode 方法修改了由外部传入的 datasource 对象。如果 datasource 用在其它场合（如另一个 Tree 实例）下，会造成状态的混乱。\nfunction Tree(datasource) { this.datasource = datasource; } Tree.prototype.selectNode = function(id) { // 从datasource中找出节点对象  var node = this.findNode(id); if (node) { node.selected = true; this.flushView(); } }; 对于此类场景，需要使用额外的对象来维护，使用由自身控制，不与外部产生任何交互的 selectedNodeIndex 对象来维护节点的选中状态，不对 datasource 作任何修改。\nfunction Tree(datasource) { this.datasource = datasource; this.selectedNodeIndex = {}; } Tree.prototype.selectNode = function(id) { // 从datasource中找出节点对象  var node = this.findNode(id); if (node) { this.selectedNodeIndex[id] = true; this.flushView(); } }; 除此之外，也可以通过 deepClone 等手段将自身维护的对象与外部传入的分离，保证不会相互影响。\n[建议] 具备强类型的设计。 解释：\n 如果一个属性被设计为 boolean 类型，则不要使用 1 或 0 作为其值。对于标识性的属性，如对代码体积有严格要求，可以从一开始就设计为 number 类型且将 0 作为否定值。 从 DOM 中取出的值通常为 string 类型，如果有对象或函数的接收类型为 number 类型，提前作好转换，而不是期望对象、函数可以处理多类型的值。  4 浏览器环境 4.1 模块化 4.1.1 AMD [强制] 使用 AMD 作为模块定义。 解释：\nAMD 作为由社区认可的模块定义形式，提供多种重载提供灵活的使用方式，并且绝大多数优秀的 Library 都支持 AMD，适合作为规范。\n目前，比较成熟的 AMD Loader 有：\n 官方实现的 requirejs 百度自己实现的 esl  [强制] 模块 id 必须符合标准。 解释：\n模块 id 必须符合以下约束条件：\n 类型为 string，并且是由 / 分割的一系列 terms 来组成。例如：this/is/a/module。 term 应该符合 [a-zA-Z0-9_-:]+ 规则。 不应该有 .js 后缀。 跟文件的路径保持一致。  4.1.2 define [建议] 定义模块时不要指明 id 和 dependencies。 解释：\n在 AMD 的设计思想里，模块名称是和所在路径相关的，匿名的模块更利于封包和迁移。模块依赖应在模块定义内部通过 local require 引用。\n所以，推荐使用 define(factory) 的形式进行模块定义。\n示例：\ndefine(function(require) {}); [建议] 使用 return 来返回模块定义。 解释：\n使用 return 可以减少 factory 接收的参数（不需要接收 exports 和 module），在没有 AMD Loader 的场景下也更容易进行简单的处理来伪造一个 Loader。\n示例：\ndefine(function(require) { var exports = {}; // ...  return exports; }); 4.1.3 require [强制] 全局运行环境中，require 必须以 async require 形式调用。 解释：\n模块的加载过程是异步的，同步调用并无法保证得到正确的结果。\n示例：\n// good require([\u0026#34;foo\u0026#34;], function(foo) {}); // bad var foo = require(\u0026#34;foo\u0026#34;); [强制] 模块定义中只允许使用 local require，不允许使用 global require。 解释：\n 在模块定义中使用 global require，对封装性是一种破坏。 在 AMD 里，global require 是可以被重命名的。并且 Loader 甚至没有全局的 require 变量，而是用 Loader 名称做为 global require。模块定义不应该依赖使用的 Loader。  [强制] Package 在实现时，内部模块的 require 必须使用 relative id。 解释：\n对于任何可能通过 发布-引入 的形式复用的第三方库、框架、包，开发者所定义的名称不代表使用者使用的名称。因此不要基于任何名称的假设。在实现源码中，require 自身的其它模块时使用 relative id。\n示例：\ndefine(function(require) { var util = require(\u0026#34;./util\u0026#34;); }); [建议] 不会被调用的依赖模块，在 factory 开始处统一 require。 解释：\n有些模块是依赖的模块，但不会在模块实现中被直接调用，最为典型的是 css / js / tpl 等 Plugin 所引入的外部内容。此类内容建议放在模块定义最开始处统一引用。\n示例：\ndefine(function(require) { require(\u0026#34;css!foo.css\u0026#34;); require(\u0026#34;tpl!bar.tpl.html\u0026#34;); // ... }); 4.2 DOM 4.2.1 元素获取 [建议] 对于单个元素，尽可能使用 document.getElementById 获取，避免使用document.all。 [建议] 对于多个元素的集合，尽可能使用 context.getElementsByTagName 获取。其中 context 可以为 document 或其他元素。指定 tagName 参数为 * 可以获得所有子元素。 [建议] 遍历元素集合时，尽量缓存集合长度。如需多次操作同一集合，则应将集合转为数组。 解释：\n原生获取元素集合的结果并不直接引用 DOM 元素，而是对索引进行读取，所以 DOM 结构的改变会实时反映到结果中。\n示例：\n\u0026lt;div\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;span\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;script\u0026gt; var elements = document.getElementsByTagName(\u0026#34;*\u0026#34;); // 显示为 DIV  alert(elements[0].tagName); var div = elements[0]; var p = document.createElement(\u0026#34;p\u0026#34;); docpment.body.insertBefore(p, div); // 显示为 P  alert(elements[0].tagName); \u0026lt;/script\u0026gt; [建议] 获取元素的直接子元素时使用 children。避免使用childNodes，除非预期是需要包含文本、注释和属性类型的节点。 4.2.2 样式获取 [建议] 获取元素实际样式信息时，应使用 getComputedStyle 或 currentStyle。 解释：\n通过 style 只能获得内联定义或通过 JavaScript 直接设置的样式。通过 CSS class 设置的元素样式无法直接通过 style 获取。\n4.2.3 样式设置 [建议] 尽可能通过为元素添加预定义的 className 来改变元素样式，避免直接操作 style 设置。 [强制] 通过 style 对象设置元素样式时，对于带单位非 0 值的属性，不允许省略单位。 解释：\n除了 IE，标准浏览器会忽略不规范的属性值，导致兼容性问题。\n4.2.4 DOM 操作 [建议] 操作 DOM 时，尽量减少页面 reflow。 解释：\n页面 reflow 是非常耗时的行为，非常容易导致性能瓶颈。下面一些场景会触发浏览器的 reflow：\n DOM 元素的添加、修改（内容）、删除。 应用新的样式或者修改任何影响元素布局的属性。 Resize 浏览器窗口、滚动页面。 读取元素的某些属性（offsetLeft、offsetTop、offsetHeight、offsetWidth、scrollTop/Left/Width/Height、clientTop/Left/Width/Height、getComputedStyle()、currentStyle(in IE)) 。  [建议] 尽量减少 DOM 操作。 解释：\nDOM 操作也是非常耗时的一种操作，减少 DOM 操作有助于提高性能。举一个简单的例子，构建一个列表。我们可以用两种方式：\n 在循环体中 createElement 并 append 到父元素中。 在循环体中拼接 HTML 字符串，循环结束后写父元素的 innerHTML。  第一种方法看起来比较标准，但是每次循环都会对 DOM 进行操作，性能极低。在这里推荐使用第二种方法。\n4.2.5 DOM 事件 [建议] 优先使用 addEventListener / attachEvent 绑定事件，避免直接在 HTML 属性中或 DOM 的 expando 属性绑定事件处理。 解释：\nexpando 属性绑定事件容易导致互相覆盖。\n[建议] 使用 addEventListener 时第三个参数使用 false。 解释：\n标准浏览器中的 addEventListener 可以通过第三个参数指定两种时间触发模型：冒泡和捕获。而 IE 的 attachEvent 仅支持冒泡的事件触发。所以为了保持一致性，通常 addEventListener 的第三个参数都为 false。\n[建议] 在没有事件自动管理的框架支持下，应持有监听器函数的引用，在适当时候（元素释放、页面卸载等）移除添加的监听器。 "});index.add({'id':57,'href':'/note-cs/docs/basic/pl/objective-c/basic/practice/spec/baidu/','title':"百度",'content':"百度 Objective-C 编码规范 (2019 版) "});index.add({'id':58,'href':'/note-cs/docs/basic/pl/php/basic/practice/spec/baidu/','title':"百度",'content':"百度 PHP 编码规范 (201904 版) "});index.add({'id':59,'href':'/note-cs/docs/basic/pl/javascript/basic/practice/spec/baidu/','title':"百度前端编程规范",'content':"百度前端编程规范 "});index.add({'id':60,'href':'/note-cs/docs/basic/pl/rust/basic/','title':"第一部分 Rust 基础",'content':""});index.add({'id':61,'href':'/note-cs/docs/basic/','title':"第一部分 基础",'content':""});index.add({'id':62,'href':'/note-cs/docs/basic/db/mysql/basic/','title':"第一部分 基础入门",'content':""});index.add({'id':63,'href':'/note-cs/docs/basic/db/postgresql/basic/','title':"第一部分 基础入门",'content':""});index.add({'id':64,'href':'/note-cs/docs/basic/db/redis/basic/','title':"第一部分 基础入门",'content':""});index.add({'id':65,'href':'/note-cs/docs/basic/os/android/basic/','title':"第一部分 基础入门",'content':""});index.add({'id':66,'href':'/note-cs/docs/basic/os/ios/basic/','title':"第一部分 基础入门",'content':""});index.add({'id':67,'href':'/note-cs/docs/basic/os/macos/basic/','title':"第一部分 基础入门",'content':""});index.add({'id':68,'href':'/note-cs/docs/basic/os/unix/basic/','title':"第一部分 基础入门",'content':""});index.add({'id':69,'href':'/note-cs/docs/basic/os/windows/basic/','title':"第一部分 基础入门",'content':""});index.add({'id':70,'href':'/note-cs/docs/basic/pl/c/basic/','title':"第一部分 基础入门",'content':""});index.add({'id':71,'href':'/note-cs/docs/basic/pl/cpp/basic/','title':"第一部分 基础入门",'content':"C++ (/ˌsiːˌplʌsˈplʌs/) 的发明人是 Bjarne Stroustrup (/ˈbjɑːrnə ˈstraʊstrʊp/, 1950/12/30, http://www.stroustrup.com)，\nC++ 的历史可以追溯到 1979，最初的灵感来自一种叫作 Simula 的语言。 起初，Bjarne Stroustrup 把他发明的语言称为 Cfront，1983 年更名为 C++。\n1998 年，C++ 标准委员会发布了第一个 C++ 国际标准 ISO/IEC 14882:1998，俗称 C++98。 C++98 包含了标准模板库 (Standard Template Library，STL)。\n2003 年，C++ 标准委员会修正了 C++98 的若干错误，发布了第二个 C++ 国际标准 ISO/IEC 14882:2003，俗称 C++03。\n之后，C++ 发展缓慢，直到 2011 年，C++ 标准委员会发布了第三个 C++ 国际标准 ISO/IEC 14882:2011，俗称 C++11。 C++11 是一次大改动，给 C++ 增加了一些很有用的功能，比如：右值引用 (Rvalue)、Lambda、对多线程的支持（包括原子操作）和智能指针等。 在 C++11 之后，C++ 标准委员会以每三年更新一次的速度向前推进 C++ 标准。\n2014 年发布 ISO/IEC 14882:2014，俗称 C++14。 C++14 只是小改动，主要修正 C++11 的错误，增加的功能不多，但包含了读写锁。\n2017 年发布 ISO/IEC 14882:2017，俗称 C++17。 C++17 增加了对文件系统的支持。\nC++20 在制定中。\n"});index.add({'id':72,'href':'/note-cs/docs/basic/pl/csharp/basic/','title':"第一部分 基础入门",'content':""});index.add({'id':73,'href':'/note-cs/docs/basic/pl/javascript/basic/','title':"第一部分 基础入门",'content':""});index.add({'id':74,'href':'/note-cs/docs/basic/pl/kotlin/basic/','title':"第一部分 基础入门",'content':""});index.add({'id':75,'href':'/note-cs/docs/basic/pl/lua/basic/','title':"第一部分 基础入门",'content':""});index.add({'id':76,'href':'/note-cs/docs/basic/pl/objective-c/basic/','title':"第一部分 基础入门",'content':""});index.add({'id':77,'href':'/note-cs/docs/basic/pl/php/basic/','title':"第一部分 基础入门",'content':""});index.add({'id':78,'href':'/note-cs/docs/basic/pl/ruby/basic/','title':"第一部分 基础入门",'content':""});index.add({'id':79,'href':'/note-cs/docs/basic/pl/scala/basic/','title':"第一部分 基础入门",'content':""});index.add({'id':80,'href':'/note-cs/docs/basic/pl/swift/basic/','title':"第一部分 基础入门",'content':""});index.add({'id':81,'href':'/note-cs/docs/direction/be/platform/nodejs/basic/','title':"第一部分 基础入门",'content':""});index.add({'id':82,'href':'/note-cs/docs/direction/client/android/basic/','title':"第一部分 基础入门",'content':""});index.add({'id':83,'href':'/note-cs/docs/direction/client/ios/basic/','title':"第一部分 基础入门",'content':""});index.add({'id':84,'href':'/note-cs/docs/direction/client/xiaochengxu/basic/','title':"第一部分 基础入门",'content':""});index.add({'id':85,'href':'/note-cs/docs/direction/embedded/basic/','title':"第一部分 基础入门",'content':""});index.add({'id':86,'href':'/note-cs/docs/direction/fe/frame/angular/basic/','title':"第一部分 基础入门",'content':""});index.add({'id':87,'href':'/note-cs/docs/direction/fe/frame/react/basic/','title':"第一部分 基础入门",'content':""});index.add({'id':88,'href':'/note-cs/docs/direction/fe/frame/vue/basic/','title':"第一部分 基础入门",'content':""});index.add({'id':89,'href':'/note-cs/docs/direction/security/basic/','title':"第一部分 基础入门",'content':""});index.add({'id':90,'href':'/note-cs/docs/domain/cc/knative/basic/','title':"第一部分 基础入门",'content':""});index.add({'id':91,'href':'/note-cs/docs/basic/db/mysql/basic/practice/spec/','title':"编程规范",'content':"编程规范 "});index.add({'id':92,'href':'/note-cs/docs/basic/db/postgresql/basic/practice/spec/','title':"编程规范",'content':"编程规范 "});index.add({'id':93,'href':'/note-cs/docs/basic/db/redis/basic/practice/spec/','title':"编程规范",'content':"编程规范 "});index.add({'id':94,'href':'/note-cs/docs/basic/pl/c/basic/practice/spec/','title':"编程规范",'content':"编程规范 "});index.add({'id':95,'href':'/note-cs/docs/basic/pl/cpp/basic/practice/spec/','title':"编程规范",'content':"编程规范 "});index.add({'id':96,'href':'/note-cs/docs/basic/pl/javascript/basic/practice/spec/','title':"编程规范",'content':"编程规范 "});index.add({'id':97,'href':'/note-cs/docs/basic/pl/objective-c/basic/practice/spec/','title':"编程规范",'content':"编程规范 "});index.add({'id':98,'href':'/note-cs/docs/basic/pl/php/basic/practice/spec/','title':"编程规范",'content':"编程规范 "});index.add({'id':99,'href':'/note-cs/docs/basic/pl/rust/basic/practice/spec/','title':"编程规范",'content':"编程规范 "});index.add({'id':100,'href':'/note-cs/docs/direction/be/platform/nodejs/basic/practice/spec/','title':"编程规范",'content':"编程规范 "});index.add({'id':101,'href':'/note-cs/docs/direction/client/android/basic/practice/spec/','title':"编程规范",'content':"编程规范 "});index.add({'id':102,'href':'/note-cs/docs/direction/client/ios/basic/practice/spec/','title':"编程规范",'content':"编程规范 "});index.add({'id':103,'href':'/note-cs/docs/direction/client/xiaochengxu/basic/practice/spec/','title':"编程规范",'content':"编程规范 "});index.add({'id':104,'href':'/note-cs/docs/direction/embedded/basic/practice/spec/','title':"编程规范",'content':"编程规范 "});index.add({'id':105,'href':'/note-cs/docs/direction/fe/frame/angular/basic/practice/spec/','title':"编程规范",'content':"编程规范 "});index.add({'id':106,'href':'/note-cs/docs/direction/fe/frame/react/basic/practice/spec/','title':"编程规范",'content':"编程规范 "});index.add({'id':107,'href':'/note-cs/docs/direction/fe/frame/vue/basic/practice/spec/','title':"编程规范",'content':"编程规范 "});index.add({'id':108,'href':'/note-cs/docs/direction/security/basic/practice/spec/','title':"编程规范",'content':"编程规范 "});index.add({'id':109,'href':'/note-cs/docs/domain/cc/knative/basic/practice/spec/','title':"编程规范",'content':"编程规范 "});index.add({'id':110,'href':'/note-cs/docs/basic/pl/c/basic/grammar/','title':"语法",'content':"C 语法 "});index.add({'id':111,'href':'/note-cs/docs/basic/pl/cpp/basic/grammar/','title':"语法",'content':"C++ 语法 "});index.add({'id':112,'href':'/note-cs/docs/direction/fe/css/','title':"CSS",'content':"CSS "});index.add({'id':113,'href':'/note-cs/docs/basic/compile/make/makefile/','title':"makefile",'content':"makefile 简介 Makefile 用于定义如何创建目标文件，比如如何从源码到可执行文件。创建这一工具的目标是 减少不必要的编译或者任务。传说 Stuart Feldman 在 1976 年花了一个周末写出来的， 而今仍然使用广泛，特别是在 Unix 和 Linux 系统上。\n基础 语法  注释：# 文件名： 必须是 Makefile  区分大小写   make \u0026lt;target\u0026gt; 生成 target  重命名：make -f \u0026quot;filename\u0026quot; \u0026lt;target\u0026gt;   只认识 TAB，不认识空格  但是在 GNU Make 3.82 之后, 可以通过设置参数 .RECIPEPREFIX 进行修改   shell 符号  @：不把命令打印到 stdout -：发生错误了也没关系    target 声明  创建一个 target： targets : prerequisites recipe  prerequisites(依赖) 是可选的, recipe(做法) 也可以多个或者不给 targets 和 prerequisites 都可以是多个, 以空格分割 file2.txt file3.txt: file0.txt file1.txt touch file2.txt touch file3.txt    target 的声明顺序并不重要  上面的依赖可以下面再声明   如果声明重复的 target，make 会给一个 warning，后面会覆盖前面的  但是如果不定义任何 recipe, 就不会冲突, 只是多了依赖关系 file2.txt: file0.txt file3.txt    Phony(假的) Targets  意思是 tagets 并不是文件, 可以想象成一个任务的名字而已 因为不是文件, 无法比对是否有更新, 所以每次 make 都会执行 依赖于 phony target 的 target 也会每次 make 都执行, 即使 target 是文件   .PHONY  如果定义的 phony target 与文件名重名, 可以用 .PHONY 显式地指明哪些 targets 是 phony    常用 phony target  all clean install uninstall  变量与通配符  $^: 代表 prerequisites # 即便分开定义依赖, $^ 依然能拿到 # 非常智能的, ex1.txt 会被找到, file0.txt 会被去重 process: ex1.txt file0.txt @echo $^  $@: 代表 target, 如果 target 为多个, $@ 代表当前执行的那个 $\u0026lt;: prerequisite 中的第一个 $?: 需要更新的 prerequisite 文件列表 $+: 所有依赖, 包括重复的 $|: 竖线后面的 order-only prerequisites $*: target % 那部分, 包括路径 a.%.b: # $* match 的target % 那部分, 包括路径, 比如 `make dir/a.foo.b` 会打出 `dir/foo` @echo $*   模式匹配  make 会找到最具体的匹配  make small/foo.png 则会匹配下面这个规则（在这之前要先有 small/foo.svg 这个文件） %.png: %.svg inkscape --export-png $^ small/%.png: %.svg inkscape --export-png --export-dpi 30 $^    make 已经有一些内置的规则, 比如从 *.c 到 *.o  变量   变量都是字符串类型\n# 这俩是一样一样的 name = Ted name2=\u0026#34;Sarah\u0026#34;   设置变量，按以下顺序由高到低:\n 命令行参数. 比如试试 make echo name3=JICHAO Makefile 里面的 shell 中的环境变量 make 预设的一些变量    ?=\n# 如果 name 被设置过了, 就不设置了 name ?= Jean   override\n# 用 override 可以防止命令行参数设置的覆盖 override name = David ``   +\n# 用加号可以连接 (中间用空格分割) name4 +=grey   内置的变量\necho_inbuilt: echo $(CC) echo ${CXX)} echo $(FC) echo ${CFLAGS)} echo $(CPPFLAGS) echo ${CXXFLAGS} echo $(LDFLAGS) echo ${LDLIBS}   :=\n 等号声明时 recursively expanded 递归扩展 加个冒号可以声明 Simply expanded variables 即时扩展变量, 即只在声明时扩展一次  # var3 声明时找不到 var4, var3 会扩展成 `and good luck`，直接忽视 var4 var3 := $(var4) and good luck # var5 是正常的，扩展为 `good night and good luck` var5 = $(var4) and good luck var4 := good night   函数   函数调用格式\n$(func arg0,arg1,arg2...)   wildcard：将后面的通配符变成一串文件路径\n  patsubst：做替换\n# 把所有 markdown 后缀的文件重命名为 md 后缀 substitue: * @echo $(patsubst %.markdown,%.md,$* $^)   指令  include：引入别的 Makefile 文件 流程控制语句顶格写 sport = tennis # 流程控制语句 (如if else 等等) 顶格写 report: ifeq ($(sport),tennis) @echo \u0026#39;game, set, match\u0026#39; else @echo \u0026#34;They think it\u0026#39;s all over; it is now\u0026#34; endif    分支和变体 GNU make  进阶  原理 "});index.add({'id':114,'href':'/note-cs/docs/basic/db/mysql/appendix/interview/basic/','title':"基础",'content':"基础面试题 "});index.add({'id':115,'href':'/note-cs/docs/basic/db/postgresql/appendix/interview/basic/','title':"基础",'content':"基础面试题 "});index.add({'id':116,'href':'/note-cs/docs/basic/db/redis/appendix/interview/basic/','title':"基础",'content':"基础面试题 Redis 有哪些数据类型，分别适合什么场景？ Redis 如何做持久化？ Redis 如何实现高可用？ Redis 如何与 Mysql 做一致性同步？ "});index.add({'id':117,'href':'/note-cs/docs/basic/os/android/appendix/interview/basic/','title':"基础",'content':"基础面试题 "});index.add({'id':118,'href':'/note-cs/docs/basic/os/ios/appendix/interview/basic/','title':"基础",'content':"基础面试题 "});index.add({'id':119,'href':'/note-cs/docs/basic/os/macos/appendix/interview/basic/','title':"基础",'content':"基础面试题 "});index.add({'id':120,'href':'/note-cs/docs/basic/os/unix/appendix/interview/basic/','title':"基础",'content':"基础面试题 "});index.add({'id':121,'href':'/note-cs/docs/basic/os/windows/appendix/interview/basic/','title':"基础",'content':"基础面试题 "});index.add({'id':122,'href':'/note-cs/docs/basic/pl/c/appendix/interview/basic/','title':"基础",'content':"基础面试题 "});index.add({'id':123,'href':'/note-cs/docs/basic/pl/cpp/appendix/interview/basic/','title':"基础",'content':"基础面试题 "});index.add({'id':124,'href':'/note-cs/docs/basic/pl/csharp/appendix/interview/basic/','title':"基础",'content':"基础面试题 "});index.add({'id':125,'href':'/note-cs/docs/basic/pl/javascript/appendix/interview/basic/','title':"基础",'content':"基础面试题 "});index.add({'id':126,'href':'/note-cs/docs/basic/pl/kotlin/appendix/interview/basic/','title':"基础",'content':"基础面试题 "});index.add({'id':127,'href':'/note-cs/docs/basic/pl/lua/appendix/interview/basic/','title':"基础",'content':"基础面试题 "});index.add({'id':128,'href':'/note-cs/docs/basic/pl/objective-c/appendix/interview/basic/','title':"基础",'content':"基础面试题 "});index.add({'id':129,'href':'/note-cs/docs/basic/pl/php/appendix/interview/basic/','title':"基础",'content':"基础面试题 "});index.add({'id':130,'href':'/note-cs/docs/basic/pl/ruby/appendix/interview/basic/','title':"基础",'content':"基础面试题 "});index.add({'id':131,'href':'/note-cs/docs/basic/pl/rust/appendix/interview/basic/','title':"基础",'content':"基础面试题 "});index.add({'id':132,'href':'/note-cs/docs/basic/pl/scala/appendix/interview/basic/','title':"基础",'content':"基础面试题 "});index.add({'id':133,'href':'/note-cs/docs/basic/pl/swift/appendix/interview/basic/','title':"基础",'content':"基础面试题 "});index.add({'id':134,'href':'/note-cs/docs/direction/be/platform/nodejs/appendix/interview/basic/','title':"基础",'content':"基础面试题 "});index.add({'id':135,'href':'/note-cs/docs/direction/client/android/appendix/interview/basic/','title':"基础",'content':"基础面试题 "});index.add({'id':136,'href':'/note-cs/docs/direction/client/ios/appendix/interview/basic/','title':"基础",'content':"基础面试题 "});index.add({'id':137,'href':'/note-cs/docs/direction/client/xiaochengxu/appendix/interview/basic/','title':"基础",'content':"基础面试题 "});index.add({'id':138,'href':'/note-cs/docs/direction/embedded/appendix/interview/basic/','title':"基础",'content':"基础面试题 "});index.add({'id':139,'href':'/note-cs/docs/direction/fe/frame/angular/appendix/interview/basic/','title':"基础",'content':"基础面试题 "});index.add({'id':140,'href':'/note-cs/docs/direction/fe/frame/react/appendix/interview/basic/','title':"基础",'content':"基础面试题 "});index.add({'id':141,'href':'/note-cs/docs/direction/fe/frame/vue/appendix/interview/basic/','title':"基础",'content':"基础面试题 "});index.add({'id':142,'href':'/note-cs/docs/direction/security/appendix/interview/basic/','title':"基础",'content':"基础面试题 "});index.add({'id':143,'href':'/note-cs/docs/domain/cc/knative/appendix/interview/basic/','title':"基础",'content':"基础面试题 "});index.add({'id':144,'href':'/note-cs/docs/basic/pl/csharp/basic/lib/common/','title':"常用库",'content':"常用库 "});index.add({'id':145,'href':'/note-cs/docs/basic/pl/rust/design/','title':"第二部分 Rust 设计",'content':""});index.add({'id':146,'href':'/note-cs/docs/basic/os/android/priciple/','title':"第二部分 原理",'content':""});index.add({'id':147,'href':'/note-cs/docs/basic/os/ios/priciple/','title':"第二部分 原理",'content':""});index.add({'id':148,'href':'/note-cs/docs/basic/os/macos/priciple/','title':"第二部分 原理",'content':""});index.add({'id':149,'href':'/note-cs/docs/basic/os/unix/priciple/','title':"第二部分 原理",'content':""});index.add({'id':150,'href':'/note-cs/docs/basic/os/windows/priciple/','title':"第二部分 原理",'content':""});index.add({'id':151,'href':'/note-cs/docs/basic/pl/csharp/priciple/','title':"第二部分 原理",'content':""});index.add({'id':152,'href':'/note-cs/docs/basic/pl/kotlin/priciple/','title':"第二部分 原理",'content':""});index.add({'id':153,'href':'/note-cs/docs/basic/pl/lua/priciple/','title':"第二部分 原理",'content':""});index.add({'id':154,'href':'/note-cs/docs/basic/pl/objective-c/priciple/','title':"第二部分 原理",'content':""});index.add({'id':155,'href':'/note-cs/docs/basic/pl/ruby/priciple/','title':"第二部分 原理",'content':""});index.add({'id':156,'href':'/note-cs/docs/basic/pl/scala/priciple/','title':"第二部分 原理",'content':""});index.add({'id':157,'href':'/note-cs/docs/basic/pl/swift/priciple/','title':"第二部分 原理",'content':""});index.add({'id':158,'href':'/note-cs/docs/direction/','title':"第二部分 方向",'content':""});index.add({'id':159,'href':'/note-cs/docs/basic/db/mysql/design/','title':"第二部分 设计",'content':""});index.add({'id':160,'href':'/note-cs/docs/basic/db/postgresql/design/','title':"第二部分 设计",'content':""});index.add({'id':161,'href':'/note-cs/docs/basic/db/redis/design/','title':"第二部分 设计",'content':""});index.add({'id':162,'href':'/note-cs/docs/basic/pl/c/design/','title':"第二部分 设计",'content':""});index.add({'id':163,'href':'/note-cs/docs/basic/pl/cpp/design/','title':"第二部分 设计",'content':""});index.add({'id':164,'href':'/note-cs/docs/basic/pl/javascript/design/','title':"第二部分 设计",'content':""});index.add({'id':165,'href':'/note-cs/docs/basic/pl/php/design/','title':"第二部分 设计",'content':""});index.add({'id':166,'href':'/note-cs/docs/direction/be/platform/nodejs/design/','title':"第二部分 设计",'content':""});index.add({'id':167,'href':'/note-cs/docs/direction/client/android/design/','title':"第二部分 设计",'content':""});index.add({'id':168,'href':'/note-cs/docs/direction/client/ios/design/','title':"第二部分 设计",'content':""});index.add({'id':169,'href':'/note-cs/docs/direction/client/xiaochengxu/design/','title':"第二部分 设计",'content':""});index.add({'id':170,'href':'/note-cs/docs/direction/embedded/design/','title':"第二部分 设计",'content':""});index.add({'id':171,'href':'/note-cs/docs/direction/fe/frame/angular/design/','title':"第二部分 设计",'content':""});index.add({'id':172,'href':'/note-cs/docs/direction/fe/frame/react/design/','title':"第二部分 设计",'content':""});index.add({'id':173,'href':'/note-cs/docs/direction/fe/frame/vue/design/','title':"第二部分 设计",'content':""});index.add({'id':174,'href':'/note-cs/docs/direction/security/design/','title':"第二部分 设计",'content':""});index.add({'id':175,'href':'/note-cs/docs/domain/cc/knative/design/','title':"第二部分 设计",'content':""});index.add({'id':176,'href':'/note-cs/docs/basic/db/mysql/appendix/interview/advanced/','title':"进阶",'content':"进阶面试题 "});index.add({'id':177,'href':'/note-cs/docs/basic/db/postgresql/appendix/interview/advanced/','title':"进阶",'content':"进阶面试题 "});index.add({'id':178,'href':'/note-cs/docs/basic/db/redis/appendix/interview/advanced/','title':"进阶",'content':"进阶面试题 "});index.add({'id':179,'href':'/note-cs/docs/basic/os/android/appendix/interview/advanced/','title':"进阶",'content':"进阶面试题 "});index.add({'id':180,'href':'/note-cs/docs/basic/os/ios/appendix/interview/advanced/','title':"进阶",'content':"进阶面试题 "});index.add({'id':181,'href':'/note-cs/docs/basic/os/macos/appendix/interview/advanced/','title':"进阶",'content':"进阶面试题 "});index.add({'id':182,'href':'/note-cs/docs/basic/os/unix/appendix/interview/advanced/','title':"进阶",'content':"进阶面试题 "});index.add({'id':183,'href':'/note-cs/docs/basic/os/windows/appendix/interview/advanced/','title':"进阶",'content':"进阶面试题 "});index.add({'id':184,'href':'/note-cs/docs/basic/pl/c/appendix/interview/advanced/','title':"进阶",'content':"进阶面试题 "});index.add({'id':185,'href':'/note-cs/docs/basic/pl/cpp/appendix/interview/advanced/','title':"进阶",'content':"进阶面试题 为什么 C++ 的 member function template 不能是 virtual 的 比如，下面的代码是不合法的：\nclass Animal{ public: template\u0026lt;typename T\u0026gt; virtual void make_sound(){ //...  } }; 因为 C++ 的编译与链接模型是 \u0026ldquo;分离\u0026rdquo; 的 (至少是部分原因吧)。\n从 Unix/C 开始，一个 C/C++ 程序就可以被分开编译，然后用一个 linker 链接起来。这种模型有一个问题，就是各个编译单元可能对另一个编译单元一无所知。 一个 function template 最后到底会被 instantiate 为多少个函数，要等整个程序 (所有的编译单元) 全部被编译完成才知道。 同时，virtual function 的实现大多利用了一个 \u0026ldquo;虚函数表\u0026rdquo; 的东西，这种实现中，一个类的内存布局 (或者说虚函数表的内存布局) 需要在这个类编译完成的时候就被完全确定。 所以，由上面的矛盾可知，C++ 的 member function 不能既是 template 又是 virtual 的。\n参考：https://www.zhihu.com/question/60911582/answer/182045051\n"});index.add({'id':186,'href':'/note-cs/docs/basic/pl/csharp/appendix/interview/advanced/','title':"进阶",'content':"进阶面试题 "});index.add({'id':187,'href':'/note-cs/docs/basic/pl/javascript/appendix/interview/advanced/','title':"进阶",'content':"进阶面试题 "});index.add({'id':188,'href':'/note-cs/docs/basic/pl/kotlin/appendix/interview/advanced/','title':"进阶",'content':"进阶面试题 "});index.add({'id':189,'href':'/note-cs/docs/basic/pl/lua/appendix/interview/advanced/','title':"进阶",'content':"进阶面试题 "});index.add({'id':190,'href':'/note-cs/docs/basic/pl/objective-c/appendix/interview/advanced/','title':"进阶",'content':"进阶面试题 "});index.add({'id':191,'href':'/note-cs/docs/basic/pl/php/appendix/interview/advanced/','title':"进阶",'content':"进阶面试题 "});index.add({'id':192,'href':'/note-cs/docs/basic/pl/ruby/appendix/interview/advanced/','title':"进阶",'content':"进阶面试题 "});index.add({'id':193,'href':'/note-cs/docs/basic/pl/rust/appendix/interview/advanced/','title':"进阶",'content':"进阶面试题 "});index.add({'id':194,'href':'/note-cs/docs/basic/pl/scala/appendix/interview/advanced/','title':"进阶",'content':"进阶面试题 "});index.add({'id':195,'href':'/note-cs/docs/basic/pl/swift/appendix/interview/advanced/','title':"进阶",'content':"进阶面试题 "});index.add({'id':196,'href':'/note-cs/docs/direction/be/platform/nodejs/appendix/interview/advanced/','title':"进阶",'content':"进阶面试题 "});index.add({'id':197,'href':'/note-cs/docs/direction/client/android/appendix/interview/advanced/','title':"进阶",'content':"进阶面试题 "});index.add({'id':198,'href':'/note-cs/docs/direction/client/ios/appendix/interview/advanced/','title':"进阶",'content':"进阶面试题 "});index.add({'id':199,'href':'/note-cs/docs/direction/client/xiaochengxu/appendix/interview/advanced/','title':"进阶",'content':"进阶面试题 "});index.add({'id':200,'href':'/note-cs/docs/direction/embedded/appendix/interview/advanced/','title':"进阶",'content':"进阶面试题 "});index.add({'id':201,'href':'/note-cs/docs/direction/fe/frame/angular/appendix/interview/advanced/','title':"进阶",'content':"进阶面试题 "});index.add({'id':202,'href':'/note-cs/docs/direction/fe/frame/react/appendix/interview/advanced/','title':"进阶",'content':"进阶面试题 "});index.add({'id':203,'href':'/note-cs/docs/direction/fe/frame/vue/appendix/interview/advanced/','title':"进阶",'content':"进阶面试题 "});index.add({'id':204,'href':'/note-cs/docs/direction/security/appendix/interview/advanced/','title':"进阶",'content':"进阶面试题 "});index.add({'id':205,'href':'/note-cs/docs/domain/cc/knative/appendix/interview/advanced/','title':"进阶",'content':"进阶面试题 "});index.add({'id':206,'href':'/note-cs/docs/basic/db/mysql/appendix/interview/','title':"面试题",'content':"面试题 基础题 进阶题 高阶题 "});index.add({'id':207,'href':'/note-cs/docs/basic/db/postgresql/appendix/interview/','title':"面试题",'content':"面试题 基础题 进阶题 高阶题 "});index.add({'id':208,'href':'/note-cs/docs/basic/db/redis/appendix/interview/','title':"面试题",'content':"面试题 基础题 进阶题 高阶题 "});index.add({'id':209,'href':'/note-cs/docs/basic/os/android/appendix/interview/','title':"面试题",'content':"面试题 基础题 进阶题 高阶题 "});index.add({'id':210,'href':'/note-cs/docs/basic/os/ios/appendix/interview/','title':"面试题",'content':"面试题 基础题 进阶题 高阶题 "});index.add({'id':211,'href':'/note-cs/docs/basic/os/macos/appendix/interview/','title':"面试题",'content':"面试题 基础题 进阶题 高阶题 "});index.add({'id':212,'href':'/note-cs/docs/basic/os/unix/appendix/interview/','title':"面试题",'content':"面试题 基础题 进阶题 高阶题 "});index.add({'id':213,'href':'/note-cs/docs/basic/os/windows/appendix/interview/','title':"面试题",'content':"面试题 基础题 进阶题 高阶题 "});index.add({'id':214,'href':'/note-cs/docs/basic/pl/c/appendix/interview/','title':"面试题",'content':"面试题 基础题 进阶题 高阶题 "});index.add({'id':215,'href':'/note-cs/docs/basic/pl/javascript/appendix/interview/','title':"面试题",'content':"面试题 基础题 进阶题  如何衡量一个人的 JavaScript 水平？  高阶题 "});index.add({'id':216,'href':'/note-cs/docs/basic/pl/objective-c/appendix/interview/','title':"面试题",'content':"面试题 基础题 进阶题 高阶题 "});index.add({'id':217,'href':'/note-cs/docs/basic/pl/php/appendix/interview/','title':"面试题",'content':"面试题 基础题 进阶题 高阶题 "});index.add({'id':218,'href':'/note-cs/docs/basic/pl/rust/appendix/interview/','title':"面试题",'content':"面试题 基础题 进阶题 高阶题 "});index.add({'id':219,'href':'/note-cs/docs/basic/pl/scala/appendix/interview/','title':"面试题",'content':"面试题 基础题 进阶题 高阶题 "});index.add({'id':220,'href':'/note-cs/docs/direction/be/platform/nodejs/appendix/interview/','title':"面试题",'content':"面试题 基础题 进阶题 高阶题 "});index.add({'id':221,'href':'/note-cs/docs/direction/client/android/appendix/interview/','title':"面试题",'content':"面试题 基础题 进阶题 高阶题 "});index.add({'id':222,'href':'/note-cs/docs/direction/client/ios/appendix/interview/','title':"面试题",'content':"面试题 基础题 进阶题 高阶题 "});index.add({'id':223,'href':'/note-cs/docs/direction/client/xiaochengxu/appendix/interview/','title':"面试题",'content':"面试题 基础题 进阶题 高阶题 "});index.add({'id':224,'href':'/note-cs/docs/direction/embedded/appendix/interview/','title':"面试题",'content':"面试题 基础题 进阶题 高阶题 "});index.add({'id':225,'href':'/note-cs/docs/direction/fe/frame/angular/appendix/interview/','title':"面试题",'content':"面试题 基础题 进阶题 高阶题 "});index.add({'id':226,'href':'/note-cs/docs/direction/fe/frame/react/appendix/interview/','title':"面试题",'content':"面试题 基础题 进阶题 高阶题 "});index.add({'id':227,'href':'/note-cs/docs/direction/fe/frame/vue/appendix/interview/','title':"面试题",'content':"面试题 基础题 进阶题 高阶题 "});index.add({'id':228,'href':'/note-cs/docs/direction/security/appendix/interview/','title':"面试题",'content':"面试题 基础题 进阶题 高阶题 "});index.add({'id':229,'href':'/note-cs/docs/domain/cc/knative/appendix/interview/','title':"面试题",'content':"面试题 基础题 进阶题 高阶题 "});index.add({'id':230,'href':'/note-cs/docs/basic/compile/make/cmake/','title':"cmake",'content':"cmake "});index.add({'id':231,'href':'/note-cs/docs/book/be/Designing-Data-Intensive-Applications/','title':"Designing Data-Intensive Applications",'content':"Designing Data-Intensive Applications 简介 \npublished by O’Reilly in March 2017.\n作者 Martin Kleppmann\nMartin Kleppmann\u0026rsquo;s blog\n阅读笔记 "});index.add({'id':232,'href':'/note-cs/docs/domain/cc/helm/','title':"Helm",'content':"Helm   Helm is the best way to find, share, and use software built for Kubernetes.\n 官网：https://helm.sh\nHelm is a tool for managing Charts. Charts are packages of pre-configured Kubernetes resources.\nUse Helm to:\n Find and use popular software packaged as Helm Charts to run in Kubernetes Share your own applications as Helm Charts Create reproducible builds of your Kubernetes applications Intelligently manage your Kubernetes manifest files Manage releases of Helm packages  开源镜像 BurdenBear/kube-charts-mirror  # 删除默认的源 helm repo remove stable helm repo remove incubator # 增加新的国内镜像源 helm repo add stable http://mirror.azure.cn/kubernetes/charts/ helm repo add incubator http://mirror.azure.cn/kubernetes/charts-incubator/ helm repo list helm search mysql "});index.add({'id':233,'href':'/note-cs/docs/basic/os/macos/','title':"MacOS",'content':"MacOS "});index.add({'id':234,'href':'/note-cs/docs/basic/os/windows/','title':"Windows",'content':"Windows "});index.add({'id':235,'href':'/note-cs/docs/basic/db/mysql/source/','title':"第三部分 源码实现",'content':""});index.add({'id':236,'href':'/note-cs/docs/basic/db/postgresql/source/','title':"第三部分 源码实现",'content':""});index.add({'id':237,'href':'/note-cs/docs/basic/db/redis/source/','title':"第三部分 源码实现",'content':""});index.add({'id':238,'href':'/note-cs/docs/basic/os/android/source/','title':"第三部分 源码实现",'content':""});index.add({'id':239,'href':'/note-cs/docs/basic/os/ios/source/','title':"第三部分 源码实现",'content':""});index.add({'id':240,'href':'/note-cs/docs/basic/os/macos/source/','title':"第三部分 源码实现",'content':""});index.add({'id':241,'href':'/note-cs/docs/basic/os/unix/source/','title':"第三部分 源码实现",'content':""});index.add({'id':242,'href':'/note-cs/docs/basic/os/windows/source/','title':"第三部分 源码实现",'content':""});index.add({'id':243,'href':'/note-cs/docs/basic/pl/c/source/','title':"第三部分 源码实现",'content':""});index.add({'id':244,'href':'/note-cs/docs/basic/pl/cpp/source/','title':"第三部分 源码实现",'content':""});index.add({'id':245,'href':'/note-cs/docs/basic/pl/csharp/source/','title':"第三部分 源码实现",'content':""});index.add({'id':246,'href':'/note-cs/docs/basic/pl/javascript/source/','title':"第三部分 源码实现",'content':""});index.add({'id':247,'href':'/note-cs/docs/basic/pl/kotlin/source/','title':"第三部分 源码实现",'content':""});index.add({'id':248,'href':'/note-cs/docs/basic/pl/lua/source/','title':"第三部分 源码实现",'content':""});index.add({'id':249,'href':'/note-cs/docs/basic/pl/objective-c/source/','title':"第三部分 源码实现",'content':""});index.add({'id':250,'href':'/note-cs/docs/basic/pl/php/source/','title':"第三部分 源码实现",'content':""});index.add({'id':251,'href':'/note-cs/docs/basic/pl/ruby/source/','title':"第三部分 源码实现",'content':""});index.add({'id':252,'href':'/note-cs/docs/basic/pl/rust/source/','title':"第三部分 源码实现",'content':""});index.add({'id':253,'href':'/note-cs/docs/basic/pl/scala/source/','title':"第三部分 源码实现",'content':""});index.add({'id':254,'href':'/note-cs/docs/basic/pl/swift/source/','title':"第三部分 源码实现",'content':""});index.add({'id':255,'href':'/note-cs/docs/direction/be/platform/nodejs/source/','title':"第三部分 源码实现",'content':""});index.add({'id':256,'href':'/note-cs/docs/direction/client/android/source/','title':"第三部分 源码实现",'content':""});index.add({'id':257,'href':'/note-cs/docs/direction/client/ios/source/','title':"第三部分 源码实现",'content':""});index.add({'id':258,'href':'/note-cs/docs/direction/client/xiaochengxu/source/','title':"第三部分 源码实现",'content':""});index.add({'id':259,'href':'/note-cs/docs/direction/embedded/source/','title':"第三部分 源码实现",'content':""});index.add({'id':260,'href':'/note-cs/docs/direction/fe/frame/angular/source/','title':"第三部分 源码实现",'content':""});index.add({'id':261,'href':'/note-cs/docs/direction/fe/frame/react/source/','title':"第三部分 源码实现",'content':""});index.add({'id':262,'href':'/note-cs/docs/direction/fe/frame/vue/source/','title':"第三部分 源码实现",'content':""});index.add({'id':263,'href':'/note-cs/docs/direction/security/source/','title':"第三部分 源码实现",'content':""});index.add({'id':264,'href':'/note-cs/docs/domain/cc/knative/source/','title':"第三部分 源码实现",'content':""});index.add({'id':265,'href':'/note-cs/docs/domain/','title':"第三部分 领域",'content':""});index.add({'id':266,'href':'/note-cs/docs/basic/db/mysql/appendix/interview/expert/','title':"高阶",'content':"高阶面试题 "});index.add({'id':267,'href':'/note-cs/docs/basic/db/postgresql/appendix/interview/expert/','title':"高阶",'content':"高阶面试题 "});index.add({'id':268,'href':'/note-cs/docs/basic/db/redis/appendix/interview/expert/','title':"高阶",'content':"高阶面试题 "});index.add({'id':269,'href':'/note-cs/docs/basic/os/android/appendix/interview/expert/','title':"高阶",'content':"高阶面试题 "});index.add({'id':270,'href':'/note-cs/docs/basic/os/ios/appendix/interview/expert/','title':"高阶",'content':"高阶面试题 "});index.add({'id':271,'href':'/note-cs/docs/basic/os/macos/appendix/interview/expert/','title':"高阶",'content':"高阶面试题 "});index.add({'id':272,'href':'/note-cs/docs/basic/os/unix/appendix/interview/expert/','title':"高阶",'content':"高阶面试题 "});index.add({'id':273,'href':'/note-cs/docs/basic/os/windows/appendix/interview/expert/','title':"高阶",'content':"高阶面试题 "});index.add({'id':274,'href':'/note-cs/docs/basic/pl/c/appendix/interview/expert/','title':"高阶",'content':"高阶面试题 "});index.add({'id':275,'href':'/note-cs/docs/basic/pl/cpp/appendix/interview/expert/','title':"高阶",'content':"高阶面试题 "});index.add({'id':276,'href':'/note-cs/docs/basic/pl/csharp/appendix/interview/expert/','title':"高阶",'content':"高阶面试题 "});index.add({'id':277,'href':'/note-cs/docs/basic/pl/javascript/appendix/interview/expert/','title':"高阶",'content':"高阶面试题 "});index.add({'id':278,'href':'/note-cs/docs/basic/pl/kotlin/appendix/interview/expert/','title':"高阶",'content':"高阶面试题 "});index.add({'id':279,'href':'/note-cs/docs/basic/pl/lua/appendix/interview/expert/','title':"高阶",'content':"高阶面试题 "});index.add({'id':280,'href':'/note-cs/docs/basic/pl/objective-c/appendix/interview/expert/','title':"高阶",'content':"高阶面试题 "});index.add({'id':281,'href':'/note-cs/docs/basic/pl/php/appendix/interview/expert/','title':"高阶",'content':"高阶面试题 "});index.add({'id':282,'href':'/note-cs/docs/basic/pl/ruby/appendix/interview/expert/','title':"高阶",'content':"高阶面试题 "});index.add({'id':283,'href':'/note-cs/docs/basic/pl/rust/appendix/interview/expert/','title':"高阶",'content':"高阶面试题 "});index.add({'id':284,'href':'/note-cs/docs/basic/pl/scala/appendix/interview/expert/','title':"高阶",'content':"高阶面试题 "});index.add({'id':285,'href':'/note-cs/docs/basic/pl/swift/appendix/interview/expert/','title':"高阶",'content':"高阶面试题 "});index.add({'id':286,'href':'/note-cs/docs/direction/be/platform/nodejs/appendix/interview/expert/','title':"高阶",'content':"高阶面试题 "});index.add({'id':287,'href':'/note-cs/docs/direction/client/android/appendix/interview/expert/','title':"高阶",'content':"高阶面试题 "});index.add({'id':288,'href':'/note-cs/docs/direction/client/ios/appendix/interview/expert/','title':"高阶",'content':"高阶面试题 "});index.add({'id':289,'href':'/note-cs/docs/direction/client/xiaochengxu/appendix/interview/expert/','title':"高阶",'content':"高阶面试题 "});index.add({'id':290,'href':'/note-cs/docs/direction/embedded/appendix/interview/expert/','title':"高阶",'content':"高阶面试题 "});index.add({'id':291,'href':'/note-cs/docs/direction/fe/frame/angular/appendix/interview/expert/','title':"高阶",'content':"高阶面试题 "});index.add({'id':292,'href':'/note-cs/docs/direction/fe/frame/react/appendix/interview/expert/','title':"高阶",'content':"高阶面试题 "});index.add({'id':293,'href':'/note-cs/docs/direction/fe/frame/vue/appendix/interview/expert/','title':"高阶",'content':"高阶面试题 "});index.add({'id':294,'href':'/note-cs/docs/direction/security/appendix/interview/expert/','title':"高阶",'content':"高阶面试题 "});index.add({'id':295,'href':'/note-cs/docs/domain/cc/knative/appendix/interview/expert/','title':"高阶",'content':"高阶面试题 "});index.add({'id':296,'href':'/note-cs/docs/direction/be/mq/mqtt/mosquitto/','title':"mosquitto",'content':"mosquitto 物联网（Internet of Things，IoT）最近曝光率越来越高。虽然 HTTP 是网页的事实标准，不过机器之间（Machine-to-Machine，M2M）的大规模沟通需要不同的模式：之前的请求 / 回答（Request/Response）模式不再合适，取而代之的是发布 / 订阅（Publish/Subscribe）模式。这就是轻量级、可扩展的 MQTT（Message Queuing Telemetry Transport）可以施展拳脚的舞台。\nMQTT 是基于二进制消息的发布 / 订阅编程模式的消息协议，最早由 IBM 提出的，如今已经成为 OASIS 规范。由于规范很简单，非常适合需要低功耗和网络带宽有限的 IoT 场景，比如：\n 遥感数据 汽车 智能家居 智慧城市 医疗医护  安装 MacOS brew install mosquitto\n参考：https://mosquitto.org/download/\n"});index.add({'id':297,'href':'/note-cs/docs/basic/os/unix/','title':"Unix",'content':"Unix "});index.add({'id':298,'href':'/note-cs/docs/others/','title':"第四部分 其他",'content':""});index.add({'id':299,'href':'/note-cs/docs/basic/db/mysql/appendix/','title':"第四部分 附录",'content':""});index.add({'id':300,'href':'/note-cs/docs/basic/db/postgresql/appendix/','title':"第四部分 附录",'content':""});index.add({'id':301,'href':'/note-cs/docs/basic/db/redis/appendix/','title':"第四部分 附录",'content':""});index.add({'id':302,'href':'/note-cs/docs/basic/os/android/appendix/','title':"第四部分 附录",'content':""});index.add({'id':303,'href':'/note-cs/docs/basic/os/ios/appendix/','title':"第四部分 附录",'content':""});index.add({'id':304,'href':'/note-cs/docs/basic/os/macos/appendix/','title':"第四部分 附录",'content':""});index.add({'id':305,'href':'/note-cs/docs/basic/os/unix/appendix/','title':"第四部分 附录",'content':""});index.add({'id':306,'href':'/note-cs/docs/basic/os/windows/appendix/','title':"第四部分 附录",'content':""});index.add({'id':307,'href':'/note-cs/docs/basic/pl/c/appendix/','title':"第四部分 附录",'content':""});index.add({'id':308,'href':'/note-cs/docs/basic/pl/cpp/appendix/','title':"第四部分 附录",'content':""});index.add({'id':309,'href':'/note-cs/docs/basic/pl/csharp/appendix/','title':"第四部分 附录",'content':""});index.add({'id':310,'href':'/note-cs/docs/basic/pl/javascript/appendix/','title':"第四部分 附录",'content':""});index.add({'id':311,'href':'/note-cs/docs/basic/pl/kotlin/appendix/','title':"第四部分 附录",'content':""});index.add({'id':312,'href':'/note-cs/docs/basic/pl/lua/appendix/','title':"第四部分 附录",'content':""});index.add({'id':313,'href':'/note-cs/docs/basic/pl/objective-c/appendix/','title':"第四部分 附录",'content':""});index.add({'id':314,'href':'/note-cs/docs/basic/pl/php/appendix/','title':"第四部分 附录",'content':""});index.add({'id':315,'href':'/note-cs/docs/basic/pl/ruby/appendix/','title':"第四部分 附录",'content':""});index.add({'id':316,'href':'/note-cs/docs/basic/pl/rust/appendix/','title':"第四部分 附录",'content':""});index.add({'id':317,'href':'/note-cs/docs/basic/pl/scala/appendix/','title':"第四部分 附录",'content':""});index.add({'id':318,'href':'/note-cs/docs/basic/pl/swift/appendix/','title':"第四部分 附录",'content':""});index.add({'id':319,'href':'/note-cs/docs/direction/be/platform/nodejs/appendix/','title':"第四部分 附录",'content':""});index.add({'id':320,'href':'/note-cs/docs/direction/client/android/appendix/','title':"第四部分 附录",'content':""});index.add({'id':321,'href':'/note-cs/docs/direction/client/ios/appendix/','title':"第四部分 附录",'content':""});index.add({'id':322,'href':'/note-cs/docs/direction/client/xiaochengxu/appendix/','title':"第四部分 附录",'content':""});index.add({'id':323,'href':'/note-cs/docs/direction/embedded/appendix/','title':"第四部分 附录",'content':""});index.add({'id':324,'href':'/note-cs/docs/direction/fe/frame/angular/appendix/','title':"第四部分 附录",'content':""});index.add({'id':325,'href':'/note-cs/docs/direction/fe/frame/react/appendix/','title':"第四部分 附录",'content':""});index.add({'id':326,'href':'/note-cs/docs/direction/fe/frame/vue/appendix/','title':"第四部分 附录",'content':""});index.add({'id':327,'href':'/note-cs/docs/direction/security/appendix/','title':"第四部分 附录",'content':""});index.add({'id':328,'href':'/note-cs/docs/domain/cc/knative/appendix/','title':"第四部分 附录",'content':""});index.add({'id':329,'href':'/note-cs/docs/basic/pl/c/','title':"C",'content':"C 学习笔记 "});index.add({'id':330,'href':'/note-cs/docs/basic/compile/gcc/','title':"gcc",'content':"gcc 安装 gcc 4.8 curl -Lks http://www.hop5.in/yum/el6/hop5.repo \u0026gt; /etc/yum.repos.d/hop5.repo yum install gcc gcc-g++ gcc --version 参考： Linux 之 CentOS 6 通过 yum 安装 gcc 4.9 5.2 等高版本 gcc\n 升级 升级到 gcc 6.3 yum -y install centos-release-scl yum -y install devtoolset-6-gcc devtoolset-6-gcc-c++ devtoolset-6-binutils # scl 命令启用只是临时的，退出 shell 或重启就会恢复原系统 gcc 版本 scl enable devtoolset-6 bash # 长期 echo \u0026#34;source /opt/rh/devtoolset-6/enable\u0026#34; \u0026gt;\u0026gt;/etc/profile 参考：\n 为 CentOS 6、7 升级 gcc 至 4.8、4.9、5.2、6.3、7.3 等高版本  "});index.add({'id':331,'href':'/note-cs/docs/others/skill/debug/gdb/','title':"GDB",'content':"GDB "});index.add({'id':332,'href':'/note-cs/docs/direction/be/platform/nodejs/basic/build/gulp/','title':"gulp",'content':"gulp 类似与 make 参考：https://learnxinyminutes.com/docs/zh-cn/make-cn/\n"});index.add({'id':333,'href':'/note-cs/docs/basic/compile/make/','title':"make",'content':"make 教程  learn make in y minutes 跟我一起写 Makefile GNU make manual  "});index.add({'id':334,'href':'/note-cs/docs/basic/db/redis/basic/quick-start/','title':"Quick Start",'content':"Quick Start redis-cli -h host -p port -a password 安装 开机自启 sudo vi /usr/lib/systemd/system/redis.service\n[Unit] Description=Redis persistent key-value database After=network.target After=network-online.target Wants=network-online.target [Service] ExecStart=/usr/bin/redis-server /etc/redis.conf --supervised systemd ExecStop=/usr/libexec/redis-shutdown Type=notify User=redis Group=redis RuntimeDirectory=redis RuntimeDirectoryMode=0755 [Install] WantedBy=multi-user.target 保存退出，执行 sudo systemctl daemon-reload 启动服务 sudo systemctl start redis.service 设置开机自启动 sudo systemctl enable redis.service\n设置密码 打开文件 /etc/redis.conf， 找到其中的 # requirepass foobared，去掉前面的 #， 并把 foobared 改成你的密码。\nps: 如果 redis 没有启用密码，我使用 redis-cli -a xxx 可以访问吗？ 答案是：可以\n为什么 Redis 默认端口是 6379 6379 在是手机按键上 MERZ 对应的号码，而 MERZ 取自意大利歌女 Alessia Merz 的名字。 MERZ 长期以来被 antirez 及其朋友当作愚蠢的代名词。\n参考：http://oldblog.antirez.com/post/redis-as-LRU-cache.html\n问答 MySQL 和 Redis 如何保持数据的一致性？ MySQL binlog 增量订阅消费 + 消息队列 + 处理并把数据更新到 redis\n参考：\nliukelin/canal_mysql_nosql_sync  alibaba/canal  阿里巴巴 MySQL binlog 增量订阅 \u0026amp; 消费组件\n 分布式的环境下， MySQL 和 Redis 如何保持数据的一致性？  "});index.add({'id':335,'href':'/note-cs/docs/basic/db/mysql/basic/practice/snippet/','title':"代码片段",'content':"代码片段 "});index.add({'id':336,'href':'/note-cs/docs/basic/db/postgresql/basic/practice/snippet/','title':"代码片段",'content':"代码片段 "});index.add({'id':337,'href':'/note-cs/docs/basic/db/redis/basic/practice/snippet/','title':"代码片段",'content':"代码片段 "});index.add({'id':338,'href':'/note-cs/docs/basic/pl/javascript/basic/practice/snippet/','title':"代码片段",'content':"代码片段 "});index.add({'id':339,'href':'/note-cs/docs/basic/pl/objective-c/basic/practice/snippet/','title':"代码片段",'content':"代码片段 "});index.add({'id':340,'href':'/note-cs/docs/direction/be/platform/nodejs/basic/practice/snippet/','title':"代码片段",'content':"代码片段 "});index.add({'id':341,'href':'/note-cs/docs/direction/client/android/basic/practice/snippet/','title':"代码片段",'content':"代码片段 "});index.add({'id':342,'href':'/note-cs/docs/direction/client/ios/basic/practice/snippet/','title':"代码片段",'content':"代码片段 "});index.add({'id':343,'href':'/note-cs/docs/direction/client/xiaochengxu/basic/practice/snippet/','title':"代码片段",'content':"代码片段 "});index.add({'id':344,'href':'/note-cs/docs/direction/fe/frame/angular/basic/practice/snippet/','title':"代码片段",'content':"代码片段 "});index.add({'id':345,'href':'/note-cs/docs/direction/fe/frame/react/basic/practice/snippet/','title':"代码片段",'content':"代码片段 "});index.add({'id':346,'href':'/note-cs/docs/direction/fe/frame/vue/basic/practice/snippet/','title':"代码片段",'content':"代码片段 "});index.add({'id':347,'href':'/note-cs/docs/basic/pl/cpp/basic/grammar/keyword/','title':"关键字",'content':"C++ 关键字 这是 C++ 中的保留字列表。因为它们为语言所用，故这些关键词不可用于重定义或重载。\n注意 and、bitor、or、xor、compl、bitand、and_eq、or_eq、xor_eq、not 及 not_eq（还有双标符 \u0026lt;%、%\u0026gt;、\u0026lt;:、:\u0026gt;、%: 及 %:%:）提供标准记号的代用表示方法。\n参考：C++ 参考手册\n"});index.add({'id':348,'href':'/note-cs/docs/others/tool/dev/vscode/shortcuts/','title':"快捷键",'content':"VScode 快捷键 MacOS 选择  选中所有同一个词 cmd + shift + L  跳转  左右括号跳转 cmd + shift + \\ 跳到定义 cmd + 鼠标左键单击 返回光标上一个位置 cmd + -  编辑  格式化 opt + shift + f  Windows 选择  选中所有同一个词 ctrl + shift + L  跳转  左右括号跳转 ctrl + shift + \\ 跳到定义 ctrl + 鼠标左键单击 返回光标上一个位置 alt + ←   "});index.add({'id':349,'href':'/note-cs/docs/others/tool/recommend/','title':"推荐软件",'content':"推荐软件 MacOS 开发 iTerm Keyboard Maestro  参考  jaywcjlove/awesome-mac   Windows todoiOS todoAndroid todoLinux todo "});index.add({'id':350,'href':'/note-cs/docs/basic/db/redis/basic/type/','title':"数据类型",'content':"数据类型 string Redis 规定了字符串的长度不得超过 512 MB。\nlist hash set zset "});index.add({'id':351,'href':'/note-cs/docs/direction/be/platform/nodejs/basic/build/','title':"构建",'content':"Node.js 构建 "});index.add({'id':352,'href':'/note-cs/docs/direction/be/platform/nodejs/basic/version/','title':"版本",'content':"Node.js 版本 版本控制 nvm-sh/nvm  Node Version Manager - POSIX-compliant bash script to manage multiple active node.js versions\n安装 curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.35.3/install.sh | bash export NVM_DIR=\u0026#34;$([ -z \u0026#34;${XDG_CONFIG_HOME-}\u0026#34; ] \u0026amp;\u0026amp; printf %s \u0026#34;${HOME}/.nvm\u0026#34; || printf %s \u0026#34;${XDG_CONFIG_HOME}/nvm\u0026#34;)\u0026#34; [ -s \u0026#34;$NVM_DIR/nvm.sh\u0026#34; ] \u0026amp;\u0026amp; \\. \u0026#34;$NVM_DIR/nvm.sh\u0026#34; # This loads nvm 基础命令 # 安装最新版 nvm install node # 安装最新 LTS 版本 nvm install --lts # 设置默认版本 nvm alias default lts/* # 查看本地版本列表 nvm ls # 查看全部版本列表 nvm ls-remote nvm ls-remote --lts # 使用最新版本 LTS nvm use lts/* # 查看安装路径 nvm which node nvm which v12.14.1 "});index.add({'id':353,'href':'/note-cs/docs/basic/pl/scala/basic/spec/baidu/','title':"百度",'content':"百度 Scala 编码规范 前言 就目前 Baidu 内部情况 (2018.10)，Scala 这门语言主要用于计算团队内部的和 Spark 相关项目研发、社区贡献工作以及公司的 Spark 用户使用 Scala API 编写 Spark 作业三个用途，所以本文主体沿用如下两部分并稍作修改：\n Apache Spark 开源社区 Scala 编程指南:\nApache Spark 有超过 1000 位贡献者，就我们所知，应该是目前大数据领域里最大的开源项目且是最活跃的 Scala 项目，结合 Baidu 内部现状，本文主体沿用此部分中和 Spark 社区相关内容，去除部分项目专用细节。 scala 官方 style guide 里的格式部分已包含在 Spark 项目文档中，这里摘录部分官方 style guide 作为 Apache Spark 社区的编程指南补充。  "});index.add({'id':354,'href':'/note-cs/docs/book/','title':"第五部分 读书",'content':"读书 "});index.add({'id':355,'href':'/note-cs/docs/others/tool/study/tutorial/','title':"编程学习网站",'content':"编程学习网站 基础 Codecademy Programiz  算法 Codewars  进阶 Codeplace 通过实际应用来学习编程。\n"});index.add({'id':356,'href':'/note-cs/docs/book/basic/cc/sicp/','title':"计算机程序的构造和解释",'content':"计算机程序的构造和解释  豆瓣   黄健宏：SICP 解题集  "});index.add({'id':357,'href':'/note-cs/docs/basic/db/redis/design/lock/','title':"锁",'content':"锁 setnx  setnx msetnx hsetnx  SET key value [EX seconds|PX milliseconds] [NX|XX] [KEEPTTL] 那么删除锁的正确姿势之一，就是可以使用 lua 脚本，通过 redis 的 eval/evalsha 命令来运行：\n-- lua删除锁： -- KEYS和ARGV分别是以集合方式传入的参数，对应上文的Test和uuid。 -- 如果对应的value等于传入的uuid。 if redis.call(\u0026#39;get\u0026#39;, KEYS[1]) == ARGV[1] then -- 执行删除操作 return redis.call(\u0026#39;del\u0026#39;, KEYS[1]) else -- 不成功，返回0 return 0 end 通过 lua 脚本能保证原子性的原因说的通俗一点：\n就算你在 lua 里写出花，执行也是一个命令 (eval/evalsha) 去执行的，一条命令没执行完，其他客户端是看不到的。\n那么既然这么麻烦，有没有比较好的工具呢？就要说到 redisson 了。\nredLock 并非是一个工具，而是 redis 官方提出的一种分布式锁的算法。\nredisson Redisson 是 java 的 redis 客户端之一，提供了一些 api 方便操作 redis。\nredisson 就实现了 redLock 版本的锁。也就是说除了 getLock 方法，还有 getRedLock 方法。\n"});index.add({'id':358,'href':'/note-cs/docs/course/','title':"第六部分 课程",'content':"课程 "});index.add({'id':359,'href':'/note-cs/docs/direction/be/platform/dotnet/','title':".NET",'content':".NET Framework "});index.add({'id':360,'href':'/note-cs/docs/direction/be/platform/dotnet/core/','title':".NET Core",'content':".NET Core "});index.add({'id':361,'href':'/note-cs/docs/direction/be/platform/dotnet/asp/','title':"ASP.NET",'content':"ASP.NET Razor Razor is an ASP.NET programming syntax used to create dynamic web pages with the C# or VB.NET programming languages.\nMVC Blazor Blazor is a feature of ASP.NET for building interactive web UIs using C# instead of JavaScript. It\u0026rsquo;s real .NET running in the browser on WebAssembly.\n客户端 "});index.add({'id':362,'href':'/note-cs/docs/direction/be/platform/nodejs/','title':"Node.js",'content':"Node.js "});index.add({'id':363,'href':'/note-cs/docs/domain/cc/container/','title':"容器运行时",'content':""});index.add({'id':364,'href':'/note-cs/docs/basic/db/redis/basic/cmd/','title':"命令",'content':"Redis 命令 key  DEL DUMP EXISTS EXPIRE EXPIREAT KEYS MOVE PERSIST PEXPIREAT PEXPIREAT PTTL RANDOMKEY RENAME RENAMENX TTL TYPE   string  APPEND DECR DECRBY DEL EXISTS GET GETRANGE GETSET INCR INCRBY INCRBYFLOAT MGET MSET MSETNX PSETEX SET SETBIT SETEX SETNX  SET if Not eXists 只在键 key 不存在的情况下， 将键 key 的值设置为 value 。   STRLEN   list  DEL DUMP EXISTS EXPIRE EXPIREAT KEYS MOVE PERSIST PEXPIREAT PEXPIREAT PTTL RANDOMKEY RENAME RENAMENX TTL TYPE   hash  HDEL HEXISTS HGET HGETALL HINCRBY HINCRBYFLOAT HKEYS HLEN HMGET HMSET HSET HSETNX HVALS   set  SADD SCARD SDIFF SDIFFSTORE SINTER SINTERSTORE SISMEMBER SMEMBERS SMOVE SPOP SRANDMEMBER SREM SSCAN SUNION SUNIONSTORE   zset  ZADD ZCARD ZCOUNT ZINCRBY ZINTERSTORE ZLEXCOUNT ZRANGE ZRANGEBYLEX ZRANGEBYSCORE ZRANK ZREM ZREMRANGEBYLEX ZREMRANGEBYRANK ZREMRANGEBYSCORE ZREVRANGE ZREVRANGEBYSCORE ZREVRANK ZSCAN ZSCORE ZUNIONSTORE   连接  AUTH ECHO PING QUIT SELECT   服务器  BGREWRITEAOF BGSAVE CLIENT GETNAME CLIENT KILL CLIENT LIST CLIENT PAUSE CLIENT SETNAME CLUSTER SLOTS COMMAND COMMAND COUNT COMMAND GETKEYS COMMAND INFO CONFIG GET CONFIG RESETSTAT CONFIG REWRITE CONFIG SET DBSIZE DEBUG OBJECT DEBUG SEGFAULT FLUSHALL FLUSHDB INFO LASTSAVE MONITOR ROLE SAVE SHOWLOG SHUTDOWN SLAVEOF SYNC TIME   脚本  EVAL EVALSHA SCRIPT EXISTS SCRIPT FLUSH SCRIPT KILL SCRIPT LOAD   事务  DISCARD EXEC MULTI UNWATCH WATCH   HyperLogLog  PFADD PFCOUNT PGMERGE   发布订阅  PSUBSCRIBE PUBLISH PUBSUB PUNSUBSCRIBE SUBSCRIBE UNSUBSCRIBE   地理位置 (geo)  GEOADD GEODIST GEOHASH GEOPOS GEORADIUS GEORADIUSBYMEMBER   参考  www.redis.net.cn/order 神奇的 HyperLogLog 算法  "});index.add({'id':365,'href':'/note-cs/docs/basic/db/redis/source/type/','title':"类型实现",'content':"Redis 类型实现 参考  5 种基本数据结构  "});index.add({'id':366,'href':'/note-cs/docs/others/tool/dev/jetbrains/goland/','title':"GoLand",'content':"GoLand 快捷键 查询   函数列表 cmd + f12\n  当前文件查询 cmd + F\n  当前文件替换 cmd + R\n  所有文件查询 shift + cmd + F\n  所有文件替换 shift + cmd + R\n    复制当前行内容到下一行 cmd + D\n  删除当前行 cmd + delete\n  格式化代码 option + cmd + L\n  跳转   指定行 cmd + L\n  指定文件 shift + cmd + O\n  在当前行下一行增加空行 shift + enter\n  在当前行上一行增加空行 option + cmd + enter\n  展开所有代码块 shift + cmd + =\n  折叠所有代码块 shift + cmd + -\n  折叠或展开当前代码块 cmd + .\n  "});index.add({'id':367,'href':'/note-cs/docs/others/tool/dev/jetbrains/idea/','title':"Idea",'content':"IntelliJ Idea 插件 Alibaba Java Coding Guidelines  教程 xiaoxiunique/tool-tips  idea 中相见恨晚的技巧 https://atips.cn/idea/\n"});index.add({'id':368,'href':'/note-cs/docs/basic/os/ios/','title':"iOS",'content':"iOS "});index.add({'id':369,'href':'/note-cs/docs/others/tool/dev/jetbrains/','title':"Jetbrains",'content':"Jetbrains 破解 License server: https://fls.jetbrains-agent.com/\n参考：https://zhile.io/\nJetbrains 系列产品最新激活方法 [持续更新]\n点击下载：jetbrains-agent.zip\n"});index.add({'id':370,'href':'/note-cs/docs/basic/computer-composition/','title':"1.1 计算机组成原理",'content':"计算机组成原理 "});index.add({'id':371,'href':'/note-cs/docs/direction/be/','title':"2.1 后端",'content':"后端开发  教程 xingshaocheng/architect-awesome  后端架构师技术图谱\n"});index.add({'id':372,'href':'/note-cs/docs/domain/cc/','title':"3.1 云计算",'content':"云计算 "});index.add({'id':373,'href':'/note-cs/docs/book/basic/','title':"5.1 计算机基础",'content':"计算机基础 计算机组成原理 操作系统 数据结构与算法 计算机网络 编程语言 数据库 编译原理 "});index.add({'id':374,'href':'/note-cs/docs/book/basic/cc/','title':"5.1.1 计算机组成原理",'content':"计算机组成原理 Computer Composition\n"});index.add({'id':375,'href':'/note-cs/docs/domain/cc/edge/5g-edge/','title':"5G 边缘计算",'content':"5G 边缘计算 5G 的 G 是英文 Generation 的缩写，也就是 “世代” 的意思\n简单说，5G 就是第五代移动通信系统\n5G 与边缘计算有什么关系？ 5G 通信网络更加去中心化，需要在网络边缘部署小规模或者便携式数据中心，进行终端请求的本地化处理，以满足 URLLC 和 mMTC 的超低延时需求，因此边缘计算是 5G 核心技术之一。\n5G 的三大典型应用场景对网络性能的要求有显著差异，但为控制成本，运营商必然选择一张承载网 + 网络切片 / 边缘计算技术，实现在最少的资本投入下最丰富的网络功能。\n在 5G 时代，承载网的带宽瓶颈、时延抖动等性能瓶颈难以突破，引入边缘计算后将大量业务在网络边缘终结。\n5G 与边缘计算的关系 5G 为边缘计算产业的落地和发展提供了良好的网络基础， 主要体现在三大场景（eMBB，uRLLC 和 mMTC）的支持、核心网用户面功能的灵活部署以及 5G 网络能力开放等方面。\n“5G + MEC + AI”是 5G 在网络边缘更好使能各行各业的关键； 是运营商助力垂直行业数字化和智能化的新模式； 是运营商进入垂直行业的触点和重点场景； 也是 5G 应用是否成功的一个重要标志。\n5G 支持将网络能力开放给边缘应用。 无线网络信息服务、位置服务、QoS服务等网络能力，可以封装成边缘计算 PaaS 平台的 API，开放给应用。 5G 与边缘计算结合，是运营商使能边缘计算的新核心竞争力和最大独特优势。 同时，边缘计算也成为 5G 服务垂直行业，充分发挥 5G 新网络特性的重要利器之一。\n5G MEC 将云计算和 5G 核心网带到网络边缘，带来了新的流量模型和部署模型。 如果运营商还继续采用 4G 移动承载网的设计思路，在 5G 时代，运营商网络将面临边缘计算的困局。\nQoS（Quality of Service，服务质量）指一个网络能够利用各种基础技术，为指定的网络通信提供更好的服务能力，是网络的一种安全机制， 是用来解决网络延迟和阻塞等问题的一种技术。\n核心网 UPF 下移到企业园区 关键业务数据不出园区，更易提供低延迟承载方案； 运营商可以为每个用户配置单独的 UPF，给企业用户定制 5G 服务。\n开放 5G 通信服务的能力 运营商以 API 模式开放的 5G 通信服务可编程能力（如定位，无线通信能力，带宽管理等）， 可以集成到企业生产业务系统中，企业可以定制自己的 5G 创新应用。\n和企业网直接互联互通 下沉的 5G MEC 系统和企业网直接互联互通，使分布在企业和运营商两个网络系统上的业务系统可以实时地集成拉通， 加上 5G 新的面向行业应用的通信功能（低延迟 uRLLC、物联网 mMTC、无线超级上行和业务连续性等）， 各行业可以做出很多创新应用。\neMBB Enhanced Mobile Broadband\neMBB（特别是超级上行技术）增强移动带宽\n对于带宽要求较高的 AR/VR、直播\nCloud VR uRLLC ultra-Reliable and Low Latency Communications 超高可靠性低时延业务\n对于时延要求极高的工业控制\nTSN TSN（时间敏感网络）\nTSN 的主要目标是通过 IEEE 802（以太网）有线网络提供确定性服务。这意味着低时延、小抖动、低丢包率、有保证的数据包传输。\n5G 和 TSN 进行融合，5G 作为 TSN 网络的 bridge\n实现 TSN 网络 controller 和 5G AF 的协同\n低时延只是一方面吧，更重要的是时延确定； 工业通信（大部分是有线通信）会有这样的要求，5G 是想把工业通信的场景也 cover 进来\n奇速播 奇速播是专门应用于酒店、商场等场所，改善公共 WiFi 用户视频体验的新概念服务，为酒店、商场公共网络环境中的用户带来极致的超高清视频体验\n带宽 max 300MB；时延\u0026lt;20ms\nmMTC massive Machine Type Communications 大物联业务\n海量机器类通信，可以分别支持不同需求的边缘计算场景\n对于海量连接需求高的 IoT 设备接入\n 5G MEC 网络规划建议和网络架构参考模型 5G MEC 网络规划建议，供运营商网络设计时参考。\n 建议采用 ECA、ECN 和 ECI 模型分段设计网络，ECA 和 ECI 可以部署在不同的物理网络上（如两个运营商共享共建 5G 承载网）。 MEC 业务和网络隔离：MEC 内部的业务变化（如部署新的 UPF）和网络连接变化（如增加服务器），尽量少或不影响外部网络，即 MEC 系统和外部网络隔离。 网络方案规划要和运营商内部网络运维团队的界面分工相匹配，减少不同运维团队间的工作交叉，例如，如果 ECN 和 IP RAN 的运维是两个数通团队，网络功能设计就要尽量保持两个团队的专业运维界面清晰。 网络设计要满足 5G MEC 按需建设的增量模式，即增量部署 5G MEC 系统，要尽量减少对网络的影响。 建议 ECI 按逻辑网络来构建，统一控制管理，在跨越多个网络时也能保证快速建立网络连接和保证 SLA，支持 5G MEC 业务的迅速部署。   参考  终于有人把 5G 和边缘计算的关系说清楚了 5G 边缘计算跟我们有什么关系？  "});index.add({'id':376,'href':'/note-cs/docs/course/basic/','title':"6.1 计算机基础",'content':"计算机基础 计算机组成原理 操作系统 数据结构与算法 计算机网络 编程语言 数据库 编译原理 "});index.add({'id':377,'href':'/note-cs/docs/course/basic/cc/','title':"6.1.1 计算机组成原理",'content':"计算机组成原理 Computer Composition\n"});index.add({'id':378,'href':'/note-cs/docs/basic/os/android/','title':"Android",'content':"Android "});index.add({'id':379,'href':'/note-cs/docs/direction/client/android/','title':"Android",'content':"Android "});index.add({'id':380,'href':'/note-cs/docs/direction/be/web-service/doc/','title':"API 文档",'content':"API 文档 swagger-api/swagger-core  swagger-api/swagger-ui   apidoc/apidoc  "});index.add({'id':381,'href':'/note-cs/docs/direction/be/proxy/bfe/','title':"BFE",'content':"BFE baidu/bfe Baidu Front End 百度统一前端\n统一的百度七层（HTTP）流量接入平台\nBFE 之前的百度前端接入架构 流量从 BGW 接入之后直接到达了产品线的前端服务器， 这些服务器种类繁多，几乎包涵了现在流行的各种 webserver，比如 nginx,apache,lighttpd 等， 不同的服务器经过后端不同业务逻辑的处理之后打印日志内容并且将响应发送给用户。\n开发成本高 如果前端多个产品线需要实现一个通用功能，比如防攻击或者 IP 地域识别，需要开发不同的 webserver 模块，虽然每个模块的功能一样，但实现方式完全不同，所以存在一定的重复开发和人力资源浪费。\n维护成本高 不同的产品线和模块都需要一定的人力来维护。前端接入服务器类型多样，实现和原理各异，出现问题的概率大，Nginx, apache 等服务器比较稳定，高效，但是如果产品线出现强烈的个性化业务需求或者严重 BUG，开源社区很难提供及时有效的技术支持。\n数据和策略共享的成本高 产品线间维护不同的前端接入模块，策略和经验很难做到有效的分享。\n技术积累难 由于产品线间沟通和分享的成本大，很多经验和成果并没有得到有效的积累。\n BFE 架构 BFE 是一个七层接入系统。 它的最基本工作就是接收用户数据，解析 HTTP 请求，对内容进行过滤和分析之后再转发给后端产品线。\nBFE 最基本的工作就是从 BGW/BVS 接入流量并将流量转发给产品线的前端 webserver 或者其他接入模块，最后接收后端 server 的内容并回复给外部用户。\n反向代理服务器 BFE 本质上是一个反向代理服务器，每天承接百度数百亿的流量，高峰期的集群 QPS 有一百多万。 在如此大的流量压力环境中，服务器的处理性能至关重要。 BFE 采用现在业界流行的多进程全异步非阻塞事件驱动模型， 但由于业务功能繁多，产品线策略及规则复杂，任何一个开源的代理服务器比如 nginx, squid, varnish 的性能都很难满足需求。 BFE 本身也需要不断优化，降低系统资源开销，提升处理性能。\n能够在任意阶段处理用户请求 从接收用户请求的时候起，BFE 就能对数据进行完全的解析和过滤，能够在读取、解析、连接、写后端等的任一阶段对数据进行修改、增加、删除、丢弃等操作。\n分流策略非常高效 NGINX 和大部分通用的网络服务器在多个正则规则和复杂策略组合下的分流效率比较低，BFE 通过反解正则规则及嵌套分流策略实现了时间复杂度为 O(1) 的分流。\nBFE 提供统一缓存 BFE 提供统一缓存，用户请求可以不经过后端处理由 BFE 直接返回。\nBFE 提供灵活的缓存策略，对于 css 及不宜存放 CDN 的静态资源，BFE 缓存。\n提升超长距离的数据传输效率和响应时间 BFE 和 BFE 级联后可以启用 tcp fast open 及任意时间的长连接，提升超长距离的数据传输效率和响应时间。\n 防攻击系统 产品线各自为战的防攻击很被动，\n 各个产品线需要重复去做防御 同一个防御策略，不同的接入服务器和架构需要不同的代码和逻辑实现 公司的防攻击策略很多都是直接从产品线日志进行挖掘的，不同的服务器日志有不同的格式，众多产品线有各自的部署机房，日志传输延时大并且计算成本高，导致部分防攻击策略时延很大，无法有效实时防止外部攻击。  BFE 防攻击系统的优点：   全局性防御\nBFE 接入目标是百度全部流量，一个策略在 BFE 生效，就可以为百度全部产品线提供保护。\n  时效性\nBFE 实时接收和分析流量，只要符合攻击特征，实时封禁攻击请求。相比 UBS 的离线日志统计和挖掘，BFE 的防攻击检测和生效延时能做到秒级。\n  支持复杂策略\nBFE 接收用户请求时需要对全部内容进行分析过滤，应用层的常见攻击都能实施有效防御。 此外，BFE 的统一防攻击系统 BDS 还在进行实时的全局攻击特征计算，对于同时符合多种封禁规则的外部请求实行封禁。\n  百度防攻击系统（BDS） BDS 是百度接入端全局防攻击系统，负责对接入端流量进行全局、旁路、常态的特征分析和防御处理。 主要由三个子系统组成：\n 旁路特征发送子系统（BDS Sender） 特征检测子系统（BDS Detector） 攻击防御子系统（BDS Defender）   流量调度及均衡系统 内网流量调度及均衡系统（GSLB） GSLB（global service load balance）即内网流量调度系统， 主要针对百度 IDC 内部的流量进行调度。\n它的主要目标是感知内网流量和产品线容量变化并自动地均衡调度流量。\nGSLB 要解决的主要问题描述如下：\n BFE 应该优先将流量转发给离其最近（延时最短）的 Service Cluster BFE Cluster 向下游多个 Service Cluster 的流量转发:  需要对每个下游的 Service Cluster 给出一个权重 这个权重是 gslb 的控制系统需要计算给出的    工作原理简述如下：\n调度模块根据流量采集模块采集到的实时流量数据和容量管理模块提供的容量数据实时计算出权重并将权重数据下发给 BFE， BFE 根据权重数据分配流量，实现快速的流量切换和负载均衡。\n外网流量调度及均衡系统 (GTC) GTC（global service control）主要针对外网流量调度。\n由于网络运营商、带宽资源、网络质量等的限制，即使同一个用户访问同一个百度服务的不同 VIP，也会带来不同的访问延时。\nGTC 要解决的主要问题是：\n对每个用户群，选择唯一的 vip，希望总延迟较小。\n 流量分析及展现 流量分析 BFE 拥有各个产品线访问日志，目前整个集群的天访问日志量有 30 多 T。包括最基本的 URI、HTTP 状态码、用户 IP、cookie、响应时间等， BFE 通过这些日志能挖掘出哪些价值？流量分析主要在以下几个方面开展工作：\n  异常检测\n本文提到的异常定义为不同于正常或者预期行为的数据模式。异常检测的研究成果目前已经应用于金融业的信用欺诈检测，网络入侵检测，医疗疾病预测等。 BFE 的异常检测主要分析访问日志中出现的各种特征数据，判断并拦截异常请求。比如可以根据用户 IP 和 COOKIE 的历史访问纪录判断该 IP 是否正常用户。\n  带宽及资源优化\n主要是针对各产品线流量的占用带宽、响应时间和页面特征优化带宽接入。尽量减少跨 IDC 流量和外网带宽资源。\n  服务质量监控\n服务质量的变化都会反映在访问日志里，响应时间上升，建立连接和重试时间增多都是服务质量下降的具体表现。BFE 希望能通过日志分析数据监控和提前预警产品线服务质量的变化。\n  流量展现 BFE 希望能够实时、准确地展现全百度各条产品线的流量概况，包括总流量趋势、响应时间、状态码变化、地域统计等。 但是在大流量大压力环境下，保证日志传输，数据计算的实时性、稳定性也是个非常有挑战的难题。\n 其他 BGW BVS UBS 日志 911 防攻击系统 公司最主要的防攻击系统就是 911\n911 运行在内核态并且主要针对四层攻击\n不支持长时间的流量清洗 因为长时间内核态运行很容易产生稳定性问题。\n不支持应用层协议的复杂防御 911 主要定位于四层防攻击，如果对七层协议进行分析和策略组合防御，性能消耗非常大。 所以无法防御很多常见的 HTTP 攻击，比如恶意 header（重定向攻击，cookie 攻击）, XSS 攻击，sql 注入等。\n BFE 未来工作（by 2014-02） BFE 的未来工作依然围绕四个核心模块进行：\n 高性能网络服务器技术 防攻击 流量调度及均衡 流量分析及展现  高性能网络服务器技术 优化网络协议 BFE 需要研究和应用业界最先进和成熟的网络优化协议，最主要的就是 TCP 和 HTTP。BFE 目前应用了 tcp fast open 技术，能有效减少 TCP 建立连接三次握手带来的延迟，在第一个 syn 包发出时就能开始传输数据。\nBFE 目前只支持 HTTP1.0\\1.1 协议，HTTP1.1 1999 年发布之后几乎没有很大更新。随着因特网的发展，HTTP1.1 协议的一些缺陷也遭受越来越多的诟病，比如网络连接的复用少，头部冗余数据等。做为下一代 HTTP 协议的 HTTP2.0（主要基于 SPDY 协议）草案正在讨论，预计于 2014 年提交 IETF。BFE 目前也在研究 HTTP2.0 协议内容及在 BFE 上的实现方式。\n优化并发连接处理模型 BFE 采用异步事件驱动实现高并发。但事件驱动的性能到底有多高？是否有新的模型支持实现百万甚至千万级的并发？这是业界广泛讨论和思考的问题。\n但事件模型也有很多缺陷，比如事件状态机的处理很复杂，事件不好管理，超时管理消耗资源等。BFE 需要考虑改进事件模型或者采用新的模型实现更高的并发。\n分流策略及计算优化 BFE 分流策略非常复杂，一条简单的请求往往要通过几十个规则的过滤才能到达产品线后端，怎样降低时间复杂度？减少规则计算？随着接入产品线越来越多，规则越来越复杂，BFE 需要通过优化分流策略来提升处理性能。\n防攻击技术 防攻击系统管理、查询平台化、接口化。 包括配置修改、策略修改及查询、防攻击数据查询等需求，全部实现接口化。\nWAF 研究 Waf 即 Web Application Firewall，是通过执行一系列针对 HTTP/HTTPS 的安全策略来专门为 Web 应用提供保护的系统。\n性能优化 复杂防攻击策略定制。 流量调度及均衡 加强流量调度结果的可视化\n在外网调度中支持更多的调度策略（比如：增加对带宽成本的考虑）\n在内网调度中，增加对更复杂内网环境的考虑（目前只考虑下游服务机群的故障）\n流量分析 流量分析争取在异常检测和服务质量监控取方面取得突破。\n"});index.add({'id':382,'href':'/note-cs/docs/direction/be/proxy/bgw/','title':"BGW",'content':"BGW Baidu Gate Way 百度智能网关 是一种用软件实现的负载均衡设备。\nBGW 将多台 server（即 RealServer）虚拟化成了一台 server，提供统一的 VIP（即 virtual ip），用户只需和 VIP 进行通讯，就能访问 RealServer 上的服务。\n最终， 从 client 的角度看到，自己和一台 server 机器（确切说是一个 ip）在通讯，感觉不到 RealServer 的存在； 从 RealServer 的角度看到，自己和 client 在通讯，没有感觉到 BGW 的存在。\nTTM 模块 BGW 会对报文做 SNAT 和 DNAT，这样 RS（RealServer）看到的源 IP 将是 BGW 的后端 IP，而不是客户端的真实 IP， 而现实中有许多业务需要知道客户端的真实 IP。\n为了解决这个问题，RS 需要在内核加载一个 TTM 模块，即可将该选项携带的真实 IP 信息获取出来， 该过程对于用户态应用程序来说是完全透明的，用户态应用程序所看到的是从客户端真实 IP，实现 BGW 的透明。\n"});index.add({'id':383,'href':'/note-cs/docs/basic/pl/csharp/','title':"C#",'content':"C# 学习笔记 "});index.add({'id':384,'href':'/note-cs/docs/direction/se/arch/principle/cap/','title':"CAP",'content':"CAP P 是前提 在理论计算机科学中，CAP 定理（CAP theorem），又被称作布鲁尔定理（Brewer\u0026rsquo;s theorem），它指出对于一个 distributed data store 来说，不可能同时满足以下三点：\n 一致性（Consistency）  每次读取要么获得最近写入的数据，要么获得一个错误。   可用性（Availability）  每次请求都能获得一个非错误响应，但不保证返回的是最新写入的数据。   分区容错性（Partition tolerance）  以实际效果而言，分区相当于对通信的时限要求。系统如果不能在时限内达成数据一致性，就意味着发生了分区的情况，必须就当前操作在 C 和 A 之间做出选择。 尽管任意数量的消息被节点间的网络丢失（或延迟），系统仍继续运行。    一般选 AP 也就是说，在存在网络分区的情况下，一致性和可用性必须二选一。\n比如：A 服务器 B 服务器同步数据，现在 A B 之间网络断掉了，那么现在发来 A 一个写入请求，但是 B 却没有相关的请求，显然，\n 如果 A 不写，保持一致性，那么我们就失去了 A 的服务， 但是如果 A 写了，跟 B 的数据就不一致了，我们自然就丧失了一致性。  这里的一致性（Consistency）是强一致性，意思是 AB 的数据时刻都是同步的， 如果我们放弃了强一致性，不代表我们的数据就是一定是不一致的了，我们可以让 A 先写入本地，等到通信恢复了再同步给 B，这就是所谓的最终一致性，长远的看我们的数据还是一致的，我们只是在某一个时间窗口里数据不一致罢了。 如果这个时间窗口小过了用户逻辑处理的时间。那么其实对于用户来说根本感觉不到。\n现实中的 CAP CAP 对实际工作缺乏指导性。\n实际系统主要有三种：\n 强调 availability 的 eventual consistency 系统，  比如 Amazon Dynamo 及他们的复制品；   强调一致性的系统，  典型的是基于 Paxos 的系统；   强调性能不顾其他的系统，  典型的是 Async replication 的主从备份系统。    参考  CAP 理论常被解释为一种 “三选二” 定律，这是否是一种误解？ 分布式事务中的最终一致具体应该如何实现？ 分布式系统中的数据一致性和性能怎么权衡？  "});index.add({'id':385,'href':'/note-cs/docs/direction/be/auth/sso/cas/','title':"CAS",'content':"CAS 简介 集中式认证服务（英语：Central Authentication Service，缩写 **CAS **）是一种针对万维网的单点登录协议。它的目的是允许一个用户访问多个应用程序，而只需提供一次凭证（如用户名和密码）。它还允许 web 应用程序在没有获得用户的安全凭据（如密码）的情况下对用户进行身份验证。\u0026ldquo;CAS\u0026rdquo; 也指实现了该协议的软件包。\nCAS 是由耶鲁大学 的 Shawn Bayern 创始的，后来由耶鲁大学的 Drew Mazurek 维护。CAS1.0 实现了单点登录。 CAS2.0 引入了多级代理认证（Multi-tier proxy authentication）。CAS 其他几个版本已经有了新的功能。\n2004 年 12 月，CAS 成为 Jasig（英语：Jasig）的一个项目，2008 年该组织负责 CAS 的维护和发展。CAS 原名 \u0026ldquo;耶鲁大学 CAS\u0026rdquo;，现在则被称为 \u0026ldquo;Jasig CAS\u0026rdquo;。\n原理 Cas Server  sequenceDiagram participant c as Client (The browser) participant ws as Web Server participant cs as CAS Server c-ws: 访问网站地址 Note over ws: 尝试从 cookie 获取 pToken 和 sToken alt pToken 和 sToken 同时存在 ws--cs: /validate 验证合法性 alt 正常登录 cs--ws: 返回用户信息 ws-c: 返回用户请求内容 else 不正常 cs--ws: 返回状态码 204 ws-c: 返回重定向到 CAS 登录接口 Note over c, cs: 后面流程参考底下 Loop 循环 end else 不同时存在 ws-c: 返回重定向到 CAS 登录接口 loop 访问 CAS 登录页面 c-cs: 登录 alt 登录成功 cs-c: 返回带 ticket 的重定向，并在浏览器写入 pToken 的 cookie c-ws: 带有 ticket 的请求 ws--cs: 使用 ticket 置换 sToken alt 合法 ticket cs--ws: 返回 sToken ws-c: 返回用户请求内容，并在浏览器写入 sToken 的 cookie else 非法 ticket ws-c: 返回重定向到 CAS 登录接口 end else 登录失败 cs-c: 返回错误提示页面 end end end Session Server + Cas Server sequenceDiagram participant c as Client (The browser) participant ws as Web Server participant cs as CAS Server participant ss as Session Server c-ws: 访问网站地址 Note over ws: 尝试从 cookie 获取 pToken 和 sToken alt pToken 和 sToken 同时存在 ws--ss: /validate 验证合法性 alt 正常登录 ss--ws: 返回用户信息 ws-c: 返回用户请求内容 else 不正常 ss--ws: 返回状态码 204 ws-c: 返回重定向到 CAS 登录接口 Note over c, ss: 后面流程参考底下 Loop 循环 end else 不同时存在 ws-c: 返回重定向到 CAS 登录接口 loop 访问 CAS 登录页面 c-cs: 登录 alt 登录成功 cs-c: 返回带 ticket 的重定向，并在浏览器写入 pToken 的 cookie c-ws: 带有 ticket 的请求 ws--cs: 使用 ticket 置换 sToken alt 合法 ticket cs--ws: 返回 sToken ws-c: 返回用户请求内容，并在浏览器写入 sToken 的 cookie else 非法 ticket ws-c: 返回重定向到 CAS 登录接口 end else 登录失败 ss-c: 返回错误提示页面 end end end 百度 UUAP   用户访问接入 uuap 的下游系统 xx.baidu.com，例如 family.baidu.com。\n  下游系统后端 server 从 cookie 中获取 pToken 及 sToken，校验是否同时存在，不同时存在直接重定向用户到 uuap 登录接口认证。\n pToken：存在于 baidu.com（baidu-int.com）域名下，cookie 的名字为 UUAP_P_TOKEN，线下环境统一为 UUAP_P_TOKEN_OFFLINE sToken：存在于下游系统的域名下面、该值为 uuap 认证成功后签发的 ticket 参数、下游系统获取后将其存入您的域名下，有效期 30 天、该值通用名称为 UUAP_S_TOKEN\n   pToken 与 sToken\n 如果 pToken 与 sToken 同时存在，则将 pToken、sToken 及您的 appKey 作为参数，发送 POST 请求到 UUAP-SESSION 的 Session 登录校验校验用户是否正常登录，如果正常登录返回登录用户的基本信息，未正常登录则返回状态码 204，重定向用户到 uuap 登录接口认证 如果 pToken 与 sToken 不是同时存在，下游系统直接重定向用户到 uuap 登录接口认证。    如果 UUAP-SESSION 返回用户登录成功并且返回登录用户的基本信息，下游系统可允许用户访问受保护的内容。\n  如果 UUAP-SESSION 返回状态码 204，则按照 3-2 的步骤，下游系统直接通知前端跳转 UUAP-SSO 认证服务器认证。\n  下游系统携带 service 及 appKey 参数，访问 UUAP-SSO 的 uuap 登录接口接口请求用户认证。\n service：第 1 步中用户访问的下游系统的 url，请对该 url 进行 urlencode appKey：uuap 签发的下游系统唯一 id\n   UUAP-SSO 认证服务器认证通过会在 baidu 的根域名下植入 pToken 的 cookie，并且会在用户传递的 service 回调地址后面追加 ticket 参数通知用户跳转，下游系统 server 可获取该参数，调用 SToken 置换接口获取 SToken，将其以 cookie 的形式存入你们的域名下，该值就是 sToken。\n cookie 植入成功后要在之前访问 url 的基础上去除 ticket 参数让用户重新 302 访问一次，这样就能防止 server 看到访问 url 中存在 ticket 参数关键字陷入反复植入 sToken 的死循环，跳转后用户重新从第 1 步执行。    认证失败，跳转错误页面。\n   参考  mermaid  "});index.add({'id':386,'href':'/note-cs/docs/basic/pl/cpp/basic/grammar/class/','title':"class",'content':"class 建议：\n class 表示被封装的用户自定义类型，不公开定义非静态数据成员，一般通过成员方法进行交互。 struct 表示数据的简单集合，公开定义数据成员，只定义用于初始化数据成员的方法 (比如：构造 / 析构函数，initialize(), reset(), validate())。  // 简单的数据聚合，没有动作 struct Coordinate { int x; int y; int z; }; // 有动作的对象 class Cat { public: void meow(); private: ... }; class vs struct  默认继承权限  class: private struct: public   成员的默认访问权限  class: private struct: public    除了这两点，class 和 struct 基本就是一个东西。\n"});index.add({'id':387,'href':'/note-cs/docs/others/tool/dev/ssh/config/','title':"config",'content':"config my config ################ vps ################ Host bcc HostName 106.13.4.39 User root IdentityFile ~/.ssh/id_rsa Host vultr HostName 149.28.142.246 User root IdentityFile ~/.ssh/id_rsa ################ baidu ################ Host baidu HostName relay.baidu-int.com User yewang ################ git ################ Host github HostName github.com User git IdentityFile ~/.ssh/id_rsa ProxyCommand nc -v -x 127.0.0.1:1081 %h %p Host gitlab HostName gitlab.com User git IdentityFile ~/.ssh/id_rsa ProxyCommand nc -v -x 127.0.0.1:1081 %h %p Host bitbucket HostName bitbucket.org User git IdentityFile ~/.ssh/id_rsa ProxyCommand nc -v -x 127.0.0.1:1081 %h %p Host gitcafe HostName e.coding.net User git IdentityFile ~/.ssh/id_rsa Host gitee HostName gitee.com User git IdentityFile ~/.ssh/id_rsa ################ others ################ Host * # 复用之前已经建立的连接 ControlMaster auto # 在最后一个连接关闭之后也不真正的关掉连接 ControlPersist yes # 指定了这个连接的 socket 保存的路径 ControlPath ~/.ssh/connection-%r@%h:%p # 心跳 ServerAliveInterval 60 # ServerAliveCountMax 20 # ForwardAgent yes # KexAlgorithms +diffie-hellman-group1-sha1 # PreferredAuthentications publickey # TCPKeepAlive no # Compression yes # 走 HTTP 代理 # ProxyCommand socat - PROXY:127.0.0.1:%h:%p,proxyport=8081 # 走 socks5 代理（如 Shadowsocks） # ProxyCommand nc -v -x 127.0.0.1:1080 %h %p "});index.add({'id':388,'href':'/note-cs/docs/domain/cc/others/saas/crm/','title':"CRM",'content':"CRM "});index.add({'id':389,'href':'/note-cs/docs/others/skill/debug/gdb/tutorial/','title':"GDB 教程",'content':"GDB 教程 "});index.add({'id':390,'href':'/note-cs/docs/others/tool/dev/git/','title':"git",'content':"git git module git submodule foreach git reset --hard HEAD git submodule update git submodule foreach \u0026#34;git checkout master; git pull\u0026#34; git submodule foreach git clean -f  merge vs squash vs rebase merge 不能保持 master 分支干净，但是保持了所有的 commit history，大多数情况下都是不好的，个别情况挺好 squash 也可以保持 master 分支干净，但是 master 中 author 都是 maintainer，而不是原 owner rebase 可以尽可能保持 master 分支干净整洁，并且易于识别 author\nsquash merge # 切换到目标分支 $ git checkout master # 以 squash 的形式 merge $ git merge --squash devel # it does not produce a commit right away: you need an additional commit $ git commit -m \u0026#34;squash branch\u0026#34;  你会发现，在 master 分支上居然有未提交的修改，然后你就需要在 master 上主动提交了修改， 注意，这里是你 commit 的，也就是改变了 commit 的 author。 git merge has a \u0026ndash;commit option, but it cannot be used with \u0026ndash;squash. It was never possible to use \u0026ndash;commit and \u0026ndash;squash together.  参考：\n In git, what is the difference between merge \u0026ndash;squash and rebase?  rebase merge # 先切换到 devel 分支（不一样咯） $ git checkout devel # 变基 $ git rebase -i master # 切换回目标分支 $ git checkout master # 合并 $ git merge  我们在 devel 里面对照 master 进行了变基  所谓的变基其实就是找到两个分支共同的祖先   然后在当前分支上合并从共同祖先到现在的所有 commit  会选择怎么处理这些 commit   然后我们就得到了一个从公共 commit 到现在的单个 commit 这个时候别人将我们这个 commit 合并到 master 也只会在 master 上留下一个 commit 记录   合并 git commit 参考：\n Trimming Git Commits/Squashing Git History   git branch 与 git tag 同名 需要使用完整路径\ngit checkout refs/heads/v1.5.2 git checkout refs/tags/v1.5.2 git push -u origin refs/heads/v4.8.0 参考：\n In git, is it a bad idea to create a tag with the same name as a deleted branch?   git pull force git fetch --all # git reset --hard origin/\u0026lt;branch_name\u0026gt; git reset --hard origin/master 参考：\n How do I force “git pull” to overwrite local files?   hard reset vs mixed reset vs soft reset # 回到 reset 版本，之后的文件都属于 git add 的状态 git reset --soft # git reset 默认就是 --mixed # 回到 reset 版本，之后的文件都属于 git add 前的状态 git reset --mixed # 回到 reset 版本，之后文件都丢弃（使用 git reflog 可以找回来） git reset --hard git reflog reflog 是 Git 操作的一道安全保障，它能够记录几乎所有本地仓库的改变。\n包括所有分支 commit 提交，已经删除的 commit（其实并未被实际删除）都会被记录。\n只要 HEAD 发生变化，就可以通过 reflog 查看到。\ngit 回退 # 文件放弃本地修改 git checkout -- \u0026lt;file\u0026gt; # 文件回退到版本 git reset --hard commit-id \u0026lt;file\u0026gt; # 目录 回退版本 git checkout commit-id \u0026lt;path\u0026gt; git reset -- \u0026lt;path\u0026gt; 参考：\n Why git can\u0026rsquo;t do hard/soft resets by path?  "});index.add({'id':391,'href':'/note-cs/docs/others/tool/dev/git/config/','title':"git config",'content':"git config config 权限 问题： Bad owner or permissions on ~/.ssh/config\n解决：\nchown $USER ~/.ssh/config chmod 644 ~/.ssh/config "});index.add({'id':392,'href':'/note-cs/docs/direction/be/microservices/rpc/grpc/','title':"gRPC",'content':"gRPC  "});index.add({'id':393,'href':'/note-cs/docs/domain/cc/virtual/hyperkit/','title':"HyperKit",'content':"HyperKit "});index.add({'id':394,'href':'/note-cs/docs/domain/cc/others/iaas/','title':"IaaS",'content':"IaaS "});index.add({'id':395,'href':'/note-cs/docs/direction/fe/lib/jquery/','title':"Jquery",'content':"Jquery "});index.add({'id':396,'href':'/note-cs/docs/direction/be/proxy/envoy/xds/lds/','title':"LDS",'content':"LDS 监听器发现服务（LDS）是一个可选的 API，Envoy 将调用它来动态获取监听器。Envoy 将协调 API 响应，并根据需要添加、修改或删除已知的监听器。\n监听器更新的语义如下：\n 每个监听器必须有一个独特的名字。如果没有提供名称，Envoy 将创建一个 UUID。要动态更新的监听器，管理服务必须提供监听器的唯一名称。 当一个监听器被添加，在参与连接处理之前，会先进入 “预热” 阶段。例如，如果监听器引用 RDS 配置，那么在监听器迁移到 “active” 之前，将会解析并提取该配置。 监听器一旦创建，实际上就会保持不变。因此，更新监听器时，会创建一个全新的监听器（使用相同的侦听套接字）。新增加的监听者都会通过上面所描述的相同 “预热” 过程。 当更新或删除监听器时，旧的监听器将被置于 “draining（逐出）” 状态，就像整个服务重新启动时一样。监听器移除之后，该监听器所拥有的连接，经过一段时间优雅地关闭（如果可能的话）剩余的连接。逐出时间通过 --drain-time-s 选项设置。  注意\n 任何在 Envoy 配置中静态定义的监听器都不能通过 LDS API 进行修改或删除。\n "});index.add({'id':397,'href':'/note-cs/docs/others/skill/debug/lldb/','title':"LLDB",'content':"LLDB "});index.add({'id':398,'href':'/note-cs/docs/others/skill/debug/lldb/tutorial/','title':"LLDB 教程",'content':"LLDB 教程 "});index.add({'id':399,'href':'/note-cs/docs/domain/cc/virtual/multipass/','title':"Multipass",'content':"Multipass canonical/multipass Multipass orchestrates virtual Ubuntu instances https://multipass.run\n# 创建一个 VM, 1GB 内存和 5GB 磁盘 multipass launch --name k3s --mem 1G --disk 5G # 为 VM 启动一个 shell multipass shell k3s # 挂载 multipass mount ~/code myvm:/home/ubuntu/yewang/code # 在其上安装 k3s curl -sfL https://get.k3s.io | sh – 网络 使用的是桥接模式，因为\n 主机可以 ping 通虚拟机  所以不是 NAT   虚拟机之间可以 ping 通  所以不是 NAT   虚拟机可以上网  所以不是 Host-Only    "});index.add({'id':400,'href':'/note-cs/docs/basic/db/mysql/','title':"Mysql",'content':"Mysql "});index.add({'id':401,'href':'/note-cs/docs/others/skill/lorawan/chirpstack/network/','title':"Network",'content':"ChirpStack Network Server ChirpStack Network Server is an open-source LoRaWAN network-server. https://www.chirpstack.io\n数据库    Schema Name Type Owner     public code_migration table chirpstack_ns   public device table chirpstack_ns   public device_activation table chirpstack_ns   public device_activation_id_seq sequence chirpstack_ns   public device_multicast_group table chirpstack_ns   public device_profile table chirpstack_ns   public device_queue table chirpstack_ns   public device_queue_id_seq sequence chirpstack_ns   public gateway table chirpstack_ns   public gateway_board table chirpstack_ns   public gateway_profile table chirpstack_ns   public gateway_profile_extra_channel table chirpstack_ns   public gateway_profile_extra_channel_id_seq sequence chirpstack_ns   public gateway_stats table chirpstack_ns   public gateway_stats_id_seq sequence chirpstack_ns   public gorp_migrations table chirpstack_ns   public multicast_group table chirpstack_ns   public multicast_queue table chirpstack_ns   public multicast_queue_id_seq sequence chirpstack_ns   public routing_profile table chirpstack_ns   public service_profile table chirpstack_ns    (21 rows)\n"});index.add({'id':402,'href':'/note-cs/docs/direction/be/proxy/nginx/','title':"Nginx",'content':"Nginx "});index.add({'id':403,'href':'/note-cs/docs/direction/be/auth/oauth/','title':"OAuth",'content':"OAuth 2.0 OAuth 2.0 协议参考 rfc6749\n1.0  问答 为什么需要 Refresh Token 这样的处理是为了职责的分离：\n refresh token 负责身份认证 access token 负责请求资源。   参考  Choosing an SSO Strategy: SAML vs OAuth2  rfc6749 百度 UUAP OAuth "});index.add({'id':404,'href':'/note-cs/docs/direction/be/auth/openid/','title':"OpenID",'content':"OpenID OpenID vs OAuth  OpenID 只用于身份认证（Authentication），允许你以同一个账户在多个网站登陆。它仅仅是为你的合法身份背书，当你以 Facebook 账号登陆某个站点之后，该站点无权访问你的在 Facebook 上的数据 OAuth 用于授权（Authorisation），允许被授权方访问授权方的用户数据  "});index.add({'id':405,'href':'/note-cs/docs/direction/be/distributed/paxos/','title':"Paxos",'content':"Paxos Paxos 算法是分布式技术大师 Lamport 提出的，主要目的是通过这个算法，让参与分布式处理的每个参与者逐步达成一致意见。\nLamport 为了讲述这个算法，假想了一个叫做 Paxos 的希腊城邦进行选举的情景，这个算法也是因此而得名。 由于城邦的居民没有人愿意把全部时间和精力放在这种事情上，所以他们只能不定时的来参加提议，不定时来了解提议、投票进展，不定时的表达自己的投票意见。 Paxos 算法的目标就是让他们按照少数服从多数的方式，最终达成一致意见。\n算法过程  先明确哪个 “提议者” 是意见领袖有权提出提议，未来，“接受者” 们就主要处理这个 “提议者” 的提议了 选出的意见领袖提出提议，“接受者” 反馈意见。如果多数 “接受者” 接受了一个提议，那么提议就通过了   参考  如何浅显易懂地解说 Paxos 的算法？  "});index.add({'id':406,'href':'/note-cs/docs/direction/be/web-service/rest/','title':"REST",'content':"REST Representational state transfer (REST) is a software architectural style that defines a set of constraints to be used for creating Web services.\n"});index.add({'id':407,'href':'/note-cs/docs/others/skill/stream-media/rtmp/','title':"RTMP",'content':"RTMP Real-Time Messaging Protocol\n默认端口 1935\nRTMP vs RTSP 目前直播方案是：rtmp 推到 server，然后转 rtmp/http-flv/hls.\n 直播走的是互联网的路子，浏览器和 Flash 不支持 RTSP。 国内的 CDN 对 RTMP 做过优化，而 RTSP 没有。 网络中的路由器或防火墙可能对 RTSP 端口不开放。  参考：\n 为什么现在的视频直播不使用 RTSP 协议而是使用 RTMP？  "});index.add({'id':408,'href':'/note-cs/docs/others/skill/stream-media/rtp/','title':"RTP",'content':"RTP 报文结构  Ver.（2 bits）是目前协议的版本号码，目前版号是 2。 P（1 bit）是用于 RTP 报文（packet）结束点的预留空间，视报文是否需要多余的填塞空间。 X（1 bit）是否在使用延伸空间于报文之中。 CC（4 bits）包含了 CSRC 数目用于修正标头（fixed header）。 M（1 bit）是用于应用等级以及其原型（profile）的定义。如果不为零表示目前的数据有特别的程序解译。 PT（7 bits）是指 payload 的格式并决定将如何去由应用程序加以解译。 SSRC 是同步化来源。  RTP/PS/H.264 基于 RTP 的 PS 封装 首先按照 ISO/IEC 13818-1:2000 将视音频封装成 PS 包， 再将 PS 包以负载的方式封装成 RTP 包。\nPS 包 进行 PS 封装时，将每个视频帧封装为一个PS 包， 且每个关键帧的 PS 包中包含系统头（System Header）和 PSM（Program Stream Map）。\n系统头和 PSM 放置于 PS 包头之后，第一个 PES 包之前。\nRTP 包 首条数据结构：RTP Header + PS Header + PS System Header + PSM + PESV（Header + Payload）\n非首条数据结构：RTP Header + PS Header + PESV（Header + Payload）\n PESV: 视频 PESA: 音频  知道了 PS 包的结构，就可以用处理程序解析数据， 从而把原始流 ES（H264）从 PES 包中解析出来\nPES Payload 就是 H264 数据\nRTP 头部  去掉 12 字节的 RTP 头部，保存下来的就是 H264 PS 流， VLC 可播放\n 第 1 字节\n第 2 字节\n第 3-4 字节\n第 5-8 字节\n第 9-12 字节\nRTP Payload  RTP Payload 中承载的即为 PS 数据 起始的 00 00 01 ba 代表 PS 包的开始 接下来跳过 9 个字节，暂时不关心它的内容 看第 10 个字节 fe，对应着二进制数据的 1111 1110  它的后三位为 110 为十进制的 6，即接下来的六个字节是扩展内容   跳过 6 个字节后，遇到了 00 00 01 bb，这时来到了 PS System Header 部分  PS 数据格式的标准文档可以参考这个 PDF：iso13818-1:2000.pdf   紧邻的 00 12 两个字节表示 System Header 的长度，换算为十进制，即为 18 个字节 在 header_length 后共有 6 个字节的数据 之后就是 stream_id 字段（码流种类）  system_id 值为 e0 0xE0: 视频流 0xC0: 音频流      payload type: PS (96) SSRC: Synchronization source CSRC: Contributing source  参考：\n 海康摄像头 PS 流格式解析（RTP/PS/H264） 基于 GB28181 从海康 NVR 获取目录 / 点播 / 回播信令备忘 RTP 协议全解析（H264 码流和 PS 流）  "});index.add({'id':409,'href':'/note-cs/docs/others/skill/stream-media/rtsp/','title':"RTSP",'content':"RTSP Real Time Streaming Protocol\n默认端口 554\n"});index.add({'id':410,'href':'/note-cs/docs/domain/cc/others/saas/crm/salesforce/','title':"Salesforce",'content':"Salesforce "});index.add({'id':411,'href':'/note-cs/docs/others/tool/dev/ssh/','title':"ssh",'content':"ssh ssh-keygen 代理 ssh -o ProxyCommand=\u0026#39;socat - SOCKS4A:myproxy:%h:%p,socksuser=nobody\u0026#39; user@host # SOCKS5 ssh -o ProxyCommand=\u0026#39;socat - \u0026#34;SOCKS5:%h:%p|tcp:myproxy:1080\u0026#34;\u0026#39; user@host # http ssh -o ProxyCommand=\u0026#39;socat - \u0026#34;PROXY:%h:%p|tcp:myproxy:80\u0026#34;\u0026#39; user@host 参考：\n Connecting to host by SSH client in Linux by proxy  "});index.add({'id':412,'href':'/note-cs/docs/basic/db/redis/source/type/string/','title':"String 实现",'content':"Redis String 类型实现 Redis 中的字符串是一种 动态字符串，这意味着使用者可以修改，它的底层实现有点类似于 Java 中的 ArrayList，有一个字符数组，从源码的 sds.h/sdshdr 文件 中可以看到 Redis 底层对于字符串的定义 SDS，即 Simple Dynamic String 结构：\n/* Note: sdshdr5 is never used, we just access the flags byte directly. * However is here to document the layout of type 5 SDS strings. */ struct __attribute__ ((__packed__)) sdshdr5 { unsigned char flags; /* 3 lsb of type, and 5 msb of string length */ char buf[]; }; struct __attribute__ ((__packed__)) sdshdr8 { uint8_t len; /* used */ uint8_t alloc; /* excluding the header and null terminator */ unsigned char flags; /* 3 lsb of type, 5 unused bits */ char buf[]; }; struct __attribute__ ((__packed__)) sdshdr16 { uint16_t len; /* used */ uint16_t alloc; /* excluding the header and null terminator */ unsigned char flags; /* 3 lsb of type, 5 unused bits */ char buf[]; }; struct __attribute__ ((__packed__)) sdshdr32 { uint32_t len; /* used */ uint32_t alloc; /* excluding the header and null terminator */ unsigned char flags; /* 3 lsb of type, 5 unused bits */ char buf[]; }; struct __attribute__ ((__packed__)) sdshdr64 { uint64_t len; /* used */ uint64_t alloc; /* excluding the header and null terminator */ unsigned char flags; /* 3 lsb of type, 5 unused bits */ char buf[]; }; 你会发现同样一组结构 Redis 使用泛型定义了好多次，为什么不直接使用 int 类型呢？\n因为当字符串比较短的时候，len 和 alloc 可以使用 byte 和 short 来表示，Redis 为了对内存做极致的优化，不同长度的字符串使用不同的结构体来表示。\nSDS 与 C 字符串的区别 为什么不考虑直接使用 C 语言的字符串呢？\nC 字符串太简单 因为 C 语言这种简单的字符串表示方式 不符合 Redis 对字符串在安全性、效率以及功能方面的要求。\nC 语言使用了一个长度为 N+1 的字符数组来表示长度为 N 的字符串，并且字符数组最后一个元素总是 \u0026lsquo;\\0\u0026rsquo;。\n这样简单的数据结构可能会造成以下一些问题：\n 获取字符串长度为 O (N) 级别的操作 → 因为 C 不保存数组的长度，每次都需要遍历一遍整个数组； 不能很好的杜绝 缓冲区溢出 / 内存泄漏 的问题 → 跟上述问题原因一样，如果执行拼接 or 缩短字符串的操作，如果操作不当就很容易造成上述问题； C 字符串 只能保存文本数据 → 因为 C 语言中的字符串必须符合某种编码（比如 ASCII），例如中间出现的 \u0026lsquo;\\0\u0026rsquo; 可能会被判定为提前结束的字符串而识别不了；  以追加字符串的操作举例，Redis 源码如下：\n/* Append the specified binary-safe string pointed by \u0026#39;t\u0026#39; of \u0026#39;len\u0026#39; bytes to the * end of the specified sds string \u0026#39;s\u0026#39;. * * After the call, the passed sds string is no longer valid and all the * references must be substituted with the new pointer returned by the call. */ sds sdscatlen(sds s, const void *t, size_t len) { // 获取原字符串的长度  size_t curlen = sdslen(s); // 按需调整空间，如果容量不够容纳追加的内容，就会重新分配字节数组并复制原字符串的内容到新数组中  s = sdsMakeRoomFor(s,len); if (s == NULL) return NULL; // 内存不足  memcpy(s+curlen, t, len); // 追加目标字符串到字节数组中  sdssetlen(s, curlen+len); // 设置追加后的长度  s[curlen+len] = \u0026#39;\\0\u0026#39;; // 让字符串以 \\0 结尾，便于调试打印  return s; }  参考  5 种基本数据结构  "});index.add({'id':413,'href':'/note-cs/docs/others/tool/dev/git/submodule/','title':"submodule",'content':"git submodule 拉取 submodule git submodule init git submodule update --remote git submodule add -b 参考：\n How can I specify a branch/tag when adding a Git submodule?  submodule 修改 url  edit the .gitmodules file to update the URL git submodule sync  参考： How to change the remote repository for a git submodule?\ndelete submodule  Delete the relevant section from the .gitmodules file. Stage the .gitmodules changes git add .gitmodules Delete the relevant section from .git/config. Run git rm --cached path_to_submodule (no trailing slash). Run rm -rf .git/modules/path_to_submodule (no trailing slash). Commit git commit -m \u0026ldquo;Removed submodule \u0026quot; Delete the now untracked submodule files rm -rf path_to_submodule   untracked status [submodule \u0026#34;example\u0026#34;] path = example url = git://github.com/ikingye/example.git ignore = dirty  How to get rid of Git submodules untracked status?  "});index.add({'id':414,'href':'/note-cs/docs/domain/cc/virtual/vmware/','title':"VMware Fusion",'content':"VMware Fusion "});index.add({'id':415,'href':'/note-cs/docs/others/tool/dev/vscode/debug/','title':"VSCode Debug",'content':"VSCode Debug 参考：\n  USER GUIDE - Debugging\n  Debug C++ in Visual Studio Code\n  "});index.add({'id':416,'href':'/note-cs/docs/direction/fe/frame/vue/','title':"Vue",'content':"Vue "});index.add({'id':417,'href':'/note-cs/docs/others/skill/stream-media/webrtc/','title':"WebRTC",'content':"WebRTC Web Real-Time Communication\n支持网页浏览器进行实时语音对话或视频对话的 API\n"});index.add({'id':418,'href':'/note-cs/docs/direction/be/proxy/envoy/xds/','title':"xDS",'content':"xDS "});index.add({'id':419,'href':'/note-cs/docs/direction/be/web-service/xml/','title':"XML",'content':"XML "});index.add({'id':420,'href':'/note-cs/docs/basic/pl/cpp/basic/grammar/vs-c/','title':"与 C 的差异",'content':"C++ 与 C 语言的差异   字符字面量的大小\n// 在C++中，字符字面量的大小是一个字节。 sizeof(\u0026#39;c\u0026#39;) == 1 // 在C语言中，字符字面量的大小与int相同。 sizeof(\u0026#39;c\u0026#39;) == sizeof(10)   函数原型与函数定义匹配\n// C++ 的函数原型与函数定义是严格匹配的 void func(); // 这个函数不能接受任何参数  // 而在C语言中 void func(); // 这个函数能接受任意数量的参数   NULL vs nullptr\n// 在 C++ 中，用 nullptr 代替 C 语言中的 NULL int* ip = nullptr;   同文件\n// C++ 也可以使用 C 语言的标准头文件， // 但是需要加上前缀 “c” 并去掉末尾的 “.h”。 #include \u0026lt;cstdio\u0026gt;  "});index.add({'id':421,'href':'/note-cs/docs/basic/pl/c/basic/grammar/vs-cpp/','title':"与 C++ 的差异",'content':"C 语言与 C++ 的差异 参考：C++ 学习笔记\n"});index.add({'id':422,'href':'/note-cs/docs/domain/cc/cn/','title':"云原生",'content':"Cloud Native 云原生 什么是云原生 2018 年 CNCF 更新了云原生的定义。\n这是新定义中描述的代表技术，其中容器和微服务两项在不同时期的不同定义中都有出现，\n而服务网格这个在 2017 年才开始被社区接纳的新热点技术被非常醒目的列出来，和微服务并列，而不是我们通常认为的服务网格只是微服务在实施时的一种新的方式。\nCloud Native 翻译为云原生，是 Matt Stine 提出的一个概念，它是一个思想的集合，\n包括 DevOps、 持续交付（Continuous Delivery）、微服务（MicroServices）、敏捷基础设施（Agile Infrastructure）、康威定律（Conways Law）等，以及根据商业能力对公司进行重组。\nCloud Native 既包含\n 技术（微服务，敏捷基础设施）， 也包含管理（DevOps，持续交付，康威定律，重组等）。  Cloud Native 也可以说是一系列 Cloud 技术、企业管理方法的集合。\n参考：\n CNCF Cloud Native Definition v1.0  云原生代表技术 云原生的代表技术包括容器、服务网格、微服务、不可变基础设施和声明式 API。\n不可变基础设施 在传统的可变服务器基础架构中，服务器会不断更新和修改。\n使用此类基础架构的工程师和管理员可以通过 SSH 连接到他们的服务器，手动升级或降级软件包，逐个服务器地调整配置文件，以及将新代码直接部署到现有服务器上。\n换句话说，这些服务器是可变的；它们可以在创建后进行更改。\n不可变基础架构的好处包括基础架构中更高的一致性和可靠性，以及更简单，更可预测的部署过程。\n它可以缓解或完全防止可变基础架构中常见的问题，例如配置漂移和雪花服务器。\n宠物与牛群 pets 是独一无二，无法模仿，失去一个可能是毁灭性的。\n牛群中的众多群体中没有一个人是独一无二或不可或缺的。\n雪花服务器与凤凰服务器 snowflakes 服务器类似于宠物。它们是手工管理的服务器，经常更新和调整到位，从而形成独特的环境。\nPhoenix 服务器与牛类似。它们是始终从头开始构建的服务器，并且易于通过自动化过程重新创建（或 “从灰烬中升起”）。\n参考：\n 什么是不可变的基础设施？  Tutum tutum (now Docker)\n参考：\n 如何更好地使用容器技术实现不可变基础设施   云原生应用 理想的云原生应用应该是这个样子：业务需求的实现占主体，只有少量的非业务需求相关的功能。\n参考：\n 未来已来：云原生 Cloud Native  梳理后端架构演化史，回顾后端架构发展历程； 回顾云服务发展历程，探讨云原生概念； 梳理云原生实现方案 Service Mesh 的发展历程； 介绍 Service Mesh 的代表 Istio 的亮眼功能；   畅谈云原生（上）：云原生应用应该是什么样子？ 云原生与无服务器架构是云计算的未来吗？—— 云计算的演进   Service Mesh vs Serverless Service Mesh 技术和 Serverless 技术是工作在不同纬度的两个技术：\n Service Mesh 技术的关注点在于服务间通讯，其目标是剥离客户端 SDK，为应用减负，提供的能力主要包括安全性、路由、策略执行、流量管理等。 Serverless 技术的关注点在于服务运维，目标是客户无需关注服务运维，提供服务实例的自动伸缩，以及按照实际使用付费。  理论上 Service Mesh 技术和 Serverless 技术并没有冲突的地方，可以结合使用。事实上目前业界也开始出现这个趋势，而融合的方式有两种：\n在 Serverless 中引入 Service Mesh 典型如 Knative 项目和 Knative 的 Google Cloud 托管版本 Google Cloud Run，通过引入对容器的支持和使用 Istio，Knative 将 Serverless 的支持扩展到 Function 之外，在极大的扩展 Serverless 适用范围的前提下，也将服务间通讯的能力引入到 Serverless。\n在 Service Mesh 中引入 Serverless 典型如 Google Traffic Director 产品，在提供 Service Mesh 各种能力的同时，支持按照流量自动伸缩服务的实例数量，从而融入了部分 Serverless 的特性。\n对于 Serverless 和 Service Mesh 的结合，我们展望未来形态：\n未来应该会出现一种新型服务模式，Serverless 和 Service Mesh 合二为一。只要将服务部署上来，就自动可以得到 Service Mesh 的服务间通讯能力和 Serverless 的无服务器运维。\nService Mesh 发展趋势：云原生中流砥柱（下）\n"});index.add({'id':423,'href':'/note-cs/docs/basic/pl/csharp/appendix/attention/','title':"关注",'content':"关注 核心 dotnet/core  Home repository for .NET Core\ndotnet/coreclr  CoreCLR is the runtime for .NET Core. It includes the garbage collector, JIT compiler, primitive data types and low-level classes. https://docs.microsoft.com/dotnet/core/\ndotnet/roslyn  The Roslyn .NET compiler provides C# and Visual Basic languages with rich code analysis APIs. https://docs.microsoft.com/zh-cn/dotnet/csharp/roslyn-sdk/\ndotnet/aspnetcore  ASP.NET Core is a cross-platform .NET framework for building modern cloud-based web applications on Windows, Mac, or Linux. https://asp.net\n dotnet/runtime  .NET is a cross-platform runtime for cloud, mobile, desktop, and IoT apps. https://docs.microsoft.com/dotnet/core/\ndotnet/corefx  Going forward, the .NET team is using https://github.com/dotnet/runtime to develop the code and issues formerly in this repository.\ndotnet/blazor  Blazor is a .NET web framework using C#/Razor and HTML that runs in the browser with WebAssembly. https://blazor.net/\n Web aspnetboilerplate/aspnetboilerplate  ASP.NET Boilerplate - Web Application Framework https://aspnetboilerplate.com\nSignalR/SignalR  Incredibly simple real-time web for .NET http://signalr.net\nabpframework/abp  Open Source Web Application Framework for ASP.NET Core https://abp.io/\nsta/websocket-sharp  A C# implementation of the WebSocket protocol client and server http://sta.github.io/websocket-sharp\n"});index.add({'id':424,'href':'/note-cs/docs/basic/pl/kotlin/appendix/attention/','title':"关注",'content':"关注 其他 octocat/Spoon-Knife  "});index.add({'id':425,'href':'/note-cs/docs/basic/pl/lua/appendix/attention/','title':"关注",'content':"关注 其他 octocat/Spoon-Knife  "});index.add({'id':426,'href':'/note-cs/docs/basic/pl/ruby/appendix/attention/','title':"关注",'content':"关注 其他 octocat/Spoon-Knife  "});index.add({'id':427,'href':'/note-cs/docs/basic/pl/swift/appendix/attention/','title':"关注",'content':"关注 其他 octocat/Spoon-Knife  "});index.add({'id':428,'href':'/note-cs/docs/direction/se/arch/scene/circuit-breaker/attention/','title':"关注",'content':"关注 其他 resilience4j/resilience4j ehcache/ehcache3  ehcache 是 ​​ 一个用 Java 实现的使用简单，高速，实现线程安全的缓存管理类库， ehcache 提供了用内存，磁盘文件存储，以及分布式存储方式等多种灵活的 cache 管理方案。 http://www.ehcache.org\nNetflix/Hystrix Hystrix 是 Netflix OSS 的一部分，是微服务领域的领先的熔断工具。Hystrix 可以被视为白盒监控工具，而 Istio 可以被视为黑盒监控工具，\nIstio 是无缝衔接服务，istio 可以在不更改应用程序代码的情况下配置和使用。Hystrix 的使用需要更改每个服务来引入 Hystrix libraries。\n"});index.add({'id':429,'href':'/note-cs/docs/basic/pl/cpp/basic/grammar/function/','title':"函数",'content':"函数 函数参数 参数默认值\n// 你可以为函数的参数指定默认值， // 默认参数必须放在所有的常规参数之后。 void doSomethingWithInts(int a, int b = 1, int c = 4) { } 函数重载 // C++支持函数重载，你可以定义一组名称相同而参数不同的函数 void print(char const* myString) { printf(\u0026#34;String %s\\n\u0026#34;, myString); } void print(int myInt) { printf(\u0026#34;My int is %d\u0026#34;, myInt); } int main() { print(\u0026#34;Hello\u0026#34;); // 解析为 void print(const char*)  print(15); // 解析为 void print(int) } "});index.add({'id':430,'href':'/note-cs/docs/direction/se/arch/principle/','title':"原则",'content':"架构设计原则 "});index.add({'id':431,'href':'/note-cs/docs/domain/cc/container/docker/command/','title':"命令",'content':"Docker 命令 docker ps docker ps vs docker container ls Management Commands vs Commands\nDocker 1.13+ introduced grouped commands to help organize a bunch of Docker commands. Both commands do the same thing.\nFor example docker container ls is the new way to do docker ps.\nSure it’s more typing, but it’s a lot more clear on what it does. Likewise, now you can run docker image ls, docker network ls or docker volume ls. There’s consistency across all of these commands.\n参考：\n Difference between docker ps vs docker container ls   docker attach vs docker exec $ sudo docker attach 665b4a1e17b6 #by ID or $ sudo docker attach loving_heisenberg #by Name $ root@665b4a1e17b6:/# $ sudo docker exec -i -t 665b4a1e17b6 /bin/bash #by ID or $ sudo docker exec -i -t loving_heisenberg /bin/bash #by Name $ root@665b4a1e17b6:/#  docker attach isn\u0026rsquo;t for running an extra thing in a container, it\u0026rsquo;s for attaching to the running process.  attach 只有一个实例   docker exec is specifically for running new things in a already started container, be it a shell or some other process.  exec 可以启动多个    参考：\n difference between docker attach and docker exec How to get bash or ssh into a running container in background mode?  "});index.add({'id':432,'href':'/note-cs/docs/basic/db/redis/basic/practice/','title':"实践",'content':"实践  注意点 用 SET, 别用 SETNX, SETEX, PSETEX Since the SET command options can replace SETNX, SETEX, PSETEX, it is possible that in future versions of Redis these three commands will be deprecated and finally removed.\n"});index.add({'id':433,'href':'/note-cs/docs/basic/pl/cpp/basic/practice/','title':"实践",'content':"实践 "});index.add({'id':434,'href':'/note-cs/docs/basic/pl/php/basic/practice/','title':"实践",'content':"实践 "});index.add({'id':435,'href':'/note-cs/docs/basic/pl/rust/basic/practice/','title':"实践",'content':"实践 "});index.add({'id':436,'href':'/note-cs/docs/direction/embedded/basic/practice/','title':"实践",'content':"实践 "});index.add({'id':437,'href':'/note-cs/docs/direction/security/basic/practice/','title':"实践",'content':"实践 "});index.add({'id':438,'href':'/note-cs/docs/domain/cc/knative/basic/practice/','title':"实践",'content':"实践 "});index.add({'id':439,'href':'/note-cs/docs/others/tool/dev/','title':"开发者工具",'content':"开发者工具 性能测试 sharkdp/hyperfine  A command-line benchmarking tool\n Linux sharkdp/fd  A simple, fast and user-friendly alternative to \u0026lsquo;find\u0026rsquo;\nbrew install fd "});index.add({'id':440,'href':'/note-cs/docs/basic/pl/csharp/basic/practice/quick/','title':"快速开始",'content':"快速开始 安装 Run apps - Runtime Build apps - SDK MacOS MacOS Linux Linux Windows Windows  .NET Core SDK 包括运行时。   "});index.add({'id':441,'href':'/note-cs/docs/basic/pl/cpp/basic/grammar/pointer/','title':"指针",'content':"C++ 指针 智能指针    指针类别 支持 备注     unique_ptr C++ 11 拥有独有对象所有权语义的智能指针   shared_ptr C++ 11 拥有共享对象所有权语义的智能指针   weak_ptr C++ 11 到 std::shared_ptr 所管理对象的弱引用   auto_ptr C++ 17 中移除 拥有严格对象所有权语义的智能指针    unique_ptr std::unique_ptr 是通过指针占有并管理另一对象，并在 unique_ptr 离开作用域时释放该对象的智能指针。在下列两者之一发生时用关联的删除器释放对象：\n 销毁了管理的 unique_ptr 对象 通过 operator= 或 reset () 赋值另一指针给管理的 unique_ptr 对象。  shared_ptr std::shared_ptr 是通过指针保持对象共享所有权的智能指针。多个 shared_ptr 对象可占有同一对象。下列情况之一出现时销毁对象并解分配其内存：\n 最后剩下的占有对象的 shared_ptr 被销毁； 最后剩下的占有对象的 shared_ptr 被通过 operator= 或 reset () 赋值为另一指针。  有两种方式创建 shared_ptr ：\nvoid main( ) { shared_ptr\u0026lt;int\u0026gt; sptr1( new int ); // 使用 make_shared 宏可以加速创建的过程  // 因为 shared_ptr 主动分配内存并且保存引用计数 (reference count)  shared_ptr\u0026lt;int\u0026gt; sptr2 = make_shared\u0026lt;int\u0026gt;(100); } 参考：C++ 智能指针 - 内存泄露的惨痛经历\n "});index.add({'id':442,'href':'/note-cs/docs/basic/pl/cpp/design/standard/','title':"标准",'content':"C++ 标准 参考：https://www.cnblogs.com/xuyaowen/p/c-cxx-standards.html\n"});index.add({'id':443,'href':'/note-cs/docs/direction/fe/frame/','title':"框架",'content':"框架 "});index.add({'id':444,'href':'/note-cs/docs/direction/se/arch/scene/circuit-breaker/','title':"熔断",'content':"熔断 断路器\n进入熔断状态后，后续对该服务接口的调用不再经过网络，直接执行本地的默认方法，达到服务降级的效果。\n参考 "});index.add({'id':445,'href':'/note-cs/docs/basic/pl/cpp/basic/version/','title':"版本",'content':"C++ 版本 "});index.add({'id':446,'href':'/note-cs/docs/domain/cc/container/docker/version/','title':"版本",'content':"Docker 版本 查看版本 docker -v docker --version #查看版本 docker-compose --version #查看版本 docker-machine --version #查看版本 docker version #查看client和server端版本，并可以查看是否开启体验功能  版本变更 最新版本 19.03 (2019-07-22) 18.09 (2018-11-08) Docker 合并版本号 New in 18.09 is an aligned release model for Docker Engine - Community and Docker Engine - Enterprise. The new versioning scheme is YY.MM.x where x is an incrementing patch version. The enterprise engine is a superset of the community engine. They will ship concurrently with the same x patch version based on the same code base.\n分拆 client 与 daemon The client and container runtime are now in separate packages from the daemon in Docker Engine 18.09. Users should install and update all three packages at the same time to get the latest patch releases.\nFor example, on Ubuntu:\nsudo apt install docker-ce docker-ce-cli containerd.io 18.06 (2018-07-18) 17.03 (2017-03-01) Docker CE 和 Docker EE（17.03） 新版本: Docker Engine release notes\n在 2017 年 3 月 2 日，docker 团队宣布企业版 Docker Enterprise Edition (EE) 发布。\n为了一致，免费的 Docker Engine 改名为 Docker Community Edition (CE), 并且采用基于时间的版本号方案。\n就在这一天，Docker EE 和 Docker CE 的 17.03 版本发布，这也是第一个采用新的版本号方案的版本。\nDocker CE/EE 每个季度发布一次 季度版本 , 也就是说每年会发布 4 个季度版本，17.03, 17.06, 17.09, 17.12 就是 2017 年的 4 个季度版本的版本号。\n同时 Docker CE 每个月还会发布一个 EDGE 版本，比如 17.04, 17.05, 17.07, 17.08, 17.10, 17.11。\nDocker CE 季度版本自发布后会有 4 个月的维护期。\n在基于时间的发布方案中，版本号格式为: YY.MM.，YY.MM 代表年月，patch 代表补丁号，从 0 开始，\n在季度版本 (如 17.03) 的维护期内，bug 修复相关的更新会以 patch 递增的方式发布，\n比如 17.03.0 -\u0026gt; 17.03.1 -\u0026gt; 17.03.2.\n1.13.1 之前 Docker Engine（0.1.0 到 1.13.1） Docker CE 在 1.13.1 及之前版本叫 Docker Engine 。\n版本说明参考：Docker Engine release notes (Previous versions)，\n可以看到 Docker Engine 的版本号范围: 0.1.0 (2013-03-23) ~ 1.13.1 (2017-02-08)\n"});index.add({'id':447,'href':'/note-cs/docs/domain/cc/container/docker/port/','title':"端口",'content':"Docker 端口 端口映射  -P（大写）：将容器内部开放的网络端口随机映射到宿主机的一个端口上 -p（小写）：指定要映射的端口，一个指定端口上只可以绑定一个容器  可以有多个 -p    端口映射格式 # 指定 ip、指定宿主机 port、指定容器 port ip:hostport:containerport # 指定 ip、未指定宿主机 port（随机）、指定容器 port ip::containerport # 未指定 ip、指定宿主机 port、指定容器 port hostport:containerport 端口映射命令 # 将容器暴露的所有端口，都随机映射到宿主机上（不推荐） docker run -P -it ubuntu /bin/bash # 将容器指定端口随机映射到宿主机一个随机端口 docker run -P 80 -it ubuntu /bin/bash # 将容器指定端口，随机映射到宿主机的指定 ip 的随机端口 # 有两个冒号 : docker run -P 192.168.0.100::80 -it ubuntu /bin/bash # 将容器指定端口指定映射到宿主机的指定端口上 docker run -p 8000:80 -it ubuntu /bin/bash # 将容器指定端口，指定映射到宿主机指定 ip 和端口 # 只能访问 192.168.0.100:8000， # 访问 127.0.0.1:8000 或 localhost:8000 都不行 docker run -p 192.168.0.100:8000:80 -it ubuntu /bin/bash 指定通信协议，比如 tcp、udp # tcp docker run -ti -d --name my-nginx5 -p 8099:80/tcp docker.io/nginx # udp docker run -ti -d --name my-nginx6 -p 192.168.10.214:8077:80/udp docker.io/nginx 查看映射端口配置 # 结果输出： 80/tcp -\u0026gt; 0.0.0.0:800 docker port container_ID # 容器 ID 通过宿主机的 iptables 进行 nat 转发 容器除了在启动时添加端口映射关系，还可以通过宿主机的 iptables 进行 nat 转发，将宿主机的端口映射到容器的内部端口上， 这种方式适用于容器启动时没有指定端口映射的情况。\n# 容器 my-nginx9 在启动时没有指定其内部的 80 端口映射到宿主机的端口上， # 所以默认是没法访问的 docker run -ti -d --name my-nginx9 docker.io/nginx # 首先获得容器的 ip 地址 docker inspect my-nginx9|grep IPAddress # 将容器的 80 端口映射到 dockers 宿主机的 9998 端口 iptables -t nat -A PREROUTING -p tcp -m tcp --dport 9998 -j DNAT --to-destination 172.17.0.9:80 iptables -t nat -A POSTROUTING -d 172.17.0.9/32 -p tcp -m tcp --sport 80 -j SNAT --to-source 192.16.10.214 iptables -t filter -A INPUT -p tcp -m state --state NEW -m tcp --dport 9998 -j ACCEPT # 保存以上 iptables 规则 iptables-save \u0026gt; /etc/sysconfig/iptables # 查看/etc/sysconfig/iptables 文件， # 注意下面两行有关 icmp-host-prohibited 的设置一定要注释掉，否则 nat 转发会失败 # -A INPUT -j REJECT --reject-with icmp-host-prohibited # -A FORWARD -j REJECT --reject-with icmp-host-prohibited # 最后重启 iptbales 服务 systemctl restart iptables # 查看 iptables 规则 iptables -L # 然后访问 http://192.168.10.214:9998/，就能转发访问到 my-nginx9 容器的 80 端口了  问答 启动 docker 容器时，有如下报错 /usr/bin/docker-current: Error response from daemon: driver failed programming external connectivity on endpoint my-nginx (db5a0edac68d1ea7ccaa3a1e0db31ebdf278076ef4851ee4250221af6167f9ac): (iptables failed: iptables --wait -t nat -A DOCKER -p tcp -d 0/0 --dport 8088 -j DNAT --to-destination 172.17.0.2:80 ! -i docker0: iptables: No chain/target/match by that name. 解决办法 1）不需要关闭防火墙 2）重启 docker 服务:systemctl restart docker 3）docker 服务重启后，所有容器都会关闭，应立即批量启动全部容器:docker start docker ps -a -q 启动的容器也会包括上面报错的容器，重启 docker 后，该容器就能正常启动和使用了。\nDocker 端口映射到宿主机后，外部无法访问对应宿主机端口 创建 docker 容器的时候,做了端口映射到宿主机, 防火墙已关闭, 但是外部始终无法访问宿主机端口? 这种情况基本就是因为宿主机没有开启 ip 转发功能，从而导致外部网络访问宿主机对应端口是没能转发到 Docker Container 所对应的端口上。\n解决办法: Linux 发行版默认情况下是不开启 ip 转发功能的。这是一个好的做法，因为大多数人是用不到 ip 转发的，但是如果架设一个 Linux 路由或者 VPN 服务我们就需要开启该服务了。\n在 Linux 中开启 ip 转发的内核参数为：net.ipv4.ip_forward，查看是否开启 ip 转发：\ncat /proc/sys/net/ipv4/ip_forward // 0：未开启，1：已开启 打开 ip 转发功能 临时打开 ip 转发功能!\n# echo 1 \u0026gt; /proc/sys/net/ipv4/ip_forward # sysctl -w net.ipv4.ip_forward=1 永久生效的 ip 转发\nvim /etc/sysctl.conf net.ipv4.ip_forward = 1 # 立即生效 sysctl -p /etc/sysctl.conf Linux 系统中也可以通过重启网卡来立即生效。\n修改 sysctl.conf 文件后的生效\n# CentOS 6 service network restart # CentOS 7 systemctl restart network 参考：\n Docker 容器内部端口映射到外部宿主机端口 - 运维笔记  "});index.add({'id':448,'href':'/note-cs/docs/basic/os/android/basic/spec/','title':"编程规范",'content':"编程规范 "});index.add({'id':449,'href':'/note-cs/docs/basic/os/ios/basic/spec/','title':"编程规范",'content':"编程规范 "});index.add({'id':450,'href':'/note-cs/docs/basic/os/macos/basic/spec/','title':"编程规范",'content':"编程规范 "});index.add({'id':451,'href':'/note-cs/docs/basic/os/unix/basic/spec/','title':"编程规范",'content':"编程规范 "});index.add({'id':452,'href':'/note-cs/docs/basic/os/windows/basic/spec/','title':"编程规范",'content':"编程规范 "});index.add({'id':453,'href':'/note-cs/docs/basic/pl/kotlin/basic/spec/','title':"编程规范",'content':"编程规范 "});index.add({'id':454,'href':'/note-cs/docs/basic/pl/lua/basic/spec/','title':"编程规范",'content':"编程规范 "});index.add({'id':455,'href':'/note-cs/docs/basic/pl/ruby/basic/spec/','title':"编程规范",'content':"编程规范 "});index.add({'id':456,'href':'/note-cs/docs/basic/pl/scala/basic/spec/','title':"编程规范",'content':"编程规范 "});index.add({'id':457,'href':'/note-cs/docs/basic/pl/swift/basic/spec/','title':"编程规范",'content':"编程规范 "});index.add({'id':458,'href':'/note-cs/docs/others/skill/onvif/discovery/','title':"设备发现",'content':"设备发现 我们传统的 Web Services 服务调用的模式都是这样的：客户端在设计时就预先知道目标服务的地址（IP 地址或者域名），客户端基于这个地址进行服务调用。\n那如果客户端预先不知道目标服务的地址该怎么办？\nWS-Discovery（全称为 Web Services Dynamic Discovery）标准就是用于解决该问题的，遵循该标准，客户端预先不知道目标服务地址的情况下，可以动态地探测到可用的目标服务，以便进行服务调用。这个过程就是「设备发现」的过程。\nWS-Discovery 模式 WS-Discovery 定义了两种模式：Ad hoc 模式和 Managed 模式。\nAd hoc 模式  Ad hoc 模式：客户端以多播 (multicast) 的形式往多播组 (multicast group) 发送一个 Probe（探测）消息搜寻目标服务，在该探测消息中，包含相应的搜寻条件。如果目标服务满足该条件，则直接将响应 ProbeMatch 消息（服务自身相关的信息，包括地址）回复给客户端。  Message Exchanges in an ad hoc mode. Message exchanges in an ad hoc mode in the presence of a Discovery Proxy. Managed 模式  Managed 模式：即代理模式。Ad hoc 模式有个局限性，只能局限于一个较小的网络。Managed 模式就是为了解决这个问题的，在 Managed 模式下，一个维护所有可用目标服务的中心发现代理（Discovery Proxy）被建立起来，客户端只需要将探测消息发送到该发现代理就可以得到相应的目标服务信息。  Message exchanges in a managed mode. 官方技术规范：http://docs.oasis-open.org/ws-dd/discovery/1.1/os/wsdd-discovery-1.1-spec-os.html\n 传输方式 TCP/IP 有三种传输方式：单播 (Unicast)、多播 (Multicast) 和广播 (Broadcast)，在 IPv6 领域还有另一种方式：任播 (Anycast)。\n单播 Unicast 单播 (Unicast)：一对一，双向通信，目的地址是对方主机地址。网络上绝大部分的数据都是以单播的形式传输的。如收发邮件、浏览网页等。\n多播 Multicast 多播 (Multicast)：也叫组播，一对多，单向通信，目的地址是多播地址，主机可以通过 IGMP 协议请求加入或退出某个多播组 (multicast group)，数据只会转发给有需要（已加入组）的主机，不影响其他不需要（未加入组）的主机。如网上视频会议、网上视频点播、IPTV 等。\n多播地址（Multicast Address）有很多，各个行业都不一样，IPC 摄像头用的是 239.255.255.250（端口 3702）。\n多播地址的范围和分类可以见官方 IANA（互联网地址分配机构） 的说明：IPv4 Multicast Address Space Registry。\nWS-Discovery 协议用到了多播。\n广播 Broadcast 广播 (Broadcast)：一对所有，单向通信，目的地址是广播地址，整个网络中所有主机均可以收到（不管你是否需要），如 ARP 地址解析、GARP 数据包等。广播会被限制在局域网范围内，禁止广播数据穿过路由器，防止广播数据影响大面积的主机。\n参考：单播、多播（组播）和广播的区别\n IPC 搜索实现 实现 socket 编程（UDP），通过 sendto 往多播地址发送探测消息（Probe），再使用 recvfrom 接收 IPC 的应答消息（ProbeMatch）\n组播 IP 地址 组播也是一种 IP 包，也有源 IP 地址，目的 IP 地址，\n 源 IP 地址为组播源的服务器 IP 地址， 目的地址为一个特殊的 IP 地址， 它位于 224.0.0.0 - 239.255.255.255 中，  由于 224.0.0.0/24 用于本地链路，即一跳的组播， 239.0.0.0/8 为私有组播地址， 所以实际的可用于在互联网上组播地址是 225.0.0.0/8 - 238.0.0.0/8    参考：\n 组播 IP 地址到底是谁的 IP？  "});index.add({'id':459,'href':'/note-cs/docs/direction/se/design-pattern/','title':"设计模式",'content':"设计模式 六大原则 单一职责原则 (SRP)  就一个类而言，应该仅有一个引起它变化的原因。  开闭原则 (OCP)  程序中的对象应该对扩展是开放的，对修改是封闭的。 当一个类实现了一个功能的时候，如果想要改变这个功能不是去修改代码，而是通过扩展的方式去实现。实现该类提供的接口方法，然后注入到该类中，通过这种方法去实现功能的改变。  里氏替换原则 (LSP)   所有引用基类的地方必须能透明的使用其子类对象。\n  只要父类能出现的地方子类就可以出现，替换为子类也不会产生任何的错误。\n  开闭原则一般可以通过里氏替换实现对扩展开放，对修改关闭的效果。\n  依赖倒置原则 (DIP)  模块间的依赖通过抽象发生，实现类之间不发生直接的依赖关系，其依赖关系是通过接口或抽象类产生的。 即依赖抽象，而不依赖具体的实现。  接口隔离原则 (ISP)  客户端不应该依赖它不需要的接口。 目的是解开系统的耦合，从而容易重构更改。  迪米特原则 (LOD)  一个对象应该对其他对象有最少的了解 一个类应该对自己需要耦合或调用的类知道的越少越好，类的内部如何实现与调用者或依赖者没关系。   常见设计模式 创建型 简单工厂模式 Simple Factory Pattern，又称为静态工厂方法 (Static Factory Method) 模式\n通过传入参数获取到对象，不关心创建对象的细节。\n// create 是静态方法，直接用类调用（不需要实例化） object1 = Factory.create(1); object2 = Factory.create(2); 优点\n 将创建实例的工作与使用实例的工作分开，使用者不必关心类对象如何创建，实现了解耦； 把初始化实例时的工作放到工厂里进行，使代码更容易维护。 更符合面向对象的原则 \u0026amp; 面向接口编程，而不是面向实现编程。  缺点\n 工厂类集中了所有实例（产品）的创建逻辑，一旦这个工厂不能正常工作，整个系统都会受到影响； 违背 “开放 - 关闭原则”，一旦添加新产品就不得不修改工厂类的逻辑，这样就会造成工厂逻辑过于复杂。 简单工厂模式由于使用了静态工厂方法，静态方法不能被继承和重写，会造成工厂角色无法形成基于继承的等级结构。 静态方法可以被继承  应用场景\n 客户如果只知道传入工厂类的参数，对于如何创建对象的逻辑不关心时； 当工厂类负责创建的对象（具体产品）比较少时。   工厂方法模式 又称工厂模式、多态工厂模式和虚拟构造器模式，\n通过定义工厂父类负责定义创建对象的公共接口，而子类则负责生成具体的对象。\n 每个产品的实例化，分别有一个具体工厂负责 符合开闭原则：对扩展开放，对修改关闭 添加一种产品，就添加一种实现该产品的工厂  缺点\n 每个工厂只能创建一类产品   抽象工厂模式 Abstract Factory Pattern\n提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类，具体的工厂负责实现具体的产品实例。\n解析\n 对产品进一步分类：抽象产品族 -\u0026gt; 抽象产品 -\u0026gt; 具体产品 每一个具体工厂，通过不同的工厂方法，可以实例化某 一类 产品族的多个具体产品  缺点\n 对于新的产品族符合开闭原则，对于新的产品不符合开闭原则，这一特性称为 开闭原则的倾斜性 。 抽象工厂接口中已经确定了可以被创建的产品集合，如果需要添加新产品，此时就必须去修改抽象工厂的接口，违反开闭原则。   建造者模式  抽象 Builder 规定要有哪些方法（用来创建产品） 具体 Builder 的方法可以实现不一样的内容，这些方法按顺序完成后，可以创建出来特定的产品 Director 规定创建产品的步骤；接收具体的 Builder 对象作为参数，按步骤调用 Builder 对象的各个方法，最后获取到创建的产品  解析\n 创建产品的步骤是一致的，所有步骤完成后，就创建出产品 不同 Builder 的同一步可以做不同的事情，最后创建出不同的产品  缺点\n 建造者模式所创建的产品一般具有较多的共同点，其组成部分相似；如果产品之间的差异性很大，则不适合使用建造者模式 如果产品的内部变化复杂，可能会导致需要定义很多具体建造者类来实现这种变化，导致系统变得很庞大   单例模式 实现方法  初始化时即创建单例  饿汉式 枚举类型   按需，延迟创建单例  懒汉式  基础实现 同步锁 双重检验锁   静态内部类实现    饿汉式（线程安全）  JVM 在类的初始化阶段 (即 在 Class 被加载后、被线程使用前)，会执行类的初始化 在执行类的初始化期间，JVM 会去获取一个锁，这个锁可以同步多个线程对同一个类的初始化  class Singleton { // 1. 加载该类时，单例就会自动被创建  private static Singleton ourInstance = new Singleton(); // 2. 构造函数设置为 私有权限，禁止他人创建实例  private Singleton() { } // 3. 通过调用静态方法获得创建的单例  public static Singleton newInstance() { return ourInstance; } } 应用场景\n 单例对象要求初始化速度快，占用内存小  枚举类（线程安全）  这是最简洁，最易用的单例实现方式   单元素的枚举类型已经成为实现 Singleton 的最佳方法 - 《Effective Java》\n public enum Singleton { // 定义 1 个枚举的元素，即为单例类的1个实例  INSTANCE; // 隐藏了 1 个空的、私有的 构造方法  // private Singleton () {} } // 获取单例的方式： Singleton singleton = Singleton.INSTANCE; 懒汉式 基础实现（线程不安全） class Singleton { // 1. 类加载时，先不自动创建单例，将单例的引用先赋值为 Null  private static Singleton ourInstance = null; // 2. 构造函数 设置为 私有权限  // 禁止他人创建实例  private Singleton() { } // 3. 需要时才手动调用 newInstance（） 创建 单例  public static Singleton newInstance() { // 先判断单例是否为空，以避免重复创建  if (ourInstance == null) { ourInstance = new Singleton(); } return ourInstance; } } 懒汉式 同步锁（线程安全） // 写法1 class Singleton { // 1. 类加载时，先不自动创建单例  // 即，将单例的引用先赋值为 Null  private static Singleton ourInstance = null； // 2. 构造函数 设置为 私有权限  // 原因：禁止他人创建实例  private Singleton() { } // 3. 加入同步锁  public static synchronized Singleton getInstance() { // 先判断单例是否为空，以避免重复创建  if (ourInstance == null) ourInstance = new Singleton(); return ourInstance; } } // 写法2 // 该写法的作用与上述写法作用相同，只是写法有所区别 class Singleton { private static Singleton instance = null; private Singleton() { } public static Singleton getInstance() { // 加入同步锁  synchronized (Singleton.class) { if (instance == null) instance = new Singleton(); } return instance; } } 缺点\n 每次访问都要进行线程同步（即 调用 synchronized 锁)，造成过多的同步开销（加锁 = 耗时、耗能） 实际上只需在第 1 次调用该方法时才需要同步，一旦单例创建成功后，就没必要进行同步  懒汉式 双重检验锁（线程安全） class Singleton { private static Singleton ourInstance = null； private Singleton() { } public static Singleton newInstance() { // 加入双重校验锁  // 校验锁1：第1个if  if (ourInstance == null) { // ①  synchronized (Singleton.class) { // ②  // 校验锁2：第2个 if  if (ourInstance == null) { ourInstance = new Singleton(); } } } return ourInstance; } } // 说明 // 校验锁1：第1个if // 作用：若单例已创建，则直接返回已创建的单例，无需再执行加锁操作 // 即直接跳到执行 return ourInstance  // 校验锁2：第2个 if // 作用：防止多次创建单例问题 // 原理 // 1. 线程A调用newInstance()，当运行到②位置时，此时线程B也调用了newInstance() // 2. 因线程A并没有执行instance = new Singleton();，此时instance仍为空，因此线程B能突破第1层 if // 判断，运行到①位置等待synchronized中的A线程执行完毕 // 3. 当线程A释放同步锁时，单例已创建，即instance已非空 // 4. 此时线程B 从①开始执行到位置②。此时第2层 if 判断 = 为空（单例已创建），因此也不会创建多余的实例 缺点\n 实现复杂（多种判断），易出错  静态内部类（线程安全） class Singleton { // 1. 创建静态内部类  private static class Singleton2 { // 在静态内部类里创建单例  private static Singleton ourInstance = new Singleton()； } // 私有构造函数  private Singleton() { } // 延迟加载、按需创建  public static Singleton newInstance() { return Singleton2.ourInstance; } } 调用过程说明：\n 外部调用类的 newInstance() 自动调用 Singleton2.ourInstance  此时单例类 Singleton2 得到初始化 而该类在装载 \u0026amp; 被初始化时，会初始化它的静态域，从而创建单例； 由于是静态域，因此只会 JVM 只会加载 1 遍，Java 虚拟机保证了线程安全性   最终只创建 1 个单例  缺点\n 单例类的职责过重，里面的代码可能会过于复杂，在一定程度上违背了 \u0026ldquo;单一职责原则\u0026rdquo; 如果实例化的对象长时间不被利用，会被系统认为是垃圾而被回收，这将导致对象状态的丢失   结构型 适配器模式 适配器 Adapter 继承自 Adaptee，同时又实现了目标(Target)接口。\npublic interface Target { // 这是源类Adapteee没有的方法  public void Request(); } public class Adaptee { public void SpecificRequest() { } } // 适配器Adapter继承自Adaptee，同时又实现了目标(Target)接口。 public class Adapter extends Adaptee implements Target { // 目标接口要求调用Request()这个方法名，但源类Adaptee没有方法Request()  // 因此适配器补充上这个方法名  // 但实际上Request()只是调用源类Adaptee的SpecificRequest()方法的内容  // 所以适配器只是将SpecificRequest()方法作了一层封装，封装成Target可以调用的Request()而已  @Override public void Request() { this.SpecificRequest(); } } public class AdapterPattern { public static void main(String[] args){ Target mAdapter = new Adapter()； mAdapter.Request(); } } 桥接模式  装饰模式 外观模式  适配器是将接口转换为不同接口 外观模式是提供一个统一的接口来简化接口  public class Facade Pattern { public static void main(String[] args) { //实例化电器类  SubSystemA_Light light = new SubSystemA_Light(); SubSystemB_Television television = new SubSystemB_Television(); SubSystemC_Aircondition aircondition = new SubSystemC_Aircondition(); //传参  Facade facade = new Facade(light,television,aircondition); //客户端直接与外观对象进行交互  facade.on; System.out.prinln(\u0026#34;可以看电视了\u0026#34;)； facade.off; System.out.prinln(\u0026#34;可以睡觉了\u0026#34;)； } }  享元模式  代理模式 public interface Subject { public void buyMac(); } public class RealSubject implement Subject { @Override public void buyMac() { System.out.println(\u0026#34;买一台Mac\u0026#34;); } } public class Proxy implements Subject { @Override public void buyMac { //引用并创建真实对象实例，即\u0026#34;我\u0026#34;  RealSubject realSubject = new RealSubject(); //调用真实对象的方法，进行代理购买Mac  realSubject.buyMac(); //代理对象额外做的操作  this.WrapMac(); } public void WrapMac() { System.out.println(\u0026#34;用盒子包装好Mac\u0026#34;); } } public class ProxyPattern { public static void main(String[] args) { Subject proxy = new Proxy(); proxy.buyMac(); } }  行为型 命令模式  中介者模式  观察者模式  状态模式  策略模式  设计模式（维基百科） 《设计模式》一书原先把设计模式分为创建型模式、结构型模式、行为型模式，把它们通过授权、聚合、诊断的概念来描述。若想更进一步了解关于面向对象设计的背景，参考接口模式、内聚性。若想更进一步了解关于面向对象编程的背景，参考继承，接口，多态。\n   模式名称 描述 《设计模式》中提及 《代码大全》中提及 [1]     创建型模式      抽象工厂模式 为一个产品族提供了统一的创建接口。当需要这个产品族的某一系列的时候，可以从抽象工厂中选出相应的系列创建一个具体的工厂类。 是 是   工厂方法模式 定义一个接口用于创建对象，但是让子类决定初始化哪个类。工厂方法把一个类的初始化下放到子类。 是 是   生成器模式 将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。 是 否   惰性初始模式 推迟对象的创建、数据的计算等需要耗费较多资源的操作，只有在第一次访问的时候才执行。 否 否   对象池模式 通过回收利用对象避免获取和释放资源所需的昂贵成本。 否 否   原型模式 用原型实例指定创建对象的种类，并且通过拷贝这些原型，创建新的对象。 是 否   单例模式 确保一个类只有一个实例，并提供对该实例的全局访问。 是 是   多例模式（英语：Multiton pattern） 确保一个类只有命名的实例，并提供对这些实例的全局访问。 否 否   资源获取为初始化 通过绑定到合适对象的生命周期来确保资源被适当地释放。 否 否   结构型模式      适配器模式 将某个类的接口转换成客户端期望的另一个接口表示。适配器模式可以消除由于接口不匹配所造成的类兼容性问题。 是 是   桥接模式 将一个抽象与实现解耦，以便两者可以独立的变化。 是 是   组合模式（英语：Composite pattern） 把多个对象组成树状结构来表示局部与整体，这样用户可以一样的对待单个对象和对象的组合。 是 是   修饰模式 向某个对象动态地添加更多的功能。修饰模式是除类继承外另一种扩展功能的方法。 是 是   外观模式 为子系统中的一组接口提供一个一致的界面， 外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。 是 是   享元 通过共享以便有效的支持大量小颗粒对象。 是 否   代理 为其他对象提供一个代理以控制对这个对象的访问。 是 否   行为型模式      黑板（英语：Blackboard (design pattern)） 广义的观察者在系统范围内交流信息，允许多位读者和写者。 否 否   责任链 为解除请求的发送者和接收者之间耦合，而使多个对象都有机会处理这个请求。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它。 是 否   命令 将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可取消的操作。 是 否   解释器（英语：Interpreter pattern） 给定一个语言，定义它的文法的一种表示，并定义一个解释器，该解释器使用该表示来解释语言中的句子。 是 否   迭代器 提供一种方法顺序访问一个聚合对象中各个元素，而又不需暴露该对象的内部表示。 是 是   中介者 包装了一系列对象相互作用的方式，使得这些对象不必相互明显作用，从而使它们可以松散偶合。当某些对象之间的作用发生改变时，不会立即影响其他的一些对象之间的作用，保证这些作用可以彼此独立的变化。 是 否   备忘录（英语：Memento pattern） 备忘录对象是一个用来存储另外一个对象内部状态的快照的对象。备忘录模式的用意是在不破坏封装的条件下，将一个对象的状态捉住，并外部化，存储起来，从而可以在将来合适的时候把这个对象还原到存储起来的状态。 是 否   空对象 通过提供默认对象来避免空引用。 否 是   观察者模式 在对象间定义一个一对多的联系性，由此当一个对象改变了状态，所有其他相关的对象会被通知并且自动刷新。 是 是   规格（英语：Specification pattern） 以布尔形式表示的可重绑定的商业逻辑。 否 否   状态（英语：State pattern） 让一个对象在其内部状态改变的时候，其行为也随之改变。状态模式需要对每一个系统可能获取的状态创立一个状态类的子类。当系统的状态变化时，系统便改变所选的子类。 是 否   策略 定义一个算法的系列，将其各个分装，并且使他们有交互性。策略模式使得算法在用户使用的时候能独立的改变。 是 是   模板方法 模板方法模式准备一个抽象类，将部分逻辑以具体方法及具体构造子类的形式实现，然后声明一些抽象方法来迫使子类实现剩余的逻辑。不同的子类可以以不同的方式实现这些抽象方法，从而对剩余的逻辑有不同的实现。先构建一个顶级逻辑框架，而将逻辑的细节留给具体的子类去实现。 是 是   访问者 封装一些施加于某种数据结构元素之上的操作。一旦这些操作需要修改，接受这个操作的数据结构可以保持不变。访问者模式适用于数据结构相对未定的系统，它把数据结构和作用于结构上的操作之间的耦合解脱开，使得操作集合可以相对自由的演化。 是 否   并发型模式      主动对象  否 否   阻碍  否 否   双重检查锁定  否 否   守卫  否 否   领导者 / 追随者  否 否   监测对象模式  否 否   读写锁  否 否   调度  否 否   线程池模式  否 否   线程特定存储  否 否   反应器  否 否    教程 综合 DovAmir/awesome-design-patterns  kamranahmedse/design-patterns-for-humans  me115/design_patterns  图说设计模式\nPHP domnikl/DesignPatternsPHP  Java iluwatar/java-design-patterns  Go tmrts/go-patterns  senghoo/golang-design-pattern  Python faif/python-patterns  "});index.add({'id':460,'href':'/note-cs/docs/basic/pl/csharp/basic/grammar/','title':"语法",'content':"语法 "});index.add({'id':461,'href':'/note-cs/docs/basic/pl/kotlin/basic/grammar/','title':"语法",'content':"语法 "});index.add({'id':462,'href':'/note-cs/docs/basic/pl/lua/basic/grammar/','title':"语法",'content':"语法 "});index.add({'id':463,'href':'/note-cs/docs/basic/pl/ruby/basic/grammar/','title':"语法",'content':"语法 "});index.add({'id':464,'href':'/note-cs/docs/basic/pl/swift/basic/grammar/','title':"语法",'content':"语法 "});index.add({'id':465,'href':'/note-cs/docs/domain/cc/edge/','title':"边缘计算",'content':"边缘计算 边缘计算的业务本质是云计算在数据中心之外边缘节点的延伸和演进， 以“边云协同”和“边缘智能”为核心能力发展方向；\n软件平台需要考虑导入云理念、云架构、云技术，提供端到端实时和协同式智能、可信赖、可动态重置等能力；\n硬件平台需要考虑异构计算能力，如鲲鹏、昇腾、ARM、X86、GPU、NPU、FPGA 等。\n边缘计算系统的落地形态 边缘计算产业联盟（ECC）将边缘计算系统的落地形态归纳为以下三种：\n 云边缘 边缘云 边缘网关  云边缘 云边缘形态的边缘计算，是云服务在边缘侧的延伸，逻辑上仍是云服务， 主要的能力提供依赖于云服务或需要与云服务紧密协同。\n主要应用在公有云场景，如华为云提供的 IEF 解决方案、AWS 提供的 Greengrass 解决方案等均属于此类。\nIntelligent EdgeFabric 智能边缘平台\n边缘云 边缘云形态的边缘计算，是在边缘侧构建中小规模云服务能力， 边缘服务能力主要由边缘云提供；\n边缘云的管理调度能力由部署在中心云的系统完成。 如运营商 MEC、CDN 等均属于此类。\n边缘网关 边缘网关形态的边缘计算，以云化技术与能力重构原有嵌入式网关系统， 边缘网关在边缘侧提供协议/接口转换、边缘计算等能力， 部署在云侧的控制器提供边缘节点的资源调度、应用管理与业务编排等能力。\n边缘网关主要应用在工业联网和车联网等场景中。\n 边缘计算的 CROSS 价值 Connection 联接的海量(Connection)\n网络是系统互联与数据采集传输的基石。 伴随联接设备数量的剧增，网络灵活扩展、低成本运维和可靠性保障面临巨大挑战。\nReal-time 业务的实时性(Real-time)\n工业系统检测、控制、执行，新兴的 VR/AR 等应用的实时性高， 部分场景实时性要求在 10ms 以内甚至更低，如果数据分析和处理全部在云端实现，难以满足业务的实时性要求，严重影响终端客户的业务体验。\nOptimization 数据的优化(Optimization)\n当前工业现场与物联网末端存在大量的多样化异构数据，需要通过数据优化实现数据的聚合、数据的统一呈现与开放，以灵活高效地服务于边缘应用的智能。\nSmart 应用的智能性(Smart)\n业务流程优化、运维自动化与业务创新驱动应用走向智能，边缘侧智能能够带来显著的效率与成本优势。\nSecurity 安全与隐私保护(Security)\n安全跨越云计算和边缘计算之间的纵深，需要实施端到端防护。 网络边缘侧由于更贴近万物互联的设备，访问控制与威胁防护的广度和难度因此大幅提升。 边缘侧安全主要包含设备安全、网络安全、数据安全与应用安全。 此外，关键数据的完整性、保密性，大量生产或人身隐私数据的保护也是安全领域需要重点关注的内容。\n 边缘计算在网络中的位置 为实现边缘计算，需要在更底层的网络节点增加计算和转发能力，运营商组网结构将逐步演进，边缘计算能力持续提升。\n边缘计算节点部署方式  MEC 网络的四大挑战 现场 MEC 现场 MEC（部署在企业园区）是 5G MEC 带来的一个新应用场景\n5G MEC 位于企业园区机房里面，一般为运营商代建和代维。\n企业借助 5G MEC 系统进行生产控制、远程监控、物流管理和智慧安防等生产活动。\n很多生产业务对延迟有严格要求， 如远程塔吊控制信息流的端到端延迟要小于 18ms， 即生产设备（塔吊等）通过无线基站，IP RAN 网络，5G MEC 系统到企业应用系统（远程控制）的端到端通信要保证低延迟。 对运营商网络的要求是，企业园区内的 5G 基站和 5G MEC 系统之间的网络，以及 5G MEC 到企业网的连接都要保证低时延。\n现场 MEC 场景对运营商的接入网提出了新的挑战，需要接入网提供低延迟 SLA 保证和数据不出园区。\n5G 核心网下移 UPF 随 MEC 下移，带动 UPF 相关业务端口下移（如 N4，N6，N9, 5GC OAM 等接口）到 5G 移动承载网。\n4G 核心网是集中部署在省或国家骨干网上， 4G 核心网网元间接口是由骨干网提供 VPN 来互通的，和 4G 移动承载网（IP RAN）没有关系。\n5G UPF 业务接口对外可靠通信是 5G MEC 对移动承载网（IP RAN）的新要求。 有些运营商采用 5GC 控制面集中到大区域的部署方案，这导致一些业务接口（如 N4 和 5GC OAM 接口）通信需要跨越移动承载网和骨干网两个网段。 由于 UPF 的大量分布式部署，以及 UPF 业务接口互通关系的复杂性， 增加了 5G 移动承载网的业务流量模型复杂度和多点通信的网络覆盖范围（基本上是全网范围）， 在 4G 时代的 L2+L3 网络设计是在汇聚层以上提供多点通信能力的。 同时，一些业务接口有传输延迟要求，如 N6，N9 这样的数据接口，这需要承载网提供 SLA 保证。\n5G 核心网下移使无线核心网承载从骨干网延伸到移动承载网， 对运营商 5G MEC 移动承载网络提出了支持复杂多点通信和 SLA 保证的新挑战。\n边云协同 5G MEC 包括下沉的 5G 核心网网元 UPF，和（云）计算应用。\n5G MEC 的 UPF 需要和中心云里 5G 核心网的控制面和管理应用系统通信\nMEC 的无缝 FMC 业务 MEC 连接设备和应用系统的接入方式是多样的，可以是 5G 接入，也可以是固网接入（包括 xPON，专线，WiFi 等），通信目标是连接所有相关应用部件，共同提供一个完整的 MEC 应用，即提供无缝的 FMC（固移融合）业务应用。\nMEC 的接入网就可能包括移动承载网和固定承载网，需要连接两个城域网网络平面。\n同时，MEC 和中心云（5GC，运营商云，第三方云）及相关业务云（可能部署在固网 MAN 上）间的通信， 有些会通过移动承载网，有些会通过固定承载网。 MEC 网络不局限于移动承载网，MEC 网络连接可能会涉及移动承载和固网承载两个城域网平面，以及 IP 骨干网。\nMEC 对网络提出了 FMC 通信新挑战，特别对于拥有移动承载城域网和固定承载城域网双平面的运营商， 在网络架构和网络互通方面都提出了新挑战。 中国三大运营商都有两个城域网平面。\n 运营商网络的边缘计算破局关键点 ECNI 的边缘计算网络模型 边缘计算产业联盟 ECC 在 2019 年和网络 5.0 联合成立了边缘计算网络基础设施联合工作组（ECNI）， 是业界第一个聚焦边缘计算网络的产业组织。\n2019 年 11 月，ECNI 发布了“运营商边缘计算网络技术白皮书”，是业界首个有关运营商边缘计算网络的白皮书。 此白皮书提出了一个新的边缘计算网络抽象模型， 将边缘计算网络分为三个逻辑网段来描述\n  ECA（Edge Computing Access，边缘计算接入网络）\n从用户系统到 MEC 所经过的网络基础设施；\n  ECN（Edge Computing Network，边缘计算内部网络）\nMEC 内部网络基础设施\n  ECI（Edge Computing Interconnect，边缘计算互联网络）\n从 MEC 到云计算系统（如公有云、私有云、通信云、用户自建云等）、其它 MEC、各类数据中心所经过的网络基础设施；\n  MEC 在物理网络中的位置不同，ECA 和 ECI 在物理网络中的映射也不一样；ECI 可能跨运营商多个网段。因此，ECA/ECN/ECI 网络模式能更好地描述复杂的 MEC 网络和多样性物理网络间的关系，本文后续都会采用该抽象模型来表述 MEC 网络问题。\nECA：最短路径 运营商应该为从基站到 MEC UPF 的 N3 业务流提供最短传输路径，特别是在现场 MEC 场景， N3 业务流应该通过在园区里的移动承载网路由器直接把业务流转发给 MEC UPF，而不应该让 N3 业务流在运营商的网络中绕行。\nECA 和 ECI：低延迟切片 ECA 切片：完整的接入网切片系统包括无线基站、移动承载网（基站到 EC 间）和 UPF 系统，即企业业务流到 MEC 所经过的所有网元，涉及 5G 无线网、网络和 5G 核心网。ECA 切片是基站到 MEC 间的 IP 网络切片。\nECI 切片：MEC 系统和企业网、中心云和其它 MEC 系统间，由于业务需要保证 SLA 和安全可靠，需要切片网络来进行互连，有可能跨多网段。\nECI：灵活多点通信 ECI 网络需要支持 5G MEC 和 5G 核心网（N4，OAM）、其它 MEC 系统（N6，N9）、互联网出口（N6）、锚点 UPF（N9）、运营商云、企业网、第三方云（OTT）等进行业务通信。\nECN：集成网络架构 运营商网和企业网：MEC 安全和互通 运营商角度，5G MEC 里面有非运营商的应用和网络连接，如 MEC 直接和企业网互通，不是电信安全域；同时 MEC 改变了原来移动承载网 IP RAN 的业务承载封闭性。企业角度，业务数据和业务应用经过外网和外部 IT 系统，即经过了企业非安全区，并且企业网增加了和运营商网络的互通点。\n网络支持云边协同 5G MEC 网络需要支持 5G UPF 的自动部署和在线扩缩容，比如 UPF VNF 增加 VM 数量来提高性能，MEC 网络能动态接受业务需求，自动下发网络配置，保证 UPF 的快速在线扩容，即网络支持云边协同。在 MEP 平台上部署的边缘计算应用，如果和中心云相关，也需要边云协同通信。另外，按业务要求快速打通云边间 VPN 通道是支持云边协同的基本通信需求。\n 参考  [pdf]5g mec ip 网络白皮书 - huawei carrier  "});index.add({'id':466,'href':'/note-cs/docs/others/skill/communication/','title':"通信技术",'content':"通信技术 通信技术发展 1G 现代移动通信的发展史可追溯到上个世纪 70 年代，贝尔实验室突破性的提出了蜂窝网络概念。\n所谓蜂窝网络，就是将网络划分为若干个相邻的小区，整体形状酷似蜂窝，以实现频率复用，提升系统容量。\n1G 时代作为移动通信开天辟地的时代，群雄逐鹿，山头林立，通信标准也是五花八门。\n尽管 1G 标准各式各样，但 1G 时代的王者非摩托罗拉莫属。\n摩托罗拉不仅发明了第一步模拟移动电话大哥大，而且还是 AMPS 系统的主要设备供应商。\n2G：GSM 与 CDMA 之争 1G 时代，以 AMPS 和 TACS 为代表的模拟移动通信系统取得了巨大成功， 但由于采用落后的模拟和频分复用（FDMA）技术，存在容量有限、系统太多、系统不兼容、通话质量差、易被窃听、设备昂贵、无法全球漫游等众多缺点。\n随着人们对移动通信的要求越来越高，业界提出向 2G 数字时代发展，以代替 1G 模拟通信。\n2G 时代主要采用数字时分多址（TDMA）和码分多址（CDMA）两种技术，分别对应 GSM 和 CDMA 系统，这是一场由美国和欧洲为代表的两大利益集团之间的竞争。\n如上所述，以 AMPS 和 TACS 为代表 1G 时代几乎被美国垄断，也意味着美国掌握了标准话语权和产业主动权。\n进入 2G 时代，欧洲不甘落后于美国，考虑到欧盟国家太小，单打独斗难以与美国抗衡，于是吸取了 1G 时代各自为政的失败教训，于是欧盟联合起来成立了 GSM，以快速形成规模向全球推广，在 2G 时代占据主导优势。\n2G 时代，欧洲 GSM 快速领先，促进了欧洲无线产业的崛起，也为欧洲带来了显著的经济利益。诺基亚和爱立信是首当其冲的受益者，在 2G 时代飞速发展成为全球领先的通信设备商和手机厂商。1993 年，爱立信占全球数字蜂窝设备市场的 60％，诺基亚一跃成为全球第二大手机供应商。2000 年，诺基亚的出口额占芬兰商品和服务总额的 24％。\n美国输了，输掉的不是技术，而是速度与规模，也输掉了一个时代。\n这也间接影响了摩托罗拉的竞争力，当数字移动电话渐渐取代模拟移动电话之时，摩托罗拉同样错估了模拟手机的寿命，也错过了 2G 数字时代。\n1997 年，摩托罗拉终于走下神坛，其全球移动电话市场份额从 1997 年的 50% 暴跌到 17%。持续了 20 年辉煌的摩托罗拉终于被来自欧洲的诺基亚击垮。\n时分多址（TDMA） 欧洲 - 时分多址（TDMA） - GSM\n码分多址（CDMA） 美国 - 码分多址（CDMA） - CDMA\nCDMA，即码分多址，它通过不同的扩频码来实现多用户在同一时间同一频率上共享。从技术上讲，CDMA 比 TDMA 更具优势。\n3G：鼎足三分 3G 时代主要有 WCDMA、CDMA2000、TD-SCDMA 三种标准。\n 欧洲 + 日本 - 3GPP - WCDMA 美国 + 韩国 - 3GPP2 - CDMA2000 中国 - TD-SCDMA  欧洲与日本等原推行 GSM 标准的国家联合起来成立了 3GPP 组织 (3rd Generation Partnership Project)，负责制定全球第三代通信标准。\n随后，3GPP 小心翼翼地参考 CDMA 技术，以尽量绕过高通的专利，开发出了原理类似的 WCDMA。\n高通也赶紧不落人后地与韩国联合组成 3GPP2 (3rd Generation Partnership Project 2) 与 3GPP 抗衡，推出了 CDMA2000。\n既然你们都有一套自己的标准，当然，咱们中国也不能落于人后，也搞了一个 TD-SCDMA。\n也就是，3G 时代形成了欧、美、中三足鼎立的格局，谁也不服谁。\n但真正的赢家是谁？从某种角度讲，最后的赢家既不是欧洲，也不是美国，而是视野之外的日本。\n4G：LTE 一统江湖 WiMax 是基于 IEEE 802.16 标准集的一系列无线通信标准。WiMax 于 2001 年 6 月成立，旨在促进该标准的一致性和互操作性。\nWiMax 采用 OFDM+MIMO 技术，解决了多径干扰，提升了频谱效率，大幅地增加系统吞吐量及传送距离。今天的 4G LTE 也采用了这两大关键技术。\n自 3GPP 首版 4G LTE 标准于 2008 年 12 月完成且于 2009 年 12 月全球首商用成功后，全球多数移动运营商果断的选择了不投资 WiMax，而是静候 LTE 的到来。\nWiMax 失败了，尽管超前于 LTE，但超前一步的往往是烈士。\nLTE LTE 的全称叫 Long Term Evolution，即长期演进，我不知道当时为何取这样的名字，但今天看来，仿佛是 3GPP 在向 WiMax 联盟隔空喊话：喂，兄弟，我们是长期演进的哦，你行不？\n于是乎，自 2008 年 12 月前后，已感到前途无望的 WiMax 阵营们纷纷退出，开始转向 LTE。\n经历了无数波折，在 4G 时代，LTE 标准终于一统江湖。\n 5G 5G 的优势：\n 速率方面：从 4G 的 100Mbps 为单位，5G 可高达 10Gps，比 4G 快达 100 倍，轻松看 3D 影片或 4K 电影； 容量与能耗方面：为了物联网 (IoT)、智慧家庭等应用，5G 网络将能容纳更多设备连接、同时维持低功耗的续航能力； 低时延方面：工业 4.0 智慧工厂、车联网、远程医疗等应用，都必须超低时延。  回顾移动通信的发展史，从生态规模来看，美国在 1G 时代领先，但从 2G 到 3G，美国整整落后了两个时代，4G 赶超机会本来渺茫，但随着智能手机的横空出世，美国迎来了弯道超车的转折点。\n苹果推出了 IOS，Google 推出了安卓操作系统，如今全球大部分智能手机都运行于 iOS 和安卓系统。\niOS 和安卓系统打败了 2G 时代的诺基亚，也彻底打败了 3G 时代的日本 i-mode 模式。诺基亚手机没落了，日本通讯产业链全线败退，NEC、东芝、三洋退出手机领域，索尼、夏普、京瓷、松下市场份额大幅下滑，留给 NEC 和富士通等电信设备的市场也只是极少的份额。\n美国花了两个时代一路追赶，有过深刻的教训，也尝到了甜头，现在 5G 来了，当然不甘错过这次大好机遇，他们已多次表示要争夺全球 5G 领导地位。\n美国认为，5G 时代是建立在无线基础设施上的一次史无前例的创新时代，5G 将连接工厂、汽车、无人机等万物，并在万物互联的基础上加速机器学习和人工智能部署。谁能领导 5G，谁就站在了未来的信息时代的制高点。\n然鹅，朗讯、摩托罗拉、北电等美系设备商已全军覆灭，美国拿什么领导 5G？\n华为在 LTE 市场份额上早已全球第一，中国企业早已加大研发 5G。美国在逐渐掉队，而中国正在引领 5G。\n尽管美国也有高通、思科等通信巨头，但他们只提供芯片和路由器，并不提供无线设备。\n6G 参考：\n IM 开发者的零基础通信技术入门 (五)：1G 到 5G，30 年移动通信技术演进史  "});index.add({'id':467,'href':'/note-cs/docs/course/basic/pl/gobyexample/','title':"通过例子学 Golang",'content':"通过例子学 Golang mmcgrana/gobyexample 点击阅读：Go by Example\n中文翻译 gobyexample-cn/gobyexample 点击阅读：通过例子学 Golang\n学习进度  Hello World 值 变量 常量 For 循环 If/Else 分支 Switch 分支结构 数组 切片 Map Range 遍历 函数 多返回值 变参函数 闭包 递归 指针 结构体 方法 接口 错误处理 协程 通道 通道缓冲 通道同步 通道方向 通道选择器 超时处理 非阻塞通道操作 通道的关闭 通道遍历 Timer Ticker 工作池 WaitGroup 速率限制 原子计数器 互斥锁 状态协程 排序 使用函数自定义排序 Panic Defer 组合函数 字符串函数 字符串格式化 正则表达式 JSON XML 时间 时间戳 时间的格式化和解析 随机数 数字解析 URL 解析 SHA1 哈希 Base64 编码 读文件 写文件 行过滤器 文件路径 目录 临时文件和目录 单元测试 命令行参数 命令行标志 命令行子命令 环境变量 HTTP 客户端 HTTP 服务端 Context 生成进程 执行进程 信号 退出  "});index.add({'id':468,'href':'/note-cs/docs/domain/cc/container/docker/image/','title':"镜像",'content':"Docker 镜像 dangling 镜像 未被任何镜像引用的镜像\n docker push 上传到 私有仓库 docker build -t human-attribute:20200415_1585818439123 . docker tag human-attribute:20200415_1585818439123 ote-harbor.baidu.com/aiedge/human-attribute:20200415_1585818439123 docker push ote-harbor.baidu.com/aiedge/human-attribute:20200415_1585818439123 "});index.add({'id':469,'href':'/note-cs/docs/domain/cc/knative/','title':"Knative",'content':"Knative "});index.add({'id':470,'href':'/note-cs/docs/domain/cc/others/paas/','title':"PaaS",'content':"PaaS "});index.add({'id':471,'href':'/note-cs/docs/domain/cc/container/docker/container/','title':"容器",'content':"Docker 容器 "});index.add({'id':472,'href':'/note-cs/docs/domain/cc/others/saas/','title':"SaaS",'content':"SaaS "});index.add({'id':473,'href':'/note-cs/docs/domain/cc/container/docker/repository/','title':"仓库",'content':"Docker 仓库 "});index.add({'id':474,'href':'/note-cs/docs/basic/pl/cpp/','title':"C++",'content':"C++ 学习笔记 "});index.add({'id':475,'href':'/note-cs/docs/domain/cc/others/paas/gae/','title':"GAE",'content':"Google App Engine "});index.add({'id':476,'href':'/note-cs/docs/book/basic/pl/go-advanced-programming/','title':"Go 语言高级编程",'content':"Go 语言实战 \n作者 柴树杉 国内第一批的 Go 语言爱好者，Go 语言代码贡献者，CGO 资深用户。同时对 WebAssembly 技术有一定研究，著有《WebAssembly 标准入门》。Github 账号为 chai2010。\n曹春晖 在 Web 领域工作多年，开源爱好者。对大型网站系统的架构和相关工具的实现很感兴趣，并且有一些研究成果。目前在滴滴平台技术部工作。\n 学习参考 "});index.add({'id':477,'href':'/note-cs/docs/direction/be/proxy/haproxy/','title':"HAProxy",'content':"HAProxy "});index.add({'id':478,'href':'/note-cs/docs/others/tool/dev/package-manager/brew/','title':"homebrew",'content':"Homebrew tap brew tap 可以为 brew 的软件的 跟踪，更新，安装添加更多的的 tap formulae\n如果你在核心仓库没有找到你需要的软件，那么你就需要安装第三方的仓库去安装你需要的软件\ntap 命令的仓库源默认来至于 Github，但是这个命令也不限制于这一个地方\nbrew tap 没有参数会自动更新已经存在的 tap 并列出当前已经 tapped 的仓库\n# URL 默认是 https://github.com/user/homebrew-repo brew tap \u0026lt;user\u0026gt;/\u0026lt;repo\u0026gt; brew tap \u0026lt;user\u0026gt;/\u0026lt;homebrew-repo\u0026gt; # URL 可以是任何位置，任何协议 brew tap \u0026lt;user\u0026gt;/\u0026lt;repo\u0026gt; URL homebrew/core 默认是最高优先级\n可以使用 brew tap-pin username/repo 使这个仓库优先级高于 core\n使用 brew-tap-unpin username/repo 取消\n当你使用 brew install foo 这个命令时，brew 将按照下面的顺序去查找哪个 formula(tap) 将被使用:\n pinned taps core formulae other taps   镜像加速 清华大学镜像 替换现有上游\n# brew 程序本身，Homebrew/Linuxbrew 相同 git -C \u0026#34;$(brew --repo)\u0026#34; remote set-url origin https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/brew.git # 以下针对 mac OS 系统上的 Homebrew git -C \u0026#34;$(brew --repo homebrew/core)\u0026#34; remote set-url origin https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/homebrew-core.git git -C \u0026#34;$(brew --repo homebrew/cask)\u0026#34; remote set-url origin https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/homebrew-cask.git git -C \u0026#34;$(brew --repo homebrew/cask-fonts)\u0026#34; remote set-url origin https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/homebrew-cask-fonts.git git -C \u0026#34;$(brew --repo homebrew/cask-drivers)\u0026#34; remote set-url origin https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/homebrew-cask-drivers.git # 以下针对 Linux 系统上的 Linuxbrew git -C \u0026#34;$(brew --repo homebrew/core)\u0026#34; remote set-url origin https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/linuxbrew-core.git # 更换后测试工作是否正常 brew update  参考  Homebrew 和 Fink、MacPort 相比有什么优势？ 解决 Homebrew 下载更新极慢的问题  "});index.add({'id':479,'href':'/note-cs/docs/direction/be/microservices/rpc/spring-cloud/','title':"Spring Cloud",'content':"Spring Cloud TarsCloud/Tars 国外 Pivotal 公司 2014 年对外开源的 RPC 框架，仅支持 Java 语言。\n Eureka：各个服务启动时，Eureka Client 都会将服务注册到 Eureka Server，并且 Eureka Client 还可以反过来从 Eureka Server 拉取注册表，从而知道其他服务在哪里 Ribbon：服务间发起请求的时候，基于 Ribbon 做负载均衡，从一个服务的多台机器中选择一台 Feign：基于 Feign 的动态代理机制，根据注解和选择的机器，拼接请求 URL 地址，发起请求 Hystrix：发起请求是通过 Hystrix 的线程池来走的，不同的服务走不同的线程池，实现了不同服务调用的隔离，避免了服务雪崩的问题 Zuul：如果前端、移动端要调用后端系统，统一从 Zuul 网关进入，由 Zuul 网关转发请求给对应的服务  Eureka Eureka 是微服务架构中的注册中心，专门负责服务的注册与发现。\n Eureka Client：负责将这个服务的信息注册到 Eureka Server 中 Eureka Server：注册中心，里面有一个注册表，保存了各个服务所在的机器和端口号  Feign Feign 的一个关键机制就是使用了动态代理。\nRibbon 负载均衡\nRibbon 的负载均衡默认使用的最经典的 Round Robin 轮询算法\nHystrix Hystrix 是隔离、熔断以及降级的一个框架。\nHystrix 会搞很多个小小的线程池， 比如订单服务请求库存服务是一个线程池，请求仓储服务是一个线程池，请求积分服务是一个线程池。 每个线程池里的线程就仅仅用于请求那个服务。\n解决服务雪崩：\n  熔断\n比如在 5 分钟内请求积分服务直接就返回了，不要去走网络请求卡住几秒钟。 这个过程，就是所谓的熔断！\n  降级\n每次调用积分服务，你就在数据库里记录一条消息，说给某某用户增加了多少积分，因为积分服务挂了，导致没增加成功！这样等积分服务恢复了，你可以根据这些记录手工加一下积分。 这个过程，就是所谓的降级。\n  Zuul 微服务网关\n可以做统一的降级、限流、认证授权、安全等等\n"});index.add({'id':480,'href':'/note-cs/docs/others/tool/dev/package-manager/','title':"包管理工具",'content':"包管理工具 Linux Ubuntu apt sudo apt install # download .deb package sudo dpkg -i fd_8.0.0_amd64.deb # adapt version number and architecture Debian apt-get sudo apt-get install Fedora dnf dnf install dnf copr dnf copr enable keefle/fd dnf install fd Alpine Linux apk apk add Arch Linux pacman pacman -S Gentoo Linux emerge emerge -av openSUSE Linux zypper zypper in Void Linux xbps-install xbps-install -S FreeBSD pkg pkg install  Mac Homebrew MacPorts  Windows Scoop Chocolatey 其他 NixOS / via Nix Nix package manager nix-env -i Node.js NPM # On linux and macOS npm install -g Rust cargo cargo install "});index.add({'id':481,'href':'/note-cs/docs/others/tool/dev/hhkb/','title':"HHKB",'content':"HHKB 键盘 Happy Hacking Keyboard\n使用 方向键 右侧的 Fn 键 + [ / ; '\n"});index.add({'id':482,'href':'/note-cs/docs/basic/os/','title':"1.2 操作系统",'content':"操作系统 "});index.add({'id':483,'href':'/note-cs/docs/direction/fe/','title':"2.2 前端",'content':"前端开发 "});index.add({'id':484,'href':'/note-cs/docs/domain/bigdata/','title':"3.2 大数据",'content':"大数据 "});index.add({'id':485,'href':'/note-cs/docs/others/skill/','title':"4.2 技能树",'content':"技能树 "});index.add({'id':486,'href':'/note-cs/docs/others/skill/communication/4g/','title':"4G",'content':"4G "});index.add({'id':487,'href':'/note-cs/docs/book/basic/os/','title':"5.1.2 操作系统",'content':"操作系统 "});index.add({'id':488,'href':'/note-cs/docs/book/be/','title':"5.2 后端",'content':"后端 "});index.add({'id':489,'href':'/note-cs/docs/others/skill/communication/5g/','title':"5G",'content':"5G 5G 速度 世界上最快的 4G 网速（挪威，63.13Mbps）\n最快的宽带网速（新加坡，189Mbps）\n2019 年 1 月 24 日，华为发布业界标杆 5G 多模终端芯片巴龙 5000\n在 5G 峰值下载速率是 4G LTE 可体验速率的 10 倍\n5G 应用场景 国际电信联盟无线电通信局（ITU-R）定义了 5G 的三大典型应用场景为：\n 增强型移动宽带（eMBB） 超可靠低时延通信（uRLLC） 海量大规模连接物联网（mMTC）  增强型移动宽带（eMBB） eMBB 主要面向虚拟现实（VR）/ 增强现实（AR）、在线 4K 视频等高带宽需求业务\n超可靠低时延通信（uRLLC） mMTC 主要面向智慧城市、智能交通等高连接密度需求的业务\n海量大规模连接物联网（mMTC） uRLLC 主要面向车联网、无人驾驶、无人机等时延敏感的业务。\n 5G 架构 5G 核心网采用控制面（SMF：Session Management Function）和用户面 UPF 分离的 CUPS（Control and User Plane Separation ）架构\n5G 控制面集中部署，一个控制面（SMF）可以同时管理很多个 UPF 而不影响 5G 核心网的性能； 5G 用户面分散部署，UPF 可以按需灵活分布部署，部署到网络边缘支持边缘计算。\nUE 的不同业务，可以引导到本地 UPF（比如企业应用），或直接引导到锚点 UPF（普通的上网业务）， 中间可以动态插入 UL CL 进行按需动态分流。\n因此，在企业园区里面的基站，是可以同时支持本地企业应用和个人普通上网应用。\n UL CL (Uplink Classifier 上行链路分类器)  SMF Session Management Function\nUPF 5G 用户面 UPF（User Plane Function）的下沉和灵活部署实现了数据流量本地卸载。\nCUPS MEP 5G MEC 给运营商进入垂直行业带来了新的业务场景和商业模式。 运营商一般是用代建代维方式， 将 5G MEC 部署到企业园区，提供边缘云计算服务， 包括 IaaS，PaaS（即 MEP 平台），以及 SaaS（结合运营商的云计算服务）等更多的增值服务，\n收益从管道转向软件和服务。\n这样，运营商能深入垂直行业的 ICT 系统及应用领域，更好地为企业数字化、网络化和智能化提供全套的 ICT 服务和云计算应用，提供的业务比传统的企业专线业务，更深入全面和有客户粘性。 这就是为什么运营商都在积极拓展 5G MEC 企业业务的原因，得 5G MEC 服务者得企业客户。\nETSI 欧洲电信标准研究所（ETSI）在 2014 年成立 MEC 工业专业组，关注运营商边缘计算的标准和工业使能， 并且在 2016 年，将 MEC 的定义从移动边缘计算（Mobile Edge Computing）改为外延更广的多接入边缘计算（Multi-Access Edge Computing）； 在运营商领域，MEC 一般被用来指代边缘计算系统。 在 5G 时代，MEC 是运营商助力垂直行业数字化和智能化的新应用模式。\n 5G 技术 5G 承载网 在无线侧有大量新技术实现对不同应用场景的支撑，但传输网络侧，硬件技术提升有限的情况下，需要对网络架构进行革新。\n5G 承载整体要求 5G 承载组网架构 多样化网络需求 边缘计算技术就是解决不同应用带来的多样化网络需求的核心技术之一\n在靠近接入网的机房增加计算能力，将能够\n 大幅降低业务时延 减少对传输网的带宽压力降低传输成本 进一步提高内容分发效率提升用户体验  传统网络结构中，信息的处理主要位于核心网的数据中心机房内，所有信息必须从网络边缘传输到核心网进行处理之后再返回网络边缘。\n5G 时代，传输网架构中引入边缘计算技术，在靠近接入侧的边缘机房部署网关、服务器等设备，增加计算能力，将低时延业务、局域性数据、低价值量数据等数据在边缘机房进行处理和传输，不需要通过传输网返回核心网，进而降低时延、减少回传压力、提升用户体验。\n 5G 应用 底层网络进步带来应用和商业模式的升级\n 4G vs 5G 4G 核心网是集中部署模式，一般是一个省（或大区）部署一个 4G 核心网， 所以 4G 承载网的流量模型是南北向为主， 运营商倾向于采用比较简单的接入网设计， 如很多运营商采用 L2（VPN）+L3（VPN）组网模式，即接入网采用相对简单的 L2 VPN 网络。\n在 4G 时代，这些无线核心网流量是在 IP 骨干网上而不是在移动承载网上来承载的。\n5G 核心网是 CUPS 架构， 控制面集中部署，一般是一个省或一个大区部署一个， 而 UPF 是分布式部署的，一般一个城市会部署一个锚点 UPF（Anchor UPF）和很多 MEC UPF。\n5G MEC 经常连接到接入网（如现场 MEC），增加了对 5G 移动承载网接入网的功能要求\n5G MEC 网络需要一个功能更强大、支持企业业务的网络架构和方案，不能是 4G 现有移动承载网架构的简单带宽升级。\n"});index.add({'id':490,'href':'/note-cs/docs/course/basic/os/','title':"6.1.2 操作系统",'content':"操作系统 "});index.add({'id':491,'href':'/note-cs/docs/course/be/','title':"6.2 后端",'content':"后端 "});index.add({'id':492,'href':'/note-cs/docs/direction/se/arch/principle/acid/','title':"ACID",'content':"ACID  In computer science, ACID (atomicity, consistency, isolation, durability) is a set of properties of database transactions intended to guarantee validity even in the event of errors, power failures, etc. In the context of databases, a sequence of database operations that satisfies the ACID properties (and these can be perceived as a single logical operation on the data) is called a transaction.\n  ACID，是指数据库管理系统（DBMS）在写入或更新资料的过程中，为保证事务（transaction）是正确可靠的，所必须具备的四个特性：\n 原子性（Atomicity 又称不可分割性）  一个事务（transaction）中的所有操作，或者全部完成，或者全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。即，事务不可分割、不可约简。   一致性（Consistency）  在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设约束、触发器、级联回滚等。   隔离性（Isolation，又称独立性）  数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括未提交读（Read uncommitted）、提交读（read committed）、可重复读（repeatable read）和串行化（Serializable）。   持久性（Durability）  事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。     ACID 是追求 CAP 的一致性 "});index.add({'id':493,'href':'/note-cs/docs/others/skill/lorawan/chirpstack/application/','title':"Application",'content':"ChirpStack Application Server ChirpStack Application Server is an open-source LoRaWAN application-server. https://www.chirpstack.io\n数据库    Schema Name Type Owner     public application table chirpstack_as   public application_id_seq sequence chirpstack_as   public code_migration table chirpstack_as   public device table chirpstack_as   public device_activation table chirpstack_as   public device_activation_id_seq sequence chirpstack_as   public device_keys table chirpstack_as   public device_multicast_group table chirpstack_as   public device_profile table chirpstack_as   public fuota_deployment table chirpstack_as   public fuota_deployment_device table chirpstack_as   public gateway table chirpstack_as   public gateway_ping table chirpstack_as   public gateway_ping_id_seq sequence chirpstack_as   public gateway_ping_rx table chirpstack_as   public gateway_ping_rx_id_seq sequence chirpstack_as   public gateway_profile table chirpstack_as   public gorp_migrations table chirpstack_as   public integration table chirpstack_as   public integration_id_seq sequence chirpstack_as   public multicast_group table chirpstack_as   public network_server table chirpstack_as   public network_server_id_seq sequence chirpstack_as   public organization table chirpstack_as   public organization_id_seq sequence chirpstack_as   public organization_user table chirpstack_as   public organization_user_id_seq sequence chirpstack_as   public remote_fragmentation_session table chirpstack_as   public remote_multicast_class_c_session table chirpstack_as   public remote_multicast_setup table chirpstack_as   public service_profile table chirpstack_as   public user table chirpstack_as   public user_id_seq sequence chirpstack_as    (33 rows)\n"});index.add({'id':494,'href':'/note-cs/docs/direction/se/arch/principle/base/','title':"BASE",'content':"BASE Basically Available, Soft state, Eventual consistency\nBASE 理论是 CAP 理论中的 AP 的延伸，是对互联网大规模分布式系统的实践总结，强调可用性。\n基本可用  流量削峰  在不同的时间，出售不同区域的票，将访问请求错开，削弱请求峰值   延迟响应  在春运期间，自己提交的购票请求，往往会在队列中排队等待处理，可能几分钟或十几分钟后，系统才开始处理，然后响应处理结果   体验降级  比如用小图片来替代原始图片，通过降低图片的清晰度和大小，提升系统的处理能力。   过载保护  把接收到的请求放在指定的队列中排队处理，如果请求等待时间超时了（假设是 100ms），这个时候直接拒绝超时请求；再比如队列满了之后，就清除队列中一定数量的排队请求，保护系统不过载，实现系统的基本可用。    最终的一致  读时修复：在读取数据时，检测数据的不一致，进行修复。  比如 Cassandra 的 Read Repair 实现，具体来说，在向 Cassandra 系统查询数据的时候，如果检测到不同节点的副本数据不一致，系统就自动修复数据。   写时修复：在写入数据，检测数据的不一致时，进行修复。  比如 Cassandra 的 Hinted Handoff 实现。具体来说，Cassandra 集群的节点之间远程写数据的时候，如果写失败就将数据缓存下来，然后定时重传，修复数据的不一致性。 写时修复不需要做数据一致性对比，性能消耗比较低，对系统运行影响也不大，推荐在实现最终一致性时优先实现这种方式。   异步修复：这个是最常用的方式，通过定时对账检测副本数据的一致性，并修复。   BASE 是追求 CAP 的可用性 "});index.add({'id':495,'href':'/note-cs/docs/direction/be/microservices/rpc/brpc/','title':"brpc",'content':"brpc  "});index.add({'id':496,'href':'/note-cs/docs/direction/be/proxy/envoy/xds/cds/','title':"CDS",'content':"CDS "});index.add({'id':497,'href':'/note-cs/docs/direction/be/microservices/rpc/dubbo/','title':"Dubbo",'content':"Dubbo 国内最早开源的 RPC 框架，由阿里巴巴公司开发并于 2011 年末对外开源，仅支持 Java 语言\n"});index.add({'id':498,'href':'/note-cs/docs/direction/be/search/elasticsearch/','title':"Elasticsearch",'content':"Elasticsearch Open Source, Distributed, RESTful Search Engine https://www.elastic.co/products/elasticsearch\n"});index.add({'id':499,'href':'/note-cs/docs/direction/be/proxy/envoy/','title':"Envoy",'content':"Envoy "});index.add({'id':500,'href':'/note-cs/docs/direction/be/frame/python/flask/','title':"flask",'content':"flask 教程 realpython/discover-flask  Full Stack Web Development with Flask.\n   Part Title Git Tag     1 Setting Up a Static Site (blog post) part1   2 Creating a login page (blog post) part2   3 User Authentication part3   4 Template Inheritance part4   5 Databases part5   6 List Comprehensions N/A   7 Unit Tests part7   8 Deploying to Heroku part8   9 SQLAlchemy part9   10 Configuration part10   11 Secret Key part11   12 Heroku Configuration Settings part12   13 Heroku Postgres Setup part13   14 Local PostgreSQL Setup part14   15 Managing Database Migrations part15   16 Database Downgrades with Flask-Migrate/Alembic part16   17 Virtualenvwrapper part17   18 Password Hashing part18   19 Blueprints part19   20 Blueprints Redux part20   21 User Authentication (part 2) part21   22 Unit Testing with Flask-Testing part22   23 Session Management with Flask-Login part23   24 Testing User Login and Logout part24   25 User Registration (functionality and unit tests) part25   26 Finalize Messaging System part26   27 Test Coverage with coverage.py part27   28 Flask Testing! part28   29 Flask Testing (increase test coverage) part29   30 Continuous Integration part30     "});index.add({'id':501,'href':'/note-cs/docs/basic/pl/go/','title':"Go",'content':"Go 学习笔记 见：Go 学习笔记\n"});index.add({'id':502,'href':'/note-cs/docs/others/skill/stream-media/h264/','title':"H264",'content':"H264 H.264，又称为 MPEG-4 第 10 部分，高级视频编码（英语： MPEG-4 Part 10, Advanced Video Coding ，缩写为 MPEG-4 AVC）是一种面向块，基于运动补偿的视频编码标准（英语：Advanced Video Coding） 。\nAVC 和 XviD 都属于 MPEG-4 编码，但由于 AVC 属于 MPEG-4 Part 10，在技术特性上比属于 MPEG-4 Part2 的 XviD 要先进。\n它和 ITU-T H.264 标准是一致的，故又称为 H.264。\n裸流 H.264 原始码流（又称为 “裸流”）是由一个一个的 NALU 组成的。\nH264 码流可以分为两层\n VCL 层 NAL 层（Network abstraction layer, 叫网络抽象层），保存了 H264 相关的参数信息和图像信息  NAL 层由多个单元 NALU 组成    NALU NAL Units\nNALU 组成\n NALU 头（00 00 00 01 或者 00 00 01） sps (序列参数集) pps (图像参数集合) slice sei IDR 帧 I 帧（在图像运动变化较少时，I 帧后面是 7 个 P 帧，如果图像运动变化大时，一个序列就短了，I 帧后面可能是 3 个或者 4 个 P 帧） P 帧 B 帧等数据。  一个完整的 NALU 单元结构图\n参考：\n H.264 码流结构 (H.264 Data Structure)   其他 ITU-T 国际电信联盟电信标准化部门（英语： ITU Telecommunication Standardization Sector，缩写 ITU-T ）是国际电信联盟管理下的专门制定远程通信相关国际标准的组织。该机构创建于 1993 年，前身是国际电报电话咨询委员会（法语： Comité Consultatif International Téléphonique et Télégraphique，英语：International Telegraph and Telephone Consultative Committee，缩写：CCITT ），总部设在瑞士日内瓦。\n由 ITU-T 指定的国际标准通常被称为 “建议书”（Recommendations），ITU-T 的各种建议书的分类由一个首字母来代表，称为系列，每个系列的建议书除了分类字母以外还有一个编号，例如 “V.90”。\n"});index.add({'id':503,'href':'/note-cs/docs/domain/cc/others/paas/heroku/','title':"Heroku",'content':"Heroku "});index.add({'id':504,'href':'/note-cs/docs/others/skill/stream-media/http-flv/','title':"HTTP FLV",'content':"HTTP FLV Bilibili/flv.js  HTML5 FLV Player\n"});index.add({'id':505,'href':'/note-cs/docs/direction/client/ios/','title':"iOS",'content':"iOS "});index.add({'id':506,'href':'/note-cs/docs/direction/be/frame/java/','title':"Java 框架",'content':"Java 框架 "});index.add({'id':507,'href':'/note-cs/docs/direction/be/auth/jwt/','title':"JWT",'content':"JWT JSON Web Tokens\n背景  JWT 原理 JWT 结构 JWT 由 Header, Payload, Signature 三部分组成\nconst token = base64urlEncoding(header) + '.' + base64urlEncoding(payload) + '.' + base64urlEncoding(signature)\neyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJsb2dnZWRJbkFzIjoiYWRtaW4iLCJpYXQiOjE0MjI3Nzk2Mzh9.gzSraSYS8EXBxLN_oWnFSRgCzcmJmMjLiuyu5CSpyHI\n  Header\n{ \u0026quot;alg\u0026quot; : \u0026quot;HS256\u0026quot;, \u0026quot;typ\u0026quot; : \u0026quot;JWT\u0026quot; }   Payload\n{ \u0026quot;loggedInAs\u0026quot; : \u0026quot;admin\u0026quot;, \u0026quot;iat\u0026quot; : 1422779638 }   Signature\nHMAC-SHA256( base64urlEncoding(header) + '.' + base64urlEncoding(payload), secret )   Authorization: Bearer eyJhbGci...\u0026lt;snip\u0026gt;...yu5CSpyHI\n JWT 优缺点 优点  JWT 把数据存储在客户端，服务端不需要存储  缺点  JWT 的 Token 无法主动失效   JWT 适用场景  参考  阮一峰：JSON Web Token 入门教程  "});index.add({'id':508,'href':'/note-cs/docs/direction/be/mq/kafka/','title':"Kafka",'content':"Kafka Kafka 是 linkedin 开源的 MQ 系统，主要特点是基于 Pull 的模式来处理消息消费，追求高吞吐量，一开始的目的就是用于日志收集和传输，0.8 开始支持复制，不支持事务，适合产生大量数据的互联网服务的数据收集业务。\n序列化 StringSerializer 序列化，写入时使用 dest.kafka.1\u0026amp;key.serializer=org.apache.kafka.common.serialization.StringSerializer dest.kafka.1\u0026amp;value.serializer=org.apache.kafka.common.serialization.StringSerializer\nStringDeserializer 反序列化，读出时使用 source.kafka.2\u0026amp;key.deserializer=org.apache.kafka.common.serialization.StringDeserializer source.kafka.2\u0026amp;value.deserializer=org.apache.kafka.common.serialization.StringDeserializer\n"});index.add({'id':509,'href':'/note-cs/docs/direction/be/frame/php/laravel/','title':"Laravel",'content':"Laravel "});index.add({'id':510,'href':'/note-cs/docs/basic/db/redis/source/type/list/','title':"List 实现",'content':"Redis List 类型实现  参考  5 种基本数据结构  "});index.add({'id':511,'href':'/note-cs/docs/direction/be/search/lucene/','title':"Lucene",'content':"Lucene https://lucene.apache.org/\napache/lucene-solr  Apache Lucene is a high-performance, full featured text search engine library written in Java.\nApache Solr is an enterprise search platform written using Apache Lucene. Major features include full-text search, index replication and sharding, and result faceting and highlighting.\n 教程 zzboy/lucene  lucene 技术细节\n"});index.add({'id':512,'href':'/note-cs/docs/others/tool/dev/mas/','title':"Mas",'content':"mas-cli/mas  Each application in the Mac App Store has a product identifier which is also used for mas-cli commands. Using mas list will show all installed applications and their product identifiers.\n$ mas list 446107677 Screens 407963104 Pixelmator 497799835 Xcode $ mas search Xcode 497799835 Xcode 688199928 Docs for Xcode 449589707 Dash 3 - API Docs \u0026amp; Snippets. Integrates with Xcode, Alfred, TextWrangler and many more. [...] $ mas install 808809998 ==\u0026gt; Downloading PaintCode 2 ==\u0026gt; Installed PaintCode 2 # If you want to install the first result that the search command returns, use the lucky command. $ mas lucky twitter ==\u0026gt; Downloading Twitter ==\u0026gt; Installed Twitter $ mas outdated 497799835 Xcode (7.0) 446107677 Screens VNC - Access Your Computer From Anywhere (3.6.7) $ mas upgrade Upgrading 2 outdated applications: Xcode (7.0), Screens VNC - Access Your Computer From Anywhere (3.6.7) ==\u0026gt; Downloading Xcode ==\u0026gt; Installed Xcode ==\u0026gt; Downloading iFlicks ==\u0026gt; Installed iFlicks $ mas upgrade 715768417 Upgrading 1 outdated application: Xcode (8.0) ==\u0026gt; Downloading Xcode ==\u0026gt; Installed Xcode $ mas signin mas@example.com ==\u0026gt; Signing in to Apple ID: mas@example.com Password: "});index.add({'id':513,'href':'/note-cs/docs/others/skill/stream-media/mpeg/','title':"MPEG",'content':"MPEG  MPEG-1：第一个官方的视讯音频压缩标准，随后在 Video CD 中被采用，其中的音频压缩的第三级（MPEG-1 Layer 3）简称 MP3，成为比较流行的音频压缩格式。 MPEG-2：广播质量的视讯、音频和传输协议。被用于无线 数字电视 - ATSC、DVB 以及 ISDB、数字卫星电视（例如 DirecTV）、数字 有线电视信号，以及 DVD 视频光盘技术中。 MPEG-3：原本目标是为 高清晰度电视（ HDTV）设计，随后发现 MPEG-2 已足够 HDTV 应用，故 MPEG-3 的研发便中止。 MPEG-4：2003 年发布的视讯压缩标准，主要是扩展 MPEG-1、MPEG-2 等标准以支持视频／音频对象（video/audio \u0026ldquo;objects\u0026rdquo;）的编码、3D 内容、低比特率编码（low bitrate encoding）和 数字版权管理（Digital Rights Management），其中第 10 部分由 ISO/IEC 和 ITU-T 联合发布，称为 H.264/MPEG-4 Part 10。 MPEG-7：MPEG-7 并不是一个视讯压缩标准，它是一个多媒体内容的描述标准。 MPEG-21：MPEG-21 是一个正在制定中的标准，它的目标是为未来多媒体的应用提供一个完整的平台。  "});index.add({'id':514,'href':'/note-cs/docs/domain/cc/virtual/parallels/','title':"Parallels",'content':"Parallels "});index.add({'id':515,'href':'/note-cs/docs/direction/be/frame/php/','title':"PHP 框架",'content':"PHP 框架 "});index.add({'id':516,'href':'/note-cs/docs/others/tool/dev/picgo/','title':"picgo",'content':"picgo CLI 命令 PicGo/PicGo-Core  Molunerfinn/PicGo  "});index.add({'id':517,'href':'/note-cs/docs/basic/db/postgresql/','title':"PostgreSQL",'content':"PostgreSQL "});index.add({'id':518,'href':'/note-cs/docs/direction/be/microservices/rpc/protobuf/','title':"protobuf",'content':"protobuf  "});index.add({'id':519,'href':'/note-cs/docs/others/skill/stream-media/ps/','title':"PS",'content':"PS Program stream\nPS 流的包结构是可变长度的， 一旦某一 PS 包的同步信息丢失，接收机无法确定下一包的同步位置，就会造成失步，导致严重的信息丢失。\n在信道环境较好，传输误码较低时，一般采用 PS 码流。\n TS MPEG transport stream (MPEG-TS, MTS)\n传输流，是由固定长度为 188 字节的包组成， 含有一个或多个 program, 一个 program 可以包含多个视频、音频、和文字信息的 ES 流； 每个 ES 流会有不同的 PID 标示。\n而又为了可以分析这些 ES 流，TS 有一些固定的 PID 用来间隔发送 program 和 ES 流信息的表格:\n PAT PMT 表  TS 流的包结构是固定长度的， 当传输误码破坏了某一 TS 包的同步信息时，接收机可在固定的位置检测它后面包中的同步信息，从而恢复同步，避免了信息丢失。\n在信道环境较为恶劣，传输误码较高时，一般采用 TS 码流。\nTS 流解码过程  获取 TS 中的 PAT 获取 TS 中的 PMT 根据 PMT 可以知道当前网络中传输的视频（音频）类型（H264），相应的 PID，PCR 的 PID 等信息。 设置 demux 模块的视频 Filter 为相应视频的 PID 和 stream type 等。 从视频 Demux Filter 后得到的 TS 数据包中的 payload 数据就是 one piece of PES， 在 TS header 中有一些关于此 payload 属于哪个 PES 的 第多少个数据包。 因此软件中应该将此 payload 中的数据 copy 到 PES 的 buffer 中，用于拼接一个 PES 包。 拼接好的 PES 包的包头会有 PTS，DTS 信息，去掉 PES 的 header 就是 ES。 直接将被拔掉 PES 包头的 ES 包送给 decoder 就可以进行解码。 解码出来的数据就是一帧一帧的视频数据，这些数据至少应当与 PES 中的 PTS 关联一下，以便进行视音频同步。   ES Elementary Stream\n基本码流，包含视频、音频或数据的连续码流。\nES -\u0026gt; PES -\u0026gt; PS/TS\n PES Packet Elementary Stream\n打包的基本码流\n将基本的码流 ES 流根据需要分成长度不等的数据包，并加上包头就形成了打包的基本码流 PES 流。\n"});index.add({'id':520,'href':'/note-cs/docs/direction/be/frame/python/','title':"Python 框架",'content':"Python 框架 "});index.add({'id':521,'href':'/note-cs/docs/direction/be/distributed/raft/','title':"Raft",'content':"Raft https://raft.github.io\n由于 Paxos 难以理解，所以才有了 Raft\nRaft 以可理解性和易于实现为目标：\n Leader 选举（Leader election） 日志同步（Log replication） 安全性（Safety） 日志压缩（Log compaction） 成员变更（Membership change）   教程 maemual/raft-zh_cn   关注 baidu/braft  tikv/raft-rs  Raft distributed consensus algorithm implemented in Rust.\nhashicorp/raft  Golang implementation of the Raft consensus protocol\netcd-io/etcd  Distributed reliable key-value store for the most critical data of a distributed system\n"});index.add({'id':522,'href':'/note-cs/docs/direction/fe/frame/react/','title':"React",'content':"React "});index.add({'id':523,'href':'/note-cs/docs/direction/be/microservices/rpc/','title':"RPC",'content':"RPC "});index.add({'id':524,'href':'/note-cs/docs/direction/be/frame/java/spring/','title':"Spring",'content':"Spring "});index.add({'id':525,'href':'/note-cs/docs/direction/be/frame/java/spring/spring-boot/','title':"Spring Boot",'content':"Spring Boot 教程 ityouknow/spring-boot-examples  Spring Boot 教程、技术栈示例代码，快速简单上手教程。\n"});index.add({'id':526,'href':'/note-cs/docs/direction/be/frame/java/spring/spring-cloud/','title':"Spring Cloud",'content':"Spring Cloud 教程 ityouknow/spring-cloud-examples  Spring Cloud 学习案例，服务发现、服务治理、链路追踪、服务监控等\n"});index.add({'id':527,'href':'/note-cs/docs/direction/be/frame/java/spring/spring-mvc/','title':"Spring MVC",'content':"Spring MVC "});index.add({'id':528,'href':'/note-cs/docs/others/tool/dev/tmux/','title':"tmux",'content':"tmux 配置 ChrisJohnsen/tmux-MacOSX-pasteboard  Using the Mac OS X programs pbpaste and pbcopy under tmux does not work.\nOther services and unpatched builds of screen are also affected.\ngpakosz/.tmux  Oh My Tmux!\ncd git clone https://github.com/gpakosz/.tmux.git ln -s -f .tmux/.tmux.conf cp .tmux/.tmux.conf.local .  教程 tmux 2: Productive Mouse-Free Development by @bphogan. "});index.add({'id':529,'href':'/note-cs/docs/direction/se/uml/','title':"UML",'content':"UML 泛化关系 (generalization)  is-a 最终代码中，泛化关系表现为继承非抽象类  带空心三角形箭头的直线\n实现关系 (realize)  最终代码中，实现关系表现为继承抽象类  带空心三角形箭头的虚线\n聚合关系 (aggregation)  表示整体由部分构成的语义  例如一个部门由多个员工组成   整体和部分不是强依赖的，即使整体不存在了，部分仍然存在  例如， 部门撤销了，人员不会消失，他们依然存在    带空心菱形箭头的直线\n组合关系 (composition)  表示整体由部分构成的语义  比如公司由多个部门组成   是一种强依赖的特殊聚合关系，如果整体不存在了，则部分也不存在了  例如， 公司不存在了，部门也将不存在了    带实心菱形箭头直线\n关联关系 (association)  它一般用来定义对象之间静态的、天然的结构；通常与运行状态无关 所以，关联关系是一种 \u0026ldquo;强关联\u0026rdquo; 的关系  比如，乘车人和车票之间就是一种关联关系；学生和学校就是一种关联关系   在最终代码中，关联对象通常是以成员变量的形式实现的  带箭头的直线\n依赖关系 (dependency)  描述一个对象在运行期间会用到另一个对象的关系 是一种临时性的关系，通常在运行期间产生，并且随着运行时的变化，依赖关系也可能发生变化 在最终代码中，依赖关系体现为类构造方法及类方法的传入参数，箭头的指向为调用关系  依赖关系除了临时知道对方外，还是 \u0026ldquo;使用\u0026rdquo; 对方的方法和属性；    带箭头的虚线\n"});index.add({'id':530,'href':'/note-cs/docs/domain/cc/virtual/virtualbox/','title':"VirtualBox",'content':"VirtualBox "});index.add({'id':531,'href':'/note-cs/docs/direction/be/web-service/','title':"Web Service",'content':"Web Service "});index.add({'id':532,'href':'/note-cs/docs/direction/be/proxy/','title':"代理",'content':"代理 "});index.add({'id':533,'href':'/note-cs/docs/basic/pl/cpp/basic/grammar/namespace/','title':"命名空间",'content':"C++ 命名空间 // 命名空间为变量、函数和其他声明提供了分离的的作用域。 // 命名空间可以嵌套使用。  namespace First { namespace Nested { void foo() { printf(\u0026#34;This is First::Nested::foo\\n\u0026#34;); } } // 结束嵌套的命名空间Nested } // 结束命名空间First  namespace Second { void foo() { printf(\u0026#34;This is Second::foo\\n\u0026#34;) } } void foo() { printf(\u0026#34;This is global foo\\n\u0026#34;); } int main() { // 如果没有特别指定，就从“Second”中取得所需的内容。  using namespace Second; foo(); // 显示“This is Second::foo”  First::Nested::foo(); // 显示“This is First::Nested::foo”  ::foo(); // 显示“This is global foo” } "});index.add({'id':534,'href':'/note-cs/docs/basic/db/postgresql/basic/practice/error/','title':"常见错误",'content':"PostgreSQL 常见错误 权限 permission denied for relation 解决 1:\n 以 superUser 进入数据库  psql -U postgres -d postgres   切换到 mydb 数据库  \\c mydb   赋予所有表的所有权限给 xiaoming  GRANT ALL PRIVILEGES ON ALL TABLES IN SCHEMA public TO xiaoming;   赋予 wechart 用户，tuser 表的所有权限  GRANT ALL PRIVILEGES ON tuser TO wechart;    解决 2：\nERROR: permission denied for relation hycom 权限被拒绝\n 检查数据库连接 检查数据库拥有者和配置的是否一样 访问不同的数据库分区 @TableName (\u0026ldquo;分区名。表名\u0026rdquo;) @TableField (exist = false) 取消数据库映射  "});index.add({'id':535,'href':'/note-cs/docs/direction/be/platform/','title':"平台",'content':"平台 "});index.add({'id':536,'href':'/note-cs/docs/basic/pl/csharp/basic/lib/','title':"库",'content':"库 "});index.add({'id':537,'href':'/note-cs/docs/direction/fe/lib/','title':"库",'content':"库 "});index.add({'id':538,'href':'/note-cs/docs/basic/pl/cpp/basic/grammar/reference/','title':"引用",'content':"C++ 引用   引用是一种特殊的指针类型，一旦被定义就不能重新赋值，并且不能被设置为空值。\n  使用引用时的语法与原变量相同\n 对引用类型进行解引用时，不需要使用 * 赋值时也不需要用 \u0026amp; 来取地址  using namespace std; string foo = \u0026#34;I am foo\u0026#34;; string bar = \u0026#34;I am bar\u0026#34;; string\u0026amp; fooRef = foo; // 建立了一个对foo的引用。 fooRef += \u0026#34;. Hi!\u0026#34;; // 通过引用来修改foo的值 cout \u0026lt;\u0026lt; fooRef; // \u0026#34;I am foo. Hi!\u0026#34; // 这句话的并不会改变fooRef的指向，其效果与“foo = bar”相同。 // 也就是说，在执行这条语句之后，foo == \u0026#34;I am bar\u0026#34;。 fooRef = bar;   不能修改一个常量引用的值\nconst string\u0026amp; barRef = bar; // 建立指向bar的常量引用。 // 和C语言中一样，（指针和引用）声明为常量时，对应的值不能被修改。 barRef += \u0026#34;. Hi!\u0026#34;; // 这是错误的，不能修改一个常量引用的值。   "});index.add({'id':539,'href':'/note-cs/docs/direction/be/search/','title':"搜索引擎",'content':"搜索引擎 "});index.add({'id':540,'href':'/note-cs/docs/domain/cc/container/docker/volume/','title':"数据卷",'content':"Docker 数据卷 "});index.add({'id':541,'href':'/note-cs/docs/basic/pl/csharp/basic/practice/best/','title':"最佳实践",'content':"C# 最佳实践 "});index.add({'id':542,'href':'/note-cs/docs/domain/ai/deep-learning/','title':"深度学习",'content':"深度学习 "});index.add({'id':543,'href':'/note-cs/docs/basic/db/postgresql/basic/version/','title':"版本",'content':"PostgreSQL 版本 12 12.2  "});index.add({'id':544,'href':'/note-cs/docs/domain/cc/virtual/network/','title':"虚拟机网络",'content':"虚拟机网络 在 VMware 的 3 中网络模式中，NAT 模式是最简单的，基本不需要手动配置 IP 地址等相关参数。至于桥接模式则需要额外的 IP 地址，如果是在内网环境中还很容易，如果是 ADSL 宽带就比较麻烦了，ISP 一般是不会大方的多提供一个公网 IP 的。\n三种网络模式 桥接 特点：\n 如果主机可以上网，虚拟机可以上网 虚拟机之间可以 ping 通 虚拟机可以 ping 通主机 主机可以 ping 通虚拟机 如果主机不可以上网，所有 1-4 特点均无  应用场景：\n 虚拟机要求可以上网，且虚拟机完全模拟一台实体机  桥接网络是指本地物理网卡和虚拟网卡通过 VMnet0 虚拟交换机进行桥接，物理网卡和虚拟网卡在拓扑图上处于同等地位，那么物理网卡和虚拟网卡就相当于处于同一个网段，虚拟交换机就相当于一台现实网络中的交换机，所以两个网卡的 IP 地址也要设置为同一网段。\n所以当我们要在局域网使用虚拟机，对局域网其他 pc 提供服务时，例如提供 ftp，提供 ssh，提供 http 服务，那么就要选择桥接模式。\n例如大学宿舍里有一个路由器，宿舍里四个人连接这个路由器，路由器的 wanip 就不理会了，这个 ip 是动态获取的，而 lanip 默认是 192.168.1.1, 子网掩码是 255.255.255.0。而其他四个人是自动获取 ip，假设四个人的 ip 是:\nA:192.168.1.100/255.255.255.0, B:192.168.1.101/255.255.255.0, C:192.168.1.102/255.255.255.0, D:192.168.1.103/255.255.255.0\n那么虚拟机的 ip 可以设置的 ip 地址是 192.168.1.2-192.168.1.99,192.168.1.104-192.168.1.254 (网络地址全 0 和全 1 的除外，再除去 ABCD 四个人的 ip 地址)\n那么虚拟机的 ip 地址可以设置为 192.168.1.98/255.255.255.0, 设置了这个 ip 地址，ABCD 这四个人就可以通过 192.168.1.98 访问虚拟机了，如果虚拟机需要上外网，那么还需要配置虚拟机的路由地址，就是 192.168.1.1 了，这样，虚拟机就可以上外网了，但是，上网我们一般是通过域名去访问外网的，所以我们还需要为虚拟机配置一个 dns 服务器，我们可以简单点，把 dns 服务器地址配置为 google 的 dns 服务器：8.8.8.8, 到此，虚拟机就可以上网了。\nNAT 特点：\n 如果主机可以上网，虚拟机可以上网 虚拟机之间不能 ping 通 虚拟机可以 ping 通主机（此时 ping 虚拟机的网关，即是 ping 主机） 主机不能 ping 通虚拟机  应用场景：\n 虚拟机只要求可以上网，无其它特殊要求，满足最一般需求  NAT 模式中，就是让虚拟机借助 NAT (网络地址转换) 功能，通过宿主机器所在的网络来访问公网。\nNAT 模式中，虚拟机的网卡和物理网卡的网络，不在同一个网络，虚拟机的网卡，是在 vmware 提供的一个虚拟网络。\nNAT 和桥接的比较:\n(1) NAT 模式和桥接模式虚拟机都可以上外网。\n(2) 由于 NAT 的网络在 vmware 提供的一个虚拟网络里，所以局域网其他主机是无法访问虚拟机的，而宿主机可以访问虚拟机， 虚拟机可以访问局域网的所有主机，因为真实的局域网相对于 NAT 的虚拟网络，就是 NAT 的虚拟网络的外网，不懂的人可以查查 NAT 的相关知识。\n(3) 桥接模式下，多个虚拟机之间可以互相访问；NAT 模式下，多个虚拟机之间也可以相互访问。\n如果你建一个虚拟机，只是给自己用，不需要给局域网其他人用，那么可以选择 NAT，毕竟 NAT 模式下的虚拟系统的 TCP/IP 配置信息是由 VMnet8 (NAT) 虚拟网络的 DHCP 服务器提供的，只要虚拟机的网路配置是 DHCP，那么你不需要进行任何其他的配置，只需要宿主机器能访问互联网即可，就可以让虚拟机联网了。\n例如你想建多个虚拟机集群，作为测试使用，而宿主机可能是一个笔记本，ip 不固定。这种应用场景，我们需要采用 nat 模式了，但是我们要考虑一个问题，虚拟机之间是需要互访的，默认采用 dhcp，虚拟机的 ip 每次重启，ip 都是不固定的，所以我们需要手工设置虚拟机的 ip 地址。\n但是我们对虚拟机网卡所在的虚拟网络的信息还一无所知，例如虚拟机网络的路由地址，子网掩码，所以我们需要先查下 nat 虚拟网络的信息。\n使用 vmware, 在 Edit-\u0026gt;Virtual Network Editor 中配置好虚拟网络信息后看到下图所示，注意 VMnet8，VMnet8 相当于是本机的一个路由，虚拟机设置 NAT 后就通过这个路由进行上网的，可以查看其网络地址，路由地址，子网掩码。\n选择 VMnet8-\u0026gt;NAT 设置，可以看到子网 ip 显示为 192.168.233.0，子网掩码是 255.255.255.0，那路由地址呢，其实就是网关 IP 了，都是同个东西，这里是 192.168.233.2。\n接下来就好办了，在对应的虚拟机设置好 ip，子网掩码，路由地址就可以上外网了，至于 dns 可以设置为 8.8.8.8.\nHost-Only 特点：\n 虚拟机不可以上网 虚拟机之间可以 ping 通 虚拟机可以 ping 通主机 注意虚拟机与主机通信是通过主机的名为 VirtualBox Host-Only Network 的网卡，因此 ip 是该网卡 ip 192.168.56.1，而不是你现在正在上网所用的 ip 主机可以 ping 通虚拟机  应用场景：\n 在主机无法上网的情况下（主机可以上网的情况下可以用 host-only，也可以用桥接），需要搭建一个模拟局域网，所有机器可以互访  在 Host-Only 模式下，虚拟网络是一个全封闭的网络，它唯一能够访问的就是主机。其实 Host-Only 网络和 NAT 网络很相似，不同的地方就是 Host-Only 网络没有 NAT 服务，所以虚拟网络不能连接到 Internet。主机和虚拟机之间的通信是通过 VMware Network Adepter VMnet1 虚拟网卡来实现的。\nHost-Only 的宗旨就是建立一个与外界隔绝的内部网络，来提高内网的安全性。这个功能或许对普通用户来说没有多大意义，但大型服务商会常常利用这个功能。如果你想为 VMnet1 网段提供路由功能，那就需要使用 RRAS，而不能使用 XP 或 2000 的 ICS，因为 ICS 会把内网的 IP 地址改为 192.168.0.1，但虚拟机是不会给 VMnet1 虚拟网卡分配这个地址的，那么主机和虚拟机之间就不能通信了。\n"});index.add({'id':545,'href':'/note-cs/docs/others/tool/study/','title':"计算机学习",'content':"计算机学习 "});index.add({'id':546,'href':'/note-cs/docs/basic/pl/cpp/appendix/interview/','title':"面试题",'content':"面试题 基础题 进阶题 高阶题 综合  你遇到过哪些高质量的 C++ 面试？ What is the best C++ interview question? [closed]  "});index.add({'id':547,'href':'/note-cs/docs/basic/pl/csharp/appendix/interview/','title':"面试题",'content':"面试题 基础题 进阶题 高阶题 "});index.add({'id':548,'href':'/note-cs/docs/basic/pl/kotlin/appendix/interview/','title':"面试题",'content':"面试题 基础题 进阶题 高阶题 "});index.add({'id':549,'href':'/note-cs/docs/basic/pl/lua/appendix/interview/','title':"面试题",'content':"面试题 基础题 进阶题 高阶题 "});index.add({'id':550,'href':'/note-cs/docs/basic/pl/ruby/appendix/interview/','title':"面试题",'content':"面试题 基础题 进阶题 高阶题 "});index.add({'id':551,'href':'/note-cs/docs/basic/pl/swift/appendix/interview/','title':"面试题",'content':"面试题 基础题 进阶题 高阶题 "});index.add({'id':552,'href':'/note-cs/docs/direction/be/proxy/mosn/','title':"MOSN",'content':"MOSN "});index.add({'id':553,'href':'/note-cs/docs/direction/be/microservices/servicecomb/','title':"ServiceComb",'content':"ServiceComb 子项目 ServiceComb 目前拥有三个主要的子项目\napache/servicecomb-java-chassis  开箱即用 Java 语言 微服务 SDK，含服务契约、编程模型、运行模型与通信模型四个部分，具备负载均衡、容错熔断、限流降级、调用链追踪等全面微服务治理能力，服务治理能力与业务逻辑隔离。\napache/servicecomb-service-center  基于 Etcd 的高性能、高可用、无状态的 Golang 版分布式服务注册与发现中心，可实时服务实例注册、实时服务实例推送和服务间契约测试等。\napache/servicecomb-pack  Apache ServiceComb Pack (原 ServiceComb Saga) 是提供了分布式事务最终一致性解决方案，用户只需要通过注解方式定义事务的执行方法以及撤销方法，ServiceComb Pack 框架会自动保证分布式事务执行的最终一致性。\n其他 apache/servicecomb-mesher  A high performance service mesh implementation written in go\nservicecomb-saga-actuator  Apache ServiceComb Saga Actuator https://servicecomb.apache.org/\n参考：\n 如何评价华为新开源的 ServiceComb 微服务框架？  "});index.add({'id':554,'href':'/note-cs/docs/direction/be/microservices/rpc/thrift/','title':"Thrift",'content':"Thrift 最初是由 Facebook 开发的内部系统跨语言的 RPC 框架，2007 年贡献给了 Apache 基金，成为 Apache 开源项目之一，支持多种语言。\n"});index.add({'id':555,'href':'/note-cs/docs/book/basic/pl/go-in-action/','title':"Go in Action",'content':"Go in Action \n作者 William Kennedy\n"});index.add({'id':556,'href':'/note-cs/docs/book/others/practical-vim/','title':"Practical Vim",'content':"Practical Vim, 2nd Edition \n作者 Drew Neil\n"});index.add({'id':557,'href':'/note-cs/docs/basic/algs/','title':"1.3 数据结构与算法",'content':"数据结构与算法 见：算法学习笔记\n"});index.add({'id':558,'href':'/note-cs/docs/direction/client/','title':"2.3 客户端",'content':"客户端 "});index.add({'id':559,'href':'/note-cs/docs/domain/ai/','title':"3.3 人工智能",'content':"人工智能 "});index.add({'id':560,'href':'/note-cs/docs/others/tool/','title':"4.3 工具",'content':"工具 "});index.add({'id':561,'href':'/note-cs/docs/book/basic/algs/','title':"5.1.3 数据结构与算法",'content':"数据结构与算法 "});index.add({'id':562,'href':'/note-cs/docs/book/fe/','title':"5.3 前端",'content':"前端 "});index.add({'id':563,'href':'/note-cs/docs/course/basic/algs/','title':"6.1.3 数据结构与算法",'content':"数据结构与算法 "});index.add({'id':564,'href':'/note-cs/docs/course/fe/','title':"6.3 前端",'content':"前端 "});index.add({'id':565,'href':'/note-cs/docs/direction/se/arch/scene/release/ab-testing/','title':"A/B 测试",'content':"A/B 测试 A/B testing\n 参考 "});index.add({'id':566,'href':'/note-cs/docs/direction/be/mq/activemq/','title':"ActiveMQ",'content':"ActiveMQ "});index.add({'id':567,'href':'/note-cs/docs/direction/fe/frame/angular/','title':"Angular",'content':"Angular "});index.add({'id':568,'href':'/note-cs/docs/others/skill/debug/','title':"Debug",'content':"Debug "});index.add({'id':569,'href':'/note-cs/docs/domain/cc/container/docker/dockerfile/','title':"Dockerfile",'content':"Dockerfile 教程 CMD # exec form, preferredCMD [\u0026#34;executable\u0026#34;,\u0026#34;param1\u0026#34;,\u0026#34;param2\u0026#34;]# shell formCMD command param1 param2# as default parameters to ENTRYPOINTCMD [\u0026#34;param1\u0026#34;,\u0026#34;param2\u0026#34;]# 下面两者是等价的CMD echo \u0026#34;hello cmd!\u0026#34;CMD [\u0026#34;/bin/bash\u0026#34;, \u0026#34;-c\u0026#34;, \u0026#34;echo \u0026#39;hello cmd!\u0026#39;\u0026#34;]docker run 时指定了命令或者有 ENTRYPOINT，那么 CMD 就会被覆盖\nDockerfile 文件中可以存在多个 CMD 指令，但仅有最后一个会生效。  ENTRYPOINT  docker run 使用 --entrypoint，则覆盖 Dockerfile 的 ENTRYPOINT 如何 ENTRYPOINT 使用中括号形式  docker run 带了参数，则参数会加给 ENTRYPOINT 定义了 CMD，则 CMD 的参数会加给 ENTRYPOINT    # exec form, preferredENTRYPOINT [\u0026#34;executable\u0026#34;, \u0026#34;param1\u0026#34;, \u0026#34;param2\u0026#34;]# shell formENTRYPOINT command param1 param2# ENTRYPOINT 使用中括号时，也可以直接指定命令# 而 CMD 不行，必须带上 shell 命令做前缀ENTRYPOINT [\u0026#34;/start.sh\u0026#34;]ENTRYPOINT [\u0026#34;/bin/bash\u0026#34;, \u0026#34;-C\u0026#34;, \u0026#34;/start.sh\u0026#34;]ENTRYPOINT /bin/bash -C \u0026#39;/start.sh\u0026#39; ENTRYPOINT 使用 shell 模式（非中括号），则 docker run 或者 CMD 的参数都无法传入。 Dockerfile 文件中可以存在多个 ENTRYPOINT 指令，但仅有最后一个会生效。   EXPOSE EXPOSE 只是声明容器应该打开的端口，并没有实际去打开\n当使用 -P 时，会使用 EXPOSE 指定的端口。\n\u0026ndash;expose 可以接受端口范围作为参数，比如 --expose=2000-3000\nADD 如果是 URL 或压缩包，会自动下载或自动解压。\nCOPY（优先使用 COPY，不使用 ADD） USER 为 RUN、CMD 和 ENTRYPOINT 执行 Shell 命令指定运行用户\nUSER\u0026lt;user\u0026gt;[:\u0026lt;usergroup\u0026gt;]USER\u0026lt;UID\u0026gt;[:\u0026lt;UID\u0026gt;]USERedisonzhouARG The ARG instruction defines a variable that users can pass at build-time to the builder with the docker build command using the \u0026ndash;build-arg = flag.\nFROMcentos:6# ARG \u0026lt;name\u0026gt;[=\u0026lt;default value\u0026gt;]ARG user # ARG user=rootUSER$user# docker build --build-arg user=edisonzhou Dockerfile .MAINTAINER 指明镜像维护着及其联系方式（一般是邮箱地址）\nMAINTAINER Edison Zhou edisonchou@hotmail.com\nMAINTAINER 并不推荐使用，更推荐使用 LABEL 来指定镜像作者\nLABEL maintainer=\u0026#34;edisonzhou.cn\u0026#34;  ENV WORKDIR 类似 cd\nVOLUME 指定容器挂载点到宿主机自动生成的目录或其他容器\nVOLUME [\u0026#34;/var/lib/mysql\u0026#34;]一般不会在 Dockerfile 中用到，更常见的还是在 docker run 的时候指定 -v 数据卷。   最佳实践 目标:\n 更快的构建速度 更小的 Docker 镜像大小 更少的 Docker 镜像层 充分利用镜像缓存 增加 Dockerfile 可读性 让 Docker 容器使用起来更简单  做法：\n  编写.dockerignore 文件\n  容器只运行单个应用\n  将多个 RUN 指令合并为一个\n  基础镜像的标签不要用 latest\n 如果你的确需要使用最新版的基础镜像，可以使用 latest 标签，否则的话，最好指定确定的镜像标签    每个 RUN 指令后删除多余文件\n# 假设我们更新了 apt-get 源，下载，解压并安装了一些软件包，它们都保存在 /var/lib/apt/lists/ 目录中 RUN apt-get update \\  \u0026amp;\u0026amp; apt-get install -y nodejs \\  # added lines \u0026amp;\u0026amp; rm -rf /var/lib/apt/lists/*   选择合适的基础镜像 (alpine 版本最好)\n alpine 是一个极小化的 Linux 发行版，只有 4MB，这让它非常适合作为基础镜像    设置 WORKDIR 和 CMD\nFROM node:7-alpine # WORKDIR 指令可以设置默认目录，也就是运行 RUN / CMD / ENTRYPOINT 指令的地方。 WORKDIR /app ADD . /app RUN npm install # CMD 指令可以设置容器创建是执行的默认命令。另外，你应该讲命令写在一个数组中，数组中每个元素为命令的每个单词。 CMD [\u0026#34;npm\u0026#34;, \u0026#34;start\u0026#34;]     使用 ENTRYPOINT (可选)\n  在 entrypoint 脚本中使用 exec\n在前文的 entrypoint 脚本中，我使用了 exec 命令运行 node 应用。 不使用 exec 的话，我们则不能顺利地关闭容器，因为 SIGTERM 信号会被 bash 脚本进程吞没。exec 命令启动的进程可以取代脚本进程，因此所有的信号都会正常工作。\n    优先使用 COPY，不使用 ADD\n  合理调整 COPY 与 RUN 的顺序\n 把变化最少的部分放在 Dockerfile 的前面，这样可以充分利用镜像缓存  # 源代码会经常变化，则每次构建镜像时都需要重新安装 NPM 模块，这显然不是我们希望看到的。 # 因此我们可以先拷贝 package.json，然后安装 NPM 模块，最后才拷贝其余的源代码。 # 这样的话，即使源代码变化，也不需要重新安装 NPM 模块 FROM node:7-alpine WORKDIR /app COPY package.json /app RUN npm install COPY . /app ENTRYPOINT [\u0026#34;./entrypoint.sh\u0026#34;] CMD [\u0026#34;start\u0026#34;]    设置默认的环境变量，映射端口和数据卷 使用 LABEL 设置镜像元数据 添加 HEALTHCHECK  参考：\n 你必须知道的 Dockerfile 如何编写最佳的 Dockerfile  "});index.add({'id':570,'href':'/note-cs/docs/direction/be/proxy/envoy/xds/eds/','title':"EDS",'content':"EDS "});index.add({'id':571,'href':'/note-cs/docs/domain/cc/service-mesh/istio/','title':"Istio",'content':"Istio 见：Istio 学习笔记\n"});index.add({'id':572,'href':'/note-cs/docs/basic/pl/java/','title':"Java",'content':"Java 见：Java 学习笔记\n"});index.add({'id':573,'href':'/note-cs/docs/domain/cc/kong/','title':"Kong",'content':"Kong Kong/kong  Kong is a cloud-native, fast, scalable, and distributed Microservice Abstraction Layer (also known as an API Gateway or API Middleware). Made available as an open-source project in 2015, its core values are high performance and extensibility.\n Quickstart "});index.add({'id':574,'href':'/note-cs/docs/domain/cc/kubernetes/','title':"Kubernetes",'content':"Kubernetes 见：Kubernetes 学习笔记\n"});index.add({'id':575,'href':'/note-cs/docs/basic/pl/php/appendix/snippet/simple-php-github-toc/','title':"Markdown 文件生成 TOC",'content':"生成 Github Readme 文件 TOC 目录 的简单脚本 \u0026lt;?php /** * site: https://github.com/xingshaocheng/simple-php-github-toc */ if(count($argv) \u0026lt; 2){ exit(\u0026#34;Please input github file url, eg \u0026#39;php github-toc.php https://github.com/xingshaocheng/architect-awesome/blob/master/README.md\u0026#39;.\\n\u0026#34;); } $url = $argv[1]; #$url = \u0026#34;https://github.com/xingshaocheng/architect-awesome/blob/master/README.md\u0026#34;;  function get_anchor($content){ preg_match_all(\u0026#34;/href=\\\u0026#34;(.*)\\\u0026#34;\u0026gt;/iUs\u0026#34;, $content, $anchor_arr); if(count($anchor_arr) \u0026gt; 0){ return $anchor_arr[1][0]; } return \u0026#34;\u0026#34;; } function get_title($content){ preg_match_all(\u0026#34;/a\\\u0026gt;(.*)$/iUs\u0026#34;, $content, $title_arr); if(count($title_arr) \u0026gt; 0){ return trim($title_arr[1][0]); } return \u0026#34;\u0026#34;; } $content = file_get_contents($url); preg_match_all(\u0026#34;/\u0026lt;article(.*)\u0026lt;\\/article\u0026gt;/iUs\u0026#34;, $content, $article); $article_html = $article[0][0]; preg_match_all(\u0026#34;/\u0026lt;h([1-6])\u0026gt;(.*)\u0026lt;\\/h[1-6]{1}\u0026gt;/iUs\u0026#34;, $article_html, $each_head); $len = count($each_head[0]); for($i = 0;$i \u0026lt; $len; $i++){ $level = $each_head[1][$i]; $each_content = $each_head[2][$i]; $anchor = get_anchor($each_content); $title = get_title($each_content); echo str_repeat(\u0026#34;\\t\u0026#34;,($level-1)),\u0026#34;* \u0026#34;,\u0026#34;[${title}](${url}${anchor})\\n\u0026#34;; } echo \u0026#34;\\nTOC generated by [simple-php-github-toc](https://github.com/xingshaocheng/simple-php-github-toc) \\n\\n\u0026#34;; 参考 xingshaocheng/simple-php-github-toc  "});index.add({'id':576,'href':'/note-cs/docs/domain/cc/oam/','title':"OAM",'content':"OAM (Open Application Model) OAM 是阿里巴巴和微软共同开源的云原生应用规范模型\nRudr 的应用程序有三个元素：Components（组件）、Configuration（配置）、Traits（特征）：\n组件定义一个或多个面向操作系统的容器镜像以及硬件需求，如 CPU、内存和存储等 配置处理运行时的参数，比如环境变量 特征声明运行时的属性，比如 Volume、Ingress、伸缩等等。\n2019 年 10 月宣布开源，同时开源了基于 OAM 的实现 Rudr。\nRudr  A Kubernetes implementation of the Open Application Model specification https://oam.dev\nOpenTelemetry  Specifications for OpenTelemetry https://opentelemetry.io\n参考：\n OAM（开放应用模型）—— 定义云原生应用标准的野望  "});index.add({'id':577,'href':'/note-cs/docs/domain/cc/others/paas/openshift/','title':"OpenShift",'content':"OpenShift Red Hat OpenShift is a leading hybrid cloud, enterprise Kubernetes application platform. OpenShift 在 Kubernetes 的基础上整合了应用的生命周期管理，包括 image 的编译，持续集成，部署以及更新。\nOpenshift 以前是 IaaS，现在 Openshift 自己宣称自己搭配 LXC 已经是 PaaS 了，VPS 不是云服务但可以类比为 IaaS。\nOpenshift 没有 root 权限 参考：openshift 和普通 vps 的区别在哪儿？\n"});index.add({'id':578,'href':'/note-cs/docs/domain/ai/frame/paddlepaddle/','title':"PaddlePaddle",'content':"PaddlePaddle  PArallel Distributed Deep LEarning: Machine Learning Framework from Industrial Practice （『飞桨』核心框架，深度学习 \u0026amp; 机器学习高性能单机、分布式训练和跨平台部署） http://www.paddlepaddle.org/\n"});index.add({'id':579,'href':'/note-cs/docs/direction/be/mq/rocketmq/','title':"RocketMQ",'content':"RocketMQ "});index.add({'id':580,'href':'/note-cs/docs/domain/cc/service-mesh/','title':"Service Mesh",'content':"Service Mesh Service Mesh Comparison "});index.add({'id':581,'href':'/note-cs/docs/direction/be/web-service/soa/','title':"SOA",'content':"SOA "});index.add({'id':582,'href':'/note-cs/docs/direction/be/web-service/soap/','title':"SOAP",'content':"SOAP "});index.add({'id':583,'href':'/note-cs/docs/direction/be/auth/sso/','title':"SSO",'content':"SSO (Single sign-on) "});index.add({'id':584,'href':'/note-cs/docs/domain/ai/frame/tensorflow/','title':"Tensorflow",'content':"Tensorflow  PArallel Distributed Deep LEarning: Machine Learning Framework from Industrial Practice （『飞桨』核心框架，深度学习 \u0026amp; 机器学习高性能单机、分布式训练和跨平台部署） http://www.paddlepaddle.org/\n教程 lyhue1991/eat_tensorflow2_in_30_days  tensorflow/models  Models and examples built with TensorFlow\naymericdamien/TensorFlow-Examples  TensorFlow Tutorial and Examples for Beginners (support TF v1 \u0026amp; v2)\n"});index.add({'id':585,'href':'/note-cs/docs/basic/os/android/basic/practice/','title':"实践",'content':"实践 "});index.add({'id':586,'href':'/note-cs/docs/basic/os/ios/basic/practice/','title':"实践",'content':"实践 "});index.add({'id':587,'href':'/note-cs/docs/basic/os/macos/basic/practice/','title':"实践",'content':"实践 "});index.add({'id':588,'href':'/note-cs/docs/basic/os/unix/basic/practice/','title':"实践",'content':"实践 "});index.add({'id':589,'href':'/note-cs/docs/basic/os/windows/basic/practice/','title':"实践",'content':"实践 "});index.add({'id':590,'href':'/note-cs/docs/basic/pl/csharp/basic/practice/','title':"实践",'content':"实践 "});index.add({'id':591,'href':'/note-cs/docs/basic/pl/kotlin/basic/practice/','title':"实践",'content':"实践 "});index.add({'id':592,'href':'/note-cs/docs/basic/pl/lua/basic/practice/','title':"实践",'content':"实践 "});index.add({'id':593,'href':'/note-cs/docs/basic/pl/ruby/basic/practice/','title':"实践",'content':"实践 "});index.add({'id':594,'href':'/note-cs/docs/basic/pl/scala/basic/practice/','title':"实践",'content':"Scala 实践 "});index.add({'id':595,'href':'/note-cs/docs/basic/pl/swift/basic/practice/','title':"实践",'content':"实践 "});index.add({'id':596,'href':'/note-cs/docs/direction/client/xiaochengxu/','title':"小程序",'content':"小程序 "});index.add({'id':597,'href':'/note-cs/docs/domain/ai/frame/','title':"框架",'content':"框架 "});index.add({'id':598,'href':'/note-cs/docs/basic/pl/scala/basic/practice/baidu/','title':"百度",'content':"百度 Scala 最佳实践 "});index.add({'id':599,'href':'/note-cs/docs/basic/pl/csharp/basic/practice/spec/','title':"编程规范",'content':"编程规范 "});index.add({'id':600,'href':'/note-cs/docs/domain/cc/virtual/','title':"虚拟化",'content':"虚拟化 "});index.add({'id':601,'href':'/note-cs/docs/direction/se/arch/scene/release/canary-rollouts/','title':"金丝雀发布",'content':"金丝雀发布 canary rollouts\n 参考 "});index.add({'id':602,'href':'/note-cs/docs/basic/pl/javascript/','title':"JavaScript",'content':"JavaScript "});index.add({'id':603,'href':'/note-cs/docs/basic/pl/kotlin/','title':"Kotlin",'content':"Kotlin 学习笔记 "});index.add({'id':604,'href':'/note-cs/docs/basic/pl/lua/','title':"Lua",'content':"Lua 学习笔记 "});index.add({'id':605,'href':'/note-cs/docs/basic/network/','title':"1.4 计算机网络",'content':"计算机网络 见：网络学习笔记\n"});index.add({'id':606,'href':'/note-cs/docs/direction/embedded/','title':"2.4 嵌入式",'content':"嵌入式开发 "});index.add({'id':607,'href':'/note-cs/docs/book/basic/network/','title':"5.1.4 计算机网络",'content':"计算机网络 "});index.add({'id':608,'href':'/note-cs/docs/book/security/','title':"5.4 安全",'content':"安全 "});index.add({'id':609,'href':'/note-cs/docs/course/basic/network/','title':"6.1.4 计算机网络",'content':"计算机网络 "});index.add({'id':610,'href':'/note-cs/docs/course/security/','title':"6.4 安全",'content':"安全 "});index.add({'id':611,'href':'/note-cs/docs/domain/cc/others/paas/cloud-foundry/','title':"Cloud Foundry",'content':"Cloud Foundry Cloud Foundry 提供了云、开发者框架和应用服务的选择，可以更快、更容易的构建、测试、发布和大规模部署应用程序。它是一个开源项目，可通过各种私有云发行版和公有云实例获得。\n组件 cloudfoundry/bosh  Cloud Foundry BOSH is an open source tool for release engineering, deployment, lifecycle management, and monitoring of distributed systems.\ncloudfoundry/cli  The official command line client for Cloud Foundry https://docs.cloudfoundry.org/cf-cli\ncloudfoundry/uaa  CloudFoundry User Account and Authentication (UAA) Server\n Cloud Foundry 缺点 诸如 Cloud Foundry 的 PaaS，用户必须为不同语言、不同框架区分不同的打包方式，这个打包过程是非常具有灾难性的。 而现实往往更糟糕，当在本地跑的好好的应用，由于和远端环境的不一致，在打包后却需要在云端各种调试，最终才能让应用 “平稳” 运行。\n而 Docker 的出现改变了一切，它凭借镜像解决了这个问题。Docker 一不做二不休，干脆把完整的操作系统目录也打包进去，如此高的集成度，保证了云端和本地环境的高度一致，并且随时随地轻易地移植。\n参考：\n Kubernetes 如何打赢容器之战？  "});index.add({'id':612,'href':'/note-cs/docs/domain/cc/container/docker/network/','title':"Docker 网络",'content':"Docker 网络 网络模式  bridge 模式  使用 –net=bridge 指定，默认   host 模式  使用 –net=host 指定 一些对安全性有求高并且不需要联网的应用可以使用 none 网络   none 模式  使用 –net=none 指定   container 模式  使用 –net=container:NAMEorID 指定    bridge 模式 Docker Daemon 启动时默认会创建 Docker0 这个网桥，网段为 172.17.0.0/16,\n宿主机 IP 为 172.17.0.1 , 作为这个虚拟子网的网关。\n创建网桥 新建一个名为 anyesu_net 网段为 172.18.0.0/16 的网桥：\ndocker network create --subnet=172.18.0.0/16 anyesu_net 启动容器时指定 --net anyesu_net 即可。\nhost 模式 优势 host 网络最大的好处就是性能\n劣势 host 网络不便之处就是考虑端口冲突问题\n参考：\n Docker 下的网络模式  "});index.add({'id':613,'href':'/note-cs/docs/basic/pl/objective-c/','title':"Objective-C",'content':"Objective-C 学习笔记 "});index.add({'id':614,'href':'/note-cs/docs/direction/be/proxy/envoy/xds/rds/','title':"RDS",'content':"RDS "});index.add({'id':615,'href':'/note-cs/docs/direction/be/microservices/rpc/tars/','title':"Tars",'content':"Tars - Total Application Framework TarsCloud/Tars 腾讯内部使用的 RPC 框架，于 2017 年对外开源。\n目前支持 C++, Java 和 NodeJs 三种语言。\n"});index.add({'id':616,'href':'/note-cs/docs/direction/be/web-service/wsdl/','title':"WSDL",'content':"WSDL "});index.add({'id':617,'href':'/note-cs/docs/direction/be/microservices/','title':"微服务",'content':"微服务 "});index.add({'id':618,'href':'/note-cs/docs/direction/be/mq/','title':"消息队列",'content':"消息队列 ZeroMQ 和 RabbitMQ/Kafka 不同，它只是一个异步消息库，在套接字的基础上提供了类似于消息代理的机制。使用 ZeroMQ 的话，需要对自己的业务代码进行改造，不利于服务解耦。\nRabbitMQ 支持 AMQP（二进制），STOMP（文本），MQTT（二进制），HTTP（里面包装其他协议）等协议。Kafka 使用自己的协议。\nKafka 自身服务和消费者都需要依赖 Zookeeper。\nRabbitMQ 在有大量消息堆积的情况下性能会下降，Kafka 不会。毕竟 AMQP 设计的初衷不是用来持久化海量消息的，而 Kafka 一开始是用来处理海量日志的。\n 常见消息队列实现 apache/kafka  apache/rocketmq  阿里 RocketMQ 是站在巨人的肩膀上（kafka）\nrabbitmq/rabbitmq-server  apache/activemq   ZeroMQ zeromq/libzmq  ZeroMQ core engine in C++, implements ZMTP/3.1\nzeromq/jeromq  Pure Java ZeroMQ\nzeromq/netmq  A 100% native C# implementation of ZeroMQ for .NET\nzeromq/pyzmq  PyZMQ: Python bindings for zeromq\n 参考  RabbitMQ, ZeroMQ, Kafka 是一个层级的东西吗？  "});index.add({'id':619,'href':'/note-cs/docs/direction/be/proxy/envoy/version/1.13/','title':"1.13",'content':"1.13 "});index.add({'id':620,'href':'/note-cs/docs/basic/pl/','title':"1.5 编程语言",'content':"编程语言 函数式编程 教程 MostlyAdequate/mostly-adequate-guide  Mostly adequate guide to FP (in javascript)\n中文版 llh911001/mostly-adequate-guide-chinese 点击阅读\n"});index.add({'id':621,'href':'/note-cs/docs/direction/security/','title':"2.5 安全",'content':"安全 "});index.add({'id':622,'href':'/note-cs/docs/book/basic/pl/','title':"5.1.5 编程语言",'content':"编程语言 Go    书名 作者 / 译者 出版时间 语言版本 豆瓣评分 其他说明     Go in Action         参考：\n golang/go/wiki/Books dariubs/GoBooks  List of Golang books    "});index.add({'id':623,'href':'/note-cs/docs/book/se/','title':"5.5 软件工程",'content':"软件工程 "});index.add({'id':624,'href':'/note-cs/docs/course/basic/pl/','title':"6.1.5 编程语言",'content':"编程语言 "});index.add({'id':625,'href':'/note-cs/docs/course/se/','title':"6.5 软件工程",'content':"软件工程 "});index.add({'id':626,'href':'/note-cs/docs/domain/cc/others/paas/appfog/','title':"AppFog",'content':"AppFog "});index.add({'id':627,'href':'/note-cs/docs/direction/be/distributed/consul/','title':"Consul",'content':"Consul "});index.add({'id':628,'href':'/note-cs/docs/direction/be/distributed/etcd/','title':"Etcd",'content':"Etcd "});index.add({'id':629,'href':'/note-cs/docs/domain/bigdata/flink/','title':"Flink",'content':"Flink "});index.add({'id':630,'href':'/note-cs/docs/domain/bigdata/hadoop/','title':"Hadoop",'content':"Hadoop HDFS Hadoop Distributed File System，是 Hadoop 的分布式文件系统\n每台机器上运行一个 DataNode 进程，负责管理一部分数据。\n有一台机器上运行了 NameNode 进程，负责管理整个 HDFS 集群的这么一个进程，里面存储了 HDFS 集群的所有元数据\n每次内存里改完了，写一条 edits log，元数据修改的操作日志到磁盘文件里，不修改磁盘文件内容，就是顺序追加\n每次 NameNode 重启的时候，把 edits log 里的操作日志读到内存里，就可以恢复元数据\nYARN MapReduce "});index.add({'id':631,'href':'/note-cs/docs/domain/bigdata/hadoop/hbase/','title':"HBase",'content':"HBase "});index.add({'id':632,'href':'/note-cs/docs/domain/bigdata/hadoop/hdfs/','title':"HDFS",'content':"HDFS "});index.add({'id':633,'href':'/note-cs/docs/domain/bigdata/hadoop/mapreduce/','title':"MapReduce",'content':"MapReduce "});index.add({'id':634,'href':'/note-cs/docs/direction/be/microservices/rpc/motan/','title':"Motan",'content':"Motan 微博内部使用的 RPC 框架，于 2016 年对外开源，仅支持 Java 语言。\n"});index.add({'id':635,'href':'/note-cs/docs/basic/pl/php/','title':"PHP",'content':"PHP "});index.add({'id':636,'href':'/note-cs/docs/direction/be/mq/rabbitmq/','title':"RabbitMQ",'content':"RabbitMQ RabbitMQ 是一个 AMQP 实现，传统的 messaging queue 系统实现，基于 Erlang。老牌 MQ 产品了。AMQP 协议更多用在企业系统内，对数据一致性、稳定性和可靠性要求很高的场景，对性能和吞吐量还在其次。\n"});index.add({'id':637,'href':'/note-cs/docs/basic/db/redis/','title':"Redis",'content':"Redis "});index.add({'id':638,'href':'/note-cs/docs/domain/bigdata/spark/','title':"Spark",'content':"Spark "});index.add({'id':639,'href':'/note-cs/docs/direction/be/frame/php/swoole/','title':"Swoole",'content':"Swoole Swoole 使 PHP 开发人员可以编写高性能高并发的 TCP、UDP、Unix Socket、HTTP、 WebSocket 等服务，让 PHP 不再局限于 Web 领域。\nswoole/swoole-src  Coroutine-based concurrency library for PHP https://www.swoole.co.uk\n"});index.add({'id':640,'href':'/note-cs/docs/basic/db/tidb/','title':"TiDB",'content':"TiDB pingcap/tidb TiDB is a distributed HTAP database compatible with the MySQL protocol https://pingcap.com\nTiDB (\u0026ldquo;Ti\u0026rdquo; stands for Titanium) is an open-source NewSQL database that supports Hybrid Transactional and Analytical Processing (HTAP) workloads. It is MySQL compatible and features horizontal scalability, strong consistency, and high availability.\nTiDB 是 PingCAP 公司设计的开源分布式 HTAP (Hybrid Transactional and Analytical Processing) 数据库，结合了传统的 RDBMS 和 NoSQL 的最佳特性。TiDB 兼容 MySQL，支持无限的水平扩展，具备强一致性和高可用性。TiDB 的目标是为 OLTP (Online Transactional Processing) 和 OLAP (Online Analytical Processing) 场景提供一站式的解决方案。\n"});index.add({'id':641,'href':'/note-cs/docs/direction/be/web-service/uudi/','title':"UUDI",'content':"UUDI "});index.add({'id':642,'href':'/note-cs/docs/direction/be/distributed/zookeeper/','title':"Zookeeper",'content':"Zookeeper "});index.add({'id':643,'href':'/note-cs/docs/direction/be/distributed/consistent-hashing/','title':"一致性哈希",'content':"一致性哈希 这篇论文中提出了一致性 hash 的概念。\nincubator-brpc doc - 一致性哈希\n一致性 hash 满足以下四个性质：\n 平衡性 (Balance) : 每个节点被选到的概率是 O (1/n)。 单调性 (Monotonicity) : 当新节点加入时， 不会有请求在老节点间移动， 只会从老节点移动到新节点。当有节点被删除时，也不会影响落在别的节点上的请求。 分散性 (Spread) : 当上游的机器看到不同的下游列表时 (在上线时及不稳定的网络中比较常见), 同一个请求尽量映射到少量的节点中。 负载 (Load) : 当上游的机器看到不同的下游列表的时候， 保证每台下游分到的请求数量尽量一致。  "});index.add({'id':644,'href':'/note-cs/docs/basic/os/android/basic/snippet/','title':"代码片段",'content':"代码片段 "});index.add({'id':645,'href':'/note-cs/docs/basic/os/ios/basic/snippet/','title':"代码片段",'content':"代码片段 "});index.add({'id':646,'href':'/note-cs/docs/basic/os/macos/basic/snippet/','title':"代码片段",'content':"代码片段 "});index.add({'id':647,'href':'/note-cs/docs/basic/os/unix/basic/snippet/','title':"代码片段",'content':"代码片段 "});index.add({'id':648,'href':'/note-cs/docs/basic/os/windows/basic/snippet/','title':"代码片段",'content':"代码片段 "});index.add({'id':649,'href':'/note-cs/docs/basic/pl/c/basic/snippet/','title':"代码片段",'content':"代码片段 "});index.add({'id':650,'href':'/note-cs/docs/basic/pl/cpp/basic/snippet/','title':"代码片段",'content':"代码片段 "});index.add({'id':651,'href':'/note-cs/docs/basic/pl/csharp/basic/practice/snippet/','title':"代码片段",'content':"代码片段 "});index.add({'id':652,'href':'/note-cs/docs/basic/pl/kotlin/basic/snippet/','title':"代码片段",'content':"代码片段 "});index.add({'id':653,'href':'/note-cs/docs/basic/pl/lua/basic/snippet/','title':"代码片段",'content':"代码片段 "});index.add({'id':654,'href':'/note-cs/docs/basic/pl/php/appendix/snippet/','title':"代码片段",'content':"代码片段 "});index.add({'id':655,'href':'/note-cs/docs/basic/pl/ruby/basic/snippet/','title':"代码片段",'content':"代码片段 "});index.add({'id':656,'href':'/note-cs/docs/basic/pl/rust/appendix/snippet/','title':"代码片段",'content':"代码片段 "});index.add({'id':657,'href':'/note-cs/docs/basic/pl/scala/basic/snippet/','title':"代码片段",'content':"代码片段 "});index.add({'id':658,'href':'/note-cs/docs/basic/pl/swift/basic/snippet/','title':"代码片段",'content':"代码片段 "});index.add({'id':659,'href':'/note-cs/docs/direction/be/distributed/transaction/','title':"分布式事务",'content':"分布式事务 微服务化带来的分布式事务问题 每一个服务内部的数据一致性仍由本地事务来保证。而整个业务层面的全局数据一致性要如何保障呢？\n解决方案 分布式事务的实现主要有以下 5 种方案：\n XA 方案 TCC 方案 本地消息表 可靠消息最终一致性方案 最大努力通知方案  如果你真的被问到，可以这么说，我们某某特别严格的场景，用的是 TCC 来保证强一致性；然后其他的一些场景基于阿里的 RocketMQ 来实现分布式事务。\n你找一个严格资金要求绝对不能错的场景，你可以说你是用的 TCC 方案；如果是一般的分布式事务场景，订单插入之后要调用库存服务更新库存，库存数据没有资金那么的敏感，可以用可靠消息最终一致性方案。\n友情提示一下，RocketMQ 3.2.6 之前的版本，是可以按照上面的思路来的，但是之后接口做了一些改变，我这里不再赘述了。\n当然如果你愿意，你可以参考可靠消息最终一致性方案来自己实现一套分布式事务，比如基于 RocketMQ 来玩儿。\n参考：\n 分布式事务了解吗？你们是如何解决分布式事务问题的？  XA 方案 两阶段提交方案\n有一个事务管理器的概念，负责协调多个数据库（资源管理器）的事务，事务管理器先问问各个数据库你准备好了吗？ 如果每个数据库都回复 ok，那么就正式提交事务，在各个数据库上执行操作；如果任何其中一个数据库回答不 ok，那么就回滚事务。\n这种分布式事务方案，比较适合单块应用里，跨多个库的分布式事务，而且因为严重依赖于数据库层面来搞定复杂的事务，效率很低，绝对不适合高并发的场景。\n如果要玩儿，那么基于 Spring + JTA 就可以搞定，自己随便搜个 demo 看看就知道了。\n这个方案，我们很少用，一般来说某个系统内部如果出现跨多个库的这么一个操作，是不合规的。\n TCC 这种方案说实话几乎很少人使用， 因为这个事务回滚实际上是严重依赖于你自己写代码来回滚和补偿了，会造成补偿代码巨大，非常之恶心，业务代码是很难维护的。\n比如说我们，一般来说跟钱相关的，跟钱打交道的，支付、交易相关的场景，我们会用 TCC，严格保证分布式事务要么全部成功，要么全部自动回滚，严格保证资金的正确性，保证在资金上不会出现问题。\n而且最好是你的各个业务执行的时间都比较短。\nTCC 分布式事务框架，比如国内开源的\n ByteTCC himly tcc-transaction  Try 首先你的业务的主流程以及各个接口提供的业务含义，不是说直接完成那个业务操作，而是完成一个 Try 的操作。\n这个操作，一般都是锁定某个资源，设置一个预备类的状态，冻结部分数据，等等，大概都是这类操作。\nConfirm Cancel 参考：\n 拜托，面试请不要再问我 TCC 分布式事务的实现原理！   本地消息表 本地消息表其实是国外的 ebay 搞出来的这么一套思想。\n这个大概意思是这样的：\n A 系统在自己本地一个事务里操作同时，插入一条数据到消息表； 接着 A 系统将这个消息发送到 MQ 中去； B 系统接收到消息之后，在一个事务里，往自己本地消息表里插入一条数据，同时执行其他的业务操作，如果这个消息已经被处理过了，那么此时这个事务会回滚，这样保证不会重复处理消息； B 系统执行成功之后，就会更新自己本地消息表的状态以及 A 系统消息表的状态； 如果 B 系统处理失败了，那么就不会更新消息表状态，那么此时 A 系统会定时扫描自己的消息表，如果有未处理的消息，会再次发送到 MQ 中去，让 B 再次处理； 这个方案保证了最终一致性，哪怕 B 事务失败了，但是 A 会不断重发消息，直到 B 那边成功为止。  这个方案说实话最大的问题就在于严重依赖于数据库的消息表来管理事务啥的，如果是高并发场景咋办呢？咋扩展呢？所以一般确实很少用。\n 可靠消息最终一致性方案 这个的意思，就是干脆不要用本地的消息表了，直接基于 MQ 来实现事务。比如阿里的 RocketMQ 就支持消息事务。\n大概的意思就是：\n A 系统先发送一个 prepared 消息到 mq，如果这个 prepared 消息发送失败那么就直接取消操作别执行了； 如果这个消息发送成功过了，那么接着执行本地事务，如果成功就告诉 mq 发送确认消息，如果失败就告诉 mq 回滚消息； 如果发送了确认消息，那么此时 B 系统会接收到确认消息，然后执行本地的事务； mq 会自动定时轮询所有 prepared 消息回调你的接口，问你，这个消息是不是本地事务处理失败了，所以没发送确认的消息，是继续重试还是回滚？一般来说这里你就可以查下数据库看之前本地事务是否执行，如果回滚了，那么这里也回滚吧。这个就是避免可能本地事务执行成功了，而确认消息却发送失败了。 这个方案里，要是系统 B 的事务失败了咋办？重试咯，自动不断重试直到成功，如果实在是不行，要么就是针对重要的资金类业务进行回滚，比如 B 系统本地回滚后，想办法通知系统 A 也回滚；或者是发送报警由人工来手工回滚和补偿。 这个还是比较合适的，目前国内互联网公司大都是这么玩儿的，要不你就用 RocketMQ 支持的，要不你就自己基于类似 ActiveMQ？RabbitMQ？自己封装一套类似的逻辑出来，总之思路就是这样子的。   最大努力通知方案 这个方案的大致意思就是：\n 系统 A 本地事务执行完之后，发送个消息到 MQ； 这里会有个专门消费 MQ 的最大努力通知服务，这个服务会消费 MQ 然后写入数据库中记录下来，或者是放入个内存队列也可以，接着调用系统 B 的接口； 要是系统 B 执行成功就 ok 了；要是系统 B 执行失败了，那么最大努力通知服务就定时尝试重新调用系统 B，反复 N 次，最后还是不行就放弃。   开源实现 seata/seata  TXC/GTS/Fescar/Seata 一脉相承\n 2014 年，阿里中间件团队发布 TXC（Taobao Transaction Constructor），为集团内应用提供分布式事务服务。 2016 年，TXC 经过产品化改造，以 GTS（Global Transaction Service） 的身份登陆阿里云，成为当时业界唯一一款云上分布式事务产品，在阿云里的公有云、专有云解决方案中，开始服务于众多外部客户。 2019 年起，基于 TXC 和 GTS 的技术积累，阿里中间件团队发起了开源项目 Fescar（Fast \u0026amp; EaSy Commit And Rollback, FESCAR），和社区一起建设这个分布式事务解决方案。 开源分布式事务 Fescar 更名为 Seata  华为 DTM 分布式事务管理中间件（Distributed Transaction Management）是一款用于解决分布式环境下事务一致性问题的产品。在复杂环境下，事务可能会出现的各种异常，DTM 能够将开发者从处理这种异常中解放出来，聚焦于业务逻辑本身。\nDTM 支持 TCC（Try-Confirm-Cancel）事务模型，支持以注解的方式定义事务信息，实现事务高效便捷的接入。此外，DTM 具有处理高并发事务请求的能力，支持自动部署、弹性伸缩等全生命周期运维管控能力。\n参考  如何理解 TCC 分布式事务？  "});index.add({'id':660,'href':'/note-cs/docs/direction/be/distributed/','title':"分布式系统",'content':"分布式系统 Distributed System\n问答 分布式与集群的区别 参考：\n 知乎：分布式与集群的区别是什么？ 分布式架构（1） - 大白话讲解：分布式与集群的区别是什么？  "});index.add({'id':661,'href':'/note-cs/docs/others/tool/study/coding-online/','title':"在线编程",'content':"在线编程 "});index.add({'id':662,'href':'/note-cs/docs/direction/be/proxy/envoy/version/','title':"版本",'content':"版本 "});index.add({'id':663,'href':'/note-cs/docs/basic/pl/python/','title':"Python",'content':"Python 见：Python 学习笔记\n"});index.add({'id':664,'href':'/note-cs/docs/basic/pl/ruby/','title':"Ruby",'content':"Ruby 学习笔记 "});index.add({'id':665,'href':'/note-cs/docs/basic/db/','title':"1.6 数据库",'content':"数据库 OLTP vs OLAP OLTP (On-line Transaction Processing) is involved in the operation of a particular system.\nOLAP (On-line Analytical Processing) deals with Historical Data or Archival Data.\n参考：\n What are OLTP and OLAP. What is the difference between them?  OLAP prestodb/presto  The official home of the Presto distributed SQL query engine for big data http://prestodb.github.io\nPresto 是 Facebook 开发的分布式大数据 SQL 查询引擎，专门进行快速数据分析。\n特点：\n  可以将多个数据源的数据进行合并，可以跨越整个组织进行分析。\n  直接从 HDFS 读取数据，在使用前不需要大量的 ETL 操作。\n  apache/druid  Apache Druid: a high performance real-time analytics database. https://druid.apache.org/\nDruid 是广告分析公司 Metamarkets 开发的一个用于大数据实时查询和分析的分布式实时处理系统，主要用于广告分析，互联网广告系统监控、度量和网络监控。\napache/impala  Apache Impala https://impala.apache.org\ncloudera/Impala  Real-time Query for Hadoop; mirror of Apache Impala http://impala.io\n apache/kylin  Apache Kylin is an open source Distributed Analytics Engine, contributed by eBay Inc., provides SQL interface and multi-dimensional analysis (OLAP) on Hadoop supporting extremely large datasets. http://kylin.apache.org.\nApache Kylin 最初由 eBay 开发并贡献至开源社区的分布式分析引擎，提供 Hadoop 之上的 SQL 查询接口及多维分析（OLAP）能力以支持超大规模数据。\napache/hive  Apache Hive https://hive.apache.org/\nThe Apache Hive (TM) data warehouse software facilitates reading, writing, and managing large datasets residing in distributed storage using SQL. Built on top of Apache Hadoop (TM).\n"});index.add({'id':666,'href':'/note-cs/docs/direction/mp/','title':"2.6 中台",'content':"中台 "});index.add({'id':667,'href':'/note-cs/docs/book/basic/db/','title':"5.1.6 数据库",'content':"数据库 "});index.add({'id':668,'href':'/note-cs/docs/book/cc/','title':"5.6 云计算",'content':"云计算 "});index.add({'id':669,'href':'/note-cs/docs/course/basic/db/','title':"6.1.6 数据库",'content':"数据库 "});index.add({'id':670,'href':'/note-cs/docs/course/cc/','title':"6.6 云计算",'content':"云计算 "});index.add({'id':671,'href':'/note-cs/docs/basic/pl/rust/','title':"Rust",'content':"Rust "});index.add({'id':672,'href':'/note-cs/docs/direction/be/mq/zeromq/','title':"ZeroMQ",'content':"ZeroMQ ZeroMQ 只是一个网络编程的 Pattern 库，将常见的网络请求形式（分组管理，链接管理，发布订阅等）模式化、组件化，简而言之 socket 之上、MQ 之下。对于 MQ 来说，网络传输只是它的一部分，更多需要处理的是消息存储、路由、Broker 服务发现和查找、事务、消费模式（ack、重投等）、集群服务等。\n"});index.add({'id':673,'href':'/note-cs/docs/direction/se/arch/scene/release/','title':"发布形式",'content':"发布形式  参考 "});index.add({'id':674,'href':'/note-cs/docs/domain/ai/deep-learning/tutorial/','title':"教程",'content':"教程 基础 《深度学习》(花书) MingchaoZhu/DeepLearning  Python for《Deep Learning》，该书为《深度学习》(花书) 数学推导、原理剖析与源码级别代码实现\n 进阶  高阶 "});index.add({'id':675,'href':'/note-cs/docs/domain/ai/tutorial/','title':"教程",'content':"教程 基础 [book]dod-o/statistical-learning-method_code  手写实现李航《统计学习方法》书中全部算法\n[video]shuhuai007/machine-learning-session  【机器学习】【白板推导系列】【合集 1 ～ 23】\ntsyw/MachineLearningNotes  My personal notes\nBilibili - 机器学习白板系列\n [video]机器学习教程（小象学院）  josephmisiti/awesome-machine-learning   ZuzooVn/machine-learning-for-software-engineers  A complete daily plan for studying to become a machine learning engineer.\n ageron/handson-ml  A series of Jupyter notebooks that walk you through the fundamentals of Machine Learning and Deep Learning in python using Scikit-Learn and TensorFlow.\n fighting41love/funNLP  NLP 民工的乐园：几乎最全的中文 NLP 资源库\n eriklindernoren/ML-From-Scratch  Machine Learning From Scratch. Bare bones NumPy implementations of machine learning models and algorithms with a focus on accessibility. Aims to cover everything from linear regression to deep learning.\n trekhleb/homemade-machine-learning  Python examples of popular machine learning algorithms with interactive Jupyter demos and math being explained.\n kailashahirwar/cheatsheets-ai  Essential Cheat Sheets for deep learning and machine learning researchers\nhttps://medium.com/@kailashahirwar/essential-cheat-sheets-for-machine-learning-and-deep-learning-researchers-efb6a8ebd2e5\nhttps://aicheatsheets.com\n rasbt/python-machine-learning-book  The \u0026ldquo;Python Machine Learning (1st edition)\u0026rdquo; book code repository and info resource\n afshinea/stanford-cs-229-machine-learning !Github stars\nVIP cheatsheets for Stanford\u0026rsquo;s CS 229 Machine Learning https://stanford.edu/~shervine/teaching/cs-229/\n ujjwalkarn/Machine-Learning-Tutorials  machine learning and deep learning tutorials, articles and other resources http://ujjwalkarn.github.io/Machine-Learning-Tutorials/\n janishar/mit-deep-learning-book-pdf  MIT Deep Learning Book in PDF format (complete and parts) by Ian Goodfellow, Yoshua Bengio and Aaron Courville\n 进阶 [book]christophm/interpretable-ml-book  Book about interpretable machine learning https://christophm.github.io/interpretable-ml-book/\n[book]mingchaozhu/interpretablemlbook  该书为《Interpretable Machine Learning》中文版。该书原作者是 Christoph Molnar，他是一名统计学家和机器学习者 @christophM。该书的项目 地址，这是一个很棒的工作。你可以在 releases 中下载本书英文版 pdf。\n我是 朱明超，同样，我也是一名机器学习者。关于此书的译本，我在翻译后进行了校正。如果你在英文原书中看到某些表述问题，可以参考我在中文书里的描述。当然，由于英文原书是较早前出版的，本书并不是完全基于英文书，作者 Christoph Molnar 在《Interpretable Machine Learning》的 网页版 中对内容不断填充，所以中文版的翻译主要基于网页版 (内容会多于英文书)。你可以在 releases 中下载本书中文版 pdf。\n hangtwenty/dive-into-machine-learning  Dive into Machine Learning with Python Jupyter notebook and scikit-learn! http://hangtwenty.github.io/dive-into-machine-learning/\n RedditSota/state-of-the-art-result-for-machine-learning-problems  This repository provides state of the art (SoTA) results for all machine learning problems.\n rushter/MLAlgorithms  Minimal and clean examples of machine learning algorithms implementations\n 高阶 "});index.add({'id':676,'href':'/note-cs/docs/direction/se/arch/scene/seckill/','title':"秒杀",'content':"秒杀  参考 qiurunze123/miaosha  秒杀系统设计与实现。互联网工程师进阶与分析\ncodingXiaxw/seckill  Java 高并发秒杀系统 API\nGuoZhaoran/spikeSystem  一个秒杀系统的例子分析\nzaiyunduan123/springboot-seckill  基于 SpringBoot + MySQL + Redis + RabbitMQ + Guava 开发的高并发商品限时秒杀系统\n 前端技术 ：Bootstrap + jQuery + Thymeleaf 后端技术 ：SpringBoot + MyBatis + MySQL 中间件技术 : Druid + Redis + RabbitMQ + Guava  "});index.add({'id':677,'href':'/note-cs/docs/basic/compile/','title':"1.7 编译原理",'content':"编译原理 "});index.add({'id':678,'href':'/note-cs/docs/direction/se/arch/','title':"2.7 架构设计",'content':"架构设计 "});index.add({'id':679,'href':'/note-cs/docs/book/basic/compile/','title':"5.1.7 编译原理",'content':"编译原理 "});index.add({'id':680,'href':'/note-cs/docs/book/bigdata/','title':"5.7 大数据",'content':"大数据 "});index.add({'id':681,'href':'/note-cs/docs/course/basic/compile/','title':"6.1.7 编译原理",'content':"编译原理 "});index.add({'id':682,'href':'/note-cs/docs/course/bigdata/','title':"6.7 大数据",'content':"大数据 "});index.add({'id':683,'href':'/note-cs/docs/basic/db/cassandra/','title':"Cassandra",'content':"Cassandra "});index.add({'id':684,'href':'/note-cs/docs/basic/pl/scala/','title':"Scala",'content':"Scala 学习笔记 "});index.add({'id':685,'href':'/note-cs/docs/basic/pl/c/appendix/attention/','title':"关注",'content':"关注 torvalds/linux  Linux kernel source tree\nantirez/redis  Redis is an in-memory database that persists on disk. The data model is key-value, but many different kind of values are supported: Strings, Lists, Sets, Sorted Sets, Hashes, Streams, HyperLogLogs, Bitmaps. http://redis.io\n"});index.add({'id':686,'href':'/note-cs/docs/basic/pl/cpp/appendix/attention/','title':"关注",'content':"关注 google/glog  C++ implementation of the Google logging module\ngRPC  gRPC is a modern, open source, high-performance remote procedure call (RPC) framework that can run anywhere. gRPC enables client and server applications to communicate transparently, and simplifies the building of connected systems.\ngrpc.io\n web ipkn/crow  Crow is very fast and easy to use C++ micro web framework (inspired by Python Flask)\n"});index.add({'id':687,'href':'/note-cs/docs/basic/pl/javascript/appendix/attention/','title':"关注",'content':"关注 octokit/rest.js  GitHub REST API client for JavaScript https://octokit.github.io/rest.js/\n"});index.add({'id':688,'href':'/note-cs/docs/basic/pl/rust/appendix/attention/','title':"关注",'content':"关注 rust-lang/rust  Empowering everyone to build reliable and efficient software. https://www.rust-lang.org\nredox-os/redox  Redox is an operating system written in Rust\nservo/servo  The Servo Browser Engine https://servo.org/\nrajasekarv/vega  A new arguably faster implementation of Apache Spark from scratch in Rust\n web framework yewstack/yew  Rust / Wasm framework for building client web apps https://yew.rs\nSergioBenitez/Rocket  A web framework for Rust. https://rocket.rs\nactix/actix-web  Actix web is a small, pragmatic, and extremely fast rust web framework.\n 工具 sharkdp/fd  A simple, fast and user-friendly alternative to \u0026lsquo;find\u0026rsquo;\nogham/exa  A modern version of ‘ls’.\n 其他 swc-project/swc  Super-fast typescript / javascript compiler written in rust https://swc-project.github.io\ntokio-rs/tokio  A runtime for writing reliable, asynchronous, and slim applications with the Rust programming language.\nvaleriansaliou/sonic  Fast, lightweight \u0026amp; schema-less search backend. An alternative to Elasticsearch that runs on a few MBs of RAM. https://crates.io/crates/sonic-server\n"});index.add({'id':689,'href':'/note-cs/docs/basic/pl/scala/appendix/attention/','title':"关注",'content':"关注 akka/akka  Build highly concurrent, distributed, and resilient message-driven applications on the JVM https://akka.io\n"});index.add({'id':690,'href':'/note-cs/docs/domain/ai/attention/','title':"关注",'content':"关注 机器学习 tensorflow/tensorflow  scikit-learn/scikit-learn  scikit-learn: machine learning in Python https://scikit-learn.org\nphp-ai/php-ml  PHP-ML - Machine Learning library for PHP https://php-ml.org/\n 深度学习 paddlepaddle/paddle   机器人 gunthercox/ChatterBot  ChatterBot is a machine learning, conversational dialog engine for creating chat bots https://chatterbot.readthedocs.io\n"});index.add({'id':691,'href':'/note-cs/docs/domain/cc/cn/attention/','title':"关注",'content':"关注 cncf/landscape  The Cloud Native Interactive Landscape filters and sorts hundreds of projects and products, and shows details including GitHub stars, funding or market cap, first and last commits, contributor counts, headquarters location, and recent tweets. https://l.cncf.io\nTrail Map CNCF Cloud Native Landscape \nCNCF Serverless Landscape \n dragonflyoss/Dragonfly  Dragonfly is an intelligent P2P based image and file distribution system.\nhttps://d7y.io\n"});index.add({'id':692,'href':'/note-cs/docs/direction/se/arch/scene/','title':"场景",'content':"场景 "});index.add({'id':693,'href':'/note-cs/docs/direction/se/arch/scene/cache/','title':"缓存",'content':"缓存 热点数据集中失效问题\n 设置不同的失效时间 互斥锁  缓存穿透 查询不存在的数据\n缓存雪崩 当某一时刻发生大规模的缓存失效的情况，比如你的缓存服务宕机了，会有大量的请求进来直接打到 DB 上面。结果就是 DB 称不住，挂掉。\n解决  事前：使用集群缓存，保证缓存服务的高可用 事中：ehcache 本地缓存 + Hystrix 限流 \u0026amp; 降级，避免 MySQL 被打死 事后：开启 Redis 持久化机制，尽快恢复缓存集群  参考：\n ehcache/ehcache3    缓存击穿 在平常高并发的系统中，大量的请求同时查询一个 key 时，此时这个 key 正好失效了， 就会导致大量的请求都打到数据库上面去。\n缓存击穿实际上是缓存雪崩的一个特例\n解决 问题是多个线程同时去查询数据库的这条数据， 我们可以在第一个查询数据的请求上使用一个互斥锁来锁住它。 其他的线程走到这一步拿不到锁就等着，等第一个线程查询到了数据，然后做缓存。 后面的线程进来发现已经有缓存了，就直接走缓存。\n"});index.add({'id':694,'href':'/note-cs/docs/basic/pl/swift/','title':"Swift",'content':"Swift 学习笔记 "});index.add({'id':695,'href':'/note-cs/docs/direction/se/','title':"2.8 软件工程",'content':"软件工程  参考 "});index.add({'id':696,'href':'/note-cs/docs/book/ai/','title':"5.8 人工智能",'content':"人工智能 "});index.add({'id':697,'href':'/note-cs/docs/course/ai/','title':"6.8 人工智能",'content':"人工智能 "});index.add({'id':698,'href':'/note-cs/docs/direction/be/auth/','title':"认证与授权",'content':"认证与授权 "});index.add({'id':699,'href':'/note-cs/docs/book/others/','title':"5.9 其他",'content':"其他 "});index.add({'id':700,'href':'/note-cs/docs/course/others/','title':"6.9 其他",'content':"其他 "});index.add({'id':701,'href':'/note-cs/docs/direction/se/arch/tutorial/','title':"教程",'content':"教程 基础 系统设计入门  学习如何设计可扩展的系统将会有助于你成为一个更好的工程师。\n系统设计是一个很宽泛的话题。在互联网上，关于系统设计原则的资源也是多如牛毛。\n这个仓库就是这些资源的组织收集，它可以帮助你学习如何构建可扩展的系统。\n 进阶 "});index.add({'id':702,'href':'/note-cs/docs/domain/cc/container/docker/tutorial/','title':"教程",'content':"Docker 教程 play-with-docker/play-with-docker  Play With Docker gives you the experience of having a free Alpine Linux Virtual Machine in the cloud where you can build and run Docker containers and even create clusters with Docker features like Swarm Mode.\nUnder the hood DIND or Docker-in-Docker is used to give the effect of multiple VMs/PCs.\nA live version is available at: http://play-with-docker.com/\n"});index.add({'id':703,'href':'/note-cs/docs/direction/be/frame/','title':"框架",'content':"后端框架 "});index.add({'id':704,'href':'/note-cs/docs/direction/be/mq/mqtt/','title':"MQTT",'content':"MQTT mqtt 各种 broker 如何选择？\nAgent 和 Broker 的差别是什么？\n 经纪人（Broker）：是为促成他人交易，充当订约居间人，为委托方提供订约的信息、机会和条件的主体。  Broker 是一个独立主体，但没有自主决策能力，只负责订约过程。   代理人（Agent）：是行使被代理者的权力，完成相关的使命或者任务主体。  Agent 是一个独立主体，负责完成任务但不负责执行任务，Agent 具有一定的自主决策能力，如对服务请求的选择。   代理（Proxy）是指行为代理，不是一个主体。  Proxy 是完全的传递者，如请求和响应的转发，操作控制的传递。    "});index.add({'id':705,'href':'/note-cs/docs/direction/be/auth/sso/saml/','title':"SAML",'content':"SAML 1.0 2.0 参考  How SAML Authentication Works  "});index.add({'id':706,'href':'/note-cs/docs/domain/cc/container/docker/attention/','title':"关注",'content':"关注 moby/moby  Moby Project - a collaborative project for the container ecosystem to assemble container-based systems https://mobyproject.org/\ndocker/docker-ce  Docker CE https://www.docker.com/community-edition\nplay-with-docker/play-with-docker  Play With Docker gives you the experience of having a free Alpine Linux Virtual Machine in the cloud where you can build and run Docker containers and even create clusters with Docker features like Swarm Mode.\nUnder the hood DIND or Docker-in-Docker is used to give the effect of multiple VMs/PCs.\nA live version is available at: http://play-with-docker.com/\ngliderlabs/logspout  Log routing for Docker container logs\n"});index.add({'id':707,'href':'/note-cs/docs/domain/cc/others/','title':"其他",'content':"其他 "});index.add({'id':708,'href':'/note-cs/docs/direction/se/tutorial/','title':"教程",'content':"教程 基础  进阶 "});index.add({'id':709,'href':'/note-cs/docs/others/skill/lorawan/chirpstack/','title':"ChirpStack",'content':"ChirpStack ChirpStack Network Server ChirpStack Network Server is an open-source LoRaWAN network-server. https://www.chirpstack.io\n ChirpStack Application Server ChirpStack Application Server is an open-source LoRaWAN application-server. https://www.chirpstack.io\n"});index.add({'id':710,'href':'/note-cs/docs/others/skill/lorawan/','title':"LoRaWan",'content':"LoRaWan "});index.add({'id':711,'href':'/note-cs/docs/others/skill/ffmpeg/','title':"FFmpeg",'content':"FFmpeg FFmpeg/FFmpeg Fast Forward Moving Picture Experts Group\nFFmpeg is a collection of libraries and tools to process multimedia content such as audio, video, subtitles and related metadata.\n安装 linux 安装 ffmpeg\nhttps://www.tecmint.com/install-ffmpeg-in-linux/\nffmpeg -re -i car-brand.MOV -rtsp_transport tcp -vcodec h264 -f rtsp rtsp://localhost/test ffplay # 添加到 ~/.zshrc function rtsp() { ffplay -analyzeduration 1000000 -fflags nobuffer -probesize 32 -sync ext $@ }  命令 ffmpeg -i rtsp://admin:root123@192.168.66.119/ -vcodec copy -acodec copy -rtsp_transport tcp -f rtsp rtsp://127.0.0.1/test.sdp # 音视频转码后推送 ffmpeg -i rtsp://admin:root123@192.168.66.119/ -vcodec libx264 -acodec libvo_aacenc -rtsp_transport tcp -f rtsp rtsp://127.0.0.1/test.sdp ffmpeg -re -i ./car-brand.MOV -stream_loop -1 -vcodec libx264 -acodec aac -f rtsp rtsp://10.159.11.167:8194/car-brand ffmpeg -re -i ./car-brand.MOV -rtsp_transport tcp -vcodec h264 -f rtsp rtsp://localhost/test ffmpeg -re -i ./car-brand.MOV -rtsp_transport udp -vcodec h264 -f rtsp rtsp://localhost/test ffmpeg -re -stream_loop -1 -i carbrand.MOV -rtsp_transport tcp -vcodec h264 -f rtsp rtsp://localhost/test1 ffmpeg -re -stream_loop -1 -i carbrand.MOV -c copy -f rtsp rtsp://localhost:8554/mystream ffmpeg 参数 # 参考文档 https://ffmpeg.org/ffmpeg.html Main options: # Force input or output file format. The format is normally auto detected for input files and guessed from the file extension for output files, so this option is not needed in most cases. -f fmt force format # Select an encoder (when used before an output file) # or a decoder (when used before an input file) for one or more streams. # codec is the name of a decoder/encoder # or a special value copy (output only) to indicate that the stream is not to be re-encoded. -c codec codec name -codec codec codec name # input file url -i url # Set number of times input stream shall be looped. Loop 0 means no loop, loop -1 means infinite loop. # -1 无限循环 -stream_loop number Video options: -r rate set frame rate (Hz value, fraction or abbreviation) -vcodec codec force video codec (\u0026#39;copy\u0026#39; to copy stream) Audio options: -acodec codec force audio codec (\u0026#39;copy\u0026#39; to copy stream) # Read input at native frame rate. Mainly used to simulate a grab device, or live input stream (e.g. when reading from a file). # 用来模拟一个摄像头或者实时流，不要在正式环境使用 -re  h264_nvenc vs libx264 vs h264 h264_nvenc uses the NVidia hardware assisted H.264 video encoder. libx264 is a software (CPU) based H.264 encoder.\n参考：\n What is the difference between libx264 and h264_nvenc?  "});index.add({'id':712,'href':'/note-cs/docs/others/skill/gb28181/','title':"GB28181",'content':"GB28181 GB28181 协议是设备端主动向服务端发起注册消息，并定时发送保活消息，服务端收到后就认为设备在线，超时收不到保活的话就认为设备离线了。客户端发起播放视频请求时，服务端给指定的设备发送 INVITE 请求，通知设备将指定的通道的视频推送到服务端，服务端再转发给客户端，用户就可以播放了。\nGB28181 传输协议是 RTP，去掉 RTP 头部，剩余数据为 H264 PS 流，可使用 VLC 直接播放\nGB28181 报文 国标 IPC 的 IP 为 192.168.10.8， IPC 本地 SIP 端口为 60719， SIP ID 为 34020000002000000719；\nSIP 服务器的 IP 为 192.168.10.10， SIP 服务器的端口为 57030， SIP ID 为 34020000002000000001。\n整个国标信令部分基于 UDP 协议进行传输。\n开发基于 resiprocate/resiprocate 注册（REGISTER） 注销（CANCEL） 心跳（Keepalive） INVITE 云台控制（PTZ）  GB28181 协议版本 2012 年，GB/T-28181 的第一版标准 国家为了规范安防行业的设备平台互联互通，在 2012 年出台了 GB/T-28181 的第一版标准\n协议对流媒体的规范还是比较好（H.264 + G711 封装成 PS 流，再经过 RTP 协议进行实时传输），但是控制方面有很多不足，相对于当前流行的 ONVIF 协议在控制信令上还是有很多不足。\n2014 年，修改补充文件 后续公安一所又感觉 2011 版本的协议不能满足方方面面的信令需求，于是增加了修改补充协议 这次的补充，完善之前协议各地方说辞有误或是不清晰的地方，还增加了不少的信令需求，如：回放、下载、配置、传输协议、设备控制（拉宽放大、缩小）等待一系列的功能。\n2016 年，GB/T-28181 - 2016 版本 2016 年公安部一所又推出了 GB/T-28181 - 2016 版本，此版本就是对之前的 2011 版和修改补充版进行合并，并增加一些信令，说明制定协议的同志们一直都在努力。\n这次的版本应该算是阶段性的版本了，短时间内应该不会修改了。\n参考：\n GB28181 协议实现简介   GB28181 的协议栈实现 GB/T-28181 协议其实就是在国际上通用的 SIP 协议进行私有化定制， 流媒体方面就是在国际最流行的编码上进行封装（当然也有我们国家的编码标准 SVAC）。\nlibosip + libexosip + libxml 来实现 IPC 和平台协议功能，前面两者负责 sip 协议的实现，libxml 用来封装和解析实体信令。通过 3~4 年的市场应用感觉挺稳定的。\n流媒体方面：从编码中获取的 h.264 + g711 的视音频帧，进行 PS 媒体协议封装（自己写的 PS 封装协议），再经过 RTP 传输协议（自己实现）发送至平台。\n平台对收到的 RTP 流媒体进行解 RTP, 解 PS，再进行 h.264 + g711 的解码。\n SIP 协议 会话初始协议\nSIP 协议是一个应用层的点对点协议，用于初始、管理和终止网络中的语音和视频会话，是 GB28181 的核心之一。\n会话发起协议（ Session Initiation Protocol，缩写 SIP）是一个由 IETF MMUSIC 工作组开发的协议，作为标准被提议用于创建，修改和终止包括视频，语音，即时通信，在线游戏和虚拟现实等多种多媒体元素在内的交互式用户会话。2000 年 11 月，SIP 被正式批准成为 3GPP 信号协议之一，并成为 IMS 体系结构的一个永久单元。SIP 与 H.323 一样，是用于 VoIP 最主要的信令协议之一。\n  Antisip\n  List of SIP software\n  osip vs exosip osip oSIP is a free software library for VoIP applications implementing lower layers of Session Initiation Protocol (SIP).\noSIP 的开发开始于 2000 年 7 月，第一个版本在 2001 年 5 月发布。\noSIP 采用 ANSI C 编写，而且结构简单小巧，所以速度特别快。\n它并不提供高层的 SIP 会话 控制 API，它主要提供一些解析 SIP/SDP 消息的 API 和事务处理的状态机。\noSIP 不提供任何快速产生请求消息和响应消息的方法，所有请求消息和响应消息的形成必须调用一组 sip message api 来手动组装完成，\noSIP 的作者还开发了基于 oSIP 的 UA lib:exosip 和 proxy server lib:partysip\nSoftware using oSIP\n eXosip, the \u0026ldquo;eXtended osip\u0026rdquo; library. An extension of oSIP for softphone implementation written by Aymeric Moizard. GNU SIP Witch  exosip  pjsip PJSIP 是一个开源的 SIP 协议库，它实现了 SIP、SDP、RTP、STUN、TURN 和 ICE。PJSIP 作为基于 SIP 的一个多媒体通信框架提供了非常清晰的 API，以及 NAT 穿越的功能。PJSIP 具有非常好的移植性，几乎支持现今所有系统：从桌面系统、嵌入式系统到智能手机。\nPJSIP 同时支持语音、视频、状态呈现和即时通讯。PJSIP 具有非常完善的文档，对开发者非常友好。\nPJSIP 由 Benny Prijono、Perry Ismangil 在 2005 年创建，之后不久，Nanang Izzuddin、Sauw Ming 加入开发团队。2006 年成立 Teluu Ltd.，成为开发和维护 PJSIP 的公司。PJSIP 采用双 License：GPLv2 以及商业许可证，开发者可以根据需要选择不同的 License。\n"});index.add({'id':713,'href':'/note-cs/docs/others/skill/gb28181/protocal/','title':"GB28181 协议解析",'content':"GB28181 协议解析 点击在线查看标准完整文本： 公共安全视频监控联网系统信息传输、交换、控制技术要求。\n名词解释 SIP 服务器 SIP client 具有注册登记、建立 / 终止会话连接、接收和播放视音频流等功能，主要包括用户界面、用户代理 (UA)、媒体解码模块和媒体通信模块。\nSIP device 具有注册、建立 / 终止会话连接和控制、采集 / 编解码以及传送视音频流等的功能实体，主要包括用户代理 (UA)、媒体采集 / 编解码模块和媒体通信模块。\n联网系统中 SIP 设备的实现形式主要有支持 SIP 协议的网络摄像机、视频编 / 解码设备、数字硬盘录像机 (DVR) 和报警设备等。若 SIP 设备具有多路视音频编解码通道，每个通道宜成为一个 SIP 逻辑 UA, 具有唯一的 SIPURI, 并向 SIP 服务器注册。\nSIP 监控域 SIP surveil lance realm 支持本标准规定的通信协议的监控网络，通常由 SIP 服务器和注册在 SIP 服务器上的监控资源、用户终端、网络等组成。\n注册服务器 register server IETF RFC 3261 规定的 SIP 逻辑实体，是具有接收注册请求、将请求中携带的信息进行保存并提供本域内位置服务的功能服务器。\n中心信令控制服务器 center control server 具有向 SIP 客户端、SIP 设备、媒体服务器和网关提供注册、路由选择以及逻辑控制功能，并且提供接口与应用服务器通信。\n组成中心信令控制的逻辑实体包括代理服务器、注册服务器、重定向服务器、背靠背用户代理等的一种或者几种，是负责核心 SIP 信令应用处理的 SIP 服务器。\n媒体服务器 media server 提供实时媒体流的转发服务，提供媒体的存储、历史媒体信息的检索和点播服务。\n媒体服务器接收来自 SIP 设备、网关或其他媒体服务器等设备的媒体数据，并根据指令，将这些数据转发到其他单个或者多个 SIP 客户端和媒体服务器。\n信令安全路由网关 secure signal routing gateway 具有接收或转发域内外 SIP 信令功能，并且完成信令安全路由网关间路由信息的传递以及路由信令、信令身份标识的添加和鉴别等功能，是一种具有安全功能的 SIP 服务器。\n SIP 监控域互联结构  交互过程 客户端主动发起 趣解：\n第三方呼叫控制 "});index.add({'id':714,'href':'/note-cs/docs/others/skill/gb28181/sdp/','title':"SDP",'content':"SDP Session Description Protocol\nSDP 本身并不提供媒体服务，它只是描述了媒体服务在哪，以及如何和那个媒体服务打交道。\n媒体传输相关的协议在 SIP 消息 SDP 段携带， 在服务器和客户端之间进行商议。\nSDP 协议的具体内容参看：RFC2327\n由于 Web 端、IOS、Android、PC、MAC 端的差异性导致它们对音视频的支持能力不同， 所以我们进行一些音视频会话之前，需要交互下彼此的音视频编解码能力、网络带宽和传输协议等信息， 这些需要协商的信息需要用 SDP 来描述。\nSDP 并不是传输协议，需要用 RTSP、SIP、HTTP 等协议进行承载传输、交换， 如果大家协调好了之后，就可以建立会话，完成真实的音视频码流传输，再完成解码和播放。\nSDP 一般用在媒体会话建立之前，可以适用于实时流媒体、点播、直播等领域，特别在音视频通话、视频会议、VoIP、视频监控等领域应用较多。 媒体码流一般基于 RTP 传输，服务质量用 RTCP 协议保障。\n但是 SDP 的交互不是所有音视频会话建立时都是必须的，假如双方提前约定好这些音视频会话创建需要的信息就不用这个步骤来交互彼此的 SDP 信息， 比如 HTTP-FLV、RTMP-FLV 直播和点播方案，因为一旦采用了这套方案，这些音视频会话建立需要的信息都是确定的， 但是这样会降低或者说没有充分发挥端到端的音视频能力，协商显得更加灵活点。\nSDP 作用 SDP 作用包括以下一些方面\n 建立会话的详细信息，包括名称，网络，带宽等信息 包含在会话中的媒体信息，包括：  媒体类型 (video, audio, etc) 传输协议 (RTP/UDP/IP, H.320, etc) 媒体格式 (H.261 video, MPEG video, etc) 多播或远端（单播）地址和端口   为接收媒体而需的信息 使用的带宽信息 可信赖的接洽信息  如果拓展，还可以描述会话的安全方案信息、服务质量信息等，其中 WebRTC 就在 SDP 的基础上进行了继续拓展\n协议包格式 Protocol: SIP/SDP\nFrame 238: 633 bytes on wire (5064 bits), 633 bytes captured (5064 bits) on interface 0 Ethernet II, Src: 98:df:82:6d:9e:52 (98:df:82:6d:9e:52), Dst: Apple_70:23:0d (88:e9:fe:70:23:0d) Internet Protocol Version 4, Src: 192.168.137.109, Dst: 192.168.137.105 User Datagram Protocol, Src Port: 5060, Dst Port: 5060 Session Initiation Protocol (200) Status-Line: SIP/2.0 200 OK Status-Code: 200 [Resent Packet: False] [Request Frame: 234] [Response Time (ms): 17] Message Header Via: SIP/2.0/UDP 192.168.64.3:15060;rport=5060;branch=z9hG4bK575396672;received=192.168.137.105 From: \u0026lt;sip:34020000002000000001@3402000000\u0026gt;;tag=139396672 To: \u0026lt;sip:34020000001320000001@3402000000\u0026gt;;tag=403895202 Call-ID: 325396492 CSeq: 3 INVITE Contact: \u0026lt;sip:34020000001320000001@192.168.64.3:41073\u0026gt; Content-Type: application/sdp User-Agent: IP Camera Content-Length: 191 Message Body Session Description Protocol Session Description Protocol Version (v): 0 Owner/Creator, Session Id (o): 34020000001320000001 1136 1136 IN IP4 192.168.137.109 Session Name (s): Play Connection Information (c): IN IP4 192.168.137.109 Time Description, active time (t): 0 0 Media Description, name and address (m): video 15060 RTP/AVP 96 Media Attribute (a): sendonly Media Attribute (a): rtpmap:96 PS/90000 Media Attribute (a): filesize:0 Unknown: y=0200000001 Version (v) Session Name (s) Media Description, name and address (m) Media Attribute (a) "});index.add({'id':715,'href':'/note-cs/docs/others/skill/gb28181/sip/','title':"SIP",'content':"SIP SIP 协议使用 RTP 协议传送音视频数据流，使用 SDP 协议进行媒体描述。\n包内容 Message Session Initiation Protocol (MESSAGE) Request-Line: MESSAGE sip:34020000002000000001@3402000000 SIP/2.0 Message Header Via: SIP/2.0/UDP 192.168.137.109:5060;rport;branch=z9hG4bK1013136823 From: \u0026lt;sip:34020000001320000001@3402000000\u0026gt;;tag=676399389 To: \u0026lt;sip:34020000002000000001@3402000000\u0026gt; Call-ID: 1119613114 CSeq: 20 MESSAGE Content-Type: Application/MANSCDP+xml Max-Forwards: 70 User-Agent: IP Camera Content-Length: 178 Message Body \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;GB2312\u0026#34;?\u0026gt;\\n \u0026lt;Notify\u0026gt;\\n \u0026lt;CmdType\u0026gt;Keepalive\u0026lt;/CmdType\u0026gt;\\n \u0026lt;SN\u0026gt;123\u0026lt;/SN\u0026gt;\\n \u0026lt;DeviceID\u0026gt;34020000001320000001\u0026lt;/DeviceID\u0026gt;\\n \u0026lt;Status\u0026gt;OK\u0026lt;/Status\u0026gt;\\n \u0026lt;Info\u0026gt;\\n \u0026lt;/Info\u0026gt;\\n \u0026lt;/Notify\u0026gt;\\n "});index.add({'id':716,'href':'/note-cs/docs/others/skill/gb28181/packet/','title':"数据包",'content':"数据包 Register request: Register (no auth) Frame 2117: 442 bytes on wire (3536 bits), 442 bytes captured (3536 bits) on interface 0 Ethernet II, Src: 98:df:82:6d:9e:52 (98:df:82:6d:9e:52), Dst: Apple_70:23:0d (88:e9:fe:70:23:0d) Internet Protocol Version 4, Src: 192.168.137.109, Dst: 192.168.137.105 User Datagram Protocol, Src Port: 5060, Dst Port: 5060 Session Initiation Protocol (REGISTER) Request-Line: REGISTER sip:34020000002000000001@3402000000 SIP/2.0 Method: REGISTER Request-URI: sip:34020000002000000001@3402000000 [Resent Packet: True] [Suspected resend of frame: 1613] Message Header Via: SIP/2.0/UDP 192.168.137.109:5060;rport;branch=z9hG4bK1935014795 From: \u0026lt;sip:34020000001320000001@3402000000\u0026gt;;tag=496441511 To: \u0026lt;sip:34020000001320000001@3402000000\u0026gt; Call-ID: 1188137981 CSeq: 1 REGISTER Contact: \u0026lt;sip:34020000001320000001@192.168.137.109:5060\u0026gt; Max-Forwards: 70 User-Agent: IP Camera Expires: 3600 Content-Length: 0 response: 401 Frame 2121: 524 bytes on wire (4192 bits), 524 bytes captured (4192 bits) on interface 0 Ethernet II, Src: Apple_70:23:0d (88:e9:fe:70:23:0d), Dst: 98:df:82:6d:9e:52 (98:df:82:6d:9e:52) Internet Protocol Version 4, Src: 192.168.137.105, Dst: 192.168.137.109 User Datagram Protocol, Src Port: 5060, Dst Port: 5060 Session Initiation Protocol (401) Status-Line: SIP/2.0 401 Unauthorized Status-Code: 401 [Resent Packet: False] [Request Frame: 1613] [Response Time (ms): 15594] Message Header Via: SIP/2.0/UDP 192.168.137.109:5060;rport=47918;received=192.168.64.3;branch=z9hG4bK1935014795 From: \u0026lt;sip:34020000001320000001@3402000000\u0026gt;;tag=496441511 To: \u0026lt;sip:34020000001320000001@3402000000\u0026gt;;tag=697042285 CSeq: 1 REGISTER Call-ID: 1188137981 User-Agent: LiveGBS v200603 Contact: \u0026lt;sip:34020000002000000001@192.168.64.3:15060\u0026gt; Content-Length: 0 WWW-Authenticate: Digest realm=\u0026#34;3402000000\u0026#34;,qop=\u0026#34;auth\u0026#34;,nonce=\u0026#34;a1b6ba00d8cbaa8ce99d1d39b2905d12\u0026#34; request: register (auth) Frame 2122: 704 bytes on wire (5632 bits), 704 bytes captured (5632 bits) on interface 0 Ethernet II, Src: 98:df:82:6d:9e:52 (98:df:82:6d:9e:52), Dst: Apple_70:23:0d (88:e9:fe:70:23:0d) Internet Protocol Version 4, Src: 192.168.137.109, Dst: 192.168.137.105 User Datagram Protocol, Src Port: 5060, Dst Port: 5060 Session Initiation Protocol (REGISTER) Request-Line: REGISTER sip:34020000002000000001@3402000000 SIP/2.0 Method: REGISTER Request-URI: sip:34020000002000000001@3402000000 [Resent Packet: False] Message Header Via: SIP/2.0/UDP 192.168.137.109:5060;rport;branch=z9hG4bK2038639153 From: \u0026lt;sip:34020000001320000001@3402000000\u0026gt;;tag=496441511 To: \u0026lt;sip:34020000001320000001@3402000000\u0026gt; Call-ID: 1188137981 CSeq: 2 REGISTER Contact: \u0026lt;sip:34020000001320000001@192.168.137.109:5060\u0026gt; [truncated]Authorization: Digest username=\u0026#34;34020000001320000001\u0026#34;, realm=\u0026#34;3402000000\u0026#34;, nonce=\u0026#34;a1b6ba00d8cbaa8ce99d1d39b2905d12\u0026#34;, uri=\u0026#34;sip:34020000002000000001@3402000000\u0026#34;, response=\u0026#34;487b46591eae35a8d8f684db454ec471\u0026#34;, algorithm=MD5, cnonce Max-Forwards: 70 User-Agent: IP Camera Expires: 3600 Content-Length: 0 response: 200 Frame 2123: 463 bytes on wire (3704 bits), 463 bytes captured (3704 bits) on interface 0 Ethernet II, Src: Apple_70:23:0d (88:e9:fe:70:23:0d), Dst: 98:df:82:6d:9e:52 (98:df:82:6d:9e:52) Internet Protocol Version 4, Src: 192.168.137.105, Dst: 192.168.137.109 User Datagram Protocol, Src Port: 5060, Dst Port: 5060 Session Initiation Protocol (200) Status-Line: SIP/2.0 200 OK Status-Code: 200 [Resent Packet: False] [Request Frame: 2122] [Response Time (ms): 17] Message Header Via: SIP/2.0/UDP 192.168.137.109:5060;rport=60954;received=192.168.64.3;branch=z9hG4bK2038639153 From: \u0026lt;sip:34020000001320000001@3402000000\u0026gt;;tag=496441511 To: \u0026lt;sip:34020000001320000001@3402000000\u0026gt;;tag=410042311 CSeq: 2 REGISTER Call-ID: 1188137981 User-Agent: LiveGBS v200603 Contact: \u0026lt;sip:34020000002000000001@192.168.64.3:15060\u0026gt; Content-Length: 0 Date: 2020-06-09T14:09:01.830 Expires: 3600 remove 1 binding 有 remove 1 binding, 然后重新 register 的现象\nMessage Header：\n CSeq 加 1， Contact 的 expires=0   Message request: sip server -\u0026gt; ipc Frame 2136: 571 bytes on wire (4568 bits), 571 bytes captured (4568 bits) on interface 0 Ethernet II, Src: Apple_70:23:0d (88:e9:fe:70:23:0d), Dst: 98:df:82:6d:9e:52 (98:df:82:6d:9e:52) Internet Protocol Version 4, Src: 192.168.137.105, Dst: 192.168.137.109 User Datagram Protocol, Src Port: 5060, Dst Port: 5060 Session Initiation Protocol (MESSAGE) Request-Line: MESSAGE sip:34020000001320000001@3402000000 SIP/2.0 Method: MESSAGE Request-URI: sip:34020000001320000001@3402000000 [Resent Packet: False] Message Header Via: SIP/2.0/UDP 192.168.64.3:15060;rport;branch=z9hG4bK268043391 From: \u0026lt;sip:34020000002000000001@3402000000\u0026gt;;tag=181043391 To: \u0026lt;sip:34020000001320000001@3402000000\u0026gt; Call-ID: 44043391 CSeq: 1 MESSAGE Content-Type: Application/MANSCDP+xml Max-Forwards: 70 User-Agent: LiveGBS v200603 Content-Length: 162 Message Body \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt;\\r\\n \u0026lt;Query\u0026gt;\\r\\n \u0026lt;CmdType\u0026gt;Catalog\u0026lt;/CmdType\u0026gt;\\r\\n \u0026lt;SN\u0026gt;445043391\u0026lt;/SN\u0026gt;\\r\\n \u0026lt;DeviceID\u0026gt;34020000001320000001\u0026lt;/DeviceID\u0026gt;\\r\\n \u0026lt;/Query\u0026gt;\\r\\n response: ipc -\u0026gt; sip server Frame 2137: 352 bytes on wire (2816 bits), 352 bytes captured (2816 bits) on interface 0 Ethernet II, Src: 98:df:82:6d:9e:52 (98:df:82:6d:9e:52), Dst: Apple_70:23:0d (88:e9:fe:70:23:0d) Internet Protocol Version 4, Src: 192.168.137.109, Dst: 192.168.137.105 User Datagram Protocol, Src Port: 5060, Dst Port: 5060 Session Initiation Protocol (200) Status-Line: SIP/2.0 200 OK Status-Code: 200 [Resent Packet: False] [Request Frame: 2136] [Response Time (ms): 5] Message Header Via: SIP/2.0/UDP 192.168.64.3:15060;rport=5060;branch=z9hG4bK268043391;received=192.168.137.105 From: \u0026lt;sip:34020000002000000001@3402000000\u0026gt;;tag=181043391 To: \u0026lt;sip:34020000001320000001@3402000000\u0026gt;;tag=2000290983 Call-ID: 44043391 CSeq: 1 MESSAGE User-Agent: IP Camera Content-Length: 0 request: ipc -\u0026gt; sip server Frame 2138: 1001 bytes on wire (8008 bits), 1001 bytes captured (8008 bits) on interface 0 Ethernet II, Src: 98:df:82:6d:9e:52 (98:df:82:6d:9e:52), Dst: Apple_70:23:0d (88:e9:fe:70:23:0d) Internet Protocol Version 4, Src: 192.168.137.109, Dst: 192.168.137.105 User Datagram Protocol, Src Port: 5060, Dst Port: 5060 Session Initiation Protocol (MESSAGE) Request-Line: MESSAGE sip:34020000002000000001@3402000000 SIP/2.0 Method: MESSAGE Request-URI: sip:34020000002000000001@3402000000 [Resent Packet: False] Message Header Via: SIP/2.0/UDP 192.168.137.109:5060;rport;branch=z9hG4bK461606833 From: \u0026lt;sip:34020000001320000001@3402000000\u0026gt;;tag=106117409 To: \u0026lt;sip:34020000002000000001@3402000000\u0026gt; Call-ID: 2113631911 CSeq: 20 MESSAGE Content-Type: Application/MANSCDP+xml Max-Forwards: 70 User-Agent: IP Camera Content-Length: 591 Message Body \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;GB2312\u0026#34;?\u0026gt;\\n \u0026lt;Response\u0026gt;\\n \u0026lt;CmdType\u0026gt;Catalog\u0026lt;/CmdType\u0026gt;\\n \u0026lt;SN\u0026gt;445043391\u0026lt;/SN\u0026gt;\\n \u0026lt;DeviceID\u0026gt;34020000001320000001\u0026lt;/DeviceID\u0026gt;\\n \u0026lt;SumNum\u0026gt;1\u0026lt;/SumNum\u0026gt;\\n \u0026lt;DeviceList Num=\u0026#34;1\u0026#34;\u0026gt;\\n \u0026lt;Item\u0026gt;\\n \u0026lt;DeviceID\u0026gt;34020000001320000001\u0026lt;/DeviceID\u0026gt;\\n \u0026lt;Name\u0026gt;Camera 01\u0026lt;/Name\u0026gt;\\n \u0026lt;Manufacturer\u0026gt;Hikvision\u0026lt;/Manufacturer\u0026gt;\\n \u0026lt;Model\u0026gt;IP Camera\u0026lt;/Model\u0026gt;\\n \u0026lt;Owner\u0026gt;Owner\u0026lt;/Owner\u0026gt;\\n \u0026lt;CivilCode\u0026gt;3402000000\u0026lt;/CivilCode\u0026gt;\\n \u0026lt;Address\u0026gt;Address\u0026lt;/Address\u0026gt;\\n \u0026lt;Parental\u0026gt;0\u0026lt;/Parental\u0026gt;\\n \u0026lt;ParentID\u0026gt;34020000002000000001\u0026lt;/ParentID\u0026gt;\\n \u0026lt;SafetyWay\u0026gt;0\u0026lt;/SafetyWay\u0026gt;\\n \u0026lt;RegisterWay\u0026gt;1\u0026lt;/RegisterWay\u0026gt;\\n \u0026lt;Secrecy\u0026gt;0\u0026lt;/Secrecy\u0026gt;\\n \u0026lt;Status\u0026gt;ON\u0026lt;/Status\u0026gt;\\n \u0026lt;/Item\u0026gt;\\n \u0026lt;/DeviceList\u0026gt;\\n \u0026lt;/Response\u0026gt;\\n request: sip server -\u0026gt; ipc Frame 2139: 360 bytes on wire (2880 bits), 360 bytes captured (2880 bits) on interface 0 Ethernet II, Src: Apple_70:23:0d (88:e9:fe:70:23:0d), Dst: 98:df:82:6d:9e:52 (98:df:82:6d:9e:52) Internet Protocol Version 4, Src: 192.168.137.105, Dst: 192.168.137.109 User Datagram Protocol, Src Port: 5060, Dst Port: 5060 Session Initiation Protocol (200) Status-Line: SIP/2.0 200 OK Status-Code: 200 [Resent Packet: False] [Request Frame: 2138] [Response Time (ms): 16] Message Header Via: SIP/2.0/UDP 192.168.137.109:5060;rport=60954;received=192.168.64.3;branch=z9hG4bK461606833 From: \u0026lt;sip:34020000001320000001@3402000000\u0026gt;;tag=106117409 To: \u0026lt;sip:34020000002000000001@3402000000\u0026gt;;tag=443043407 CSeq: 20 MESSAGE Call-ID: 2113631911 User-Agent: LiveGBS v200603 Content-Length: 0  Invite request: sip server -\u0026gt; ipc (SIP/SDP) Frame 288: 746 bytes on wire (5968 bits), 746 bytes captured (5968 bits) on interface 0 Ethernet II, Src: Apple_70:23:0d (88:e9:fe:70:23:0d), Dst: 98:df:82:6d:9e:52 (98:df:82:6d:9e:52) Internet Protocol Version 4, Src: 192.168.137.105, Dst: 192.168.137.109 User Datagram Protocol, Src Port: 5060, Dst Port: 5060 Session Initiation Protocol (INVITE) Request-Line: INVITE sip:34020000001320000001@3402000000 SIP/2.0 Method: INVITE Request-URI: sip:34020000001320000001@3402000000 [Resent Packet: False] Message Header Via: SIP/2.0/UDP 192.168.64.3:15060;rport;branch=z9hG4bK685516389 From: \u0026lt;sip:34020000002000000001@3402000000\u0026gt;;tag=171516389 To: \u0026lt;sip:34020000001320000001@3402000000\u0026gt; Call-ID: 16516245 CSeq: 4 INVITE Content-Type: APPLICATION/SDP Contact: \u0026lt;sip:34020000002000000001@192.168.64.3:15060\u0026gt; Max-Forwards: 70 User-Agent: LiveGBS v200603 Subject: 34020000001320000001:0200000001,34020000002020000001:0 Content-Length: 226 Message Body Session Description Protocol Session Description Protocol Version (v): 0 Owner/Creator, Session Id (o): 34020000002000000001 0 0 IN IP4 192.168.137.105 Session Name (s): Play Connection Information (c): IN IP4 192.168.137.105 Time Description, active time (t): 0 0 Media Description, name and address (m): video 30000 RTP/AVP 96 97 98 Media Attribute (a): recvonly Media Attribute (a): rtpmap:96 PS/90000 Media Attribute (a): rtpmap:97 MPEG4/90000 Media Attribute (a): rtpmap:98 H264/90000 Unknown: y=0200000001 response: 100 Trying (ipc -\u0026gt; sip server, SIP) Frame 295: 340 bytes on wire (2720 bits), 340 bytes captured (2720 bits) on interface 0 Ethernet II, Src: 98:df:82:6d:9e:52 (98:df:82:6d:9e:52), Dst: Apple_70:23:0d (88:e9:fe:70:23:0d) Internet Protocol Version 4, Src: 192.168.137.109, Dst: 192.168.137.105 User Datagram Protocol, Src Port: 5060, Dst Port: 5060 Session Initiation Protocol (100) Status-Line: SIP/2.0 100 Trying Status-Code: 100 [Resent Packet: False] [Request Frame: 288] [Response Time (ms): 16] Message Header Via: SIP/2.0/UDP 192.168.64.3:15060;rport=5060;branch=z9hG4bK685516389;received=192.168.137.105 From: \u0026lt;sip:34020000002000000001@3402000000\u0026gt;;tag=171516389 To: \u0026lt;sip:34020000001320000001@3402000000\u0026gt; Call-ID: 16516245 CSeq: 4 INVITE User-Agent: IP Camera Content-Length: 0 response: 200 (ipc -\u0026gt; sip server, SIP/SDP) Frame 297: 632 bytes on wire (5056 bits), 632 bytes captured (5056 bits) on interface 0 Ethernet II, Src: 98:df:82:6d:9e:52 (98:df:82:6d:9e:52), Dst: Apple_70:23:0d (88:e9:fe:70:23:0d) Internet Protocol Version 4, Src: 192.168.137.109, Dst: 192.168.137.105 User Datagram Protocol, Src Port: 5060, Dst Port: 5060 Session Initiation Protocol (200) Status-Line: SIP/2.0 200 OK Status-Code: 200 [Resent Packet: False] [Request Frame: 288] [Response Time (ms): 20] Message Header Via: SIP/2.0/UDP 192.168.64.3:15060;rport=5060;branch=z9hG4bK685516389;received=192.168.137.105 From: \u0026lt;sip:34020000002000000001@3402000000\u0026gt;;tag=171516389 To: \u0026lt;sip:34020000001320000001@3402000000\u0026gt;;tag=614786748 Call-ID: 16516245 CSeq: 4 INVITE Contact: \u0026lt;sip:34020000001320000001@192.168.64.3:55302\u0026gt; Content-Type: application/sdp User-Agent: IP Camera Content-Length: 191 Message Body Session Description Protocol Session Description Protocol Version (v): 0 Owner/Creator, Session Id (o): 34020000001320000001 2346 2346 IN IP4 192.168.137.109 Session Name (s): Play Connection Information (c): IN IP4 192.168.137.109 Time Description, active time (t): 0 0 Media Description, name and address (m): video 15060 RTP/AVP 96 Media Attribute (a): sendonly Media Attribute (a): rtpmap:96 PS/90000 Media Attribute (a): filesize:0 Unknown: y=0200000001  ACK request: sip server -\u0026gt; ipc (SIP) Frame 298: 430 bytes on wire (3440 bits), 430 bytes captured (3440 bits) on interface 0 Ethernet II, Src: Apple_70:23:0d (88:e9:fe:70:23:0d), Dst: 98:df:82:6d:9e:52 (98:df:82:6d:9e:52) Internet Protocol Version 4, Src: 192.168.137.105, Dst: 192.168.137.109 User Datagram Protocol, Src Port: 5060, Dst Port: 5060 Session Initiation Protocol (ACK) Request-Line: ACK sip:34020000001320000001@3402000000 SIP/2.0 Method: ACK Request-URI: sip:34020000001320000001@3402000000 [Resent Packet: False] [Request Frame: 288] [Response Time (ms): 61] Message Header Via: SIP/2.0/UDP 192.168.64.3:15060;rport;branch=z9hG4bK193516446 From: \u0026lt;sip:34020000002000000001@3402000000\u0026gt;;tag=171516389 To: \u0026lt;sip:34020000001320000001@3402000000\u0026gt;;tag=614786748 Call-ID: 16516245 CSeq: 4 ACK Contact: \u0026lt;sip:34020000002000000001@192.168.64.3:15060\u0026gt; Max-Forwards: 70 User-Agent: LiveGBS v200603 Content-Length: 0  RTP ipc -\u0026gt; sip server Sequence number 递增\nFrame 299: 1454 bytes on wire (11632 bits), 1454 bytes captured (11632 bits) on interface 0 Ethernet II, Src: 98:df:82:6d:9e:52 (98:df:82:6d:9e:52), Dst: Apple_70:23:0d (88:e9:fe:70:23:0d) Internet Protocol Version 4, Src: 192.168.137.109, Dst: 192.168.137.105 User Datagram Protocol, Src Port: 15060, Dst Port: 30000 Real-Time Transport Protocol [Stream setup by SDP (frame 288)] 10.. .... = Version: RFC 1889 Version (2) ..0. .... = Padding: False ...0 .... = Extension: False .... 0000 = Contributing source identifiers count: 0 0... .... = Marker: False Payload type: PS (96) Sequence number: 0 [Extended sequence number: 65536] Timestamp: 0 Synchronization Source identifier: 0x0bebc201 (200000001) Payload: 000001ba6e617c97940107599ffeffff01f2c2b4000001bb... "});index.add({'id':717,'href':'/note-cs/docs/others/skill/gb28181/code/','title':"源码实现",'content':"源码实现 名词解释  AOR：Address Of Record 是 header 中的 From 字段   开源实现 go  StefanKopieczek/gossip  rainliu/gosips  1lann/go-sip  ghettovoice/gosip Inspired by:  gossip go-sip sip.js   cloudwebrtc/go-sip-ua Dependencies  ghettovoice/gosip SIP stack c-bata/go-prompt Console for b2bua pixelbender/go-sdp SDP    C  pjsip/pjproject   C#  GB28181/GB28181.Solution   C++  ossrs/srs  xiongziliang/ZLMediaKit   Node.js  kirm/sip.js   二进制（前端开源，后端不开源）  livegbs/GB28181-Server   "});index.add({'id':718,'href':'/note-cs/docs/others/skill/onvif/','title':"ONVIF",'content':"ONVIF 官网：www.onvif.org\n"});index.add({'id':719,'href':'/note-cs/docs/others/skill/easydarwin/','title':"EasyDarwin",'content':"EasyDarwin EasyDarwin 是基于 Apple 的开源项目 Darwin Streaming Server 衍生而来的， Darwin 本身支持的是 RTSP 流媒体协议\nmacosforge/dss  Darwin Streaming Server is Apple\u0026rsquo;s open source version of the QuickTime Streaming Server technology allowing you to send streaming media across the Internet using the industry standard RTP and RTSP protocols.\n EasyDarwin 生态  EasyDarwin 开源流媒体服务器：www.EasyDarwin.org EasyDSS 商用流媒体解决方案：www.EasyDSS.com, 点播与直播服务器  EasyBMS EasyRMS, 录播服务器   EasyNVR 无插件直播方案：www.EasyNVR.com, 摄像机互联网直播服务  EasyGB28181Server EasyNVR 采用的是 Onvif 协议接入云平台， 而 EasyGB28181Server 则是以 GB/T28181 方式接入云平台\nEasyGB28181Server 交互流程\n 启动 EasyGB28181Server, 接受摄像机的注册； EasyGB28181Server 将接收到的摄像机信息写入到 Redis 的设备列表； 与摄像机维持心跳； 打开网页客户端，即可看到所有的设备列表； 单击列表中的任一设备，EasyDSS 则向 EasyGB28181 服务器请求音视频； EasyGB28181Server 在收到 EasyDSS 的请求后，在 Redis 中找到负载最小的 EasyGB28181StreamServer; EasyGB28181Server 向找到的 EasyGB28181StreamServer 发送接收摄像机流的请求 EasyGB28181StreamServer 返回自身的外网 IP 和收流的端口 EasyGB28181Server 通知摄像机向 EasyGB28181StreamServer 的 IP 和 Port 发送音视频流 EasyGB28181StreamServer 收到摄像机的音视频后，将 PS 流转换为 ES 流，再转换为 RTMP 协议，传到 EasyDSS; EasyDSS 再将 RTMP 流转发给网页客户端；  至此，EasyGB28181Server + EasyGB28181StreamServer + EasyDSS 的整个流程完成；\n"});index.add({'id':720,'href':'/note-cs/docs/others/skill/stream-media/','title':"流媒体技术",'content':"流媒体技术 视频编码  H.264 H.265 H.266 Apple Pro Res (MOV 格式的专用编码)  音频编码  AAC MP3 WAV FLAC（无损） APE（无损）  参考：\n 音频编码格式的比较  视频容器 / 视频格式 一个格式却可以有不同的编码\n AVI (Audio Video Interleaved 音视频交错格式) RMVB FLV (Flash Video) MOV WMV (Windows Media Video) MP4 MKV  MP4 MP4 或称 MPEG-4 第 14 部分（英语：MPEG-4 Part 14）是一种标准的数字多媒体容器格式。MPEG-4 第 14 部分的扩展名为.mp4，以存储数字音频及数字视频为主，但也可以存储字幕和静止图像。因其可容纳支持比特流的视频流（如高级视频编码），MP4 可以在网络传输时使用流式传输。\nMKV MKV 格式是民间流行的一种视频格式，以它兼容众多视频编码见长，可以是 DivX、XviD、RealVideo、H264、MPEG2、VC1 等等。但是由于是民间格式，没有版权限制，又易于播放，所以官方发布的视频影片都不采用 mkv，网上制作下载常见。\n 视频传输协议  RTP/RTCP RTMP HLS (HTTP Live Streaming)   流媒体传输协议 流媒体协议的作用：流同步，播放控制，质量控制，多端跨平台播放等 直播三要素：低延时，高可用，质量反馈和检测\n常见流媒体协议类型\n常见流媒体协议适用场景\nRTP/RTCP/RTSP 封装：\n ps ts  视频：\n H.264 H.265 VP9  音频：\n aac g711.a  RTSP\n 基于 TCP 基于文本的双向实时传输协议，类似 HTTP 每个会话都含有状态，保持长连接，请求信令按顺序（HTTP 无状态）  RTP/RTCP\n 基于 UDP   RTMP Real-Time Messaging Protocol\n Adobe 的私有协议，性能相对 HTTP 比较低下。 数据和信令在一条通道。 长连接 基于 TCP   HLS HTTP Live Streaming\n 基于 HTTP，性能不错 延时常常大于 10 秒，无法做直播互动  HLS 是由苹果公司提出基于 HTTP 的 流媒体网络传输协议。是苹果公司 QuickTime X 和 iPhone 软件系统的一部分。它的工作原理是把整个流分成一个个小的基于 HTTP 的文件来下载，每次只下载一些。当媒体流正在播放时，客户端可以选择从许多不同的备用源中以不同的速率下载同样的资源，允许流媒体会话适应不同的数据速率。在开始一个流媒体会话时，客户端会下载一个包含元数据的 extended M3U (m3u8) playlist 文件，用于寻找可用的媒体流。\nHLS 只请求基本的 HTTP 报文，与实时传输协议（RTP）不同，HLS 可以穿过任何允许 HTTP 数据通过的防火墙或者代理服务器。它也很容易使用内容分发网络来传输媒体流。\nHLS 基于 HTTP 协议实现，传输内容包括两部分，一是 M3U8 描述文件，二是 TS 媒体文件。\n为什么要用 TS 而不是 MP4？ 这是因为两个 TS 片段可以无缝拼接，播放器能连续播放， 而 MP4 文件由于编码方式的原因，两段 MP4 不能无缝拼接，播放器连续播放两个 MP4 文件会出现破音和画面间断，影响用户体验。\n而且如果要在一段长达一小时的视频中跳转，如果使用单个 MP4 格式的视频文件，并且也是用 HTTP 协议，那么需要代理服务器支持 HTTP range request 获取大文件中的一部分。 这样的话，对于代理服务器的性能来说要求较高。 而 HTTP Live Streaming 则只需要根据列表文件中的时间轴找出对应的 TS 片段下载即可， 不需要 range request，对代理服务器的要求小很多。 所有代理服务器都支持小文件的高效缓存。\n 流媒体协议 RTP/RTCP RTP(Real-time Transport Protocol) 是用于 Internet 上针对多媒体数据流的一种传输协议。\nRTCP 为 RTP 媒体流提供信道外控制。 RTCP 定期在流多媒体会话参加者之间传输控制数据。 RTCP 的主要功能是为 RTP 所提供的服务质量提供反馈。\nRTP 使用一个 偶数 UDP port， 而 RTCP 则使用 RTP 的下一个 port，也就是一个奇数 port。\nRTSP RTMP H264 H265 TS MPEG2-TS 传输流 （MPEG-2 Transport Stream；又称 MPEG-TS、MTS、TS） 是一种传输和存储包含视频、音频与通信协议各种数据的标准格式，用于数字电视广播系统，如 DVB、ATSC、ISDB、IPTV 等等。\nRTP Payload type 有效负载 (载荷) 类型\n有些负载类型由于诞生的较晚，没有具体的 PT 值，只能使用动态（dynamic）PT 值，即 96 到 127， 这就是为什么大家普遍指定 H264 的 PT 值为 96。\nPayload identifiers 96–127 are used for payloads defined dynamically during a session. It is recommended to dynamically assigned port numbers, although port numbers 5004 and 5005 have been registered for use of the profile when a dynamically assigned port is not required.\nMP2T (Payload type: 33)\nRFC 2250: RTP Payload Format for MPEG1/MPEG2 Video\n参考：\n RTP 有效负载 (载荷) 类型 (RTP Payload Type)  "});index.add({'id':721,'href':'/note-cs/docs/others/skill/stream-media/live-tech/','title':"直播技术",'content':"直播技术  摄像头视频采集，原始视频数据：RGB/YUV 话筒音频采集，原始音频数据：PCM 视频文件编码，RGB/YUV -\u0026gt; H.264/H.265 音频文件编码，PCM -\u0026gt; AAC 编码为有流媒体特性的多媒体容器格式（Multimedia Container Format）， 如 FLV/TS/RTMP Package 推流到流媒体服务器  应用层：HLS/RTSP/RTMP 传输层：RTP/RTCP 网络层：RSVP   服务端处理  转码/录制/截图/鉴黄 生成拉流 URL   拉流到客户端  应用层：HLS/RTMP 传输层：RTP/RTCP 网络层：RSVP   解复用，多媒体容器格式（FLV/TS/RTMP Package）的流 -\u0026gt; 音视频数据（H.264/AAC） 解码视频文件为 YUV/RGB，解码音频文件为 PCM  硬解码（GPU 解码，CPU 辅助） 软解码（CPU 解码）   音画同步 视频数据（YUV/RGB）发送到视频输出设备，音频数据（PCM）发送到音频输出设备  "});index.add({'id':722,'href':'/note-cs/docs/others/skill/stream-media/video-codec/','title':"视频编码",'content':"视频编码     年份 标准 制定组织 解除著作权保护（DRM-free） 主要应用     1984 H.120 ITU-T 是    1990 H.261 ITU-T 是 视频会议、视频通话   1993 MPEG-1 第二部分 ISO／IEC 是 影音光盘（VCD）   1995 H.262/MPEG-2 第二部分 ISO／IEC、ITU-T 否 DVD 影碟（DVD-Video）、 蓝光（ Blu-Ray）影碟、数字视频广播（DVB）、SVCD   1996 H.263 ITU-T  视频会议、视频通话、 3G 手机视频（3GP）   1999 MPEG-4 第二部分 ISO／IEC 否    2003 H.264/MPEG-4 AVC ISO／IEC、ITU-T 否 蓝光（ Blu-Ray）影碟、数字视频广播（DVB）、iPod 视频、 高清 DVD（HD DVD）   2013 H.265/High Efficiency Video Coding ISO/IEC、ITU-T 否 尚未普及     AVC (H.264) H.264，又称为 MPEG-4 第 10 部分，高级视频编码（英语： MPEG-4 Part 10, Advanced Video Coding ，缩写为 MPEG-4 AVC）是一种面向块，基于运动补偿的视频编码标准（英语：Advanced Video Coding） 。\n HEVC (H.265) 高效率视频编码（ High Efficiency Video Coding，简称 HEVC），又称为 H.265 和 MPEG-H 第 2 部分，是一种视频压缩标准，被视为是 ITU-T H.264/MPEG-4 AVC 标准的继任者。\n比起 H.264/AVC，H.265/HEVC 提供了更多不同的工具来降低码率， 以编码单位来说，H.264 中每个宏块（macroblock/MB）大小都是固定的 16x16 像素，而 H.265 的编码单位可以选择从最小的 8x8 到最大的 64x64。 那么，在相同的图象质量下，相比于 H.264，通过 H.265 编码的视频大小将减少大约 39%-44%；\nVVC (H.266) Versatile Video Coding, MPEG-I Part 3\n 应用 CD Compact Disc\n激光唱片，镭射唱片\nCD 在 1982 年面世，至今仍然是商业录音的标准存储设备。\n在 CD 尚未发明之前，音响系统都是属于模拟信号， 音乐的来源大多是 30 公分直径的密纹唱片、收音机以及录音机等，CD 发明之前没有数字音响。\nVCD Video Compact Disc\n影音光盘，又称影音压缩光盘，是一种在光盘（Compact Disc）上存储视频信息的标准。\nVCD 标准由索尼、飞利浦、 JVC、 松下电器等电器生产厂商联合于 1993 年制定，属于数字光盘的白皮书标准。\nDVD Digital Versatile Disc\nDVD 原是 Digital Video Disc（数字视频光盘）的首字母缩略字，因初推出时大多厂商只针对视频方面的宣传及推出产品，而且当时的电脑产业对高容量的存储媒体没有太大需求。 后因定位更改，于 1995 年规格正式确立时，重新定义为 Digital Versatile Disc（数字多用途光盘），但旧称的 Digital Video Disc 也有人继续沿用。现在一般都只以 “DVD” 作为其称呼。\nHD DVD High Definition Digital Versatile Disc\nHD DVD（英语：High Definition DVD ，“高清晰度 DVD” 或 “高清 DVD”）是一种以蓝光镭射技术存储数字格式信息于光盘上的产品，现已发展成高清晰度 DVD 标准，由 HD DVD 推广协会负责制定及开发。HD DVD 与其竞争对手 Blu-ray Disc（简写为 “BD”，蓝光光盘）有些许些相似之处，光盘均是和 CD 同样大小（直径 120mm）的光学数字格式存储介质，使用 405 纳米波长的蓝色镭射。\nHD DVD 由东芝、 NEC、 三洋电机等企业组成的 HD DVD 推广协会负责推广，惠普（同时支持 BD）、 微软及英特尔等相继加入 HD DVD 阵营，其中的主流片厂环球影业亦是成员之一。\n但在 2008 年，随着原先支持 HD DVD 的华纳公司宣布脱离 HD DVD，以及美国数家连锁卖场决定支持蓝光产品，东芝公司终在 2008 年 2 月 19 日正式宣布将终止 HD DVD 事业。\nBD 蓝光光盘 Blu-ray Disc\n蓝光光盘是由索尼及松下电器等企业组成的蓝光光盘联盟（Blu-ray Disc Association）策划的次世代光盘规格，并以索尼为首于 2006 年开始全面推动相关产品。\nUHD-BD 超高清蓝光光盘（英语： Ultra HD Blu-ray ）是改良型蓝光光盘的数字光盘数据存储格式。 超高清蓝光光盘的碟片尺寸规格虽与传统的 CD、DVD 及现有的蓝光光盘相同，并且采用和传统蓝光盘相似的碟片和光头。 但影音的格式有出入而专用的播放器的软硬件不兼容，需使用支持读取超高清蓝光光盘播放器才可播放，而以新的格式可以用和传统蓝光相同容量下，播放更高清晰度的影片或延长播放时间。 超高清蓝光光盘支持 4KUHD（分辨率：3840×2160）视频，帧速率高达每秒 60 帧，使用高效率视频编码（H.265）进行编码。\n"});index.add({'id':723,'href':'/note-cs/docs/basic/pl/javascript/basic/practice/spec/baidu/css/','title':"Css",'content':"CSS 编码规范 1 前言\n2 代码风格\n2.1 文件\n2.2 缩进\n2.3 空格\n2.4 行长度\n2.5 选择器\n2.6 属性\n3 通用\n3.1 选择器\n3.2 属性缩写\n3.3 属性书写顺序\n3.4 清除浮动\n3.5 !important\n3.6 z-index\n4 值与单位\n4.1 文本\n4.2 数值\n4.3 url()\n4.4 长度\n4.5 颜色\n4.6 2D 位置\n5 文本编排\n5.1 字体族\n5.2 字号\n5.3 字体风格\n5.4 字重\n5.5 行高\n6 变换与动画\n7 响应式\n8 兼容性\n8.1 属性前缀\n8.2 Hack\n8.3 Expression\n1 前言 CSS 作为网页样式的描述语言，在百度一直有着广泛的应用。本文档的目标是使 CSS 代码风格保持一致，容易被理解和被维护。\n虽然本文档是针对 CSS 设计的，但是在使用各种 CSS 的预编译器(如 less、sass、stylus 等)时，适用的部分也应尽量遵循本文档的约定。\n任何问题或建议，欢迎跟我们讨论: fe-styleguide@baidu.com\n2 代码风格 2.1 文件 [建议] CSS 文件使用无 BOM 的 UTF-8 编码。 解释：\nUTF-8 编码具有更广泛的适应性。BOM 在使用程序或工具处理文件时可能造成不必要的干扰。\n2.2 缩进 [强制] 使用 4 个空格做为一个缩进层级，不允许使用 2 个空格 或 tab 字符。 示例：\n.selector { margin: 0; padding: 0; } 2.3 空格 [强制] 选择器 与 { 之间必须包含空格。 示例：\n.selector { } [强制] 属性名 与之后的 : 之间不允许包含空格， : 与 属性值 之间必须包含空格。 示例：\nmargin: 0; [强制] 列表型属性值 书写在单行时，, 后必须跟一个空格。 示例：\nfont-family: Arial, sans-serif; 2.4 行长度 [强制] 每行不得超过 120 个字符，除非单行不可分割。 解释：\n常见不可分割的场景为 URL 超长。\n[建议] 对于超长的样式，在样式值的 空格 处或 , 后换行，建议按逻辑分组。 示例：\n/* 不同属性值按逻辑分组 */ background: transparent url(aVeryVeryVeryLongUrlIsPlacedHere) no-repeat 0 0; /* 可重复多次的属性，每次重复一行 */ background-image: url(aVeryVeryVeryLongUrlIsPlacedHere) url(anotherVeryVeryVeryLongUrlIsPlacedHere); /* 类似函数的属性值可以根据函数调用的缩进进行 */ background-image: -webkit-gradient( linear, left bottom, left top, color-stop(0.04, rgb(88, 94, 124)), color-stop(0.52, rgb(115, 123, 162)) ); 2.5 选择器 [强制] 当一个 rule 包含多个 selector 时，每个选择器声明必须独占一行。 示例：\n/* good */ .post, .page, .comment { line-height: 1.5; } /* bad */ .post, .page, .comment { line-height: 1.5; } [强制] \u0026gt;、+、~ 选择器的两边各保留一个空格。 示例：\n/* good */ main \u0026gt; nav { padding: 10px; } label + input { margin-left: 5px; } input:checked ~ button { background-color: #69c; } /* bad */ main \u0026gt; nav { padding: 10px; } label + input { margin-left: 5px; } input:checked ~ button { background-color: #69c; } [强制] 属性选择器中的值必须用双引号包围。 解释：\n不允许使用单引号，不允许不使用引号。\n示例：\n/* good */ article[character=\u0026#34;juliet\u0026#34;] { voice-family: \u0026#34;Vivien Leigh\u0026#34;, victoria, female; } /* bad */ article[character=\u0026#34;juliet\u0026#34;] { voice-family: \u0026#34;Vivien Leigh\u0026#34;, victoria, female; } 2.6 属性 [强制] 属性定义必须另起一行。 示例：\n/* good */ .selector { margin: 0; padding: 0; } /* bad */ .selector { margin: 0; padding: 0; } [强制] 属性定义后必须以分号结尾。 示例：\n/* good */ .selector { margin: 0; } /* bad */ .selector { margin: 0; } 3 通用 3.1 选择器 [强制] 如无必要，不得为 id、class 选择器添加类型选择器进行限定。 解释：\n在性能和维护性上，都有一定的影响。\n示例：\n/* good */ #error, .danger-message { font-color: #c00; } /* bad */ dialog#error, p.danger-message { font-color: #c00; } [建议] 选择器的嵌套层级应不大于 3 级，位置靠后的限定条件应尽可能精确。 示例：\n/* good */ #username input { } .comment .avatar { } /* bad */ .page .header .login #username input { } .comment div * { } 3.2 属性缩写 [建议] 在可以使用缩写的情况下，尽量使用属性缩写。 示例：\n/* good */ .post { font: 12px/1.5 arial, sans-serif; } /* bad */ .post { font-family: arial, sans-serif; font-size: 12px; line-height: 1.5; } [建议] 使用 border / margin / padding 等缩写时，应注意隐含值对实际数值的影响，确实需要设置多个方向的值时才使用缩写。 解释：\nborder / margin / padding 等缩写会同时设置多个属性的值，容易覆盖不需要覆盖的设定。如某些方向需要继承其他声明的值，则应该分开设置。\n示例：\n/* centering \u0026lt;article class=\u0026#34;page\u0026#34;\u0026gt; horizontally and highlight featured ones */ article { margin: 5px; border: 1px solid #999; } /* good */ .page { margin-right: auto; margin-left: auto; } .featured { border-color: #69c; } /* bad */ .page { margin: 5px auto; /* introducing redundancy */ } .featured { border: 1px solid #69c; /* introducing redundancy */ } 3.3 属性书写顺序 [建议] 同一 rule set 下的属性在书写时，应按功能进行分组，并以 Formatting Model（布局方式、位置） \u0026gt; Box Model（尺寸） \u0026gt; Typographic（文本相关） \u0026gt; Visual（视觉效果） 的顺序书写，以提高代码的可读性。 解释：\n Formatting Model 相关属性包括：position / top / right / bottom / left / float / display / overflow 等 Box Model 相关属性包括：border / margin / padding / width / height 等 Typographic 相关属性包括：font / line-height / text-align / word-wrap 等 Visual 相关属性包括：background / color / transition / list-style 等  另外，如果包含 content 属性，应放在最前面。\n示例：\n.sidebar { /* formatting model: positioning schemes / offsets / z-indexes / display / ... */ position: absolute; top: 50px; left: 0; overflow-x: hidden; /* box model: sizes / margins / paddings / borders / ... */ width: 200px; padding: 5px; border: 1px solid #ddd; /* typographic: font / aligns / text styles / ... */ font-size: 14px; line-height: 20px; /* visual: colors / shadows / gradients / ... */ background: #f5f5f5; color: #333; -webkit-transition: color 1s; -moz-transition: color 1s; transition: color 1s; } 3.4 清除浮动 [建议] 当元素需要撑起高度以包含内部的浮动元素时，通过对伪类设置 clear 或触发 BFC 的方式进行 clearfix。尽量不使用增加空标签的方式。 解释：\n触发 BFC 的方式很多，常见的有：\n float 非 none position 非 static overflow 非 visible  如希望使用更小副作用的清除浮动方法，参见 A new micro clearfix hack 一文。\n另需注意，对已经触发 BFC 的元素不需要再进行 clearfix。\n3.5 !important [建议] 尽量不使用 !important 声明。 [建议] 当需要强制指定样式且不允许任何场景覆盖时，通过标签内联和 !important 定义样式。 解释：\n必须注意的是，仅在设计上 确实不允许任何其它场景覆盖样式 时，才使用内联的 !important 样式。通常在第三方环境的应用中使用这种方案。下面的 z-index 章节是其中一个特殊场景的典型样例。\n3.6 z-index [建议] 将 z-index 进行分层，对文档流外绝对定位元素的视觉层级关系进行管理。 解释：\n同层的多个元素，如多个由用户输入触发的 Dialog，在该层级内使用相同的 z-index 或递增 z-index。\n建议每层包含 100 个 z-index 来容纳足够的元素，如果每层元素较多，可以调整这个数值。\n[建议] 在可控环境下，期望显示在最上层的元素，z-index 指定为 999999。 解释：\n可控环境分成两种，一种是自身产品线环境；还有一种是可能会被其他产品线引用，但是不会被外部第三方的产品引用。\n不建议取值为 2147483647。以便于自身产品线被其他产品线引用时，当遇到层级覆盖冲突的情况，留出向上调整的空间。\n[建议] 在第三方环境下，期望显示在最上层的元素，通过标签内联和 !important，将 z-index 指定为 2147483647。 解释：\n第三方环境对于开发者来说完全不可控。在第三方环境下的元素，为了保证元素不被其页面其他样式定义覆盖，需要采用此做法。\n4 值与单位 4.1 文本 [强制] 文本内容必须用双引号包围。 解释：\n文本类型的内容可能在选择器、属性值等内容中。\n示例：\n/* good */ html[lang|=\u0026#34;zh\u0026#34;] q:before { font-family: \u0026#34;Microsoft YaHei\u0026#34;, sans-serif; content: \u0026#34;“\u0026#34;; } html[lang|=\u0026#34;zh\u0026#34;] q:after { font-family: \u0026#34;Microsoft YaHei\u0026#34;, sans-serif; content: \u0026#34;”\u0026#34;; } /* bad */ html[lang|=\u0026#34;zh\u0026#34;] q:before { font-family: \u0026#34;Microsoft YaHei\u0026#34;, sans-serif; content: \u0026#34;“\u0026#34;; } html[lang|=\u0026#34;zh\u0026#34;] q:after { font-family: \u0026#34;Microsoft YaHei\u0026#34;, sans-serif; content: \u0026#34;”\u0026#34;; } 4.2 数值 [强制] 当数值为 0 - 1 之间的小数时，省略整数部分的 0。 示例：\n/* good */ panel { opacity: 0.8; } /* bad */ panel { opacity: 0.8; } 4.3 url() [强制] url() 函数中的路径不加引号。 示例：\nbody { background: url(bg.png); } [建议] url() 函数中的绝对路径可省去协议名。 示例：\nbody { background: url(//baidu.com/img/bg.png) no-repeat 0 0; } 4.4 长度 [强制] 长度为 0 时须省略单位。 (也只有长度单位可省) 示例：\n/* good */ body { padding: 0 5px; } /* bad */ body { padding: 0px 5px; } 4.5 颜色 [强制] RGB 颜色值必须使用十六进制记号形式 #rrggbb。不允许使用 rgb()。 解释：\n带有 alpha 的颜色信息可以使用 rgba()。使用 rgba() 时每个逗号后必须保留一个空格。\n示例：\n/* good */ .success { box-shadow: 0 0 2px rgba(0, 128, 0, 0.3); border-color: #008000; } /* bad */ .success { box-shadow: 0 0 2px rgba(0, 128, 0, 0.3); border-color: rgb(0, 128, 0); } [强制] 颜色值可以缩写时，必须使用缩写形式。 示例：\n/* good */ .success { background-color: #aca; } /* bad */ .success { background-color: #aaccaa; } [强制] 颜色值不允许使用命名色值。 示例：\n/* good */ .success { color: #90ee90; } /* bad */ .success { color: lightgreen; } [建议] 颜色值中的英文字符采用小写。如不用小写也需要保证同一项目内保持大小写一致。 示例：\n/* good */ .success { background-color: #aca; color: #90ee90; } /* good */ .success { background-color: #aca; color: #90ee90; } /* bad */ .success { background-color: #aca; color: #90ee90; } 4.6 2D 位置 [强制] 必须同时给出水平和垂直方向的位置。 解释：\n2D 位置初始值为 0% 0%，但在只有一个方向的值时，另一个方向的值会被解析为 center。为避免理解上的困扰，应同时给出两个方向的值。background-position 属性值的定义\n示例：\n/* good */ body { background-position: center top; /* 50% 0% */ } /* bad */ body { background-position: top; /* 50% 0% */ } 5 文本编排 5.1 字体族 [强制] font-family 属性中的字体族名称应使用字体的英文 Family Name，其中如有空格，须放置在引号中。 解释：\n所谓英文 Family Name，为字体文件的一个元数据，常见名称如下：\n   字体 操作系统 Family Name     宋体 (中易宋体) Windows SimSun   黑体 (中易黑体) Windows SimHei   微软雅黑 Windows Microsoft YaHei   微软正黑 Windows Microsoft JhengHei   华文黑体 Mac/iOS STHeiti   冬青黑体 Mac/iOS Hiragino Sans GB   文泉驿正黑 Linux WenQuanYi Zen Hei   文泉驿微米黑 Linux WenQuanYi Micro Hei    示例：\nh1 { font-family: \u0026#34;Microsoft YaHei\u0026#34;; } [强制] font-family 按「西文字体在前、中文字体在后」、「效果佳 (质量高/更能满足需求) 的字体在前、效果一般的字体在后」的顺序编写，最后必须指定一个通用字体族( serif / sans-serif )。 解释：\n更详细说明可参考本文。\n示例：\n/* Display according to platform */ .article { font-family: Arial, sans-serif; } /* Specific for most platforms */ h1 { font-family: \u0026#34;Helvetica Neue\u0026#34;, Arial, \u0026#34;Hiragino Sans GB\u0026#34;, \u0026#34;WenQuanYi Micro Hei\u0026#34;, \u0026#34;Microsoft YaHei\u0026#34;, sans-serif; } [强制] font-family 不区分大小写，但在同一个项目中，同样的 Family Name 大小写必须统一。 示例：\n/* good */ body { font-family: Arial, sans-serif; } h1 { font-family: Arial, \u0026#34;Microsoft YaHei\u0026#34;, sans-serif; } /* bad */ body { font-family: arial, sans-serif; } h1 { font-family: Arial, \u0026#34;Microsoft YaHei\u0026#34;, sans-serif; } 5.2 字号 [强制] 需要在 Windows 平台显示的中文内容，其字号应不小于 12px。 解释：\n由于 Windows 的字体渲染机制，小于 12px 的文字显示效果极差、难以辨认。\n5.3 字体风格 [建议] 需要在 Windows 平台显示的中文内容，不要使用除 normal 外的 font-style。其他平台也应慎用。 解释：\n由于中文字体没有 italic 风格的实现，所有浏览器下都会 fallback 到 obilique 实现 (自动拟合为斜体)，小字号下 (特别是 Windows 下会在小字号下使用点阵字体的情况下) 显示效果差，造成阅读困难。\n5.4 字重 [强制] font-weight 属性必须使用数值方式描述。 解释：\nCSS 的字重分 100 – 900 共九档，但目前受字体本身质量和浏览器的限制，实际上支持 400 和 700 两档，分别等价于关键词 normal 和 bold。\n浏览器本身使用一系列启发式规则来进行匹配，在 \u0026lt;700 时一般匹配字体的 Regular 字重，\u0026gt;=700 时匹配 Bold 字重。\n但已有浏览器开始支持 =600 时匹配 Semibold 字重 (见此表)，故使用数值描述增加了灵活性，也更简短。\n示例：\n/* good */ h1 { font-weight: 700; } /* bad */ h1 { font-weight: bold; } 5.5 行高 [建议] line-height 在定义文本段落时，应使用数值。 解释：\n将 line-height 设置为数值，浏览器会基于当前元素设置的 font-size 进行再次计算。在不同字号的文本段落组合中，能达到较为舒适的行间间隔效果，避免在每个设置了 font-size 都需要设置 line-height。\n当 line-height 用于控制垂直居中时，还是应该设置成与容器高度一致。\n示例：\n.container { line-height: 1.5; } 6 变换与动画 [强制] 使用 transition 时应指定 transition-property。 示例：\n/* good */ .box { transition: color 1s, border-color 1s; } /* bad */ .box { transition: all 1s; } [建议] 尽可能在浏览器能高效实现的属性上添加过渡和动画。 解释：\n见 本文，在可能的情况下应选择这样四种变换：\n transform: translate(npx, npx); transform: scale(n); transform: rotate(ndeg); opacity: 0..1;  典型的，可以使用 translate 来代替 left 作为动画属性。\n示例：\n/* good */ .box { transition: transform 1s; } .box:hover { transform: translate(20px); /* move right for 20px */ } /* bad */ .box { left: 0; transition: left 1s; } .box:hover { left: 20px; /* move right for 20px */ } 7 响应式 [强制] Media Query 不得单独编排，必须与相关的规则一起定义。 示例：\n/* Good */ /* header styles */ @media (...) { /* header styles */ } /* main styles */ @media (...) { /* main styles */ } /* footer styles */ @media (...) { /* footer styles */ } /* Bad */ /* header styles */ /* main styles */ /* footer styles */ @media (...) { /* header styles */ /* main styles */ /* footer styles */ } [强制] Media Query 如果有多个逗号分隔的条件时，应将每个条件放在单独一行中。 示例：\n@media (-webkit-min-device-pixel-ratio: 2), /* Webkit-based browsers */ (min--moz-device-pixel-ratio: 2), /* Older Firefox browsers (prior to firefox 16) */ (min-resolution: 2dppx), /* The standard way */ (min-resolution: 192dpi) { /* dppx fallback */ /* Retina-specific stuff here */ } [建议] 尽可能给出在高分辨率设备 (Retina) 下效果更佳的样式。 8 兼容性 8.1 属性前缀 [强制] 带私有前缀的属性由长到短排列，按冒号位置对齐。 解释：\n标准属性放在最后，按冒号对齐方便阅读，也便于在编辑器内进行多行编辑。\n示例：\n.box { -webkit-box-sizing: border-box; -moz-box-sizing: border-box; box-sizing: border-box; } 8.2 Hack [建议] 需要添加 hack 时应尽可能考虑是否可以采用其他方式解决。 解释：\n如果能通过合理的 HTML 结构或使用其他的 CSS 定义达到理想的样式，则不应该使用 hack 手段解决问题。通常 hack 会导致维护成本的增加。\n[建议] 尽量使用 选择器 hack 处理兼容性，而非 属性 hack。 解释：\n尽量使用符合 CSS 语法的 selector hack，可以避免一些第三方库无法识别 hack 语法的问题。\n示例：\n/* IE 7 */ *:first-child + html #header { margin-top: 3px; padding: 5px; } /* IE 6 */ * html #header { margin-top: 5px; padding: 4px; } [建议] 尽量使用简单的 属性 hack。 示例：\n.box { _display: inline; /* fix double margin */ float: left; margin-left: 20px; } .container { overflow: hidden; *zoom: 1; /* triggering hasLayout */ } 8.3 Expression [强制] 禁止使用 Expression。 "});index.add({'id':724,'href':'/note-cs/docs/basic/pl/javascript/basic/practice/spec/baidu/es-next/','title':"Es Next",'content':"JavaScript 编码规范 - ESNext 补充篇（草案） 1 前言\n2 代码风格\n2.1 文件\n2.2 结构\n2.2.1 缩进\n2.2.2 空格\n2.2.3 语句\n3 语言特性\n3.1 变量\n3.2 解构\n3.3 模板字符串\n3.4 函数\n3.5 箭头函数\n3.6 对象\n3.7 类\n3.8 模块\n3.9 集合\n3.10 异步\n4 环境\n4.1 运行环境\n4.2 预编译\n1 前言 随着 ECMAScript 的不断发展，越来越多更新的语言特性将被使用，给应用的开发带来方便。本文档的目标是使 ECMAScript 新特性的代码风格保持一致，并给予一些实践建议。\n本文档仅包含新特性部分。基础部分请遵循 JavaScript Style Guide。\n由于 ECMAScript 依然在快速的不断发展，本文档也将可能随时保持更新。更新内容主要涉及对新增的语言特性的格式规范化、实践指导，引擎与编译器环境变化的使用指导。\n虽然本文档是针对 ECMAScript 设计的，但是在使用各种基于 ECMAScript 扩展的语言时(如 JSX、TypeScript 等)，适用的部分也应尽量遵循本文档的约定。\n任何问题或建议，欢迎跟我们讨论: fe-styleguide@baidu.com\n2 代码风格 2.1 文件 [建议] ESNext 语法的 JavaScript 文件使用 .js 扩展名。 [强制] 当文件无法使用 .js 扩展名时，使用 .es 扩展名。 解释：\n某些应用开发时，可能同时包含 ES 5 和 ESNext 文件，运行环境仅支持 ES5，ESNext 文件需要经过预编译。部分场景下，编译工具的选择可能需要通过扩展名区分，需要重新定义 ESNext 文件的扩展名。此时，ESNext 文件必须使用 .es 扩展名。\n但是，更推荐使用其他条件作为是否需要编译的区分：\n 基于文件内容。 不同类型文件放在不同目录下。  2.2 结构 2.2.1 缩进 [建议] 使用多行模板字符串时遵循缩进原则。当空行与空白字符敏感时，不使用多行模板字符串。 解释：\n4 空格为一个缩进，换行后添加一层缩进。将起始和结束的 ` 符号单独放一行，有助于生成 HTML 时的标签对齐。\n为避免破坏缩进的统一，当空行与空白字符敏感时，建议使用 多个模板字符串 或 普通字符串 进行连接运算，也可使用数组 join 生成字符串。\n示例：\n// good function foo() { let html = ` \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; `; } // Good function greeting(name) { return \u0026#34;Hello, \\n\u0026#34; + `${name.firstName}${name.lastName}`; } // Bad function greeting(name) { return `Hello, ${name.firstName}${name.lastName}`; } 2.2.2 空格 [强制] 使用 generator 时，* 前面不允许有空格，* 后面必须有一个空格。 示例：\n// good function* caller() { yield \u0026#34;a\u0026#34;; yield* callee(); yield \u0026#34;d\u0026#34;; } // bad function* caller() { yield \u0026#34;a\u0026#34;; yield* callee(); yield \u0026#34;d\u0026#34;; } 2.2.3 语句 [强制] 类声明结束不允许添加分号。 解释：\n与函数声明保持一致。\n[强制] 类成员定义中，方法定义后不允许添加分号，成员属性定义后必须添加分号。 解释：\n成员属性是当前 Stage 0 的标准，如果使用的话，则定义后加上分号。\n示例：\n// good class Foo { foo = 3; bar() {} } // bad class Foo { foo = 3; bar() {} } [强制] export 语句后，不允许出现表示空语句的分号。 解释：\nexport 关键字不影响后续语句类型。\n示例：\n// good export function foo() {} export default function bar() {} // bad export function foo() {} export default function bar() {} [强制] 属性装饰器后，可以不加分号的场景，不允许加分号。 解释：\n只有一种场景是必须加分号的：当属性 key 是 computed property key 时，其装饰器必须加分号，否则修饰 key 的 [] 会做为之前表达式的 property accessor。\n上面描述的场景，装饰器后需要加分号。其余场景下的属性装饰器后不允许加分号。\n示例：\n// good class Foo { @log(\u0026#39;INFO\u0026#39;) bar() { } @log(\u0026#39;INFO\u0026#39;); [\u0026#39;bar\u0026#39; + 2]() { } } // bad class Foo { @log(\u0026#39;INFO\u0026#39;); bar() { } @log(\u0026#39;INFO\u0026#39;) [\u0026#39;bar\u0026#39; + 2]() { } } [强制] 箭头函数的参数只有一个，并且不包含解构时，参数部分的括号必须省略。 示例：\n// good list.map(item =\u0026gt; item * 2); // good let fetchName = async id =\u0026gt; { let user = await request(`users/${id}`); return user.fullName; }; // bad list.map(item =\u0026gt; item * 2); // bad let fetchName = async id =\u0026gt; { let user = await request(`users/${id}`); return user.fullName; }; [建议] 箭头函数的函数体只有一个单行表达式语句，且作为返回值时，省略 {} 和 return。 如果单个表达式过长，可以使用 () 进行包裹。\n示例：\n// good list.map(item =\u0026gt; item * 2); let foo = () =\u0026gt; (condition ? returnValueA() : returnValueB()); // bad list.map(item =\u0026gt; { return item * 2; }); [建议] 箭头函数的函数体只有一个 Object Literal，且作为返回值时，使用 () 包裹。 示例：\n// good list.map(item =\u0026gt; ({ name: item[0], email: item[1] })); [强制] 解构多个变量时，如果超过行长度限制，每个解构的变量必须单独一行。 解释：\n太多的变量解构会让一行的代码非常长，极有可能超过单行长度控制，使代码可读性下降。\n示例：\n// good let { name: personName, email: personEmail, sex: personSex, age: personAge } = person; // bad let { name: personName, email: personEmail, sex: personSex, age: personAge } = person; [强制] 对于对象初始化、数组初始化、import及export语句，当其多个子元素占用多行时，最后一个元素后必须保留逗号。 解释：\nES Next 允许以上语法最后保留逗号，多行时保留逗号有助于快速添加或删除子元素。\n本条规则不适用于函数调用和声明的参数，函数最后一个参数不得包含逗号。\n示例：\n// good const array = [foo, bar]; const array = [foo, bar]; // 单行的最后没有逗号  const object = { foo: bar, x: y }; const object = { foo: bar }; // 单行的最后没有逗号  import { foo, bar } from \u0026#34;module\u0026#34;; import { foo, bar } from \u0026#34;module\u0026#34;; // 单行的最后没有逗号  export { foo, bar }; export { foo, bar }; // 单行的最后没有逗号  // bad  const array = [foo, bar]; const object = { foo: bar, x: y }; 3 语言特性 3.1 变量 [强制] 使用 let 和 const 定义变量，不使用 var。 解释：\n使用 let 和 const 定义时，变量作用域范围更明确。\n示例：\n// good for (let i = 0; i \u0026lt; 10; i++) {} // bad for (var i = 0; i \u0026lt; 10; i++) {} 3.2 解构 [强制] 不要使用 3 层及以上的解构。 解释：\n过多层次的解构会让代码变得难以阅读。\n示例：\n// bad let { documentElement: { firstElementChild: { nextSibling } } } = window; [建议] 使用解构减少中间变量。 解释：\n常见场景如变量值交换，可能产生中间变量。这种场景推荐使用解构。\n示例：\n// good [x, y] = [y, x]; // bad let temp = x; x = y; y = temp; [强制] 如果不节省编写时产生的中间变量，解构表达式 = 号右边不允许是 ObjectLiteral 和 ArrayLiteral。 解释：\n在这种场景下，使用解构将降低代码可读性，通常也并无收益。\n示例：\n// good let { first: firstName, last: lastName } = person; let one = 1; let two = 2; // bad let [one, two] = [1, 2]; [强制] 使用剩余运算符时，剩余运算符之前的所有元素必需具名。 解释：\n剩余运算符之前的元素省略名称可能带来较大的程序阅读障碍。如果仅仅为了取数组后几项，请使用 slice 方法。\n示例：\n// good let [one, two, ...anyOther] = myArray; let other = myArray.slice(3); // bad let [, , , ...other] = myArray; 3.3 模板字符串 [强制] 字符串内变量替换时，不要使用 2 次及以上的函数调用。 解释：\n在变量替换符内有太多的函数调用等复杂语法会导致可读性下降。\n示例：\n// good let fullName = getFullName(getFirstName(), getLastName()); let s = `Hello ${fullName}`; // bad let s = `Hello ${getFullName(getFirstName(), getLastName())}`; 3.4 函数 [建议] 使用变量默认语法代替基于条件判断的默认值声明。 解释：\n添加默认值有助于引擎的优化，在未来 strong mode 下也会有更好的效果。\n示例：\n// good function foo(text = \u0026#34;hello\u0026#34;) {} // bad function foo(text) { text = text || \u0026#34;hello\u0026#34;; } [强制] 不要使用 arguments 对象，应使用 ...args 代替。 解释：\n在未来 strong mode 下 arguments 将被禁用。\n示例：\n// good function foo(...args) { console.log(args.join(\u0026#34;\u0026#34;)); } // bad function foo() { console.log([].join.call(arguments)); } 3.5 箭头函数 [强制] 一个函数被设计为需要 call 和 apply 的时候，不能是箭头函数。 解释：\n箭头函数会强制绑定当前环境下的 this。\n3.6 对象 [强制] 定义方法时使用 MethodDefinition 语法，不使用 PropertyName: FunctionExpression 语法。 解释：\nMethodDefinition 语法更清晰简洁。\n示例：\n// good let foo = { bar(x, y) { return x + y; } }; // bad let foo = { bar: function(x, y) { return x + y; } }; [建议] 使用 Object.keys 或 Object.entries 进行对象遍历。 解释：\n不建议使用 for .. in 进行对象的遍历，以避免遗漏 hasOwnProperty 产生的错误。\n示例：\n// good for (let key of Object.keys(foo)) { let value = foo[key]; } // good for (let [key, value] of Object.entries(foo)) { // ... } [建议] 定义对象的方法不应使用箭头函数。 解释：\n箭头函数将 this 绑定到当前环境，在 obj.method() 调用时容易导致不期待的 this。除非明确需要绑定 this，否则不应使用箭头函数。\n示例：\n// good let foo = { bar(x, y) { return x + y; } }; // bad let foo = { bar: (x, y) =\u0026gt; x + y }; [建议] 尽量使用计算属性键在一个完整的字面量中完整地定义一个对象，避免对象定义后直接增加对象属性。 解释：\n在一个完整的字面量中声明所有的键值，而不需要将代码分散开来，有助于提升代码可读性。\n示例：\n// good const MY_KEY = \u0026#34;bar\u0026#34;; let foo = { [MY_KEY + \u0026#34;Hash\u0026#34;]: 123 }; // bad const MY_KEY = \u0026#34;bar\u0026#34;; let foo = {}; foo[MY_KEY + \u0026#34;Hash\u0026#34;] = 123; 3.7 类 [强制] 使用 class 关键字定义一个类。 解释：\n直接使用 class 定义类更清晰。不要再使用 function 和 prototype 形式的定义。\n// good class TextNode { constructor(value, engine) { this.value = value; this.engine = engine; } clone() { return this; } } // bad function TextNode(value, engine) { this.value = value; this.engine = engine; } TextNode.prototype.clone = function() { return this; }; [强制] 使用 super 访问父类成员，而非父类的 prototype。 解释：\n使用 super 和 super.foo 可以快速访问父类成员，而不必硬编码父类模块而导致修改和维护的不便，同时更节省代码。\n// good class TextNode extends Node { constructor(value, engine) { super(value); this.engine = engine; } setNodeValue(value) { super.setNodeValue(value); this.textContent = value; } } // bad class TextNode extends Node { constructor(value, engine) { Node.apply(this, arguments); this.engine = engine; } setNodeValue(value) { Node.prototype.setNodeValue.call(this, value); this.textContent = value; } } 3.8 模块 [建议] 相互之间无关联的内容使用命名导出。 解释：\n举个例子，工具对象中的各个方法，相互之间并没有强关联，通常外部会选择几个使用，则应该使用命名导出。\n简而言之，当一个模块只扮演命名空间的作用时，使用命名导出。\n[强制] 所有 import 语句写在模块开始处。 示例：\n// good import { bar } from \u0026#34;./bar\u0026#34;; function foo() { bar.work(); } // bad function foo() { import { bar } from \u0026#34;./bar\u0026#34;; bar.work(); } 3.9 集合 [建议] 对数组进行连接操作时，使用数组展开语法。 解释：\n用数组展开代替 concat 方法，数组展开对 Iterable 有更好的兼容性。\n示例：\n// good let foo = [...foo, newValue]; let bar = [...bar, ...newValues]; // bad let foo = foo.concat(newValue); let bar = bar.concat(newValues); [建议] 不要使用数组展开进行数组的复制操作。 解释：\n使用数组展开语法进行复制，代码可读性较差。推荐使用 Array.from 方法进行复制操作。\n示例：\n// good let otherArr = Array.from(arr); // bad let otherArr = [...arr]; [建议] 尽可能使用 for .. of 进行遍历。 解释：\n使用 for .. of 可以更好地接受任何的 Iterable 对象，如 Map#values 生成的迭代器，使得方法的通用性更强。\n以下情况除外：\n 遍历确实成为了性能瓶颈，需要使用原生 for 循环提升性能。 需要遍历过程中的索引。  [强制] 当键值有可能不是字符串时，必须使用 Map；当元素有可能不是字符串时，必须使用 Set。 解释：\n使用普通 Object，对非字符串类型的 key，需要自己实现序列化。并且运行过程中的对象变化难以通知 Object。\n[建议] 需要一个不可重复的集合时，应使用 Set。 解释：\n不要使用 {foo: true} 这样的普通 Object。\n示例：\n// good let members = new Set([\u0026#34;one\u0026#34;, \u0026#34;two\u0026#34;, \u0026#34;three\u0026#34;]); // bad let members = { one: true, two: true, three: true }; [建议] 当需要遍历功能时，使用 Map 和 Set。 解释：\nMap 和 Set 是可遍历对象，能够方便地使用 for...of 遍历。不要使用使用普通 Object。\n示例：\n// good let membersAge = new Map([ [\u0026#34;one\u0026#34;, 10], [\u0026#34;two\u0026#34;, 20], [\u0026#34;three\u0026#34;, 30] ]); for (let [key, value] of map) { } // bad let membersAge = { one: 10, two: 20, three: 30 }; for (let key in membersAge) { if (membersAge.hasOwnProperty(key)) { let value = membersAge[key]; } } [建议] 程序运行过程中有添加或移除元素的操作时，使用 Map 和 Set。 解释：\n使用 Map 和 Set，程序的可理解性更好；普通 Object 的语义更倾向于表达固定的结构。\n示例：\n// good let membersAge = new Map(); membersAge.set(\u0026#34;one\u0026#34;, 10); membersAge.set(\u0026#34;two\u0026#34;, 20); membersAge.set(\u0026#34;three\u0026#34;, 30); membersAge.delete(\u0026#34;one\u0026#34;); // bad let membersAge = {}; membersAge.one = 10; membersAge.two = 20; membersAge.three = 30; delete membersAge[\u0026#34;one\u0026#34;]; 3.10 异步 [强制] 回调函数的嵌套不得超过 3 层。 解释：\n深层次的回调函数的嵌套会让代码变得难以阅读。\n示例：\n// bad getUser(userId, function(user) { validateUser(user, function(isValid) { if (isValid) { saveReport(report, user, function() { notice(\u0026#34;Saved!\u0026#34;); }); } }); }); [建议] 使用 Promise 代替 callback。 解释：\n相比 callback，使用 Promise 能够使复杂异步过程的代码更清晰。\n示例：\n// good let user; getUser(userId) .then(function(userObj) { user = userObj; return validateUser(user); }) .then(function(isValid) { if (isValid) { return saveReport(report, user); } return Promise.reject(\u0026#34;Invalid!\u0026#34;); }) .then( function() { notice(\u0026#34;Saved!\u0026#34;); }, function(message) { notice(message); } ); [强制] 使用标准的 Promise API。 解释：\n 不允许使用非标准的 Promise API，如 jQuery 的 Deferred、Q.js 的 defer 等。 不允许使用非标准的 Promise 扩展 API，如 bluebird 的 Promise.any 等。  使用标准的 Promise API，当运行环境都支持时，可以把 Promise Lib 直接去掉。\n[强制] 不允许直接扩展 Promise 对象的 prototype。 解释：\n理由和 不允许修改和扩展任何原生对象和宿主对象的原型 是一样的。如果想要使用更方便，可以用 utility 函数的形式。\n[强制] 不得为了编写的方便，将可以并行的 IO 过程串行化。 解释：\n并行 IO 消耗时间约等于 IO 时间最大的那个过程，串行的话消耗时间将是所有过程的时间之和。\n示例：\nrequestData().then(function(data) { renderTags(data.tags); renderArticles(data.articles); }); // good async function requestData() { const [tags, articles] = await Promise.all([ requestTags(), requestArticles() ]); return { tags, articles }; } // bad async function requestData() { let tags = await requestTags(); let articles = await requestArticles(); return Promise.resolve({ tags, articles }); } [建议] 使用 async/await 代替 generator + co。 解释：\n使用语言自身的能力可以使代码更清晰，也无需引入 co 库。\n示例：\naddReport(report, userId).then( function() { notice(\u0026#34;Saved!\u0026#34;); }, function(message) { notice(message); } ); // good async function addReport(report, userId) { let user = await getUser(userId); let isValid = await validateUser(user); if (isValid) { let savePromise = saveReport(report, user); return savePromise(); } return Promise.reject(\u0026#34;Invalid\u0026#34;); } // bad function addReport(report, userId) { return co(function*() { let user = yield getUser(userId); let isValid = yield validateUser(user); if (isValid) { let savePromise = saveReport(report, user); return savePromise(); } return Promise.reject(\u0026#34;Invalid\u0026#34;); }); } 4 环境 4.1 运行环境 [建议] 持续跟进与关注运行环境对语言特性的支持程度。 解释：\n查看环境对语言特性的支持程度\nES 标准的制定还在不断进行中，各种环境对语言特性的支持也日新月异。了解项目中用到了哪些 ESNext 的特性，了解项目的运行环境，并持续跟进这些特性在运行环境中的支持程度是很有必要的。这意味着：\n 如果有任何一个运行环境（比如 chrome）支持了项目里用到的所有特性，你可以在开发时抛弃预编译。 如果所有环境都支持了某一特性（比如 Promise），你可以抛弃相关的 shim，或无需在预编译时进行转换。 如果所有环境都支持了项目里用到的所有特性，你可以完全抛弃预编译。  无论如何，在选择预编译工具时，你都需要清晰的知道你现阶段将在项目里使用哪些语言特性，然后了解预编译工具对语言特性的支持程度，做出选择。\n[强制] 在运行环境中没有 Promise 时，将 Promise 的实现 shim 到 global 中。 解释：\n当前运行环境下没有 Promise 时，可以引入 shim 的扩展。如果自己实现，需要实现在 global 下，并且与标准 API 保持一致。\n这样，未来运行环境支持时，可以随时把 Promise 扩展直接扔掉，而应用代码无需任何修改。\n4.2 预编译 [建议] 使用 babel 做为预编译工具时，建议使用 5.x 版本。 解释：\n由于 babel 最新的 6 暂时还不稳定，建议暂时使用 5.x。不同的产品，对于浏览器支持的情况不同，使用 babel 的时候，需要设置的参数也有一些区别。下面在示例中给出一些建议的参数。\n示例：\n＃ 建议的参数 --loose all --modules amd --blacklist strict ＃ 如果需要使用 es7.classProperties、es7.decorators 等一些特性，需要额外的 --stage 0 参数 --loose all --modules amd --blacklist strict --stage 0 [建议] 使用 babel 做为预编译工具时，通过 external-helpers 减少生成文件的大小。 解释：\n当 babel 在转换代码的过程中发现需要一些特性时，会在该文件头部生成对应的 helper 代码。默认情况下，对于每一个经由 babel 处理的文件，均会在文件头部生成对应需要的辅助函数，多份文件辅助函数存在重复，占用了不必要的代码体积。\n因此推荐打开externalHelpers: true选项，使 babel 在转换后内容中不写入 helper 相关的代码，而是使用一个外部的 .js统一提供所有的 helper。对于external-helpers的使用，可以有两种方式：\n 默认方式：需要通过 \u0026lt;script\u0026gt; 自行引入babel-polyfill.js 和 babel-external-helpers.js。 定制方式：自己实现 babel-runtime。  示例：\n# 默认方式 --loose all --modules amd --external-helpers # `babelHelpers` 的代码可以通过执行 `babel-external-helpers -t var` 得到所有相关API的实现 # 定制方式 --loose all --modules amd --optional runtime [建议] 使用 TypeScript 做为预编译工具时，建议使用 1.6+ 版本。 解释：\nTypeScript 1.6 之后，基本摒弃了之前的与 ESNext 相冲突的地方。目前 TypeScript 的思路就是遵循标准，将 stage 已经足够成熟的功能纳入，并提供静态类型和类型检查，所以其在 stage 0/1 的支持上不如 babel。另外，TypeScript 不能指定关闭某个 transform，但其编译速度比 babel 更高。\nTypeScript 的常用参数在下面给出了示例。\n示例：\n--module amd --target ES3 --module commonjs --target ES6 [建议] 使用 TypeScript 做为预编译工具时，不使用 tsc 命令。 解释：\nTypeScript 提供的 tsc 命令只支持后缀名 .ts、.tsx、.d.ts 的文件编译，对于 JavaScript 来说，保持后缀名为 .js 是原则，本文档的 文件 章节也有所要求。\n如果要使用 TypeScript 做为预编译工具，可基于其 Compiler API 开发自己的预编译工具。如果你是 FIS 用户，可以使用 FIS TypeScript 插件。\n[建议] 生成的代码在浏览器环境运行时，应生成 AMD 模块化代码。 解释：\nAMD 在浏览器环境应用较为成熟。\n[建议] 浏览器端项目中如果 ESNext 代码和 ES3/5 代码混合，不要使用 TypeScript 做为预编译工具。 解释：\nTypeScript 产生的 module 代码使用 exports.default 导出默认的 export，但是没有直接为 module.exports 赋值，导致在另外一个普通文件中使用 require(\u0026lsquo;moduleName\u0026rsquo;) 是拿不到东西的。\n需要使用 TypeScript 的话，建议整个项目所有文件都是 ESNext module 的，采用混合的 module 容易出现不可预期的结果。\n[建议] AMD/CommonJS 模块依赖 ESNext 模块时，AMD/CommonJS 模块对 default export 的 require 需要改造。 解释：\nESNext 模块经过编译后，named export 会挂载在 exports 对象上，default export 也会挂载在 exports 对象上名称为 default 的属性。同时 exports 对象会包含一个值为 true 的 __esModule 属性。那么问题来了，当 AMD/CommonJS 模块依赖了 ESNext 模块时，require 期望拿到的是 exports.default，但你实际上拿到的是 exports。\n所以，老的 AMD/CommonJS 模块依赖了 default export 的 ESNext 模块时，对 default export 的 require 需要改造成 require('name').default。\n另外，如果是 ESNext 模块之间的互相依赖，transpiler 会通过加入中间对象和引入 interop 方法，所以不会产生这个问题。\n"});index.add({'id':725,'href':'/note-cs/docs/basic/pl/javascript/basic/practice/spec/baidu/html/','title':"Html",'content':"HTML 编码规范 1 前言\n2 代码风格\n2.1 缩进与换行\n2.2 命名\n2.3 标签\n2.4 属性\n3 通用\n3.1 DOCTYPE\n3.2 编码\n3.3 CSS 和 JavaScript 引入\n4 head\n4.1 title\n4.2 favicon\n4.3 viewport\n5 图片\n6 表单\n6.1 控件标题\n6.2 按钮\n6.3 可访问性 (A11Y)\n7 多媒体\n8 模板中的 HTML\n1 前言 HTML 作为描述网页结构的超文本标记语言，在百度一直有着广泛的应用。本文档的目标是使 HTML 代码风格保持一致，容易被理解和被维护。\n任何问题或建议，欢迎跟我们讨论: fe-styleguide@baidu.com\n2 代码风格 2.1 缩进与换行 [强制] 使用 4 个空格做为一个缩进层级，不允许使用 2 个空格 或 tab 字符。 解释： 对于非 HTML 标签之间的缩进，比如 script 或 style 标签内容缩进，与 script 或 style 标签的缩进同级。\n示例：\n\u0026lt;style\u0026gt; /* 样式内容的第一级缩进与所属的 style 标签对齐 */ ul { padding: 0; } \u0026lt;/style\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;first\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;second\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;script\u0026gt; // 脚本代码的第一级缩进与所属的 script 标签对齐  require([\u0026#34;app\u0026#34;], function (app) { app.init(); }); \u0026lt;/script\u0026gt; [建议] 每行不得超过 120 个字符。 解释：\n过长的代码不容易阅读与维护。但是考虑到 HTML 的特殊性，不做硬性要求。\n2.2 命名 [强制] class 必须单词全字母小写，单词间以 - 分隔。 [强制] class 必须代表相应模块或部件的内容或功能，不得以样式信息进行命名。 示例：\n\u0026lt;!-- good --\u0026gt; \u0026lt;div class=\u0026#34;sidebar\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;!-- bad --\u0026gt; \u0026lt;div class=\u0026#34;left\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; [强制] 元素 id 必须保证页面唯一。 解释：\n同一个页面中，不同的元素包含相同的 id，不符合 id 的属性含义。并且使用 document.getElementById 时可能导致难以追查的问题。\n[建议] id 建议单词全字母小写，单词间以 - 分隔。同项目必须保持风格一致。 [建议] id、class 命名，在避免冲突并描述清楚的前提下尽可能短。 示例：\n\u0026lt;!-- good --\u0026gt; \u0026lt;div id=\u0026#34;nav\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;!-- bad --\u0026gt; \u0026lt;div id=\u0026#34;navigation\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;!-- good --\u0026gt; \u0026lt;p class=\u0026#34;comment\u0026#34;\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;!-- bad --\u0026gt; \u0026lt;p class=\u0026#34;com\u0026#34;\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;!-- good --\u0026gt; \u0026lt;span class=\u0026#34;author\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;!-- bad --\u0026gt; \u0026lt;span class=\u0026#34;red\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; [强制] 禁止为了 hook 脚本，创建无样式信息的 class。 解释：\n不允许 class 只用于让 JavaScript 选择某些元素，class 应该具有明确的语义和样式。否则容易导致 CSS class 泛滥。\n使用 id、属性选择作为 hook 是更好的方式。\n[强制] 同一页面，应避免使用相同的 name 与 id。 解释：\nIE 浏览器会混淆元素的 id 和 name 属性， document.getElementById 可能获得不期望的元素。所以在对元素的 id 与 name 属性的命名需要非常小心。\n一个比较好的实践是，为 id 和 name 使用不同的命名法。\n示例：\n\u0026lt;input name=\u0026#34;foo\u0026#34; /\u0026gt; \u0026lt;div id=\u0026#34;foo\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; // IE6 将显示 INPUT  alert(document.getElementById(\u0026#34;foo\u0026#34;).tagName); \u0026lt;/script\u0026gt; 2.3 标签 [强制] 标签名必须使用小写字母。 示例：\n\u0026lt;!-- good --\u0026gt; \u0026lt;p\u0026gt;Hello StyleGuide!\u0026lt;/p\u0026gt; \u0026lt;!-- bad --\u0026gt; \u0026lt;p\u0026gt;Hello StyleGuide!\u0026lt;/p\u0026gt; [强制] 对于无需自闭合的标签，不允许自闭合。 解释：\n常见无需自闭合标签有 input、br、img、hr 等。\n示例：\n\u0026lt;!-- good --\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;title\u0026#34; /\u0026gt; \u0026lt;!-- bad --\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;title\u0026#34; /\u0026gt; [强制] 对 HTML5 中规定允许省略的闭合标签，不允许省略闭合标签。 解释：\n对代码体积要求非常严苛的场景，可以例外。比如：第三方页面使用的投放系统。\n示例：\n\u0026lt;!-- good --\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;first\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;second\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;!-- bad --\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;first\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;second\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; [强制] 标签使用必须符合标签嵌套规则。 解释：\n比如 div 不得置于 p 中，tbody 必须置于 table 中。\n详细的标签嵌套规则参见HTML DTD中的 Elements 定义部分。\n[建议] HTML 标签的使用应该遵循标签的语义。 解释：\n下面是常见标签语义\n p - 段落 h1,h2,h3,h4,h5,h6 - 层级标题 strong,em - 强调 ins - 插入 del - 删除 abbr - 缩写 code - 代码标识 cite - 引述来源作品的标题 q - 引用 blockquote - 一段或长篇引用 ul - 无序列表 ol - 有序列表 dl,dt,dd - 定义列表  示例：\n\u0026lt;!-- good --\u0026gt; \u0026lt;p\u0026gt; Esprima serves as an important \u0026lt;strong\u0026gt;building block\u0026lt;/strong\u0026gt; for some JavaScript language tools. \u0026lt;/p\u0026gt; \u0026lt;!-- bad --\u0026gt; \u0026lt;div\u0026gt; Esprima serves as an important \u0026lt;span class=\u0026#34;strong\u0026#34;\u0026gt;building block\u0026lt;/span\u0026gt; for some JavaScript language tools. \u0026lt;/div\u0026gt; [建议] 在 CSS 可以实现相同需求的情况下不得使用表格进行布局。 解释：\n在兼容性允许的情况下应尽量保持语义正确性。对网格对齐和拉伸性有严格要求的场景允许例外，如多列复杂表单。\n[建议] 标签的使用应尽量简洁，减少不必要的标签。 示例：\n\u0026lt;!-- good --\u0026gt; \u0026lt;img class=\u0026#34;avatar\u0026#34; src=\u0026#34;image.png\u0026#34; /\u0026gt; \u0026lt;!-- bad --\u0026gt; \u0026lt;span class=\u0026#34;avatar\u0026#34;\u0026gt; \u0026lt;img src=\u0026#34;image.png\u0026#34; /\u0026gt; \u0026lt;/span\u0026gt; 2.4 属性 [强制] 属性名必须使用小写字母。 示例：\n\u0026lt;!-- good --\u0026gt; \u0026lt;table cellspacing=\u0026#34;0\u0026#34;\u0026gt; ... \u0026lt;/table\u0026gt; \u0026lt;!-- bad --\u0026gt; \u0026lt;table cellspacing=\u0026#34;0\u0026#34;\u0026gt; ... \u0026lt;/table\u0026gt; [强制] 属性值必须用双引号包围。 解释：\n不允许使用单引号，不允许不使用引号。\n示例：\n\u0026lt;!-- good --\u0026gt; \u0026lt;script src=\u0026#34;esl.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;!-- bad --\u0026gt; \u0026lt;script src=\u0026#34;esl.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;esl.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; [强制] 属性名与属性值中间不得存在空格。 解释：\n按 HTML 规范 = 两边可以存在空格，但为了保持一致不允许添加空格。\n示例：\n\u0026lt;!-- good --\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; /\u0026gt; \u0026lt;!-- bad --\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; /\u0026gt; [建议] 布尔类型的属性，建议不添加属性值。 示例：\n\u0026lt;input type=\u0026#34;text\u0026#34; disabled /\u0026gt; \u0026lt;input type=\u0026#34;checkbox\u0026#34; value=\u0026#34;1\u0026#34; checked /\u0026gt; [建议] 自定义属性建议以 xxx- 为前缀，推荐使用 data-。 解释：\n使用前缀有助于区分自定义属性和标准定义的属性。\n示例：\n\u0026lt;ol data-ui-type=\u0026#34;Select\u0026#34;\u0026gt;\u0026lt;/ol\u0026gt; 3 通用 3.1 DOCTYPE [强制] 使用 HTML5 的 doctype 来启用标准模式，建议使用大写的 DOCTYPE。 示例：\n\u0026lt;!DOCTYPE html\u0026gt; [建议] 启用 IE Edge 模式。 示例：\n\u0026lt;meta http-equiv=\u0026#34;X-UA-Compatible\u0026#34; content=\u0026#34;IE=Edge\u0026#34; /\u0026gt; [建议] 在 html 标签上设置正确的 lang 属性。 解释：\n有助于提高页面的可访问性，如：让语音合成工具确定其所应该采用的发音，令翻译工具确定其翻译语言等。\n示例：\n\u0026lt;html lang=\u0026#34;zh-CN\u0026#34;\u0026gt;\u0026lt;/html\u0026gt; 3.2 编码 [强制] 页面必须使用精简形式，明确指定字符编码。指定字符编码的 meta 必须是 head 的第一个直接子元素。 解释：\n见 HTML5 Charset 能用吗 一文。\n示例：\n\u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34; /\u0026gt; ...... \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; ...... \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; [建议] HTML 文件使用无 BOM 的 UTF-8 编码。 解释：\nUTF-8 编码具有更广泛的适应性。BOM 在使用程序或工具处理文件时可能造成不必要的干扰。\n3.3 CSS 和 JavaScript 引入 [强制] 引入 CSS 时必须指明 rel=\u0026quot;stylesheet\u0026quot;。 示例：\n\u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;page.css\u0026#34; /\u0026gt; [建议] 引入 CSS 和 JavaScript 时无须指明 type 属性。 解释：\ntext/css 和 text/javascript 是 type 的默认值。\n[建议] 展现定义放置于外部 CSS 中，行为定义放置于外部 JavaScript 中。 解释：\n结构-样式-行为的代码分离，对于提高代码的可阅读性和维护性都有好处。\n[建议] 在 head 中引入页面需要的所有 CSS 资源。 解释：\n在页面渲染的过程中，新的 CSS 可能导致元素的样式重新计算和绘制，页面闪烁。\n[建议] JavaScript 应当放在页面末尾，或采用异步加载。 解释：\n将 script 放在页面中间将阻断页面的渲染。出于性能方面的考虑，如非必要，请遵守此条建议。\n示例：\n\u0026lt;body\u0026gt; \u0026lt;!-- a lot of elements --\u0026gt; \u0026lt;script src=\u0026#34;init-behavior.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; [建议] 移动环境或只针对现代浏览器设计的 Web 应用，如果引用外部资源的 URL 协议部分与页面相同，建议省略协议前缀。 解释：\n使用 protocol-relative URL 引入 CSS，在 IE7/8 下，会发两次请求。是否使用 protocol-relative URL 应充分考虑页面针对的环境。\n示例：\n\u0026lt;script src=\u0026#34;//s1.bdstatic.com/cache/static/jquery-1.10.2.min_f2fb5194.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; 4 head 4.1 title [强制] 页面必须包含 title 标签声明标题。 [强制] title 必须作为 head 的直接子元素，并紧随 charset 声明之后。 解释：\ntitle 中如果包含 ASCII 之外的字符，浏览器需要知道字符编码类型才能进行解码，否则可能导致乱码。\n示例：\n\u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;页面标题\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; 4.2 favicon [强制] 保证 favicon 可访问。 解释：\n在未指定 favicon 时，大多数浏览器会请求 Web Server 根目录下的 favicon.ico 。为了保证 favicon 可访问，避免 404，必须遵循以下两种方法之一：\n 在 Web Server 根目录放置 favicon.ico 文件。 使用 link 指定 favicon。  示例：\n\u0026lt;link rel=\u0026#34;shortcut icon\u0026#34; href=\u0026#34;path/to/favicon.ico\u0026#34; /\u0026gt; 4.3 viewport [建议] 若页面欲对移动设备友好，需指定页面的 viewport。 解释：\nviewport meta tag 可以设置可视区域的宽度和初始缩放大小，避免在移动设备上出现页面展示不正常。\n比如，在页面宽度小于 980px 时，若需 iOS 设备友好，应当设置 viewport 的 width 值来适应你的页面宽度。同时因为不同移动设备分辨率不同，在设置时，应当使用 device-width 和 device-height 变量。\n另外，为了使 viewport 正常工作，在页面内容样式布局设计上也要做相应调整，如避免绝对定位等。关于 viewport 的更多介绍，可以参见 Safari Web Content Guide 的介绍\n5 图片 [强制] 禁止 img 的 src 取值为空。延迟加载的图片也要增加默认的 src。 解释：\nsrc 取值为空，会导致部分浏览器重新加载一次当前页面，参考：https://developer.yahoo.com/performance/rules.html#emptysrc\n[建议] 避免为 img 添加不必要的 title 属性。 解释：\n多余的 title 影响看图体验，并且增加了页面尺寸。\n[建议] 为重要图片添加 alt 属性。 解释：\n可以提高图片加载失败时的用户体验。\n[建议] 添加 width 和 height 属性，以避免页面抖动。 [建议] 有下载需求的图片采用 img 标签实现，无下载需求的图片采用 CSS 背景图实现。 解释：\n 产品 logo、用户头像、用户产生的图片等有潜在下载需求的图片，以 img 形式实现，能方便用户下载。 无下载需求的图片，比如：icon、背景、代码使用的图片等，尽可能采用 CSS 背景图实现。  6 表单 6.1 控件标题 [强制] 有文本标题的控件必须使用 label 标签将其与其标题相关联。 解释：\n有两种方式：\n 将控件置于 label 内。 label 的 for 属性指向控件的 id。  推荐使用第一种，减少不必要的 id。如果 DOM 结构不允许直接嵌套，则应使用第二种。\n示例：\n\u0026lt;label \u0026gt;\u0026lt;input type=\u0026#34;checkbox\u0026#34; name=\u0026#34;confirm\u0026#34; value=\u0026#34;on\u0026#34; /\u0026gt; 我已确认上述条款\u0026lt;/label \u0026gt; \u0026lt;label for=\u0026#34;username\u0026#34;\u0026gt;用户名：\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026#34;textbox\u0026#34; name=\u0026#34;username\u0026#34; id=\u0026#34;username\u0026#34; /\u0026gt; 6.2 按钮 [强制] 使用 button 元素时必须指明 type 属性值。 解释：\nbutton 元素的默认 type 为 submit，如果被置于 form 元素中，点击后将导致表单提交。为显示区分其作用方便理解，必须给出 type 属性。\n示例：\n\u0026lt;button type=\u0026#34;submit\u0026#34;\u0026gt;提交\u0026lt;/button\u0026gt; \u0026lt;button type=\u0026#34;button\u0026#34;\u0026gt;取消\u0026lt;/button\u0026gt; [建议] 尽量不要使用按钮类元素的 name 属性。 解释：\n由于浏览器兼容性问题，使用按钮的 name 属性会带来许多难以发现的问题。具体情况可参考此文。\n6.3 可访问性 (A11Y) [建议] 负责主要功能的按钮在 DOM 中的顺序应靠前。 解释：\n负责主要功能的按钮应相对靠前，以提高可访问性。如果在 CSS 中指定了 float: right 则可能导致视觉上主按钮在前，而 DOM 中主按钮靠后的情况。\n示例：\n\u0026lt;!-- good --\u0026gt; \u0026lt;style\u0026gt; .buttons .button-group { float: right; } \u0026lt;/style\u0026gt; \u0026lt;div class=\u0026#34;buttons\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;button-group\u0026#34;\u0026gt; \u0026lt;button type=\u0026#34;submit\u0026#34;\u0026gt;提交\u0026lt;/button\u0026gt; \u0026lt;button type=\u0026#34;button\u0026#34;\u0026gt;取消\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;!-- bad --\u0026gt; \u0026lt;style\u0026gt; .buttons button { float: right; } \u0026lt;/style\u0026gt; \u0026lt;div class=\u0026#34;buttons\u0026#34;\u0026gt; \u0026lt;button type=\u0026#34;button\u0026#34;\u0026gt;取消\u0026lt;/button\u0026gt; \u0026lt;button type=\u0026#34;submit\u0026#34;\u0026gt;提交\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; [建议] 当使用 JavaScript 进行表单提交时，如果条件允许，应使原生提交功能正常工作。 解释：\n当浏览器 JS 运行错误或关闭 JS 时，提交功能将无法工作。如果正确指定了 form 元素的 action 属性和表单控件的 name 属性时，提交仍可继续进行。\n示例：\n\u0026lt;form action=\u0026#34;/login\u0026#34; method=\u0026#34;post\u0026#34;\u0026gt; \u0026lt;p\u0026gt;\u0026lt;input name=\u0026#34;username\u0026#34; type=\u0026#34;text\u0026#34; placeholder=\u0026#34;用户名\u0026#34; /\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;\u0026lt;input name=\u0026#34;password\u0026#34; type=\u0026#34;password\u0026#34; placeholder=\u0026#34;密码\u0026#34; /\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;/form\u0026gt; [建议] 在针对移动设备开发的页面时，根据内容类型指定输入框的 type 属性。 解释：\n根据内容类型指定输入框类型，能获得能友好的输入体验。\n示例：\n\u0026lt;input type=\u0026#34;date\u0026#34; /\u0026gt; 7 多媒体 [建议] 当在现代浏览器中使用 audio 以及 video 标签来播放音频、视频时，应当注意格式。 解释：\n音频应尽可能覆盖到如下格式：\n MP3 WAV Ogg  视频应尽可能覆盖到如下格式：\n MP4 WebM Ogg  [建议] 在支持 HTML5 的浏览器中优先使用 audio 和 video 标签来定义音视频元素。 [建议] 使用退化到插件的方式来对多浏览器进行支持。 示例：\n\u0026lt;audio controls\u0026gt; \u0026lt;source src=\u0026#34;audio.mp3\u0026#34; type=\u0026#34;audio/mpeg\u0026#34; /\u0026gt; \u0026lt;source src=\u0026#34;audio.ogg\u0026#34; type=\u0026#34;audio/ogg\u0026#34; /\u0026gt; \u0026lt;object width=\u0026#34;100\u0026#34; height=\u0026#34;50\u0026#34; data=\u0026#34;audio.mp3\u0026#34;\u0026gt; \u0026lt;embed width=\u0026#34;100\u0026#34; height=\u0026#34;50\u0026#34; src=\u0026#34;audio.swf\u0026#34; /\u0026gt; \u0026lt;/object\u0026gt; \u0026lt;/audio\u0026gt; \u0026lt;video width=\u0026#34;100\u0026#34; height=\u0026#34;50\u0026#34; controls\u0026gt; \u0026lt;source src=\u0026#34;video.mp4\u0026#34; type=\u0026#34;video/mp4\u0026#34; /\u0026gt; \u0026lt;source src=\u0026#34;video.ogg\u0026#34; type=\u0026#34;video/ogg\u0026#34; /\u0026gt; \u0026lt;object width=\u0026#34;100\u0026#34; height=\u0026#34;50\u0026#34; data=\u0026#34;video.mp4\u0026#34;\u0026gt; \u0026lt;embed width=\u0026#34;100\u0026#34; height=\u0026#34;50\u0026#34; src=\u0026#34;video.swf\u0026#34; /\u0026gt; \u0026lt;/object\u0026gt; \u0026lt;/video\u0026gt; [建议] 只在必要的时候开启音视频的自动播放。 [建议] 在 object 标签内部提供指示浏览器不支持该标签的说明。 示例：\n\u0026lt;object width=\u0026#34;100\u0026#34; height=\u0026#34;50\u0026#34; data=\u0026#34;something.swf\u0026#34; \u0026gt;DO NOT SUPPORT THIS TAG\u0026lt;/object \u0026gt; 8 模板中的 HTML [建议] 模板代码的缩进优先保证 HTML 代码的缩进规则。 示例：\n\u0026lt;!-- good --\u0026gt; {if $display == true} \u0026lt;div\u0026gt; \u0026lt;ul\u0026gt; {foreach $item_list as $item} \u0026lt;li\u0026gt;{$item.name}\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt; {/foreach} \u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; {/if} \u0026lt;!-- bad --\u0026gt; {if $display == true} \u0026lt;div\u0026gt; \u0026lt;ul\u0026gt; {foreach $item_list as $item} \u0026lt;li\u0026gt;{$item.name}\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt; {/foreach} \u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; {/if} [建议] 模板代码应以保证 HTML 单个标签语法的正确性为基本原则。 示例：\n\u0026lt;!-- good --\u0026gt; \u0026lt;li class=\u0026#34;{if $item.type_id == $current_type}focus{/if}\u0026#34;\u0026gt;{ $item.type_name }\u0026lt;/li\u0026gt; \u0026lt;!-- bad --\u0026gt; \u0026lt;li {if $item.type_id == $current_type} class=\u0026#34;focus\u0026#34;{/if}\u0026gt;{ $item.type_name }\u0026lt;/li\u0026gt; [建议] 在循环处理模板数据构造表格时，若要求每行输出固定的个数，建议先将数据分组，之后再循环输出。 示例：\n\u0026lt;!-- good --\u0026gt; \u0026lt;table\u0026gt; {foreach $item_list as $item_group} \u0026lt;tr\u0026gt; {foreach $item_group as $item} \u0026lt;td\u0026gt;{ $item.name }\u0026lt;/td\u0026gt; {/foreach} \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; {/foreach} \u0026lt;/tr\u0026gt; \u0026lt;/table\u0026gt; \u0026lt;!-- bad --\u0026gt; \u0026lt;table\u0026gt; \u0026lt;tr\u0026gt; {foreach $item_list as $item} \u0026lt;td\u0026gt;{ $item.name }\u0026lt;/td\u0026gt; {if $item@iteration is div by 5} \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; {/if} {/foreach} \u0026lt;/tr\u0026gt; \u0026lt;/table\u0026gt; [建议] 新窗口/标签页打开的链接需要按业务需要添加安全相关的 rel 属性值 noopener。 解释：\n新窗口/标签页打开的网页可以通过 window.opener 访问原网页的上下文，会引入安全问题。例如从搜索结果页打开的网页可以通过 window.opener 将结果页篡改为钓鱼网页，用户返回时将访问恶意网页内容。详见 4.8.6.8. Link type \u0026ldquo;noopener\u0026rdquo; - HTML 5.2。\n示例：\n\u0026lt;!-- good --\u0026gt; \u0026lt;a href=\u0026#34;//external.website/\u0026#34; target=\u0026#34;_blank\u0026#34; rel=\u0026#34;noopener\u0026#34;\u0026gt;外部链接\u0026lt;/a\u0026gt; \u0026lt;!-- bad --\u0026gt; \u0026lt;a href=\u0026#34;//external.website/\u0026#34; target=\u0026#34;_blank\u0026#34;\u0026gt;外部链接\u0026lt;/a\u0026gt; "});index.add({'id':726,'href':'/note-cs/docs/basic/pl/javascript/basic/practice/spec/baidu/react/','title':"React",'content':"React 编码规范 1 版本限制\n1.1 法律要求\n2 文件组织\n2.1 命名\n2.2 模块化\n3 命名规则\n3.1 组件\n3.2 属性\n3.3 高阶组件\n4 组件声明\n4.1 组件\n4.2 属性\n4.3 生命周期\n4.4 高阶组件\n5 组件实现\n5.1 更新机制\n5.2 纯函数应用\n6 JSX\n6.1 标签\n6.2 属性\n6.2.1 层级\n1 版本限制 1.1 法律要求 [强制] 使用 React \u0026gt;=15.6.2版本 解释\n在15.6.2以前的版本协议带有 Facebook Patents，依据法务风险，严禁使用。\n2 文件组织 2.1 命名 [强制] 同一目录下不得拥有同名的.js和.jsx文件。 解释：\n在使用模块导入时，倾向于不添加后缀，如果存在同名但不同后缀的文件，构建工具将无法决定哪一个是需要引入的模块。\n[强制] 组件文件使用一致的.js或 .jsx后缀。 解释：\n所有组件文件的后缀名从.js或.jsx中任选其一。\n不应在项目中出现部分组件为.js文件，部分为.jsx的情况。\n2.2 模块化 [建议] 实现单个组件的文件以export default的形式暴露一个组件。 解释：\n允许一个文件中存在多个不同的组件，但仅允许通过export default暴露一个组件，其它组件均定义为内部组件。\n[建议] 组织多个组件的目录使用一个index.js以命名导出的形式暴露所有组件。 解释：\n同目录内的组件相互引用使用import Foo from './Foo';进行。\n引用其它目录的组件使用import {Foo} from '../component';进行。\n建议使用VSCode 的 export-index 插件等插件自动生成index.js的内容。\n3 命名规则 3.1 组件 [强制] 组件名为 PascalCase。 包括函数组件，名称均为 PascalCase。\n[强制] 组件名称与文件名称保持相同。 同时组件名称应当能体现出组件的功能，以便通过观察文件名即确定使用哪一个组件。\n3.2 属性 [强制] 使用onXxx形式作为props中用于回调的属性名称。 解释：\n使用统一的命名规则用以区分props中回调和非回调部分的属性，在 JSX 上可以清晰地看到一个组件向上和向下的逻辑交互。\n对于不用于回调的函数类型的属性，使用动词作为属性名称。\n示例：\n// onClick作为回调以on开头，renderText非回调函数则使用动词 let Label = ({ onClick, renderText }) =\u0026gt; ( \u0026lt;span onClick={onClick}\u0026gt;{renderText()}\u0026lt;/span\u0026gt; ); [建议] 作为组件方法的事件处理函数以具备业务含义的词作为名称，不使用onXxx形式命名。 示例：\n// Good class Form { @bind() collectAndSubmitData() { let data = { name: this.state.name, age: this.state.age }; this.props.onSubmit(data); } @bind() syncName() { // ...  } @bind() syncAge() { // ...  } render() { return ( \u0026lt;div\u0026gt; \u0026lt;label\u0026gt; 姓名： \u0026lt;input type=\u0026#34;text\u0026#34; onChange={this.syncName} /\u0026gt; \u0026lt;/label\u0026gt; \u0026lt;label\u0026gt; 年龄： \u0026lt;input type=\u0026#34;number\u0026#34; onChange={this.syncAge} /\u0026gt; \u0026lt;/label\u0026gt; \u0026lt;button type=\u0026#34;button\u0026#34; onClick={this.collectAndSubmit}\u0026gt; 提交 \u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } } 3.3 高阶组件 [强制] 高阶组件使用 camelCase 命名。 解释：\n高阶组件事实上并非一个组件，而是一个“生成组件类型”的函数，因此遵守 JavaScript 函数命名的规范，使用 camelCase 命名。\n[建议] 使用withXxx或xxxable形式的词作为高阶组件的名称。 解释：\n高阶组件是为组件添加行为和功能的函数，因此使用如上形式的词有助于对其功能进行理解。\n4 组件声明 4.1 组件 [强制] 使用 ES Class 声明组件，禁止使用React.createClass。 解释：\nReact v15.5.0已经弃用了React.createClass函数。\n示例：\n// Bad let Message = React.createClass({ render() { return \u0026lt;span\u0026gt;{this.state.message}\u0026lt;/span\u0026gt;; } }); // Good class Message extends PureComponent { render() { return \u0026lt;span\u0026gt;{this.state.message}\u0026lt;/span\u0026gt;; } } [强制] 尽量使用无状态函数组件。 解释：\n函数组件在 React 中有着特殊的地位，在将来也有可能得到更多的内部优化。\n示例：\n// Bad class NextNumber { render() { return \u0026lt;span\u0026gt;{this.props.value + 1}\u0026lt;/span\u0026gt;; } } // Good let NextNumber = ({ value }) =\u0026gt; \u0026lt;span\u0026gt;{value + 1}\u0026lt;/span\u0026gt;; [建议] 无需显式引入 React 对象。 解释：\n使用 JSX 隐式地依赖当前环境下有React这一对象，但在源码上并没有显式使用，这种情况下添加import React from 'react';会造成一个没有使用的变量存在。\n使用babel-plugin-react-require插件可以很好地解决这一问题，因此无需显式地编写import React from 'react';这一语句。\n[建议] 使用箭头函数声明函数组件。 解释：\n箭头函数具备更简洁的语法（无需function关键字），且可以在仅有一个语句时省去return造成的额外缩进。\n4.2 属性 [强制] 对于所有非isRequired的属性，在defaultProps中声明对应的值。 解释：\n声明初始值有助于对组件初始状态的理解，也可以减少propTypes对类型进行校验产生的开销。\n对于初始没有值的属性，应当声明初始值为null而非undefined。\n[强制] 如无必要，使用属性语法声明propsTypes、contextTypes、defaultProps和state。 解释：\n仅当初始state需要从props计算得到的时候，才将state的声明放在构造函数中，其它情况下均使用属性声明进行。\n4.3 生命周期 [强制] 禁止使用componentWillMount。 解释：\n使用constructor代替。\n[强制] 依照规定顺序编排组件中的方法和属性。 按照以下顺序编排组件中的方法和属性：\n static displayName static propTypes state defaultProps 其它静态的属性 state 其它实例属性 用于事件处理并且以属性的方式（onClick = e =\u0026gt; {...}）声明的方法 constructor componentDidMount shouldComponentUpdate static getDerivedStateFromProps componentDidUpdate componentWillUnmount 事件处理方法 其它方法 render  4.4 高阶组件 [建议] 高阶组件返回新的组件类型时，添加displayName属性。 同时在displayName上声明高阶组件的存在。\n// Good let asPureComponent = Component =\u0026gt; { let componentName = Component.displayName || Component.name || \u0026#39;UnknownComponent\u0026#39;; return class extends PureComponent { static displayName = `asPure(${componentName})` render() { return \u0026lt;Component {..this.props} /\u0026gt;; } }; }; 5 组件实现 5.1 更新机制 [强制] 禁止为继承自PureComponent的组件编写shouldComponentUpdate实现。 参考React 的相关 Issue，在 React 的实现中，PureComponent并不直接实现shouldComponentUpdate，而是添加一个isReactPureComponent的标记，由CompositeComponent通过识别这个标记实现相关的逻辑。因此在PureComponent上自定义shouldComponentUpdate并无法享受super.shouldComponentUpdate的逻辑复用，也会使得这个继承关系失去意义。\n5.2 纯函数应用 [强制] 禁止在componentWillReceiveProps中包含除setState外的副作用。 解释：\ncomponentWillReceiveProps应当且仅应当用于props和state的数据同步，不得用于获取远程数据、更新外部状态、执行回调函数等逻辑。\n新版 React 使用getDerivedStateFromProps代替componentWillReceiveProps。\n[建议] 除顶层或路由级组件以外，所有组件均在概念上实现为纯组件（Pure Component）。 本条规则并非要求组件继承自PureComponent，“概念上的纯组件”的意思为一个组件在props和state没有变化（shallowEqual）的情况下，渲染的结果应保持一致。\n一个典型的非纯组件是使用了随机数或日期等函数：\nlet RandomNumber = () =\u0026gt; \u0026lt;span\u0026gt;{Math.random()}\u0026lt;/span\u0026gt;; let Clock = () =\u0026gt; \u0026lt;span\u0026gt;{Date.time()}\u0026lt;/span\u0026gt;; 非纯组件具备向上的“传染性”，即一个包含非纯组件的组件也必须是非纯组件，依次沿组件树结构向上。由于非纯组件无法通过shouldComponentUpdate优化渲染性能且具备传染性，因此要避免在非顶层或路由组件中使用。\n如果需要在组件树的某个节点使用随机数、日期等非纯的数据，应当由顶层组件生成这个值并通过props传递下来。对于使用 Redux 等应用状态管理的系统，可以在应用状态中存放相关值（如 Redux 使用 Action Creator 生成这些值并通过 Action 和 reducer 更新到 store 中）。\n6 JSX 6.1 标签 [强制] 没有子节点的组件使用自闭合语法。 解释：\nJSX 与 HTML 不同，所有元素均可以自闭合。\n示例：\n// Bad \u0026lt;Foo\u0026gt;\u0026lt;/Foo\u0026gt; \u0026lt;div\u0026gt;\u0026lt;/div\u0026gt; // Good \u0026lt;Foo /\u0026gt; \u0026lt;div /\u0026gt; [强制] 保持起始和结束标签在同一层缩进。 解释：\n对于标签前面有其它语句（如return的情况，使用括号进行换行和缩进）。\n对于直接return的函数组件，可以直接使用括号而省去大括号和return关键字：\nlet Message = () =\u0026gt; ( \u0026lt;div\u0026gt; \u0026lt;span\u0026gt;Hello World\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; ); 示例：\n// Bad class Message { render() { return \u0026lt;div\u0026gt; \u0026lt;span\u0026gt;Hello World\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt;; } } // Good class Message { render() { return ( \u0026lt;div\u0026gt; \u0026lt;span\u0026gt;Hello World\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt;; ); } } [强制] 自闭合标签的/\u0026gt;前添加一个空格。 示例：\n// Bad \u0026lt;Foo bar=\u0026#34;bar\u0026#34;/\u0026gt; \u0026lt;Foo bar=\u0026#34;bar\u0026#34; /\u0026gt; // Good \u0026lt;Foo bar=\u0026#34;bar\u0026#34; /\u0026gt; 6.2 属性 [强制] 对于多属性需要换行，从第一个属性开始，每个属性一行。 示例：\n// 没有子节点 \u0026lt;SomeComponent longProp={longProp} anotherLongProp={anotherLongProp} /\u0026gt; // 有子节点 \u0026lt;SomeComponent longProp={longProp} anotherLongProp={anotherLongProp} \u0026gt; \u0026lt;SomeChild /\u0026gt; \u0026lt;SomeChild /\u0026gt; \u0026lt;/SomeComponent\u0026gt; [强制] 以字符串字面量作为值的属性使用双引号（\u0026quot;），在其它类型表达式中的字符串使用单引号（'）。 示例：\n// Bad \u0026lt;Foo bar=\u0026#39;bar\u0026#39; /\u0026gt; \u0026lt;Foo style={{width: \u0026#34;20px\u0026#34;}} /\u0026gt; // Good \u0026lt;Foo bar=\u0026#34;bar\u0026#34; /\u0026gt; \u0026lt;Foo style={{width: \u0026#39;20px\u0026#39;}} /\u0026gt; [强制] 对于值为true的属性，省去值部分。 示例：\n// Bad \u0026lt;Foo visible={true} /\u0026gt; // Good \u0026lt;Foo visible /\u0026gt; [强制] 值为true的属性放在其它属性前面。 解释：\n将true类的值放在前面使得组件的声明更接近自然语言，提高可读性。\n示例：\n// Bad \u0026lt;Foo data={data} visible requireValidation /\u0026gt; // Good \u0026lt;Foo visible requireValidation data={data} /\u0026gt; [强制] 对于需要使用key的场合，提供一个唯一标识作为key属性的值，禁止使用可能会变化的属性（如索引）。 解释：\nkey属性是 React 在进行列表更新时的重要属性，如该属性会发生变化，渲染的性能和正确性都无法得到保证。\n示例：\n// Bad { list.map((item, index) =\u0026gt; \u0026lt;Foo key={index} {...item} /\u0026gt;); } // Good { list.map(item =\u0026gt; \u0026lt;Foo key={item.id} {...item} /\u0026gt;); } [建议] 避免在 JSX 的属性值中直接使用对象和函数表达式。 解释：\nPureComponent使用shallowEqual对props和state进行比较来决定是否需要渲染，而在 JSX 的属性值中使用对象、函数表达式会造成每一次的对象引用不同，从而shallowEqual会返回false，导致不必要的渲染。\n示例：\n// Bad class WarnButton { alertMessage(message) { alert(message); } render() { return ( \u0026lt;button type=\u0026#34;button\u0026#34; onClick={() =\u0026gt; this.alertMessage(this.props.message)} \u0026gt; 提示 \u0026lt;/button\u0026gt; ); } } // Good class WarnButton { @bind() alertMessage() { alert(this.props.message); } render() { return ( \u0026lt;button type=\u0026#34;button\u0026#34; onClick={this.alertMessage}\u0026gt; 提示 \u0026lt;/button\u0026gt; ); } } 6.2.1 层级 [建议] 将 JSX 的层级控制在 5 层以内。 解释：\nJSX 提供了基于组件的便携的复用形式，因此可以通过将结构中的一部分封装为一个函数组件来很好地拆分大型复杂的结构。层次过深的结构会带来过多缩进、可读性下降等缺点。如同控制函数内代码行数和分支层级一样，对 JSX 的层级进行控制可以有效提升代码的可维护性。\n示例：\n// Bad let List = ({ items }) =\u0026gt; ( \u0026lt;ul\u0026gt; {items.map(item =\u0026gt; ( \u0026lt;li\u0026gt; \u0026lt;header\u0026gt; \u0026lt;h3\u0026gt;{item.title}\u0026lt;/h3\u0026gt; \u0026lt;span\u0026gt;{item.subtitle}\u0026lt;/span\u0026gt; \u0026lt;/header\u0026gt; \u0026lt;section\u0026gt;{item.content}\u0026lt;/section\u0026gt; \u0026lt;footer\u0026gt; \u0026lt;span\u0026gt;{item.author}\u0026lt;/span\u0026gt;@\u0026lt;time\u0026gt;{item.postTime}\u0026lt;/time\u0026gt; \u0026lt;/footer\u0026gt; \u0026lt;/li\u0026gt; ))} \u0026lt;/ul\u0026gt; ); // Good let Header = ({ title, subtitle }) =\u0026gt; ( \u0026lt;header\u0026gt; \u0026lt;h3\u0026gt;{title}\u0026lt;/h3\u0026gt; \u0026lt;span\u0026gt;{subtitle}\u0026lt;/span\u0026gt; \u0026lt;/header\u0026gt; ); let Content = ({ content }) =\u0026gt; \u0026lt;section\u0026gt;{content}\u0026lt;/section\u0026gt;; let Footer = ({ author, postTime }) =\u0026gt; ( \u0026lt;footer\u0026gt; \u0026lt;span\u0026gt;{author}\u0026lt;/span\u0026gt;@\u0026lt;time\u0026gt;{postTime}\u0026lt;/time\u0026gt; \u0026lt;/footer\u0026gt; ); let Item = item =\u0026gt; ( \u0026lt;div\u0026gt; \u0026lt;Header {...item} /\u0026gt; \u0026lt;Content {...item} /\u0026gt; \u0026lt;Footer {...item} /\u0026gt; \u0026lt;/div\u0026gt; ); let List = ({ items }) =\u0026gt; \u0026lt;ul\u0026gt;{items.map(Item)}\u0026lt;/ul\u0026gt;; "});index.add({'id':727,'href':'/note-cs/docs/basic/pl/javascript/basic/practice/spec/baidu/typescript/','title':"Typescript",'content':"TypeScript 编码规范 1 前言\n2 代码风格\n2.1 环境\n2.2 文件\n2.3 命名\n3 语言特性\n3.1 变量\n3.2 类型\n3.3 条件\n3.4 循环\n3.5 数组\n3.6 对象\n3.7 函数\n3.8 类\n3.9 模块\n1 前言 随着 TypeScript 的不断发展，越来越多的开发者认可并使用 TypeScript 开发应用。本文档的目标是使 TypeScript 新特性的代码风格保持一致，并给予一些实践建议。\n本文档基本遵循 JavaScript Style Guide 与 \u0010ES-Next Style Guide。\n由于 TypeScript 依然在快速发展，本文档也将随时保持更新。更新内容主要涉及对新增的语言特性的格式规范化、实践指导，引擎与编译器环境变化的使用指导。\n任何问题或建议，欢迎跟我们讨论: fe-styleguide@baidu.com\n2 代码风格 2.1 环境 [强制] TypeScript 文件使用 .ts 扩展名。含 JSX 语法的 TypeScript 文件使用 .tsx 扩展名。 [建议] tsconfig.json 配置文件应开启 strict、noImplicitReturns、noUnusedLocals 选项。 [建议] tsconfig.json 配置文件应开启 allowSyntheticDefaultImports 选项。 示例：\n// good import React, { PureComponent } from \u0026#34;react\u0026#34;; // bad import * as React from \u0026#34;react\u0026#34;; [建议] 使用 VS Code 编写 TypeScript。 2.2 文件 [强制] 在文件结尾处，保留一个空行。 2.3 命名 [强制] 接口 使用 Pascal 命名法。 [强制] 接口名 不使用 I 作为前缀。 示例：\n// good interface ButtonProps { // ... } // bad interface IButtonProps { // ... } [强制] 类型别名 使用 Pascal 命名法。 示例：\n// good interface HeaderStateProps { // ... } interface HeaderDispatchProps { // ... } type HeaderProps = HeaderStateProps \u0026amp; HeaderDispatchProps; 3 语言特性 3.1 变量 [强制] 使用 const 声明 枚举 。 示例：\n// good const enum Directions { UP, DOWM, LEFT, RIGHT } // bad enum Directions { UP, DOWN, LEFT, RIGHT } 3.2 类型 [强制] 不应显式声明可以自动推导的类型。 示例：\n// good let shouldUpdate = false; // bad let shouldUpdate: boolean = false; [强制] 使用 string / number / boolean 声明基本类型，不使用 String / Number / Boolean。 示例：\n// good let str: string; // bad let str: String; [强制] 不使用 Object / Function 声明类型。 [强制] 数组元素为简单类型（非匿名且不含泛型）时，使用 T[] 声明类型，否则应使用 Array\u0026lt;T\u0026gt;。 [建议] 数组元素为不可变数据时，使用 ReadonlyArray\u0026lt;T\u0026gt; 声明类型。 示例：\n// good let files: string[]; let tokens: Array\u0026lt;string | number\u0026gt;; let buffer: Buffer[]; let responses: Array\u0026lt;Promise\u0026lt;number\u0026gt;\u0026gt;; // bad let files: Array\u0026lt;string\u0026gt;; let tokens: (string | number)[]; let buffer: Array\u0026lt;Buffer\u0026gt;; let responses: Promise\u0026lt;number\u0026gt;[]; [强制] 不使用 ! 声明对象属性非空。 示例：\n// good if (foo.bar \u0026amp;\u0026amp; foo.bar.baz) { // ... } // bad if (foo!.bar!.baz) { // ... } [建议] 不使用 any 声明类型。 示例：\n// good const identity = \u0026lt;T\u0026gt;(x: T) =\u0026gt; x; // bad const identity = (x: any) =\u0026gt; x; [强制] 使用 as 进行类型声明转换，不使用 \u0026lt;\u0026gt; 。 示例：\n// good const root = document.getElementById(\u0026#34;root\u0026#34;) as HTMLDivElement; // bad const root = \u0026lt;HTMLDivElement\u0026gt;document.getElementById(\u0026#34;root\u0026#34;); [强制] 接口不应为空。 [强制] 接口中同一函数重载的类型声明需相邻。 示例：\n// good interface AnyInterface { foo(); foo(x: string); bar(); bar(x: number); } // bad interface AnyInterface { foo(); bar(); foo(x: string); bar(x: number); } 3.3 条件 [强制] 使用 === 或 !== 判断相等性，不使用 == 或 !=。 示例：\n// good if (foo !== null \u0026amp;\u0026amp; foo !== undefined) { // ... } // bad if (foo != null) { // ... } 3.4 循环 [建议] 使用 Object.keys / Object.values / Object.entries / Object.getOwnPropertyNames 遍历对象，不使用 for .. in 。 示例：\n// good Object.keys(obj).forEach(key =\u0026gt; /* ... */); // bad for (const key in obj) { if (obj.hasOwnProperty(key)) { // ...  } } [建议] 索引仅用于获取数组当前被迭代的项时，使用 for .. of 遍历数组，不使用 for 。 示例：\n// good for (const item of items) { // ... } // bad for (let i = 0; i \u0026lt; items.length; i++) { const item = items[i]; // ... } 3.5 数组 [建议] 使用 ... 进行数组浅拷贝，不使用 Array.from / Array.prototype.slice 。 示例：\n// good const copies = [...items]; // bad const copies = items.slice(); // worst let copies = []; for (let i = 0; i \u0026lt; items.length; i++) { copies.push(items[i]); } [建议] 使用 ... 将类数组对象转化为数组，不使用 Array.from / Array.prototype.slice 。 示例：\n// good const elements = [...document.querySelectorAll(\u0026#34;.foo\u0026#34;)]; // bad const element = Array.from(document.querySelectorAll(\u0026#34;.foo\u0026#34;)); // worst const element = Array.prototype.slice.call(document.querySelectorAll(\u0026#34;.foo\u0026#34;)); 3.6 对象 [强制] 使用 ... 进行对象浅拷贝，不使用 Object.assign 。 示例：\n// good this.setState(state =\u0026gt; ({ ...state, clicked: true })); // bad this.setState(state =\u0026gt; Object.assign({}, state, { clicked: true })); 3.7 函数 [强制] 避免 return undefined ，应直接 return。 示例：\n// good function foo(bar: boolean) { if (!bar) { return; } } // bad function foo(bar: boolean) { if (!bar) { return undefined; } } 3.8 类 [建议] 每个文件中最多声明一个类。 [强制] 类成员的可访问性为 public 时，不应显式声明。 [建议] 构造函数可忽略时，应忽略。 [建议] 类成员之间使用空行隔开。 示例：\n// good class Button extends PureComponent\u0026lt;ButtonProps, ButtonState\u0026gt; { readonly state: ButtonState = { clicked: false }; render() { // ...  } } // bad class Button extends PureComponent\u0026lt;ButtonProps, ButtonState\u0026gt; { public state: ButtonState = { clicked: false }; constructor(props: ButtonProps) { super(props); } public render() { // ...  } } [建议] 构造函数初始化实例属性时，应尽量使用参数属性。 [建议] 构造函数的参数中，作为属性的参数应排列于其他参数前。 示例：\n// good class AppComponent { constructor(private readonly heroService: HeroService) {} } // bad class AppComponent { private readonly heroService: HeroService; constructor(heroService: HeroService) { this.heroService = heroService; } } 3.9 模块 [强制] 使用 ECMAScript 2015 标准的模块系统。 [强制] 除类型声明文件外，不使用 module / namespace 关键字。 [强制] 不使用 /// \u0026lt;reference path= \u0026gt; 。 示例：\n// good import foo from \u0026#34;foo\u0026#34;; // bad import foo = require(\u0026#34;foo\u0026#34;); [强制] 对于同一个模块路径，仅 import 一次。 示例：\n// good import React, { PureComponent } from \u0026#34;react\u0026#34;; // bad import React from \u0026#34;react\u0026#34;; import { PureComponent } from \u0026#34;react\u0026#34;; [建议] 对于使用 webpack 等构建工具的项目，在模块中引入其他资源（如样式、图片等）时，为资源编写类型声明文件，或使用合适的 loader 生成类型声明文件。 示例：\n// good  // Button.scss.d.ts export clicked: string; // logo.png.d.ts declare const logo: string; export default logo; // Button.tsx import styles from \u0026#39;./Button.scss\u0026#39;; import logo from \u0026#39;./logo.png\u0026#39;; // bad const styles = require\u0026lt;any\u0026gt;(\u0026#39;./Button.scss\u0026#39;); const logo = require\u0026lt;string\u0026gt;(\u0026#39;./logo.png\u0026#39;); "});index.add({'id':728,'href':'/note-cs/docs/basic/pl/javascript/basic/practice/spec/baidu/vue/','title':"Vue",'content':"Vue 组件代码规范 1 前言\n2 代码风格\n2.1 缩进\n2.2 单行最长限制\n2.3 模块书写顺序\n3 template 部分\n3.1 根节点\n3.2 标签\n3.3 属性\n3.4 指令\n3.5 插值（Mustache）\n3.6 空格\n3.7 变量\n4 javascript 部分\n4.1 props\n4.2 data\n4.3 变量\n4.4 其他\n5 style 部分\n6 参考\n1 前言 任何问题或建议，欢迎跟我们讨论: fe-styleguide@baidu.com\n2 代码风格 2.1 缩进 [强制] 使用 4 个空格做为一个缩进层级，不允许使用 2 个空格或 tab 字符 2.2 单行最长限制 [强制] 每行不得超过 120 个字符 2.3 模块书写顺序 [建议] template -\u0026gt; script -\u0026gt; style 3 template 部分 3.1 根节点 [强制] template 根节点只允许包含一个直接子节点，以下情况都是不允许的：  根结点为空； 根结点是文字； 根结点有多个元素； 在根结点使用循环； 在根结点使用 template 和 slot； 在根结点使用 v-if，但是没有 v-else；  // bad \u0026lt;template\u0026gt;\u0026lt;/template\u0026gt; \u0026lt;template\u0026gt;hello\u0026lt;/template\u0026gt; \u0026lt;template \u0026gt;\u0026lt;div\u0026gt;one\u0026lt;/div\u0026gt; \u0026lt;div\u0026gt;two\u0026lt;/div\u0026gt;\u0026lt;/template \u0026gt; \u0026lt;template\u0026gt;\u0026lt;div v-for=\u0026#34;x in list\u0026#34;\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/template\u0026gt; \u0026lt;template\u0026gt;\u0026lt;template\u0026gt;hello\u0026lt;/template\u0026gt;\u0026lt;/template\u0026gt; \u0026lt;template\u0026gt;\u0026lt;div v-if=\u0026#34;title\u0026#34;\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/template\u0026gt; // good \u0026lt;template\u0026gt;\u0026lt;div\u0026gt;one\u0026lt;/div\u0026gt;\u0026lt;/template\u0026gt; 3.2 标签 [强制] 自定义组件的标签名不得使用 HTML 中默认已定义的标签（reserved HTML elements），要求至少由两个单词组成，并且符合 kebab-case 解释：\n避免和 HTML 保留字段冲突导致错误。\n// bad \u0026lt;template\u0026gt; \u0026lt;sub /\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import OtherComponent from \u0026#34;./OtherComponent.vue\u0026#34;; export default { components: { sub: OtherComponent } }; \u0026lt;/script\u0026gt; // good \u0026lt;template\u0026gt; \u0026lt;other-component /\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import OtherComponent from \u0026#34;./OtherComponent.vue\u0026#34;; export default { components: { OtherComponent } }; \u0026lt;/script\u0026gt; // bad \u0026lt;component /\u0026gt; \u0026lt;mycomponent /\u0026gt; \u0026lt;myComponent /\u0026gt; \u0026lt;MyComponent /\u0026gt; // good \u0026lt;my-component /\u0026gt;  预留的 html 标签包括：\n  html,body,base,head,link,meta,style,title,address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,menuitem,summary,content,element,shadow,template,blockquote,iframe,tfoot；\n  预留的 SVG 标签包括：\n  svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,foreignObject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view\n [强制]html void element 不需要闭合，其它类型标签都需要闭合 // bad \u0026lt;input\u0026gt;\u0026lt;/input\u0026gt; \u0026lt;br\u0026gt;\u0026lt;/br\u0026gt; // good \u0026lt;input\u0026gt; \u0026lt;br\u0026gt; [强制] 非根结点的 template 标签里必须有一个以上的子结点 // bad \u0026lt;ul\u0026gt; \u0026lt;template\u0026gt; \u0026lt;li\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;/ul\u0026gt; // good \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; // good \u0026lt;ul\u0026gt; \u0026lt;template\u0026gt; \u0026lt;li\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;/ul\u0026gt; [强制] template 标签上不能带有 key 属性 // bad \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;template key=\u0026#34;x\u0026#34;\u0026gt;\u0026lt;/template\u0026gt; \u0026lt;template v-bind:key=\u0026#34;y\u0026#34;\u0026gt;\u0026lt;/template\u0026gt; \u0026lt;template :key=\u0026#34;z\u0026#34;\u0026gt;\u0026lt;/template\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; // good \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;div key=\u0026#34;x\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;template\u0026gt;\u0026lt;/template\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; [强制] 如果自定义标签中没有内容，需要以自闭合标签形式出现 // bad \u0026lt;c-title :url=\u0026#34;url\u0026#34; :label-type=\u0026#34;type\u0026#34;\u0026gt;\u0026lt;/c-title\u0026gt; // good \u0026lt;c-title :url=\u0026#34;url\u0026#34; :label-type=\u0026#34;type\u0026#34; /\u0026gt; [强制] 标签右括号 \u0026gt; 的位置：  元素只有一行时，右括号与元素保持在同一行。 多行元素（元素最后一个属性与左括号 \u0026lt; 不在同一行）时，右括号 \u0026gt; 需要另起一行，缩进与左括号 \u0026lt; 保持对齐。  // bad \u0026lt;div id=\u0026#34;foo\u0026#34; class=\u0026#34;bar\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; // good \u0026lt;div id=\u0026#34;foo\u0026#34; class=\u0026#34;bar\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; // bad \u0026lt;div id=\u0026#34;foo\u0026#34; class=\u0026#34;bar\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; // good \u0026lt;div id=\u0026#34;foo\u0026#34; class=\u0026#34;bar\u0026#34;\u0026gt; some message \u0026lt;/div\u0026gt; // bad \u0026lt;c-title :text=\u0026#34;text\u0026#34; :url=\u0026#34;url\u0026#34; :label-type=\u0026#34;type\u0026#34; /\u0026gt; // good \u0026lt;c-title :text=\u0026#34;text\u0026#34; :url=\u0026#34;url\u0026#34; :label-type=\u0026#34;type\u0026#34; /\u0026gt; [建议] 自闭合标签的 /\u0026gt; 前不用添加空格 // bad \u0026lt;c-title :url=\u0026#34;url\u0026#34; :label-type=\u0026#34;type\u0026#34; /\u0026gt; // good \u0026lt;div\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;c-title :url=\u0026#34;url\u0026#34; :label-type=\u0026#34;type\u0026#34; /\u0026gt; 3.3 属性 [强制] 属性值必须用双引号包围 // bad \u0026lt;div class=\u0026#34;c-color\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; // good \u0026lt;div class=\u0026#34;c-color\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; [强制] 模板中的属性命名需要符合 kebab-case // bad \u0026lt;my-component greetingText=\u0026#34;hi\u0026#34; /\u0026gt; // good \u0026lt;my-component greeting-text=\u0026#34;hi\u0026#34; /\u0026gt; [强制] class / style 属性值不能设置空字符串 // bad \u0026lt;div class=\u0026#34;\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div style=\u0026#34;\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; // good \u0026lt;div\u0026gt;\u0026lt;/div\u0026gt; [建议] 布尔类型的属性值为 true 时，建议不添加属性值 // bad \u0026lt;c-title text=\u0026#34;带箭头标题\u0026#34; :arrow=\u0026#34;true\u0026#34; /\u0026gt; // good \u0026lt;input type=\u0026#34;text\u0026#34; disabled /\u0026gt; \u0026lt;c-title text=\u0026#34;带箭头标题\u0026#34; arrow /\u0026gt; \u0026lt;c-title text=\u0026#34;带箭头标题\u0026#34; :arrow=\u0026#34;false\u0026#34; /\u0026gt; [强制] 当组件的属性多于 2 个时，必须分成多行，每行写一个属性；只有属性个数小于或等于 2 个时，可以写在一行内 // bad \u0026lt;c-title :text=\u0026#34;text\u0026#34; :url=\u0026#34;url\u0026#34; :label-type=\u0026#34;type\u0026#34; /\u0026gt; // good \u0026lt;c-title :text=\u0026#34;text\u0026#34; :url=\u0026#34;url\u0026#34; /\u0026gt; \u0026lt;c-title :text=\u0026#34;text\u0026#34; :url=\u0026#34;url\u0026#34; :label-type=\u0026#34;type\u0026#34; /\u0026gt; [建议] 当元素有多个属性时，应该按照统一的顺序书写 优先级顺序：\n 定义（提供组件的选项）  is   列表渲染（创建多个变化的相同元素）  v-for   条件渲染（元素是否渲染/显示）  v-if v-else-if v-else v-show v-cloak   渲染方式（改变元素的渲染方式）  v-pre/v-once   全局感知（需要超越组件的知识）  id   唯一的特性（需要唯一值的特性）  ref key slot   双向绑定（把绑定和事件结合起来）  v-model   未绑定的属性 其它绑定（所有普通的绑定）  v-bind   事件（组件事件监听器）  v-on   内容（覆写元素的内容）  v-html v-text    [强制] 不能有重复的属性，class 和 style 除外 解释：\n这里重复的属性包括以下两种情况：\n 属性名完全一样：如有多个 foo 或者有多个 :foo 有一个普通属性和一个 v-bind 动态绑定的属性，动态绑定的属性名与普通属性名重复  // bad \u0026lt;c-title foo=\u0026#34;abc\u0026#34; :foo=\u0026#34;def\u0026#34; /\u0026gt; \u0026lt;c-title foo=\u0026#34;def\u0026#34; foo=\u0026#34;abc\u0026#34; /\u0026gt; \u0026lt;c-title class=\u0026#34;def\u0026#34; class=\u0026#34;abc\u0026#34; /\u0026gt; \u0026lt;c-title style=\u0026#34;def\u0026#34; style=\u0026#34;abc\u0026#34; /\u0026gt; // good \u0026lt;c-title :foo=\u0026#34;def\u0026#34; /\u0026gt; \u0026lt;c-title foo=\u0026#34;abc\u0026#34; /\u0026gt; \u0026lt;c-title class=\u0026#34;c-color\u0026#34; :class=\u0026#34;{\u0026#39;c-selected\u0026#39;: selected}\u0026#34; /\u0026gt; \u0026lt;c-title style=\u0026#34;color: #000;\u0026#34; :style=\u0026#34;{width: \u0026#39;100px\u0026#39;}\u0026#34; /\u0026gt; [建议] slot 命名采用 kebab-case \u0026lt;slot name=\u0026#34;header-left\u0026#34;\u0026gt;\u0026lt;/slot\u0026gt; \u0026lt;div slot=\u0026#34;header-left\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; [建议] ref 命名采用 PascalCase \u0026lt;div ref=\u0026#34;userInfo\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; 3.4 指令 [强制] 在使用 v-for 的元素上添加 key，以便维护内部组件及其子树的状态 \u0026lt;ul\u0026gt; \u0026lt;li v-for=\u0026#34;todo in todos\u0026#34; :key=\u0026#34;todo.id\u0026#34;\u0026gt; {{ todo.text }} \u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; [建议] 不要把 v-if 和 v-for 同时用在同一个元素上 解释：\n当 Vue 处理指令时，v-for 比 v-if 具有更高的优先级。所以如果想要使用 v-if 判断 v-for 元素列表是否显示，将两个指令同时应用在同一个元素的方法就是错误的。引入这个规则是为了避免引起困惑。\n// bad \u0026lt;ul\u0026gt; \u0026lt;li v-for=\u0026#34;user in users\u0026#34; v-if=\u0026#34;user.isActive\u0026#34; :key=\u0026#34;user.id\u0026#34;\u0026gt; {{ user.name }} \u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; // good \u0026lt;template\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li v-for=\u0026#34;user in activeUsers\u0026#34; :key=\u0026#34;user.id\u0026#34;\u0026gt; {{ user.name }} \u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; export default { computed: { activeUsers: function() { return this.users.filter(function(user) { return user.isActive; }); } } }; \u0026lt;/script\u0026gt; [建议] 以下指令统一使用缩写  使用 : 表示 v-bind: 使用 @ 表示 v-on:  3.5 插值（Mustache） [建议] 插值左右添加一个空格 // bad \u0026lt;div\u0026gt;{{ text }}\u0026lt;/div\u0026gt; \u0026lt;div\u0026gt;{{text}}\u0026lt;/div\u0026gt; // good \u0026lt;div\u0026gt;{{ text }}\u0026lt;/div\u0026gt; 3.6 空格 [强制] 不能有多余空格 // bad \u0026lt;div class=\u0026#34;foo\u0026#34; :style=\u0026#34;bar\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; // good \u0026lt;div class=\u0026#34;foo\u0026#34; :style=\u0026#34;bar\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; 3.7 变量 [强制] 不能有多余的变量 // bad \u0026lt;ol\u0026gt; \u0026lt;!-- \u0026#34;i\u0026#34; is defined but never used. --\u0026gt; \u0026lt;li v-for=\u0026#34;i in 5\u0026#34;\u0026gt;item\u0026lt;/li\u0026gt; \u0026lt;/ol\u0026gt; // good \u0026lt;ol\u0026gt; \u0026lt;li v-for=\u0026#34;i in 5\u0026#34;\u0026gt;{{ i }}\u0026lt;/li\u0026gt; \u0026lt;/ol\u0026gt; [强制] 禁止在插值中使用 this // bad \u0026lt;a :href=\u0026#34;this.url\u0026#34;\u0026gt; {{ this.text }} \u0026lt;/a\u0026gt; // good \u0026lt;a :href=\u0026#34;url\u0026#34;\u0026gt; {{ text }} \u0026lt;/a\u0026gt; 4 javascript 部分 4.1 props [强制] 指定 props 类型 // bad \u0026lt;script\u0026gt; export default { props: [\u0026#39;status\u0026#39;] }; \u0026lt;/script\u0026gt; // good \u0026lt;script\u0026gt; export default { props: { status: String } }; [强制] 如果 props 没有指定为 required 或者 required 为 false，则需要指定默认值 // bad \u0026lt;script\u0026gt; export default { props: { a: Number, b: [Number, String], c: { type: Number }, d: { type: Number, required: false } } }; \u0026lt;/script\u0026gt; // good \u0026lt;script\u0026gt; export default { props: { a: { type: Number, required: true }, b: { type: [Number, String], default: 0 }, c: { type: Number, default: 0, required: false } } }; \u0026lt;/script\u0026gt; [强制] props 提供的默认值必须满足校验条件 // bad \u0026lt;script\u0026gt; export default { props: { propA: { type: String, default: {} }, propB: { type: String, default: [] }, propC: { type: Object, default: [] }, propD: { type: Array, default: [] }, propE: { type: Object, default: { message: \u0026#39;hello\u0026#39; } } } }; \u0026lt;/script\u0026gt; // good \u0026lt;script\u0026gt; export default { props: { propA: Number, propB: [String, Number], propD: { type: Number, default: 100 }, propE: { type: Object, default() { return { message: \u0026#39;hello\u0026#39; }; } } } }; [强制] 在 props 中声明的属性，其属性名应该始终符合 camelCase // bad \u0026lt;script\u0026gt; export default { props: { \u0026#34;greeting-text\u0026#34;: String } }; \u0026lt;/script\u0026gt; // good \u0026lt;script\u0026gt; export default { props: { greetingText: String } }; \u0026lt;/script\u0026gt; 4.2 data [强制] data 必须是一个函数 // bad \u0026lt;script\u0026gt; export default { data: { b: 1 } }; \u0026lt;/script\u0026gt; // good \u0026lt;script\u0026gt; export default { data() { return { b: 1 }; } }; \u0026lt;/script\u0026gt; [强制] data 中禁止使用 computed 中的变量 // bad \u0026lt;script\u0026gt; export default { props: { a: { type: String, default: 0 } }, data() { return { d: this.f }; }, computed: { f() { return this.a * 10; } } }; \u0026lt;/script\u0026gt; [强制] props, data, computed, methods 中不能有重复的 key // bad \u0026lt;script\u0026gt; export default { props: { foo: String }, data() { return { foo: null }; }, computed: { foo() { return \u0026#34;foo\u0026#34;; } } }; \u0026lt;/script\u0026gt; // good \u0026lt;script\u0026gt; export default { props: { foo: String }, data() { return { bar: null }; }, computed: { baz() { return foo + bar; } } }; \u0026lt;/script\u0026gt; 4.3 变量 [强制] 不能使用 Vue 中的保留字段命名变量 解释：\nVue 使用 _ 前缀来定义其自身的私有属性，所以使用相同的前缀 (比如 _update) 有覆写实例属性的风险。即便你检查确认 Vue 当前版本没有用到这个属性名，也不能保证和将来的版本没有冲突。\n对于 $ 前缀来说，其在 Vue 生态系统中的目的是暴露给用户的一个特殊的实例属性，所以把它用于私有属性并不合适。\n不过，我们推荐把这两个前缀结合为 $_，作为一个用户定义的私有属性的约定，以确保不会和 Vue 自身相冲突。\n// bad \u0026lt;script\u0026gt; export default { props: { $el: String }, data() { return { _foo: null }; }, computed: { $on() { return 2; } }, methods: { $nextTick() {} } }; \u0026lt;/script\u0026gt; 4.4 其它 [建议] 组件中使用 $emit 事件时携带的参数，个数不应该超过 2 个。建议将数据参数以 Object 形式传递，将事件参数 event 放在最后 // bad onClick(event) { this.$emit(\u0026#39;click\u0026#39;, this.value1, this.value2, event); } // good onClick(event) { this.$emit( \u0026#39;click\u0026#39;, { value1: this.value1, value2: this.value2 }, event ); } // good onClick(event) { this.$emit(\u0026#39;click\u0026#39;, event); } 5 style 部分 [建议] 为组件样式设置作用域 \u0026lt;style scoped\u0026gt; .button { border: none; border-radius: 2px; } \u0026lt;/style\u0026gt; 6 参考  vue 代码风格指南 ecomfe HTML 编码规范 ecomfe JavaScript 编码规范 ecomfe JavaScript 编码规范 - ESNext 补充篇（草案） ecomfe CSS 编码规范 ecomfe less 编码规范  "});index.add({'id':729,'href':'/note-cs/docs/','title':"Docs",'content':""});})();