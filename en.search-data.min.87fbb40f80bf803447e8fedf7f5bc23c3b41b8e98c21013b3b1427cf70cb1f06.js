'use strict';(function(){const indexCfg={cache:true};indexCfg.doc={id:'id',field:['title','content'],store:['title','href'],};const index=FlexSearch.create('balance',indexCfg);window.bookSearchIndex=index;index.add({'id':0,'href':'/note-cs/docs/os/linux/','title':"Linux",'content':"Linux 见：Linux 学习笔记\n"});index.add({'id':1,'href':'/note-cs/docs/editor/vscode/','title':"VSCode",'content':"VSCode 推荐插件 PicGo/vs-picgo https://github.com/PicGo/vs-picgo\n"});index.add({'id':2,'href':'/note-cs/docs/computer-composition/','title':"计算机组成原理",'content':"计算机组成原理 "});index.add({'id':3,'href':'/note-cs/docs/compile/make/makefile/','title':"makefile",'content':"makefile 简介 Makefile 用于定义如何创建目标文件，比如如何从源码到可执行文件。创建这一工具的目标是 减少不必要的编译或者任务。传说 Stuart Feldman 在 1976 年花了一个周末写出来的， 而今仍然使用广泛，特别是在 Unix 和 Linux 系统上。\n基础 语法  注释：# 文件名： 必须是 Makefile  区分大小写   make \u0026lt;target\u0026gt; 生成 target  重命名：make -f \u0026quot;filename\u0026quot; \u0026lt;target\u0026gt;   只认识 TAB，不认识空格  但是在 GNU Make 3.82 之后, 可以通过设置参数 .RECIPEPREFIX 进行修改   shell 符号  @：不把命令打印到 stdout -：发生错误了也没关系    target 声明  创建一个 target： targets : prerequisites recipe  prerequisites(依赖) 是可选的, recipe(做法) 也可以多个或者不给 targets 和 prerequisites 都可以是多个, 以空格分割 file2.txt file3.txt: file0.txt file1.txt touch file2.txt touch file3.txt    target 的声明顺序并不重要  上面的依赖可以下面再声明   如果声明重复的 target，make 会给一个 warning，后面会覆盖前面的  但是如果不定义任何 recipe, 就不会冲突, 只是多了依赖关系 file2.txt: file0.txt file3.txt    Phony(假的) Targets  意思是 tagets 并不是文件, 可以想象成一个任务的名字而已 因为不是文件, 无法比对是否有更新, 所以每次 make 都会执行 依赖于 phony target 的 target 也会每次 make 都执行, 即使 target 是文件   .PHONY  如果定义的 phony target 与文件名重名, 可以用 .PHONY 显式地指明哪些 targets 是 phony    常用 phony target  all clean install uninstall  变量与通配符  $^: 代表 prerequisites # 即便分开定义依赖, $^ 依然能拿到 # 非常智能的, ex1.txt 会被找到, file0.txt 会被去重 process: ex1.txt file0.txt @echo $^  $@: 代表 target, 如果 target 为多个, $@ 代表当前执行的那个 $\u0026lt;: prerequisite 中的第一个 $?: 需要更新的 prerequisite 文件列表 $+: 所有依赖, 包括重复的 $|: 竖线后面的 order-only prerequisites $*: target % 那部分, 包括路径 a.%.b: # $* match 的target % 那部分, 包括路径, 比如 `make dir/a.foo.b` 会打出 `dir/foo` @echo $*   模式匹配  make 会找到最具体的匹配  make small/foo.png 则会匹配下面这个规则（在这之前要先有 small/foo.svg 这个文件） %.png: %.svg inkscape --export-png $^ small/%.png: %.svg inkscape --export-png --export-dpi 30 $^    make 已经有一些内置的规则, 比如从 *.c 到 *.o  变量   变量都是字符串类型\n# 这俩是一样一样的 name = Ted name2=\u0026#34;Sarah\u0026#34;   设置变量，按以下顺序由高到低:\n 命令行参数. 比如试试 make echo name3=JICHAO Makefile 里面的 shell 中的环境变量 make 预设的一些变量    ?=\n# 如果 name 被设置过了, 就不设置了 name ?= Jean   override\n# 用 override 可以防止命令行参数设置的覆盖 override name = David ``   +\n# 用加号可以连接 (中间用空格分割) name4 +=grey   内置的变量\necho_inbuilt: echo $(CC) echo ${CXX)} echo $(FC) echo ${CFLAGS)} echo $(CPPFLAGS) echo ${CXXFLAGS} echo $(LDFLAGS) echo ${LDLIBS}   :=\n 等号声明时 recursively expanded 递归扩展 加个冒号可以声明 Simply expanded variables 即时扩展变量, 即只在声明时扩展一次  # var3 声明时找不到 var4, var3 会扩展成 `and good luck`，直接忽视 var4 var3 := $(var4) and good luck # var5 是正常的，扩展为 `good night and good luck` var5 = $(var4) and good luck var4 := good night   函数   函数调用格式\n$(func arg0,arg1,arg2...)   wildcard：将后面的通配符变成一串文件路径\n  patsubst：做替换\n# 把所有 markdown 后缀的文件重命名为 md 后缀 substitue: * @echo $(patsubst %.markdown,%.md,$* $^)   指令  include：引入别的 Makefile 文件 流程控制语句顶格写 sport = tennis # 流程控制语句 (如if else 等等) 顶格写 report: ifeq ($(sport),tennis) @echo \u0026#39;game, set, match\u0026#39; else @echo \u0026#34;They think it\u0026#39;s all over; it is now\u0026#34; endif    分支和变体 GNU make  进阶  原理 "});index.add({'id':4,'href':'/note-cs/docs/os/','title':"操作系统",'content':"操作系统 "});index.add({'id':5,'href':'/note-cs/docs/compile/make/cmake/','title':"cmake",'content':"cmake "});index.add({'id':6,'href':'/note-cs/docs/os/macos/','title':"MacOS",'content':"MacOS "});index.add({'id':7,'href':'/note-cs/docs/os/windows/','title':"Windows",'content':"Windows "});index.add({'id':8,'href':'/note-cs/docs/data-structure/','title':"数据结构",'content':"数据结构 见：算法学习笔记\n"});index.add({'id':9,'href':'/note-cs/docs/os/unix/','title':"Unix",'content':"Unix "});index.add({'id':10,'href':'/note-cs/docs/network/','title':"计算机网络",'content':"计算机网络 见：网络学习笔记\n"});index.add({'id':11,'href':'/note-cs/docs/compile/make/','title':"make",'content':"make 教程  learn make in y minutes 跟我一起写 Makefile GNU make manual  "});index.add({'id':12,'href':'/note-cs/docs/compile/','title':"编译原理",'content':"编译原理 "});index.add({'id':13,'href':'/note-cs/docs/os/ios/','title':"iOS",'content':"iOS "});index.add({'id':14,'href':'/note-cs/docs/os/android/','title':"Android",'content':"Android "});index.add({'id':15,'href':'/note-cs/docs/cloud-computing/saas/crm/','title':"CRM",'content':"CRM "});index.add({'id':16,'href':'/note-cs/docs/language/go/','title':"Go",'content':"Go 见：Go 学习笔记\n"});index.add({'id':17,'href':'/note-cs/docs/virtual/hyperkit/','title':"HyperKit",'content':"HyperKit "});index.add({'id':18,'href':'/note-cs/docs/cloud-computing/iaas/','title':"IaaS",'content':"IaaS "});index.add({'id':19,'href':'/note-cs/docs/domain/onvif/','title':"ONVIF",'content':"ONVIF 官网：www.onvif.org\n"});index.add({'id':20,'href':'/note-cs/docs/language/python/','title':"Python",'content':"Python 见：Python 学习笔记\n"});index.add({'id':21,'href':'/note-cs/docs/language/rust/','title':"Rust",'content':"Rust 见：Rust 学习笔记\n"});index.add({'id':22,'href':'/note-cs/docs/cloud-computing/saas/crm/salesforce/','title':"Salesforce",'content':"Salesforce "});index.add({'id':23,'href':'/note-cs/docs/virtual/vmware/','title':"VMware Fusion",'content':"VMware Fusion "});index.add({'id':24,'href':'/note-cs/docs/cloud-computing/','title':"云计算",'content':"云计算 "});index.add({'id':25,'href':'/note-cs/docs/language/','title':"编程语言",'content':"编程语言 "});index.add({'id':26,'href':'/note-cs/docs/cloud-computing/paas/','title':"PaaS",'content':"PaaS "});index.add({'id':27,'href':'/note-cs/docs/cloud-computing/saas/','title':"SaaS",'content':"SaaS "});index.add({'id':28,'href':'/note-cs/docs/cloud-computing/paas/gae/','title':"GAE",'content':"Google App Engine "});index.add({'id':29,'href':'/note-cs/docs/cloud-computing/paas/heroku/','title':"Heroku",'content':"Heroku "});index.add({'id':30,'href':'/note-cs/docs/virtual/parallels/','title':"Parallels",'content':"Parallels "});index.add({'id':31,'href':'/note-cs/docs/virtual/virtualbox/','title':"VirtualBox",'content':"VirtualBox "});index.add({'id':32,'href':'/note-cs/docs/database/','title':"数据库",'content':"数据库 见：数据库学习笔记\n"});index.add({'id':33,'href':'/note-cs/docs/cloud-computing/paas/openshift/','title':"OpenShift",'content':"OpenShift Red Hat OpenShift is a leading hybrid cloud, enterprise Kubernetes application platform. OpenShift 在 Kubernetes 的基础上整合了应用的生命周期管理，包括 image 的编译，持续集成，部署以及更新。\nOpenshift 以前是 IaaS，现在 Openshift 自己宣称自己搭配 LXC 已经是 PaaS 了，VPS 不是云服务但可以类比为 IaaS。\nOpenshift 没有 root 权限 参考：openshift 和普通 vps 的区别在哪儿？\n"});index.add({'id':34,'href':'/note-cs/docs/virtual/','title':"虚拟化",'content':"虚拟化 "});index.add({'id':35,'href':'/note-cs/docs/cloud-computing/paas/cloud-foundry/','title':"Cloud Foundry",'content':"Cloud Foundry "});index.add({'id':36,'href':'/note-cs/docs/cloud-computing/paas/appfog/','title':"AppFog",'content':"AppFog "});index.add({'id':37,'href':'/note-cs/docs/editor/','title':"编辑器",'content':"编辑器 "});index.add({'id':38,'href':'/note-cs/docs/domain/','title':"领域",'content':"领域 "});index.add({'id':39,'href':'/note-cs/categories/','title':"Categories",'content':""});index.add({'id':40,'href':'/note-cs/docs/','title':"Docs",'content':""});index.add({'id':41,'href':'/note-cs/tags/','title':"Tags",'content':""});index.add({'id':42,'href':'/note-cs/','title':"首页",'content':""});})();