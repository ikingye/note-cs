<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>make on 计算机学习笔记</title><link>https://kingye.me/note-cs/docs/basic/compile/make/</link><description>Recent content in make on 计算机学习笔记</description><generator>Hugo</generator><language>en</language><atom:link href="https://kingye.me/note-cs/docs/basic/compile/make/index.xml" rel="self" type="application/rss+xml"/><item><title>makefile</title><link>https://kingye.me/note-cs/docs/basic/compile/make/makefile/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://kingye.me/note-cs/docs/basic/compile/make/makefile/</guid><description>&lt;h1 id="makefile"&gt;
 makefile
 &lt;a class="anchor" href="#makefile"&gt;#&lt;/a&gt;
&lt;/h1&gt;
&lt;p&gt;make 不带参数，只会执行 makefile 中第一条 &lt;code&gt;target 声明&lt;/code&gt;（带冒号的语句）&lt;/p&gt;
&lt;h2 id="简介"&gt;
 简介
 &lt;a class="anchor" href="#%e7%ae%80%e4%bb%8b"&gt;#&lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;Makefile 用于定义如何创建目标文件，比如如何从源码到可执行文件。
创建这一工具的目标是 减少不必要的编译或者任务。
传说 &lt;a href="https://en.wikipedia.org/wiki/Stuart_Feldman"&gt;Stuart Feldman&lt;/a&gt; 在 1976 年花了一个周末写出来的， 而今仍然使用广泛，特别是在 Unix 和 Linux 系统上。&lt;/p&gt;
&lt;h2 id="基础"&gt;
 基础
 &lt;a class="anchor" href="#%e5%9f%ba%e7%a1%80"&gt;#&lt;/a&gt;
&lt;/h2&gt;
&lt;h3 id="语法"&gt;
 语法
 &lt;a class="anchor" href="#%e8%af%ad%e6%b3%95"&gt;#&lt;/a&gt;
&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;注释：&lt;code&gt;#&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;文件名： 必须是 &lt;code&gt;Makefile&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;区分大小写&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;make &amp;lt;target&amp;gt;&lt;/code&gt; 生成 target
&lt;ul&gt;
&lt;li&gt;重命名：&lt;code&gt;make -f &amp;quot;filename&amp;quot; &amp;lt;target&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;只认识 &lt;code&gt;TAB&lt;/code&gt;&lt;/strong&gt;，不认识空格
&lt;ul&gt;
&lt;li&gt;但是在 GNU Make 3.82 之后, 可以通过设置参数 &lt;code&gt;.RECIPEPREFIX&lt;/code&gt; 进行修改&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;shell 符号
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;@&lt;/code&gt;：不把命令打印到 stdout&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-&lt;/code&gt;：发生错误了也没关系&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.gnu.org/software/make/manual/html_node/Variables-in-Recipes.html"&gt;&lt;code&gt;$$&lt;/code&gt;&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;$&lt;/code&gt; 是 make 变量&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$$&lt;/code&gt; 是 shell 变量&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="target-声明"&gt;
 target 声明
 &lt;a class="anchor" href="#target-%e5%a3%b0%e6%98%8e"&gt;#&lt;/a&gt;
&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;创建一个 &lt;code&gt;target&lt;/code&gt;：
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-makefile" data-lang="makefile"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#a6e22e"&gt;targets &lt;/span&gt;&lt;span style="color:#f92672"&gt;:&lt;/span&gt; prerequisites
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; recipe
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;prerequisites&lt;/code&gt;(依赖) 是可选的, &lt;code&gt;recipe&lt;/code&gt;(做法) 也可以多个或者不给
&lt;ul&gt;
&lt;li&gt;没有给 prerequisites, 只会在目标文件文件不存在时执行&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;targets 和 prerequisites 都可以是多个, 以空格分割
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-makefile" data-lang="makefile"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#a6e22e"&gt;file2.txt file3.txt&lt;/span&gt;&lt;span style="color:#f92672"&gt;:&lt;/span&gt; file0.txt file1.txt
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; touch file2.txt
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; touch file3.txt
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;target 的&lt;strong&gt;声明顺序不重要&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;上面的依赖可以下面再声明&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;如果声明重复的 &lt;code&gt;target&lt;/code&gt;，make 会给一个 warning，&lt;strong&gt;后面会覆盖前面的&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;但是如果&lt;strong&gt;不定义任何 recipe&lt;/strong&gt;, 就不会冲突, 只是多了依赖关系
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-makefile" data-lang="makefile"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#a6e22e"&gt;file2.txt&lt;/span&gt;&lt;span style="color:#f92672"&gt;:&lt;/span&gt; file0.txt file3.txt
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Phony&lt;/code&gt;(假的) Targets
&lt;ul&gt;
&lt;li&gt;意思是 tagets 并不是文件, 可以想象成一个任务的名字而已&lt;/li&gt;
&lt;li&gt;因为不是文件, 无法比对是否有更新, 所以每次 &lt;code&gt;make&lt;/code&gt; 都会执行&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;依赖于 phony target 的 target 也会每次 make 都执行&lt;/strong&gt;, 即使 target 是文件&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.PHONY&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;如果定义的 phony target 与文件名重名, 可以用 .PHONY 显式地指明哪些 targets 是 phony&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id="常用-phony-target"&gt;
 常用 phony target
 &lt;a class="anchor" href="#%e5%b8%b8%e7%94%a8-phony-target"&gt;#&lt;/a&gt;
&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;all&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;clean&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;install&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;uninstall&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h4 id="变量与通配符"&gt;
 变量与通配符
 &lt;a class="anchor" href="#%e5%8f%98%e9%87%8f%e4%b8%8e%e9%80%9a%e9%85%8d%e7%ac%a6"&gt;#&lt;/a&gt;
&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;$^&lt;/code&gt;: 代表 prerequisites
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-makefile" data-lang="makefile"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;# 即便分开定义依赖, $^ 依然能拿到
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;&lt;/span&gt;&lt;span style="color:#a6e22e"&gt;process&lt;/span&gt;&lt;span style="color:#f92672"&gt;:&lt;/span&gt; file*.txt
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;# 非常智能的, ex1.txt 会被找到, file0.txt 会被去重
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;&lt;/span&gt;&lt;span style="color:#a6e22e"&gt;process&lt;/span&gt;&lt;span style="color:#f92672"&gt;:&lt;/span&gt; ex1.txt file0.txt
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; @echo $^
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$@&lt;/code&gt;: 代表 target, 如果 target 为多个, &lt;code&gt;$@&lt;/code&gt; 代表当前执行的那个&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$&amp;lt;&lt;/code&gt;: prerequisite 中的第一个&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$?&lt;/code&gt;: 需要更新的 prerequisite 文件列表&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$+&lt;/code&gt;: 所有依赖, 包括重复的&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$|&lt;/code&gt;: 竖线后面的 &lt;code&gt;order-only prerequisites&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$*&lt;/code&gt;: &lt;code&gt;target&lt;/code&gt; &lt;code&gt;%&lt;/code&gt; 那部分, 包括路径
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-makefile" data-lang="makefile"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#a6e22e"&gt;a.%.b&lt;/span&gt;&lt;span style="color:#f92672"&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#75715e"&gt;# $* match 的target % 那部分, 包括路径, 比如 `make dir/a.foo.b` 会打出 `dir/foo`&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; @echo $*
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h4 id="模式匹配"&gt;
 模式匹配
 &lt;a class="anchor" href="#%e6%a8%a1%e5%bc%8f%e5%8c%b9%e9%85%8d"&gt;#&lt;/a&gt;
&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;make 会找到最具体的匹配
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;make small/foo.png&lt;/code&gt; 则会匹配下面这个规则（在这之前要先有 small/foo.svg 这个文件）
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-makefile" data-lang="makefile"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#a6e22e"&gt;%.png&lt;/span&gt;&lt;span style="color:#f92672"&gt;:&lt;/span&gt; %.svg
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; inkscape --export-png $^
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#a6e22e"&gt;small/%.png&lt;/span&gt;&lt;span style="color:#f92672"&gt;:&lt;/span&gt; %.svg
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; inkscape --export-png --export-dpi &lt;span style="color:#ae81ff"&gt;30&lt;/span&gt; $^
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;make 已经有一些内置的规则, 比如从 _.c 到 _.o&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h4 id="竖线"&gt;
 竖线
 &lt;a class="anchor" href="#%e7%ab%96%e7%ba%bf"&gt;#&lt;/a&gt;
&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;竖线左边为：正常前提目标（&lt;code&gt;Normal Prerequisites&lt;/code&gt;）
&lt;ul&gt;
&lt;li&gt;当正常前提目标变化时，target 重新生成&lt;/li&gt;
&lt;li&gt;可以为空&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;竖线右边为：命令前提目标（&lt;code&gt;order-only Prerequisites&lt;/code&gt;）
&lt;ul&gt;
&lt;li&gt;当命令前提目标变化时，target &lt;strong&gt;不&lt;/strong&gt;重新生成&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-makefile" data-lang="makefile"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#a6e22e"&gt;process&lt;/span&gt;&lt;span style="color:#f92672"&gt;:&lt;/span&gt; file*.txt | dir/a.foo.b
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;hr&gt;
&lt;h4 id="变量"&gt;
 变量
 &lt;a class="anchor" href="#%e5%8f%98%e9%87%8f"&gt;#&lt;/a&gt;
&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;变量都是字符串类型&lt;/p&gt;</description></item><item><title>cmake</title><link>https://kingye.me/note-cs/docs/basic/compile/make/cmake/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://kingye.me/note-cs/docs/basic/compile/make/cmake/</guid><description>&lt;h1 id="cmake"&gt;
 cmake
 &lt;a class="anchor" href="#cmake"&gt;#&lt;/a&gt;
&lt;/h1&gt;
&lt;p&gt;推荐 xmake&lt;/p&gt;
&lt;p&gt;参考：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://www.zhihu.com/question/493402906"&gt;CMake 是不是阻碍了 C++的发展?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://modern-cmake-cn.github.io/Modern-CMake-zh_CN/"&gt;CMake 教程 Modern-CMake 的简体中文翻译&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description></item></channel></rss>