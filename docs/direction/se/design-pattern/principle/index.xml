<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>设计原则 on 计算机学习笔记</title><link>https://kingye.me/note-cs/docs/direction/se/design-pattern/principle/</link><description>Recent content in 设计原则 on 计算机学习笔记</description><generator>Hugo</generator><language>en</language><atom:link href="https://kingye.me/note-cs/docs/direction/se/design-pattern/principle/index.xml" rel="self" type="application/rss+xml"/><item><title>单一职责原则</title><link>https://kingye.me/note-cs/docs/direction/se/design-pattern/principle/srp/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://kingye.me/note-cs/docs/direction/se/design-pattern/principle/srp/</guid><description>&lt;h1 id="单一职责原则">
 单一职责原则
 &lt;a class="anchor" href="#%e5%8d%95%e4%b8%80%e8%81%8c%e8%b4%a3%e5%8e%9f%e5%88%99">#&lt;/a>
&lt;/h1>
&lt;p>就一个类而言，应该仅有一个引起它变化的原因。&lt;/p></description></item><item><title>开闭原则</title><link>https://kingye.me/note-cs/docs/direction/se/design-pattern/principle/ocp/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://kingye.me/note-cs/docs/direction/se/design-pattern/principle/ocp/</guid><description>&lt;h1 id="开闭原则">
 开闭原则
 &lt;a class="anchor" href="#%e5%bc%80%e9%97%ad%e5%8e%9f%e5%88%99">#&lt;/a>
&lt;/h1>
&lt;p>程序中的对象应该对扩展是开放的，对修改是封闭的。&lt;/p>
&lt;p>当一个类实现了一个功能的时候，如果想要改变这个功能不是去修改代码，而是通过扩展的方式去实现。
实现该类提供的接口方法，然后注入到该类中，通过这种方法去实现功能的改变。&lt;/p></description></item><item><title>里氏替换原则</title><link>https://kingye.me/note-cs/docs/direction/se/design-pattern/principle/lsp/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://kingye.me/note-cs/docs/direction/se/design-pattern/principle/lsp/</guid><description>&lt;h1 id="里氏替换原则">
 里氏替换原则
 &lt;a class="anchor" href="#%e9%87%8c%e6%b0%8f%e6%9b%bf%e6%8d%a2%e5%8e%9f%e5%88%99">#&lt;/a>
&lt;/h1>
&lt;ul>
&lt;li>所有引用基类的地方必须能透明的使用其子类对象。&lt;/li>
&lt;li>只要父类能出现的地方子类就可以出现，替换为子类也不会产生任何的错误。&lt;/li>
&lt;li>开闭原则一般可以通过里氏替换实现对扩展开放，对修改关闭的效果。&lt;/li>
&lt;/ul></description></item><item><title>依赖倒置原则</title><link>https://kingye.me/note-cs/docs/direction/se/design-pattern/principle/dip/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://kingye.me/note-cs/docs/direction/se/design-pattern/principle/dip/</guid><description>&lt;h1 id="依赖倒置原则">
 依赖倒置原则
 &lt;a class="anchor" href="#%e4%be%9d%e8%b5%96%e5%80%92%e7%bd%ae%e5%8e%9f%e5%88%99">#&lt;/a>
&lt;/h1>
&lt;ul>
&lt;li>模块间的依赖通过抽象发生，实现类之间不发生直接的依赖关系，其依赖关系是通过接口或抽象类产生的。&lt;/li>
&lt;li>即依赖抽象，而不依赖具体的实现。&lt;/li>
&lt;/ul></description></item><item><title>接口隔离原则</title><link>https://kingye.me/note-cs/docs/direction/se/design-pattern/principle/isp/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://kingye.me/note-cs/docs/direction/se/design-pattern/principle/isp/</guid><description>&lt;h1 id="接口隔离原则">
 接口隔离原则
 &lt;a class="anchor" href="#%e6%8e%a5%e5%8f%a3%e9%9a%94%e7%a6%bb%e5%8e%9f%e5%88%99">#&lt;/a>
&lt;/h1>
&lt;ul>
&lt;li>客户端不应该依赖它不需要的接口。&lt;/li>
&lt;li>目的是解开系统的耦合，从而容易重构更改。&lt;/li>
&lt;/ul></description></item><item><title>迪米特原则</title><link>https://kingye.me/note-cs/docs/direction/se/design-pattern/principle/lod/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://kingye.me/note-cs/docs/direction/se/design-pattern/principle/lod/</guid><description>&lt;h1 id="迪米特原则">
 迪米特原则
 &lt;a class="anchor" href="#%e8%bf%aa%e7%b1%b3%e7%89%b9%e5%8e%9f%e5%88%99">#&lt;/a>
&lt;/h1>
&lt;ul>
&lt;li>一个对象应该对其他对象有最少的了解&lt;/li>
&lt;li>一个类应该对自己需要耦合或调用的类知道的越少越好，类的内部如何实现与调用者或依赖者没关系。&lt;/li>
&lt;/ul></description></item></channel></rss>