<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>其他模式 on 计算机学习笔记</title>
    <link>https://kingye.me/note-cs/docs/direction/se/design-pattern/other/</link>
    <description>Recent content in 其他模式 on 计算机学习笔记</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <atom:link href="https://kingye.me/note-cs/docs/direction/se/design-pattern/other/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>简单工厂</title>
      <link>https://kingye.me/note-cs/docs/direction/se/design-pattern/other/simple-factory/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://kingye.me/note-cs/docs/direction/se/design-pattern/other/simple-factory/</guid>
      <description> 简单工厂模式 # Simple Factory Pattern，又称为静态工厂方法 (Static Factory Method) 模式&#xA;通过传入参数获取到对象，不关心创建对象的细节。&#xA;// create 是静态方法，直接用类调用（不需要实例化） object1 = Factory.create(1); object2 = Factory.create(2); 优点&#xA;将创建实例的工作与使用实例的工作分开，使用者不必关心类对象如何创建，实现了解耦； 把初始化实例时的工作放到工厂里进行，使代码更容易维护。更符合面向对象的原则 &amp;amp; 面向接口编程，而不是面向实现编程。 缺点&#xA;工厂类集中了所有实例（产品）的创建逻辑，一旦这个工厂不能正常工作，整个系统都会受到影响； 违背 “开放 - 关闭原则”，一旦添加新产品就不得不修改工厂类的逻辑，这样就会造成工厂逻辑过于复杂。 简单工厂模式由于使用了静态工厂方法，静态方法不能被继承和重写，会造成工厂角色无法形成基于继承的等级结构。 静态方法可以被继承 应用场景&#xA;客户如果只知道传入工厂类的参数，对于如何创建对象的逻辑不关心时； 当工厂类负责创建的对象（具体产品）比较少时。 代码示例 # C C&amp;#43;&amp;#43; C# Go Java JavaScript Kotlin PHP Python2 Python3 Ruby Rust Scala Swift TypeScript </description>
    </item>
  </channel>
</rss>
