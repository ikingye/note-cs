'use strict';(function(){const indexCfg={cache:true};indexCfg.doc={id:'id',field:['title','content'],store:['title','href','section'],};const index=FlexSearch.create('balance',indexCfg);window.bookSearchIndex=index;index.add({'id':0,'href':'/note-cs/docs/book/basic/pl/go-in-action/zh/','title':"Go 语言实战",'section':"Go in Action",'content':"Go 语言实战 #  \n译者 #  李兆海，多年专注于后端分布式网络服务开发，曾使用过多个流行后端技术和相关架构实践，是 Go 语言和 Docker 的早期使用者和推广者，《第 1 本 Docker 书》的译者。作为项目技术负责人，成功开发了百万用户级直播系统。\n"});index.add({'id':1,'href':'/note-cs/docs/basic/os/type/linux/','title':"Linux",'section':"操作系统类型",'content':"Linux #  见：Linux 学习笔记\n"});index.add({'id':2,'href':'/note-cs/docs/basic/pl/shell/command/ps/','title':"ps",'section':"1.3.1 Shell 命令",'content':"ps #  "});index.add({'id':3,'href':'/note-cs/docs/direction/be/db/mysql/basic/quick-start/','title':"Quick Start",'section':"第一部分 基础入门",'content':"Quick Start #  Mysql Client #  /etc/my.cnf\nMysql Server #  "});index.add({'id':4,'href':'/note-cs/docs/basic/pl/shell/type/sh/','title':"sh",'section':"1.3.4 Shell 类型",'content':"sh #  标记为 #!/bin/sh 的脚本不应使用任何 POSIX 没有规定的特性 (如 let 等命令，但 #!/bin/bash 可以)。\n"});index.add({'id':5,'href':'/note-cs/docs/book/others/practical-vim/zh/','title':"Vim 实用技巧（第 2 版）",'section':"Practical Vim",'content':"Vim 实用技巧（第 2 版） #  \n译者 #  杨源 / 车文隆\n"});index.add({'id':6,'href':'/note-cs/docs/skill/tool/note/storage/imagehost/','title':"图床",'section':"存储",'content':"图床 #  图床选择 #  GitHub + jsdelivr #  上传图床软件 #  PicGo #  参考官网：https://github.com/Molunerfinn/PicGo\nvs-picgo #  https://github.com/PicGo/vs-picgo\n"});index.add({'id':7,'href':'/note-cs/docs/direction/be/db/mysql/basic/practice/','title':"实践",'section':"第一部分 基础入门",'content':"实践 #  问答 #  Mysql 不指定 ip 与指定本地 ip，有什么区别？ #  "});index.add({'id':8,'href':'/note-cs/docs/direction/be/db/postgresql/basic/practice/','title':"实践",'section':"第一部分 基础入门",'content':"PostgreSQL 实践 #  "});index.add({'id':9,'href':'/note-cs/docs/direction/be/platform/nodejs/basic/practice/','title':"实践",'section':"第一部分 基础入门",'content':"实践 #  "});index.add({'id':10,'href':'/note-cs/docs/direction/client/android/basic/practice/','title':"实践",'section':"第一部分 基础入门",'content':"实践 #  "});index.add({'id':11,'href':'/note-cs/docs/direction/client/ios/basic/practice/','title':"实践",'section':"第一部分 基础入门",'content':"实践 #  "});index.add({'id':12,'href':'/note-cs/docs/direction/client/xiaochengxu/basic/practice/','title':"实践",'section':"第一部分 基础入门",'content':"实践 #  "});index.add({'id':13,'href':'/note-cs/docs/direction/fe/frame/angular/basic/practice/','title':"实践",'section':"第一部分 基础入门",'content':"实践 #  "});index.add({'id':14,'href':'/note-cs/docs/direction/fe/frame/react/basic/practice/','title':"实践",'section':"第一部分 基础入门",'content':"实践 #  "});index.add({'id':15,'href':'/note-cs/docs/direction/fe/frame/vue/basic/practice/','title':"实践",'section':"第一部分 基础入门",'content':"实践 #  "});index.add({'id':16,'href':'/note-cs/docs/direction/be/db/postgresql/basic/quick-start/','title':"快速上手",'section':"第一部分 基础入门",'content':"PostgreSQL 快速上手 #  安装 #  MacOS #   安装：brew install postgresql 启动：brew services start postgresql 创建用户名数据库：createdb  基础命令 #  登录 PostgreSQL 控制台：psql #  psql -U [user] -d [database] -h [host] -p [port]\n默认 psql\nuser：当前mac用户 database：用户同名数据库 主机：localhost 端口号：5432，postgresql的默认端口是5432 \\l #  使用 \\l 命令列出所有的数据库，看到已存在用户同名数据库、postgres 数据库。 但是 postgres 数据库的所有者是当前用户，没有 postgres 用户。\n 创建 postgres 用户：CREATE USER postgres WITH PASSWORD 'password'; 删除默认生成的 postgres 数据库：DROP DATABASE postgres; 创建属于 postgres 用户的 postgres 数据库：CREATE DATABASE postgres OWNER postgres; 将数据库所有权限赋予 postgres 用户：GRANT ALL PRIVILEGES ON DATABASE postgres to postgres; 给 postgres 用户添加创建数据库的属性：ALTER ROLE postgres CREATEDB;  常用控制台命令 #  \\password：设置当前登录用户的密码 \\h：查看SQL命令的解释，比如\\h select。 \\?：查看psql命令列表。 \\l：列出所有数据库。 \\c [database_name]：连接其他数据库。 \\d：列出当前数据库的所有表格。 \\d [table_name]：列出某一张表格的结构。 \\du：列出所有用户。 \\e：打开文本编辑器。 \\conninfo：列出当前数据库和连接的信息。 \\password [user]: 修改用户密码 \\q：退出 查询 #  \\x #  类似 mysql 的 \\G\n# \\x Expanded display is on. # \\x Expanded display is off. 参考：\n Display select results vertically in psql, as is done by MySQL\u0026rsquo;s \\G   权限 #  GRANT #  GRANT on the database is not what you need. Grant on the tables directly.\nGranting privileges on the database mostly is used to grant or revoke connect privileges. This allows you to specify who may do stuff in the database if they have sufficient other permissions.\nGRANT ALL PRIVILEGES ON TABLE side_adzone TO jerry; 参考：\n Permission denied for relation  "});index.add({'id':17,'href':'/note-cs/docs/direction/be/db/mysql/basic/practice/optimize/','title':"性能优化",'section':"实践",'content':"Mysql 性能优化 #  存储引擎 #  使用 Innodb 存储引擎 #  没有特殊要求（即 Innodb 无法满足的功能如：列存储，存储空间数据等）的情况下，所有表必须使用 Innodb 存储引擎（MySQL5.5 之前默认使用 Myisam，5.6 以后默认的为 Innodb）。\nInnodb 支持事务，支持行级锁，更好的恢复性，高并发下性能更好。\n 编码 #  统一使用 UTF8 #  库和表的字符集统一使用 UTF8\n 表 #  控制单表数据量的大小 #  建议在 500 万以内。500 万并不是 MySQL 数据库的限制，过大会造成修改表结构，备份，恢复都会有很大的问题。\n可以用历史数据归档（应用于日志数据），分库分表（应用于业务数据）等手段来控制数据量大小\n谨慎使用 MySQL 分区表 #  分区表在物理上表现为多个文件，在逻辑上表现为一个表；\n谨慎选择分区键，跨分区查询效率可能更低；\n建议采用物理分表的方式管理大数据。\n冷热数据分离，减小表的宽度 #   MySQL 限制每个表最多存储 4096 列，并且每一行数据的大小不能超过 65535 字节。\n 减少磁盘 IO, 保证热数据的内存缓存命中率（表越宽，把表装载进内存缓冲池时所占用的内存也就越大，也会消耗更多的 IO）；\n更有效的利用缓存，避免读入无用的冷数据；\n经常一起使用的列放到一个表中（避免更多的关联操作）。\n优先选择小的数据类型 #  列的字段越大，建立索引时所需要的空间也就越大，这样一页中所能存储的索引节点的数量也就越少也越少，在遍历时所需要的 IO 次数也就越多，索引的性能也就越差。\n如：\n 将 IP 地址转换成整形数据 对于非负型的数据 (如自增 ID, 整型 IP) 来说，要优先使用无符号整型来存储  列定义为 NOT NULL #  索引 NULL 列需要额外的空间来保存，所以要占用更多的空间。\n进行比较和计算时要对 NULL 值做特别的处理。\n 索引 #  限制每张表上的索引数量 #  建议单张表索引不超过 5 个 索引并不是越多越好！索引可以提高效率同样可以降低效率。\n索引可以增加查询效率，但同样也会降低插入和更新的效率，甚至有些情况下会降低查询效率。\n因为 MySQL 优化器在选择如何优化查询时，会根据统一信息，对每一个可以用到的索引来进行评估，以生成出一个最好的执行计划，如果同时有很多个索引都可以用于查询，就会增加 MySQL 优化器生成执行计划的时间，同样会降低查询性能。\n必须有个主键 #  Innodb 是一种索引组织表：数据的存储的逻辑顺序和索引的顺序是相同的。每个表都可以有多个索引，但是表的存储顺序只能有一种。\nInnodb 是按照主键索引的顺序来组织表的\n 不要使用更新频繁的列作为主键，不适用多列主键（相当于联合索引） 不要使用 UUID,MD5,HASH, 字符串列作为主键（无法保证数据的顺序增长） 主键建议使用自增 ID 值   开发 #  避免数据类型的隐式转换 #  避免使用双 % 号的查询条件 #  联合索引 #  在定义联合索引时，如果 a 列要用到范围查找的话，就要把 a 列放到联合索引的右侧。\n一个 SQL 只能利用到复合索引中的一列进行范围查询。如：有 a,b,c 列的联合索引，在查询条件中有 a 列的范围查询，则在 b,c 列上的索引将不会被用到。\n使用 left join 替代 not in 操作 #  使用 left join 或 not exists 来优化 not in 操作，因为 not in 也通常会使用索引失效。\n 参考 #   MySQL 高性能优化规范建议  "});index.add({'id':18,'href':'/note-cs/docs/basic/pl/objective-c/basic/spec/baidu/','title':"百度",'section':"1.3 编程规范",'content':"百度 Objective-C 编码规范 (2019 版) #  "});index.add({'id':47,'href':'/note-cs/docs/direction/be/db/mysql/basic/practice/spec/','title':"编程规范",'section':"实践",'content':"编程规范 #  "});index.add({'id':48,'href':'/note-cs/docs/direction/be/db/postgresql/basic/practice/spec/','title':"编程规范",'section':"实践",'content':"编程规范 #  "});index.add({'id':49,'href':'/note-cs/docs/direction/be/db/redis/basic/practice/spec/','title':"编程规范",'section':"实践",'content':"编程规范 #  "});index.add({'id':50,'href':'/note-cs/docs/direction/be/platform/nodejs/basic/practice/spec/','title':"编程规范",'section':"实践",'content':"编程规范 #  "});index.add({'id':51,'href':'/note-cs/docs/direction/client/android/basic/practice/spec/','title':"编程规范",'section':"实践",'content':"编程规范 #  "});index.add({'id':52,'href':'/note-cs/docs/direction/client/ios/basic/practice/spec/','title':"编程规范",'section':"实践",'content':"编程规范 #  "});index.add({'id':53,'href':'/note-cs/docs/direction/client/xiaochengxu/basic/practice/spec/','title':"编程规范",'section':"实践",'content':"编程规范 #  "});index.add({'id':54,'href':'/note-cs/docs/direction/embedded/basic/practice/spec/','title':"编程规范",'section':"实践",'content':"编程规范 #  "});index.add({'id':55,'href':'/note-cs/docs/direction/fe/frame/angular/basic/practice/spec/','title':"编程规范",'section':"实践",'content':"编程规范 #  "});index.add({'id':56,'href':'/note-cs/docs/direction/fe/frame/react/basic/practice/spec/','title':"编程规范",'section':"实践",'content':"编程规范 #  "});index.add({'id':57,'href':'/note-cs/docs/direction/fe/frame/vue/basic/practice/spec/','title':"编程规范",'section':"实践",'content':"编程规范 #  "});index.add({'id':58,'href':'/note-cs/docs/direction/security/basic/practice/spec/','title':"编程规范",'section':"实践",'content':"编程规范 #  "});index.add({'id':59,'href':'/note-cs/docs/basic/pl/shell/type/bash/','title':"Bash",'section':"1.3.4 Shell 类型",'content':"Bash #  "});index.add({'id':60,'href':'/note-cs/docs/skill/tool/note/hugo/theme/academic/','title':"hugo-academic",'section':"主题",'content':"Academic #  配置 #  写博客 #  hugo new \u0026ndash;kind post post/my-post\n"});index.add({'id':61,'href':'/note-cs/docs/basic/compile/make/makefile/','title':"makefile",'section':"make",'content':"makefile #  make 不带参数，只会执行 makefile 中第一条 target 声明（带冒号的语句）\n简介 #  Makefile 用于定义如何创建目标文件，比如如何从源码到可执行文件。 创建这一工具的目标是 减少不必要的编译或者任务。 传说 Stuart Feldman 在 1976 年花了一个周末写出来的， 而今仍然使用广泛，特别是在 Unix 和 Linux 系统上。\n基础 #  语法 #   注释：# 文件名： 必须是 Makefile  区分大小写   make \u0026lt;target\u0026gt; 生成 target  重命名：make -f \u0026quot;filename\u0026quot; \u0026lt;target\u0026gt;   只认识 TAB，不认识空格  但是在 GNU Make 3.82 之后, 可以通过设置参数 .RECIPEPREFIX 进行修改   shell 符号  @：不把命令打印到 stdout -：发生错误了也没关系   $$  $ 是 make 变量 $$ 是 shell 变量    target 声明 #   创建一个 target： targets : prerequisites recipe  prerequisites(依赖) 是可选的, recipe(做法) 也可以多个或者不给  没有给 prerequisites, 只会在目标文件文件不存在时执行   targets 和 prerequisites 都可以是多个, 以空格分割 file2.txt file3.txt: file0.txt file1.txt touch file2.txt touch file3.txt    target 的声明顺序不重要  上面的依赖可以下面再声明   如果声明重复的 target，make 会给一个 warning，后面会覆盖前面的  但是如果不定义任何 recipe, 就不会冲突, 只是多了依赖关系 file2.txt: file0.txt file3.txt    Phony(假的) Targets  意思是 tagets 并不是文件, 可以想象成一个任务的名字而已 因为不是文件, 无法比对是否有更新, 所以每次 make 都会执行 依赖于 phony target 的 target 也会每次 make 都执行, 即使 target 是文件   .PHONY  如果定义的 phony target 与文件名重名, 可以用 .PHONY 显式地指明哪些 targets 是 phony    常用 phony target #   all clean install uninstall   变量与通配符 #   $^: 代表 prerequisites # 即便分开定义依赖, $^ 依然能拿到 process: file*.txt # 非常智能的, ex1.txt 会被找到, file0.txt 会被去重 process: ex1.txt file0.txt @echo $^  $@: 代表 target, 如果 target 为多个, $@ 代表当前执行的那个 $\u0026lt;: prerequisite 中的第一个 $?: 需要更新的 prerequisite 文件列表 $+: 所有依赖, 包括重复的 $|: 竖线后面的 order-only prerequisites $*: target % 那部分, 包括路径 a.%.b: # $* match 的target % 那部分, 包括路径, 比如 `make dir/a.foo.b` 会打出 `dir/foo` @echo $*    模式匹配 #   make 会找到最具体的匹配  make small/foo.png 则会匹配下面这个规则（在这之前要先有 small/foo.svg 这个文件） %.png: %.svg inkscape --export-png $^ small/%.png: %.svg inkscape --export-png --export-dpi 30 $^    make 已经有一些内置的规则, 比如从 _.c 到 _.o   竖线 #   竖线左边为：正常前提目标（Normal Prerequisites）  当正常前提目标变化时，target 重新生成 可以为空   竖线右边为：命令前提目标（order-only Prerequisites）  当命令前提目标变化时，target 不重新生成    process: file*.txt | dir/a.foo.b  变量 #    变量都是字符串类型\n# 这俩是一样一样的 name = Ted name2=\u0026#34;Sarah\u0026#34;   设置变量，按以下顺序由高到低:\n 命令行参数. 比如试试 make echo name3=JICHAO Makefile 里面的 shell 中的环境变量 make 预设的一些变量    ?=\n# 如果 name 被设置过了, 就不设置了 name ?= Jean   override\n# 用 override 可以防止命令行参数设置的覆盖 override name = David ``   +\n# 用加号可以连接 (中间用空格分割) name4 +=grey   内置的变量\necho_inbuilt: echo $(CC) echo ${CXX)} echo $(FC) echo ${CFLAGS)} echo $(CPPFLAGS) echo ${CXXFLAGS} echo $(LDFLAGS) echo ${LDLIBS}   :=\n 等号声明时 recursively expanded 递归扩展 加个冒号可以声明 Simply expanded variables 即时扩展变量, 即只在声明时扩展一次  # var3 声明时找不到 var4, var3 会扩展成 `and good luck`，直接忽视 var4 var3 := $(var4) and good luck # var5 是正常的，扩展为 `good night and good luck` var5 = $(var4) and good luck var4 := good night    函数 #    函数调用格式\n$(func arg0,arg1,arg2...)   wildcard：将后面的通配符变成一串文件路径\n  patsubst：做替换\n# 把所有 markdown 后缀的文件重命名为 md 后缀 substitue: * @echo $(patsubst %.markdown,%.md,$* $^)    指令 #   include：引入别的 Makefile 文件 流程控制语句顶格写 sport = tennis # 流程控制语句 (如if else 等等) 顶格写 report: ifeq ($(sport),tennis) @echo \u0026#39;game, set, match\u0026#39; else @echo \u0026#34;They think it\u0026#39;s all over; it is now\u0026#34; endif    分支和变体 #  GNU make #   进阶 #   原理 #  "});index.add({'id':62,'href':'/note-cs/docs/skill/type/markdown/','title':"markdown",'section':"文档类型",'content':"markdown #  图片大小设置 \u0026lt;img src=\u0026quot;xxx\u0026quot; width=\u0026quot;30%\u0026quot; height=\u0026quot;30%\u0026quot;\u0026gt;\n"});index.add({'id':63,'href':'/note-cs/docs/basic/os/type/android/appendix/interview/basic/','title':"基础",'section':"4.2 面试题",'content':"基础面试题 #  "});index.add({'id':64,'href':'/note-cs/docs/basic/os/type/ios/appendix/interview/basic/','title':"基础",'section':"4.2 面试题",'content':"基础面试题 #  "});index.add({'id':65,'href':'/note-cs/docs/basic/os/type/macos/appendix/interview/basic/','title':"基础",'section':"4.2 面试题",'content':"基础面试题 #  "});index.add({'id':66,'href':'/note-cs/docs/basic/os/type/unix/appendix/interview/basic/','title':"基础",'section':"4.2 面试题",'content':"基础面试题 #  "});index.add({'id':67,'href':'/note-cs/docs/basic/os/type/windows/appendix/interview/basic/','title':"基础",'section':"4.2 面试题",'content':"基础面试题 #  "});index.add({'id':68,'href':'/note-cs/docs/basic/pl/csharp/appendix/interview/basic/','title':"基础",'section':"4.2 面试题",'content':"基础面试题 #  "});index.add({'id':69,'href':'/note-cs/docs/basic/pl/erlang/appendix/interview/basic/','title':"基础",'section':"4.2 面试题",'content':"基础面试题 #  "});index.add({'id':70,'href':'/note-cs/docs/basic/pl/haskell/appendix/interview/basic/','title':"基础",'section':"4.2 面试题",'content':"基础面试题 #  "});index.add({'id':71,'href':'/note-cs/docs/basic/pl/kotlin/appendix/interview/basic/','title':"基础",'section':"4.2 面试题",'content':"基础面试题 #  "});index.add({'id':72,'href':'/note-cs/docs/basic/pl/lua/appendix/interview/basic/','title':"基础",'section':"4.2 面试题",'content':"基础面试题 #  "});index.add({'id':73,'href':'/note-cs/docs/basic/pl/objective-c/appendix/interview/basic/','title':"基础",'section':"4.2 面试题",'content':"基础面试题 #  "});index.add({'id':74,'href':'/note-cs/docs/basic/pl/r/appendix/interview/basic/','title':"基础",'section':"4.2 面试题",'content':"基础面试题 #  "});index.add({'id':75,'href':'/note-cs/docs/basic/pl/ruby/appendix/interview/basic/','title':"基础",'section':"4.2 面试题",'content':"基础面试题 #  "});index.add({'id':76,'href':'/note-cs/docs/basic/pl/scala/appendix/interview/basic/','title':"基础",'section':"4.2 面试题",'content':"基础面试题 #  "});index.add({'id':77,'href':'/note-cs/docs/basic/pl/swift/appendix/interview/basic/','title':"基础",'section':"4.2 面试题",'content':"基础面试题 #  "});index.add({'id':78,'href':'/note-cs/docs/direction/be/db/mysql/appendix/interview/basic/','title':"基础",'section':"4.2 面试题",'content':"基础面试题 #  "});index.add({'id':79,'href':'/note-cs/docs/direction/be/db/postgresql/appendix/interview/basic/','title':"基础",'section':"4.2 面试题",'content':"基础面试题 #  "});index.add({'id':80,'href':'/note-cs/docs/direction/be/db/redis/appendix/interview/basic/','title':"基础",'section':"4.2 面试题",'content':"基础面试题 #  Redis 有哪些数据类型，分别适合什么场景？ #  Redis 如何做持久化？ #  Redis 如何实现高可用？ #  Redis 如何与 Mysql 做一致性同步？ #  "});index.add({'id':81,'href':'/note-cs/docs/direction/be/platform/nodejs/appendix/interview/basic/','title':"基础",'section':"4.2 面试题",'content':"基础面试题 #  "});index.add({'id':82,'href':'/note-cs/docs/direction/client/android/appendix/interview/basic/','title':"基础",'section':"4.2 面试题",'content':"基础面试题 #  "});index.add({'id':83,'href':'/note-cs/docs/direction/client/ios/appendix/interview/basic/','title':"基础",'section':"4.2 面试题",'content':"基础面试题 #  "});index.add({'id':84,'href':'/note-cs/docs/direction/client/xiaochengxu/appendix/interview/basic/','title':"基础",'section':"4.2 面试题",'content':"基础面试题 #  "});index.add({'id':85,'href':'/note-cs/docs/direction/embedded/appendix/interview/basic/','title':"基础",'section':"4.2 面试题",'content':"基础面试题 #  "});index.add({'id':86,'href':'/note-cs/docs/direction/fe/frame/angular/appendix/interview/basic/','title':"基础",'section':"4.2 面试题",'content':"基础面试题 #  "});index.add({'id':87,'href':'/note-cs/docs/direction/fe/frame/react/appendix/interview/basic/','title':"基础",'section':"4.2 面试题",'content':"基础面试题 #  "});index.add({'id':88,'href':'/note-cs/docs/direction/fe/frame/vue/appendix/interview/basic/','title':"基础",'section':"4.2 面试题",'content':"基础面试题 #  "});index.add({'id':89,'href':'/note-cs/docs/direction/security/appendix/interview/basic/','title':"基础",'section':"4.2 面试题",'content':"基础面试题 #  "});index.add({'id':90,'href':'/note-cs/docs/book/basic/cc/csapp/','title':"深入理解计算机系统",'section':"5.1.1 计算机组成原理",'content':"深入理解计算机系统 #   豆瓣   学习参考 #  如何阅读《深入理解计算机系统》这本书？ #  EugeneLiu/translationCSAPP #  为 CSAPP 视频课程提供字幕，翻译 PPT，Lab\nDreamAndDead/CSAPP-3e-Solutions #  CSAPP 3e Solutions gitbook\nvonzhou/CSAPP #  CSAPP,《深入理解计算机系统结构》2nd ，阅读与实践！\nExely/CSAPP-Labs #  Solutions and Notes for Labs of Computer Systems: A Programmer\u0026rsquo;s Perspective 3rd Editon // 《深入理解计算机系统》第三版的实验文件、解答与笔记\n"});index.add({'id':119,'href':'/note-cs/docs/basic/os/type/android/appendix/interview/advanced/','title':"进阶",'section':"4.2 面试题",'content':"进阶面试题 #  "});index.add({'id':120,'href':'/note-cs/docs/basic/os/type/ios/appendix/interview/advanced/','title':"进阶",'section':"4.2 面试题",'content':"进阶面试题 #  "});index.add({'id':121,'href':'/note-cs/docs/basic/os/type/macos/appendix/interview/advanced/','title':"进阶",'section':"4.2 面试题",'content':"进阶面试题 #  "});index.add({'id':122,'href':'/note-cs/docs/basic/os/type/unix/appendix/interview/advanced/','title':"进阶",'section':"4.2 面试题",'content':"进阶面试题 #  "});index.add({'id':123,'href':'/note-cs/docs/basic/os/type/windows/appendix/interview/advanced/','title':"进阶",'section':"4.2 面试题",'content':"进阶面试题 #  "});index.add({'id':124,'href':'/note-cs/docs/basic/pl/csharp/appendix/interview/advanced/','title':"进阶",'section':"4.2 面试题",'content':"进阶面试题 #  "});index.add({'id':125,'href':'/note-cs/docs/basic/pl/erlang/appendix/interview/advanced/','title':"进阶",'section':"4.2 面试题",'content':"进阶面试题 #  "});index.add({'id':126,'href':'/note-cs/docs/basic/pl/haskell/appendix/interview/advanced/','title':"进阶",'section':"4.2 面试题",'content':"进阶面试题 #  "});index.add({'id':127,'href':'/note-cs/docs/basic/pl/kotlin/appendix/interview/advanced/','title':"进阶",'section':"4.2 面试题",'content':"进阶面试题 #  "});index.add({'id':128,'href':'/note-cs/docs/basic/pl/lua/appendix/interview/advanced/','title':"进阶",'section':"4.2 面试题",'content':"进阶面试题 #  "});index.add({'id':129,'href':'/note-cs/docs/basic/pl/objective-c/appendix/interview/advanced/','title':"进阶",'section':"4.2 面试题",'content':"进阶面试题 #  "});index.add({'id':130,'href':'/note-cs/docs/basic/pl/r/appendix/interview/advanced/','title':"进阶",'section':"4.2 面试题",'content':"进阶面试题 #  "});index.add({'id':131,'href':'/note-cs/docs/basic/pl/ruby/appendix/interview/advanced/','title':"进阶",'section':"4.2 面试题",'content':"进阶面试题 #  "});index.add({'id':132,'href':'/note-cs/docs/basic/pl/scala/appendix/interview/advanced/','title':"进阶",'section':"4.2 面试题",'content':"进阶面试题 #  "});index.add({'id':133,'href':'/note-cs/docs/basic/pl/swift/appendix/interview/advanced/','title':"进阶",'section':"4.2 面试题",'content':"进阶面试题 #  "});index.add({'id':134,'href':'/note-cs/docs/direction/be/db/mysql/appendix/interview/advanced/','title':"进阶",'section':"4.2 面试题",'content':"进阶面试题 #  "});index.add({'id':135,'href':'/note-cs/docs/direction/be/db/postgresql/appendix/interview/advanced/','title':"进阶",'section':"4.2 面试题",'content':"进阶面试题 #  "});index.add({'id':136,'href':'/note-cs/docs/direction/be/db/redis/appendix/interview/advanced/','title':"进阶",'section':"4.2 面试题",'content':"进阶面试题 #  "});index.add({'id':137,'href':'/note-cs/docs/direction/be/platform/nodejs/appendix/interview/advanced/','title':"进阶",'section':"4.2 面试题",'content':"进阶面试题 #  "});index.add({'id':138,'href':'/note-cs/docs/direction/client/android/appendix/interview/advanced/','title':"进阶",'section':"4.2 面试题",'content':"进阶面试题 #  "});index.add({'id':139,'href':'/note-cs/docs/direction/client/ios/appendix/interview/advanced/','title':"进阶",'section':"4.2 面试题",'content':"进阶面试题 #  "});index.add({'id':140,'href':'/note-cs/docs/direction/client/xiaochengxu/appendix/interview/advanced/','title':"进阶",'section':"4.2 面试题",'content':"进阶面试题 #  "});index.add({'id':141,'href':'/note-cs/docs/direction/embedded/appendix/interview/advanced/','title':"进阶",'section':"4.2 面试题",'content':"进阶面试题 #  "});index.add({'id':142,'href':'/note-cs/docs/direction/fe/frame/angular/appendix/interview/advanced/','title':"进阶",'section':"4.2 面试题",'content':"进阶面试题 #  "});index.add({'id':143,'href':'/note-cs/docs/direction/fe/frame/react/appendix/interview/advanced/','title':"进阶",'section':"4.2 面试题",'content':"进阶面试题 #  "});index.add({'id':144,'href':'/note-cs/docs/direction/fe/frame/vue/appendix/interview/advanced/','title':"进阶",'section':"4.2 面试题",'content':"进阶面试题 #  "});index.add({'id':145,'href':'/note-cs/docs/direction/security/appendix/interview/advanced/','title':"进阶",'section':"4.2 面试题",'content':"进阶面试题 #  "});index.add({'id':146,'href':'/note-cs/docs/skill/tool/note/hugo/config/','title':"配置",'section':"Hugo",'content':"Hugo 配置 #  参考：https://themes.gohugo.io/hugo-book\n"});index.add({'id':147,'href':'/note-cs/docs/basic/compile/make/cmake/','title':"cmake",'section':"make",'content':"cmake #  "});index.add({'id':148,'href':'/note-cs/docs/book/be/Designing-Data-Intensive-Applications/','title':"Designing Data-Intensive Applications",'section':"5.2 后端",'content':"Designing Data-Intensive Applications #  简介 #  \npublished by O’Reilly in March 2017.\n作者 #  Martin Kleppmann\nMartin Kleppmann\u0026rsquo;s blog\n阅读笔记 #  "});index.add({'id':149,'href':'/note-cs/docs/skill/tool/note/hugo/theme/hugo-book/','title':"hugo-book",'section':"主题",'content':"hugo-book #  配置 #  Site Configuration #   点击查看配置详情 ...  # (Optional) Set Google Analytics if you use it to track your website. # Always put it on the top of the configuration file, otherwise it won\u0026#39;t work googleAnalytics = \u0026#34;UA-XXXXXXXXX-X\u0026#34; # (Optional) If you provide a Disqus shortname, comments will be enabled on # all pages. disqusShortname = \u0026#34;my-site\u0026#34; # (Optional) Set this to true if you use capital letters in file names disablePathToLower = true # (Optional) Set this to true to enable \u0026#39;Last Modified by\u0026#39; date and git author # information on \u0026#39;doc\u0026#39; type pages. enableGitInfo = true # (Optional) Theme is intended for documentation use, therefore it doesn\u0026#39;t render taxonomy. # You can remove related files with config below disableKinds = [\u0026#39;taxonomy\u0026#39;, \u0026#39;taxonomyTerm\u0026#39;] [params] # (Optional, default true) Controls table of contents visibility on right side of pages. # Start and end levels can be controlled with markup.tableOfContents setting. # You can also specify this parameter per page in front matter. BookToC = true # (Optional, default none) Set the path to a logo for the book. If the logo is # /static/logo.png then the path would be \u0026#39;logo.png\u0026#39; BookLogo = \u0026#39;logo.png\u0026#39; # (Optional, default none) Set leaf bundle to render as side menu # When not specified file structure and weights will be used BookMenuBundle = \u0026#39;/menu\u0026#39; # (Optional, default docs) Specify section of content to render as menu # You can also set value to \u0026#34;*\u0026#34; to render all sections to menu BookSection = \u0026#39;docs\u0026#39; # Set source repository location. # Used for \u0026#39;Last Modified\u0026#39; and \u0026#39;Edit this page\u0026#39; links. BookRepo = \u0026#39;https://github.com/alex-shpak/hugo-book\u0026#39; # Enable \u0026#39;Edit this page\u0026#39; links for \u0026#39;doc\u0026#39; page type. # Disabled by default. Uncomment to enable. Requires \u0026#39;BookRepo\u0026#39; param. # Path must point to \u0026#39;content\u0026#39; directory of repo. BookEditPath = \u0026#39;edit/master/exampleSite/content\u0026#39; # (Optional, default January 2, 2006) Configure the date format used on the pages # - In git information # - In blog posts BookDateFormat = \u0026#39;Jan 2, 2006\u0026#39; # (Optional, default true) Enables search function with flexsearch, # Index is built on fly, therefore it might slowdown your website. # Configuration for indexing can be adjusted in i18n folder per language. BookSearch = true # (Optional, default true) Enables comments template on pages # By default partals/docs/comments.html includes Disqus template # See https://gohugo.io/content-management/comments/#configure-disqus # Can be overwritten by same param in page frontmatter BookComments = true     Page Configuration #   点击查看配置详情 ...  # Set type to \u0026#39;docs\u0026#39; if you want to render page outside of configured section or if you render section other than \u0026#39;docs\u0026#39; type = \u0026#39;docs\u0026#39; # Set page weight to re-arrange items in file-tree menu (if BookMenuBundle not set) weight = 10 # (Optional) Set to mark page as flat section in file-tree menu (if BookMenuBundle not set) bookFlatSection = true # (Optional, Experimental) Set to hide nested sections or pages at that level. Works only with file-tree menu mode bookCollapseSection = true # (Optional) Set true to hide page or section from side menu (if BookMenuBundle not set) bookHidden = true # (Optional) Set \u0026#39;false\u0026#39; to hide ToC from page bookToC = true # (Optional) If you have enabled BookComments for the site, you can disable it for specific pages. bookComments = true      使用 #  Shortcodes #  Buttons #   Get Home  Contribute   点击查看配置 ...  {{\u0026lt; button relref=\u0026#34;/\u0026#34; \u0026gt;}}Get Home{{\u0026lt; /button \u0026gt;}} {{\u0026lt; button href=\u0026#34;https://github.com/alex-shpak/hugo-book\u0026#34; \u0026gt;}}Contribute{{\u0026lt; /button \u0026gt;}}     Columns #  Left Content hello hugo book shortcodes  Mid Content hello hugo book  Right Content hello hugo book shortcodes    点击查看配置 ...  {{\u0026lt; columns \u0026gt;}} \u0026lt;!-- begin columns block --\u0026gt; # Left Content Lorem markdownum insigne... \u0026lt;---\u0026gt; \u0026lt;!-- magic sparator, between columns --\u0026gt; # Mid Content Lorem markdownum insigne... \u0026lt;---\u0026gt; \u0026lt;!-- magic sparator, between columns --\u0026gt; # Right Content Lorem markdownum insigne... {{\u0026lt; /columns \u0026gt;}}     Expand #   Custom Label ...  Markdown content hello hugo book shortcodes     点击查看配置 ...  {{\u0026lt; expand \u0026#34;Custom Label\u0026#34; \u0026#34;...\u0026#34; \u0026gt;}} ## Markdown content Lorem markdownum insigne... {{\u0026lt; /expand \u0026gt;}}     Hints #  Markdown content hello hugo book  Markdown content hello hugo book  Markdown content hello hugo book   点击查看配置 ...  {{\u0026lt; hint [info|warning|danger] \u0026gt;}} **Markdown content** hello hugo book {{\u0026lt; /hint \u0026gt;}}     Katex #     \\(x = \\begin{cases} a \u0026amp;\\text{if } b \\\\ c \u0026amp;\\text{if } d \\end{cases}\\)   点击查看配置 ...  {{\u0026lt; katex [display] \u0026gt;}} x = \\begin{cases} a \u0026amp;\\text{if } b \\\\ c \u0026amp;\\text{if } d \\end{cases} {{\u0026lt; /katex \u0026gt;}}     Mermaid #     mermaid.initialize({ flowchart: { useMaxWidth:true } });  sequenceDiagram Alice-Bob: Hello Bob, how are you? alt is sick Bob-Alice: Not so good :( else is well Bob-Alice: Feeling fresh like a daisy end opt Extra response Bob-Alice: Thanks for asking end  点击查看配置 ...  {{\u0026lt; mermaid \u0026gt;}} sequenceDiagram Alice-\u0026gt;\u0026gt;Bob: Hello Bob, how are you? alt is sick Bob-\u0026gt;\u0026gt;Alice: Not so good :( else is well Bob-\u0026gt;\u0026gt;Alice: Feeling fresh like a daisy end opt Extra response Bob-\u0026gt;\u0026gt;Alice: Thanks for asking end {{\u0026lt; /mermaid \u0026gt;}}     Tabs #  MacOS MacOS This is tab MacOS content.Linux Linux This is tab Linux content.Windows Windows This is tab Windows content.  点击查看配置 ...  {{\u0026lt; tabs \u0026#34;uniqueid\u0026#34; \u0026gt;}} {{\u0026lt; tab \u0026#34;MacOS\u0026#34; \u0026gt;}} # MacOS Content {{\u0026lt; /tab \u0026gt;}} {{\u0026lt; tab \u0026#34;Linux\u0026#34; \u0026gt;}} # Linux Content {{\u0026lt; /tab \u0026gt;}} {{\u0026lt; tab \u0026#34;Windows\u0026#34; \u0026gt;}} # Windows Content {{\u0026lt; /tab \u0026gt;}} {{\u0026lt; /tabs \u0026gt;}}      参考 #   https://github.com/alex-shpak/hugo-book  https://themes.gohugo.io/hugo-book   KaTeX/KaTeX  TeX wiki  "});index.add({'id':150,'href':'/note-cs/docs/basic/pl/shell/command/kill/','title':"kill",'section':"1.3.1 Shell 命令",'content':"kill #  kill -9 与 kill 的区别 #   kill 等于 kill -15，是安全的  TERM   kill -9 是不安全的  SIGKILL    kill aka kill -TERM aka kill -15 is the safe and correct way of terminating a process. It\u0026rsquo;s equivalent to safely shutting down a computer.\nkill -9 is the unsafe way of brutally murdering a process. It\u0026rsquo;s equivalent to pulling the power cord, and may cause data corruption.\n参考：\n what-is-the-difference-between-kill-and-kill-9 what-is-the-purpose-of-the-9-option-in-the-kill-command Linux kill -9 和 kill -15 的区别  "});index.add({'id':151,'href':'/note-cs/docs/basic/os/type/macos/','title':"MacOS",'section':"操作系统类型",'content':"MacOS #  "});index.add({'id':152,'href':'/note-cs/docs/basic/pl/shell/command/netcat/','title':"netcat",'section':"1.3.1 Shell 命令",'content':"netcat #  netcat -u 127.0.0.1 9502 "});index.add({'id':153,'href':'/note-cs/docs/basic/pl/shell/command/netstat/','title':"netstat",'section':"1.3.1 Shell 命令",'content':"netstat #  "});index.add({'id':154,'href':'/note-cs/docs/basic/pl/shell/command/telnet/','title':"telnet",'section':"1.3.1 Shell 命令",'content':"telnet #  只能测试 tcp 端口连接\n无法测试 udp 端口连接（可以用 netcat）\ntelnet domain/ip [port] telnet 退出 #   按 CTRL + ] 然后输入 quit  "});index.add({'id':155,'href':'/note-cs/docs/basic/os/type/windows/','title':"Windows",'section':"操作系统类型",'content':"Windows #  "});index.add({'id':156,'href':'/note-cs/docs/skill/tool/note/hugo/theme/','title':"主题",'section':"Hugo",'content':"Hugo 主题 #  hugo-academic #  适合作为个人主页，内容比较丰富，尤其适合作为技术或科研人员的博客。\nhugo-book #   适合记笔记，或者写书。我很喜欢他右侧的页面目录，类似语雀。 其实语雀编辑体验很好，尤其是最近改版后允许用户直接在左侧目录操作新增页面。 不使用语雀，而使用 github pages，最关键也可以说唯一的原因就是对其他平台不放心，内容还是自己保管比较好。 不然万一哪天平台下线，只是一个道歉页面，而作为免费用户，只能自己想办法导出笔记，想想还是算了。  参考：https://themes.gohugo.io\n"});index.add({'id':178,'href':'/note-cs/docs/basic/pl/lua/code/','title':"第三部分 设计与实现",'section':"Lua",'content':"设计与实现 #  lua #  lua/lua LuaJIT #  LuaJIT/LuaJIT LuaJIT is a Just-In-Time Compiler (JIT) for the Lua programming language.\nGopherLua #  yuin/gopher-lua GopherLua is a Lua5.1 VM and compiler written in Go. GopherLua has a same goal with Lua: Be a scripting language with extensible semantics . It provides Go APIs that allow you to easily embed a scripting language to your Go host programs.\n"});index.add({'id':185,'href':'/note-cs/docs/basic/os/type/android/appendix/interview/expert/','title':"高阶",'section':"4.2 面试题",'content':"高阶面试题 #  "});index.add({'id':186,'href':'/note-cs/docs/basic/os/type/ios/appendix/interview/expert/','title':"高阶",'section':"4.2 面试题",'content':"高阶面试题 #  "});index.add({'id':187,'href':'/note-cs/docs/basic/os/type/macos/appendix/interview/expert/','title':"高阶",'section':"4.2 面试题",'content':"高阶面试题 #  "});index.add({'id':188,'href':'/note-cs/docs/basic/os/type/unix/appendix/interview/expert/','title':"高阶",'section':"4.2 面试题",'content':"高阶面试题 #  "});index.add({'id':189,'href':'/note-cs/docs/basic/os/type/windows/appendix/interview/expert/','title':"高阶",'section':"4.2 面试题",'content':"高阶面试题 #  "});index.add({'id':190,'href':'/note-cs/docs/direction/be/db/mysql/appendix/interview/expert/','title':"高阶",'section':"4.2 面试题",'content':"高阶面试题 #  "});index.add({'id':191,'href':'/note-cs/docs/direction/be/db/postgresql/appendix/interview/expert/','title':"高阶",'section':"4.2 面试题",'content':"高阶面试题 #  "});index.add({'id':192,'href':'/note-cs/docs/direction/be/db/redis/appendix/interview/expert/','title':"高阶",'section':"4.2 面试题",'content':"高阶面试题 #  "});index.add({'id':193,'href':'/note-cs/docs/direction/be/platform/nodejs/appendix/interview/expert/','title':"高阶",'section':"4.2 面试题",'content':"高阶面试题 #  "});index.add({'id':194,'href':'/note-cs/docs/direction/client/android/appendix/interview/expert/','title':"高阶",'section':"4.2 面试题",'content':"高阶面试题 #  "});index.add({'id':195,'href':'/note-cs/docs/direction/client/ios/appendix/interview/expert/','title':"高阶",'section':"4.2 面试题",'content':"高阶面试题 #  "});index.add({'id':196,'href':'/note-cs/docs/direction/client/xiaochengxu/appendix/interview/expert/','title':"高阶",'section':"4.2 面试题",'content':"高阶面试题 #  "});index.add({'id':197,'href':'/note-cs/docs/direction/embedded/appendix/interview/expert/','title':"高阶",'section':"4.2 面试题",'content':"高阶面试题 #  "});index.add({'id':198,'href':'/note-cs/docs/direction/fe/frame/angular/appendix/interview/expert/','title':"高阶",'section':"4.2 面试题",'content':"高阶面试题 #  "});index.add({'id':199,'href':'/note-cs/docs/direction/fe/frame/react/appendix/interview/expert/','title':"高阶",'section':"4.2 面试题",'content':"高阶面试题 #  "});index.add({'id':200,'href':'/note-cs/docs/direction/fe/frame/vue/appendix/interview/expert/','title':"高阶",'section':"4.2 面试题",'content':"高阶面试题 #  "});index.add({'id':201,'href':'/note-cs/docs/direction/security/appendix/interview/expert/','title':"高阶",'section':"4.2 面试题",'content':"高阶面试题 #  "});index.add({'id':202,'href':'/note-cs/docs/direction/be/mq/mqtt/mosquitto/','title':"mosquitto",'section':"MQTT",'content':"mosquitto #  物联网（Internet of Things，IoT）最近曝光率越来越高。虽然 HTTP 是网页的事实标准，不过机器之间（Machine-to-Machine，M2M）的大规模沟通需要不同的模式：之前的请求 / 回答（Request/Response）模式不再合适，取而代之的是发布 / 订阅（Publish/Subscribe）模式。这就是轻量级、可扩展的 MQTT（Message Queuing Telemetry Transport）可以施展拳脚的舞台。\nMQTT 是基于二进制消息的发布 / 订阅编程模式的消息协议，最早由 IBM 提出的，如今已经成为 OASIS 规范。由于规范很简单，非常适合需要低功耗和网络带宽有限的 IoT 场景，比如：\n 遥感数据 汽车 智能家居 智慧城市 医疗医护  安装 #  MacOS #  brew install mosquitto\n参考：https://mosquitto.org/download/\n"});index.add({'id':203,'href':'/note-cs/docs/basic/os/type/unix/','title':"Unix",'section':"操作系统类型",'content':"Unix #  "});index.add({'id':232,'href':'/note-cs/docs/basic/pl/c/','title':"C",'section':"1.5 编程语言",'content':"C 学习笔记 #  见：C 学习笔记\n"});index.add({'id':233,'href':'/note-cs/docs/basic/compile/gcc/','title':"gcc",'section':"1.6 编译原理",'content':"gcc #  安装 #  gcc 4.8 #  curl -Lks http://www.hop5.in/yum/el6/hop5.repo \u0026gt; /etc/yum.repos.d/hop5.repo yum install gcc gcc-g++ gcc --version 参考： Linux 之 CentOS 6 通过 yum 安装 gcc 4.9 5.2 等高版本 gcc\n 升级 #  升级到 gcc 6.3 #  yum -y install centos-release-scl yum -y install devtoolset-6-gcc devtoolset-6-gcc-c++ devtoolset-6-binutils # scl 命令启用只是临时的，退出 shell 或重启就会恢复原系统 gcc 版本 scl enable devtoolset-6 bash # 长期 echo \u0026#34;source /opt/rh/devtoolset-6/enable\u0026#34; \u0026gt;\u0026gt;/etc/profile 参考：\n 为 CentOS 6、7 升级 gcc 至 4.8、4.9、5.2、6.3、7.3 等高版本  "});index.add({'id':234,'href':'/note-cs/docs/skill/stream-media/debug/gdb/','title':"GDB",'section':"Debug",'content':"GDB #  GDB 的主要功能就是监控程序的执行流程，\n只有当源程序文件编译为可执行文件并执行时，GDB 才会派上用场。\n# -g Generate source-level debug information $ gcc -g main.c -o main # 启动时不显示提示信息 # -q, --quiet, --silent $ gdb -q # 显示 gdb 版本信息 (gdb) show version # 查看 gdb 版权相关信息 (gdb) show copying # 输出信息多时不会暂停输出 (gdb) set pagination off # 列出函数的名字 (gdb) info functions (gdb) info functions regex GDB 常用的调试指令 #     调试指令 作 用     (gdb) break xxx (gdb) b xxx 在源代码指定的某一行设置断点，其中 xxx 用于指定具体打断点的位置。   (gdb) run (gdb) r 执行被调试的程序，其会自动在第一个断点处暂停执行。   (gdb) continue (gdb) c 当程序在某一断点处停止运行后，使用该指令可以继续执行，直至遇到下一个断点或者程序结束。   (gdb) next (gdb) n 令程序一行代码一行代码的执行。   (gdb) print xxx (gdb) p xxx 打印指定变量的值，其中 xxx 指的就是某一变量名。   (gdb) list (gdb) l 显示源程序代码的内容，包括各行代码所在的行号。   (gdb) quit (gdb) q 终止调试。     问题 #  解决 GDB 在 Mac 下不能调试的问题 #  Darwin 内核在你没有特殊权限的情况下，不允许调试其它进程。 调试某个进程，意味着你对这个进程有完全的控制权限，所以为了防止被恶意利用，它是默认禁止的。允许 gdb 控制其它进程最好的方法就是用系统信任的证书对它进行签名。\n创建代码签名的证书 #   打开 Keychain Access 应用程序（/Applications/Utilities/Keychain Access.app） 执行菜单 钥匙串访问 -\u0026gt; 证书助理 -\u0026gt; 创建证书 填写如下信息：  名称：gdb_codesign 身份类型：自签名根证书 证书类型：代码签名 钩选：让我覆盖这些默认设置\n   一路确定，直到指定证书位置的步骤，选择系统\n 点击 \u0026ldquo;创建\u0026rdquo;，会提示用输入系统登录密码，创建完成 在钥匙串访问程序中，选择左侧栏的系统和我的证书，找到你刚刚创建的 gdb_codesign 证书并双击打开证书信息窗口，展开 信任项，设置使用此证书时：为始终信任。\n 关闭证书信息窗口，系统会再次要求输入系统登录密码。  签名 #  如果是之前的系统，直接执行：\ncodesign -fs gdb-cert $(which gdb)\n如果是 Mojave (10.14) 之后的系统，\n先创建一个文件 gdb-entitlement.xml，内容为:\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;!DOCTYPE plist PUBLIC \u0026#34;-//Apple//DTD PLIST 1.0//EN\u0026#34; \u0026#34;http://www.apple.com/DTDs/PropertyList-1.0.dtd\u0026#34;\u0026gt; \u0026lt;plist version=\u0026#34;1.0\u0026#34;\u0026gt; \u0026lt;dict\u0026gt; \u0026lt;key\u0026gt;com.apple.security.cs.debugger\u0026lt;/key\u0026gt; \u0026lt;true/\u0026gt; \u0026lt;/dict\u0026gt; \u0026lt;/plist\u0026gt; \u0026lt;/pre\u0026gt; 再执行:\ncodesign --entitlements gdb-entitlement.xml -fs gdb-cert $(which gdb)\n具体参考这里：https://sourceware.org/gdb/wi\u0026hellip;\n参考：\n 解决 GDB 在 Mac 下不能调试的问题   工具 #  cyrus-and/gdb-dashboard "});index.add({'id':235,'href':'/note-cs/docs/direction/be/platform/nodejs/basic/build/gulp/','title':"gulp",'section':"构建",'content':"gulp #  类似与 make 参考：https://learnxinyminutes.com/docs/zh-cn/make-cn/\n"});index.add({'id':236,'href':'/note-cs/docs/basic/compile/make/','title':"make",'section':"1.6 编译原理",'content':"make #  教程 #   learn make in y minutes 跟我一起写 Makefile GNU make manual  "});index.add({'id':237,'href':'/note-cs/docs/direction/be/db/redis/basic/quick-start/','title':"Quick Start",'section':"第一部分 基础入门",'content':"Quick Start #  redis-cli -h host -p port -a password 安装 #  开机自启 #  sudo vi /usr/lib/systemd/system/redis.service\n[Unit] Description=Redis persistent key-value database After=network.target After=network-online.target Wants=network-online.target [Service] ExecStart=/usr/bin/redis-server /etc/redis.conf --supervised systemd ExecStop=/usr/libexec/redis-shutdown Type=notify User=redis Group=redis RuntimeDirectory=redis RuntimeDirectoryMode=0755 [Install] WantedBy=multi-user.target 保存退出，执行 sudo systemctl daemon-reload 启动服务 sudo systemctl start redis.service 设置开机自启动 sudo systemctl enable redis.service\n设置密码 #  打开文件 /etc/redis.conf， 找到其中的 # requirepass foobared，去掉前面的 #， 并把 foobared 改成你的密码。\nps: 如果 redis 没有启用密码，我使用 redis-cli -a xxx 可以访问吗？ 答案是：可以\n为什么 Redis 默认端口是 6379 #  6379 在是手机按键上 MERZ 对应的号码，而 MERZ 取自意大利歌女 Alessia Merz 的名字。 MERZ 长期以来被 antirez 及其朋友当作愚蠢的代名词。\n参考：http://oldblog.antirez.com/post/redis-as-LRU-cache.html\n问答 #  MySQL 和 Redis 如何保持数据的一致性？ #  MySQL binlog 增量订阅消费 + 消息队列 + 处理并把数据更新到 redis\n参考：\nliukelin/canal_mysql_nosql_sync #  alibaba/canal #  阿里巴巴 MySQL binlog 增量订阅 \u0026amp; 消费组件\n 分布式的环境下， MySQL 和 Redis 如何保持数据的一致性？  "});index.add({'id':238,'href':'/note-cs/docs/basic/pl/shell/type/zsh/','title':"Zsh",'section':"1.3.4 Shell 类型",'content':"Zsh #  "});index.add({'id':239,'href':'/note-cs/docs/direction/be/db/mysql/basic/practice/snippet/','title':"代码片段",'section':"实践",'content':"代码片段 #  "});index.add({'id':240,'href':'/note-cs/docs/direction/be/db/postgresql/basic/practice/snippet/','title':"代码片段",'section':"实践",'content':"代码片段 #  "});index.add({'id':241,'href':'/note-cs/docs/direction/be/db/redis/basic/practice/snippet/','title':"代码片段",'section':"实践",'content':"代码片段 #  "});index.add({'id':242,'href':'/note-cs/docs/direction/be/platform/nodejs/basic/practice/snippet/','title':"代码片段",'section':"实践",'content':"代码片段 #  "});index.add({'id':243,'href':'/note-cs/docs/direction/client/android/basic/practice/snippet/','title':"代码片段",'section':"实践",'content':"代码片段 #  "});index.add({'id':244,'href':'/note-cs/docs/direction/client/ios/basic/practice/snippet/','title':"代码片段",'section':"实践",'content':"代码片段 #  "});index.add({'id':245,'href':'/note-cs/docs/direction/client/xiaochengxu/basic/practice/snippet/','title':"代码片段",'section':"实践",'content':"代码片段 #  "});index.add({'id':246,'href':'/note-cs/docs/direction/fe/frame/angular/basic/practice/snippet/','title':"代码片段",'section':"实践",'content':"代码片段 #  "});index.add({'id':247,'href':'/note-cs/docs/direction/fe/frame/react/basic/practice/snippet/','title':"代码片段",'section':"实践",'content':"代码片段 #  "});index.add({'id':248,'href':'/note-cs/docs/direction/fe/frame/vue/basic/practice/snippet/','title':"代码片段",'section':"实践",'content':"代码片段 #  "});index.add({'id':249,'href':'/note-cs/docs/direction/be/db/redis/basic/type/','title':"数据类型",'section':"第一部分 基础入门",'content':"数据类型 #  string #  Redis 规定了字符串的长度不得超过 512 MB。\nlist #  hash #  set #  zset #  "});index.add({'id':250,'href':'/note-cs/docs/direction/be/platform/nodejs/basic/build/','title':"构建",'section':"第一部分 基础入门",'content':"Node.js 构建 #  "});index.add({'id':251,'href':'/note-cs/docs/direction/be/platform/nodejs/basic/version/','title':"版本",'section':"第一部分 基础入门",'content':"Node.js 版本 #  版本控制 #  nvm-sh/nvm #  Node Version Manager - POSIX-compliant bash script to manage multiple active node.js versions\n安装 #  curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.35.3/install.sh | bash export NVM_DIR=\u0026#34;$([ -z \u0026#34;${XDG_CONFIG_HOME-}\u0026#34; ] \u0026amp;\u0026amp; printf %s \u0026#34;${HOME}/.nvm\u0026#34; || printf %s \u0026#34;${XDG_CONFIG_HOME}/nvm\u0026#34;)\u0026#34; [ -s \u0026#34;$NVM_DIR/nvm.sh\u0026#34; ] \u0026amp;\u0026amp; \\. \u0026#34;$NVM_DIR/nvm.sh\u0026#34; # This loads nvm 基础命令 #  # 安装最新版 nvm install node # 安装最新 LTS 版本 nvm install --lts # 设置默认版本 nvm alias default lts/* # 查看本地版本列表 nvm ls # 查看全部版本列表 nvm ls-remote nvm ls-remote --lts # 使用最新版本 LTS nvm use lts/* # 查看安装路径 nvm which node nvm which v12.14.1 "});index.add({'id':252,'href':'/note-cs/docs/basic/pl/scala/basic/spec/baidu/','title':"百度",'section':"1.3 编程规范",'content':"百度 Scala 编码规范 #  前言 #  就目前 Baidu 内部情况 (2018.10)，Scala 这门语言主要用于计算团队内部的和 Spark 相关项目研发、社区贡献工作以及公司的 Spark 用户使用 Scala API 编写 Spark 作业三个用途，所以本文主体沿用如下两部分并稍作修改：\n Apache Spark 开源社区 Scala 编程指南:\nApache Spark 有超过 1000 位贡献者，就我们所知，应该是目前大数据领域里最大的开源项目且是最活跃的 Scala 项目，结合 Baidu 内部现状，本文主体沿用此部分中和 Spark 社区相关内容，去除部分项目专用细节。 scala 官方 style guide 里的格式部分已包含在 Spark 项目文档中，这里摘录部分官方 style guide 作为 Apache Spark 社区的编程指南补充。  "});index.add({'id':253,'href':'/note-cs/docs/book/','title':"第五部分 读书",'section':"Docs",'content':"读书 #  论文 #  papers-we-love/papers-we-love #  Papers from the computer science community to read and discuss.\n"});index.add({'id':255,'href':'/note-cs/docs/book/basic/cc/sicp/','title':"计算机程序的构造和解释",'section':"5.1.1 计算机组成原理",'content':"计算机程序的构造和解释 #   豆瓣  参考 #   黄健宏：SICP 解题集  "});index.add({'id':256,'href':'/note-cs/docs/direction/be/db/redis/design/lock/','title':"锁",'section':"第二部分 设计",'content':"锁 #  setnx #   setnx msetnx hsetnx  SET key value [EX seconds|PX milliseconds] [NX|XX] [KEEPTTL] 那么删除锁的正确姿势之一，就是可以使用 lua 脚本，通过 redis 的 eval/evalsha 命令来运行：\n-- lua删除锁： -- KEYS和ARGV分别是以集合方式传入的参数，对应上文的Test和uuid。 -- 如果对应的value等于传入的uuid。 if redis.call(\u0026#39;get\u0026#39;, KEYS[1]) == ARGV[1] then -- 执行删除操作 return redis.call(\u0026#39;del\u0026#39;, KEYS[1]) else -- 不成功，返回0 return 0 end 通过 lua 脚本能保证原子性的原因说的通俗一点：\n就算你在 lua 里写出花，执行也是一个命令 (eval/evalsha) 去执行的，一条命令没执行完，其他客户端是看不到的。\n那么既然这么麻烦，有没有比较好的工具呢？就要说到 redisson 了。\nredLock #  并非是一个工具，而是 redis 官方提出的一种分布式锁的算法。\nredisson #  Redisson 是 java 的 redis 客户端之一，提供了一些 api 方便操作 redis。\nredisson 就实现了 redLock 版本的锁。也就是说除了 getLock 方法，还有 getRedLock 方法。\n"});index.add({'id':257,'href':'/note-cs/docs/course/','title':"第六部分 课程",'section':"Docs",'content':"课程 #  "});index.add({'id':258,'href':'/note-cs/docs/direction/be/platform/dotnet/','title':".NET",'section':"平台",'content':".NET Framework #  "});index.add({'id':259,'href':'/note-cs/docs/direction/be/platform/dotnet/core/','title':".NET Core",'section':".NET",'content':".NET Core #  "});index.add({'id':260,'href':'/note-cs/docs/direction/be/platform/dotnet/asp/','title':"ASP.NET",'section':".NET",'content':"ASP.NET #  Razor #  Razor is an ASP.NET programming syntax used to create dynamic web pages with the C# or VB.NET programming languages.\nMVC #  Blazor #  Blazor is a feature of ASP.NET for building interactive web UIs using C# instead of JavaScript. It\u0026rsquo;s real .NET running in the browser on WebAssembly.\n客户端 #  "});index.add({'id':261,'href':'/note-cs/docs/basic/pl/cpp/','title':"C++",'section':"1.5 编程语言",'content':"C++ 学习笔记 #  见：C++ 学习笔记\n"});index.add({'id':262,'href':'/note-cs/docs/direction/be/platform/nodejs/','title':"Node.js",'section':"平台",'content':"Node.js #  "});index.add({'id':263,'href':'/note-cs/docs/activity/','title':"第七部分 学习活动",'section':"Docs",'content':"学习活动 #  "});index.add({'id':264,'href':'/note-cs/docs/direction/be/db/redis/basic/cmd/','title':"命令",'section':"第一部分 基础入门",'content':"Redis 命令 #  key #   DEL DUMP EXISTS EXPIRE EXPIREAT KEYS MOVE PERSIST PEXPIREAT PEXPIREAT PTTL RANDOMKEY RENAME RENAMENX TTL TYPE   string #   APPEND DECR DECRBY DEL EXISTS GET GETRANGE GETSET INCR INCRBY INCRBYFLOAT MGET MSET MSETNX PSETEX SET SETBIT SETEX SETNX  SET if Not eXists 只在键 key 不存在的情况下， 将键 key 的值设置为 value 。   STRLEN   list #   DEL DUMP EXISTS EXPIRE EXPIREAT KEYS MOVE PERSIST PEXPIREAT PEXPIREAT PTTL RANDOMKEY RENAME RENAMENX TTL TYPE   hash #   HDEL HEXISTS HGET HGETALL HINCRBY HINCRBYFLOAT HKEYS HLEN HMGET HMSET HSET HSETNX HVALS   set #   SADD SCARD SDIFF SDIFFSTORE SINTER SINTERSTORE SISMEMBER SMEMBERS SMOVE SPOP SRANDMEMBER SREM SSCAN SUNION SUNIONSTORE   zset #   ZADD ZCARD ZCOUNT ZINCRBY ZINTERSTORE ZLEXCOUNT ZRANGE ZRANGEBYLEX ZRANGEBYSCORE ZRANK ZREM ZREMRANGEBYLEX ZREMRANGEBYRANK ZREMRANGEBYSCORE ZREVRANGE ZREVRANGEBYSCORE ZREVRANK ZSCAN ZSCORE ZUNIONSTORE   连接 #   AUTH ECHO PING QUIT SELECT   服务器 #   BGREWRITEAOF BGSAVE CLIENT GETNAME CLIENT KILL CLIENT LIST CLIENT PAUSE CLIENT SETNAME CLUSTER SLOTS COMMAND COMMAND COUNT COMMAND GETKEYS COMMAND INFO CONFIG GET CONFIG RESETSTAT CONFIG REWRITE CONFIG SET DBSIZE DEBUG OBJECT DEBUG SEGFAULT FLUSHALL FLUSHDB INFO LASTSAVE MONITOR ROLE SAVE SHOWLOG SHUTDOWN SLAVEOF SYNC TIME   脚本 #   EVAL EVALSHA SCRIPT EXISTS SCRIPT FLUSH SCRIPT KILL SCRIPT LOAD   事务 #   DISCARD EXEC MULTI UNWATCH WATCH   HyperLogLog #   PFADD PFCOUNT PGMERGE   发布订阅 #   PSUBSCRIBE PUBLISH PUBSUB PUNSUBSCRIBE SUBSCRIBE UNSUBSCRIBE   地理位置 (geo) #   GEOADD GEODIST GEOHASH GEOPOS GEORADIUS GEORADIUSBYMEMBER   参考 #   www.redis.net.cn/order 神奇的 HyperLogLog 算法  "});index.add({'id':265,'href':'/note-cs/docs/direction/be/db/redis/source/type/','title':"类型实现",'section':"第三部分 源码实现",'content':"Redis 类型实现 #  参考 #   5 种基本数据结构  "});index.add({'id':266,'href':'/note-cs/docs/basic/os/type/ios/','title':"iOS",'section':"操作系统类型",'content':"iOS #  "});index.add({'id':267,'href':'/note-cs/docs/skill/type/pdf/','title':"pdf",'section':"文档类型",'content':"pdf #  "});index.add({'id':268,'href':'/note-cs/docs/basic/computer-composition/','title':"1.1 计算机组成原理",'section':"第一部分 基础",'content':"计算机组成原理 #  "});index.add({'id':269,'href':'/note-cs/docs/basic/pl/csharp/basic/grammar/','title':"1.1 语法",'section':"第一部分 基础入门",'content':"语法 #  "});index.add({'id':270,'href':'/note-cs/docs/basic/pl/erlang/basic/grammar/','title':"1.1 语法",'section':"第一部分 基础入门",'content':"语法 #  "});index.add({'id':271,'href':'/note-cs/docs/basic/pl/haskell/basic/grammar/','title':"1.1 语法",'section':"第一部分 基础入门",'content':"语法 #  "});index.add({'id':272,'href':'/note-cs/docs/basic/pl/kotlin/basic/grammar/','title':"1.1 语法",'section':"第一部分 基础入门",'content':"语法 #  "});index.add({'id':273,'href':'/note-cs/docs/basic/pl/lua/basic/grammar/','title':"1.1 语法",'section':"第一部分 基础入门",'content':"语法 #  "});index.add({'id':274,'href':'/note-cs/docs/basic/pl/objective-c/basic/grammar/','title':"1.1 语法",'section':"第一部分 基础入门",'content':"语法 #  "});index.add({'id':275,'href':'/note-cs/docs/basic/pl/r/basic/grammar/','title':"1.1 语法",'section':"第一部分 基础入门",'content':"语法 #  "});index.add({'id':276,'href':'/note-cs/docs/basic/pl/ruby/basic/grammar/','title':"1.1 语法",'section':"第一部分 基础入门",'content':"语法 #  "});index.add({'id':277,'href':'/note-cs/docs/basic/pl/scala/basic/grammar/','title':"1.1 语法",'section':"第一部分 基础入门",'content':"语法 #  "});index.add({'id':278,'href':'/note-cs/docs/basic/pl/swift/basic/grammar/','title':"1.1 语法",'section':"第一部分 基础入门",'content':"语法 #  "});index.add({'id':279,'href':'/note-cs/docs/basic/pl/csharp/basic/grammar/type/','title':"1.1.1 数据类型",'section':"1.1 语法",'content':"数据类型 #  "});index.add({'id':280,'href':'/note-cs/docs/basic/pl/erlang/basic/grammar/type/','title':"1.1.1 数据类型",'section':"1.1 语法",'content':"数据类型 #  "});index.add({'id':281,'href':'/note-cs/docs/basic/pl/haskell/basic/grammar/type/','title':"1.1.1 数据类型",'section':"1.1 语法",'content':"数据类型 #  "});index.add({'id':282,'href':'/note-cs/docs/basic/pl/kotlin/basic/grammar/type/','title':"1.1.1 数据类型",'section':"1.1 语法",'content':"数据类型 #  "});index.add({'id':283,'href':'/note-cs/docs/basic/pl/lua/basic/grammar/type/','title':"1.1.1 数据类型",'section':"1.1 语法",'content':"数据类型 #  "});index.add({'id':284,'href':'/note-cs/docs/basic/pl/objective-c/basic/grammar/type/','title':"1.1.1 数据类型",'section':"1.1 语法",'content':"数据类型 #  "});index.add({'id':285,'href':'/note-cs/docs/basic/pl/r/basic/grammar/type/','title':"1.1.1 数据类型",'section':"1.1 语法",'content':"数据类型 #  "});index.add({'id':286,'href':'/note-cs/docs/basic/pl/ruby/basic/grammar/type/','title':"1.1.1 数据类型",'section':"1.1 语法",'content':"数据类型 #  "});index.add({'id':287,'href':'/note-cs/docs/basic/pl/scala/basic/grammar/type/','title':"1.1.1 数据类型",'section':"1.1 语法",'content':"数据类型 #  "});index.add({'id':288,'href':'/note-cs/docs/basic/pl/swift/basic/grammar/type/','title':"1.1.1 数据类型",'section':"1.1 语法",'content':"数据类型 #  "});index.add({'id':289,'href':'/note-cs/docs/basic/pl/shell/command/','title':"1.3.1 Shell 命令",'section':"Shell",'content':"Shell 命令 #  查看服务器信息 #  CPU #  # 物理 cpu 个数 cat /proc/cpuinfo| grep \u0026#39;physical id\u0026#39; | sort | uniq | wc -l # 每个物理 cpu 的核心数 cat /proc/cpuinfo| grep \u0026#39;core id\u0026#39; | sort | uniq | wc -l # 逻辑 cpu 个数（线程数） cat /proc/cpuinfo| grep \u0026#39;processor\u0026#39; | sort | uniq | wc -l # CPU 位数 getconf LONG_BIT # CPU 型号 dmidecode -s processor-version 系统版本 #  # 操作系统版本 cat /etc/issue cat /etc/*release # 系统内核 uname -a cat /proc/version Linux 内核版本 #  参考：\n The Linux Kernel Archives Linux 内核 Linux 内核开发指南  磁盘 #  # 目录空间大小排行 du -m --max-depth=2 | sort -rn | head -10 文件类型 #  文件类型分为 p、d、l、s、c、b 和 -：\n   表示普通文件   p 表示命名管道文件 d 表示目录文件 l 表示符号连接文件 s 表示 socket 文件 c 表示字符设备文件 b 表示块设备文件  带宽 #  ifconfig sudo ethtool 网卡名 | grep Speed  查看运行信息 #  lsof #  # 列出所有 tcp 网络连接信息 lsof -i tcp # 列出所有 udp 网络连接信息 lsof -i udp # 列出谁在使用某个端口 lsof -i :3306 # 列出谁在使用某个特定的 udp 端口 lsof -i udp:55 # 列出特定的 tcp 端口 lsof -i tcp:80 文件删除，但是磁盘没有释放 #  lsof | grep deleted 进程 #  # 查看文件被哪个进程占用 lsof /path/to/file # 怎么查看进程打开的文件 lsof -p pid lsof -c cmd  参考 #  Linux 工具快速教程 #  "});index.add({'id':290,'href':'/note-cs/docs/basic/pl/csharp/advanced/pattern/','title':"2.1 设计模式",'section':"第二部分 进阶实战",'content':"设计模式 #  "});index.add({'id':291,'href':'/note-cs/docs/basic/pl/erlang/advanced/pattern/','title':"2.1 设计模式",'section':"第二部分 进阶实战",'content':"设计模式 #  "});index.add({'id':292,'href':'/note-cs/docs/basic/pl/haskell/advanced/pattern/','title':"2.1 设计模式",'section':"第二部分 进阶实战",'content':"设计模式 #  "});index.add({'id':293,'href':'/note-cs/docs/basic/pl/kotlin/advanced/pattern/','title':"2.1 设计模式",'section':"第二部分 进阶实战",'content':"设计模式 #  "});index.add({'id':294,'href':'/note-cs/docs/basic/pl/lua/advanced/pattern/','title':"2.1 设计模式",'section':"第二部分 进阶实战",'content':"设计模式 #  "});index.add({'id':295,'href':'/note-cs/docs/basic/pl/objective-c/advanced/pattern/','title':"2.1 设计模式",'section':"第二部分 进阶实战",'content':"设计模式 #  "});index.add({'id':296,'href':'/note-cs/docs/basic/pl/r/advanced/pattern/','title':"2.1 设计模式",'section':"第二部分 进阶实战",'content':"设计模式 #  "});index.add({'id':297,'href':'/note-cs/docs/basic/pl/ruby/advanced/pattern/','title':"2.1 设计模式",'section':"第二部分 进阶实战",'content':"设计模式 #  "});index.add({'id':298,'href':'/note-cs/docs/basic/pl/scala/advanced/pattern/','title':"2.1 设计模式",'section':"第二部分 进阶实战",'content':"设计模式 #  "});index.add({'id':299,'href':'/note-cs/docs/basic/pl/swift/advanced/pattern/','title':"2.1 设计模式",'section':"第二部分 进阶实战",'content':"设计模式 #  "});index.add({'id':300,'href':'/note-cs/docs/direction/se/','title':"2.1 软件工程",'section':"第二部分 方向",'content':"软件工程 #  教程 #  系统设计入门 #  学习如何设计可扩展的系统将会有助于你成为一个更好的工程师。\n系统设计是一个很宽泛的话题。在互联网上，关于系统设计原则的资源也是多如牛毛。\n这个仓库就是这些资源的组织收集，它可以帮助你学习如何构建可扩展的系统。\n 参考 #  "});index.add({'id':301,'href':'/note-cs/docs/direction/se/design-pattern/','title':"2.1.1 设计模式",'section':"2.1 软件工程",'content':"设计模式 #  见：设计模式学习笔记\n"});index.add({'id':302,'href':'/note-cs/docs/direction/fe/html/','title':"2.2.1 HTML",'section':"2.3 前端",'content':"HTML #  "});index.add({'id':303,'href':'/note-cs/docs/direction/be/db/','title':"2.2.1 数据库",'section':"2.2 后端",'content':"数据库 #  OLTP vs OLAP #  OLTP (On-line Transaction Processing) is involved in the operation of a particular system.\nOLAP (On-line Analytical Processing) deals with Historical Data or Archival Data.\n参考：\n What are OLTP and OLAP. What is the difference between them?  OLAP #  prestodb/presto #  The official home of the Presto distributed SQL query engine for big data http://prestodb.github.io\nPresto 是 Facebook 开发的分布式大数据 SQL 查询引擎，专门进行快速数据分析。\n特点：\n  可以将多个数据源的数据进行合并，可以跨越整个组织进行分析。\n  直接从 HDFS 读取数据，在使用前不需要大量的 ETL 操作。\n  apache/druid #  Apache Druid: a high performance real-time analytics database. https://druid.apache.org/\nDruid 是广告分析公司 Metamarkets 开发的一个用于大数据实时查询和分析的分布式实时处理系统，主要用于广告分析，互联网广告系统监控、度量和网络监控。\napache/impala #  Apache Impala https://impala.apache.org\ncloudera/Impala #  Real-time Query for Hadoop; mirror of Apache Impala http://impala.io\n apache/kylin #  Apache Kylin is an open source Distributed Analytics Engine, contributed by eBay Inc., provides SQL interface and multi-dimensional analysis (OLAP) on Hadoop supporting extremely large datasets. http://kylin.apache.org.\nApache Kylin 最初由 eBay 开发并贡献至开源社区的分布式分析引擎，提供 Hadoop 之上的 SQL 查询接口及多维分析（OLAP）能力以支持超大规模数据。\napache/hive #  Apache Hive https://hive.apache.org/\nThe Apache Hive (TM) data warehouse software facilitates reading, writing, and managing large datasets residing in distributed storage using SQL. Built on top of Apache Hadoop (TM).\n"});index.add({'id':304,'href':'/note-cs/docs/direction/be/db/mysql/','title':"2.2.1.1 Mysql",'section':"2.2.1 数据库",'content':"Mysql #  mysql/mysql-server 查看版本 #  # client $ mysql --version $ mysql -V # server $ mysqld --version $ mysqld -V select version(); select @@version; show variables like \u0026#34;%version%\u0026#34;; "});index.add({'id':305,'href':'/note-cs/docs/direction/be/mq/kafka/','title':"2.2.2.1 Kafka",'section':"2.2.2 消息队列",'content':"Kafka #  apache/kafka Kafka 是 linkedin 开源的 MQ 系统，主要特点是基于 Pull 的模式来处理消息消费，追求高吞吐量，一开始的目的就是用于日志收集和传输，0.8 开始支持复制，不支持事务，适合产生大量数据的互联网服务的数据收集业务。\n序列化 #  StringSerializer 序列化，写入时使用 dest.kafka.1\u0026amp;key.serializer=org.apache.kafka.common.serialization.StringSerializer dest.kafka.1\u0026amp;value.serializer=org.apache.kafka.common.serialization.StringSerializer\nStringDeserializer 反序列化，读出时使用 source.kafka.2\u0026amp;key.deserializer=org.apache.kafka.common.serialization.StringDeserializer source.kafka.2\u0026amp;value.deserializer=org.apache.kafka.common.serialization.StringDeserializer\n"});index.add({'id':306,'href':'/note-cs/docs/direction/fe/frame/vue/','title':"2.2.3.1 Vue",'section':"2.2.3 框架",'content':"Vue #  "});index.add({'id':307,'href':'/note-cs/docs/direction/be/distributed/raft/','title':"2.2.4.1 Raft",'section':"2.2.4 分布式系统",'content':"Raft #  https://raft.github.io\n由于 Paxos 难以理解，所以才有了 Raft\nRaft 以可理解性和易于实现为目标：\n Leader 选举（Leader election） 日志同步（Log replication） 安全性（Safety） 日志压缩（Log compaction） 成员变更（Membership change）   教程 #  maemual/raft-zh_cn #   关注 #  baidu/braft #  tikv/raft-rs #  Raft distributed consensus algorithm implemented in Rust.\nhashicorp/raft #  Golang implementation of the Raft consensus protocol\netcd-io/etcd #  Distributed reliable key-value store for the most critical data of a distributed system\n"});index.add({'id':308,'href':'/note-cs/docs/direction/be/microservices/rpc/','title':"2.2.5.1 RPC",'section':"2.2.5 微服务",'content':"RPC #  "});index.add({'id':309,'href':'/note-cs/docs/direction/be/microservices/rpc/protobuf/','title':"2.2.5.1.1 protobuf",'section':"2.2.5.1 RPC",'content':"protobuf #  "});index.add({'id':310,'href':'/note-cs/docs/direction/client/android/','title':"2.4.1 Android",'section':"2.4 客户端",'content':"Android #  "});index.add({'id':311,'href':'/note-cs/docs/domain/cc/','title':"3.1 云计算",'section':"第三部分 领域",'content':"云计算 #  "});index.add({'id':312,'href':'/note-cs/docs/basic/pl/csharp/code/type/','title':"3.1 数据类型",'section':"第三部分 设计与实现",'content':"数据类型 #  "});index.add({'id':313,'href':'/note-cs/docs/basic/pl/erlang/code/type/','title':"3.1 数据类型",'section':"第三部分 设计与实现",'content':"数据类型 #  "});index.add({'id':314,'href':'/note-cs/docs/basic/pl/haskell/code/type/','title':"3.1 数据类型",'section':"第三部分 设计与实现",'content':"数据类型 #  "});index.add({'id':315,'href':'/note-cs/docs/basic/pl/kotlin/code/type/','title':"3.1 数据类型",'section':"第三部分 设计与实现",'content':"数据类型 #  "});index.add({'id':316,'href':'/note-cs/docs/basic/pl/lua/code/type/','title':"3.1 数据类型",'section':"第三部分 设计与实现",'content':"数据类型 #  "});index.add({'id':317,'href':'/note-cs/docs/basic/pl/objective-c/code/type/','title':"3.1 数据类型",'section':"第三部分 设计与实现",'content':"数据类型 #  "});index.add({'id':318,'href':'/note-cs/docs/basic/pl/r/code/type/','title':"3.1 数据类型",'section':"第三部分 设计与实现",'content':"数据类型 #  "});index.add({'id':319,'href':'/note-cs/docs/basic/pl/ruby/code/type/','title':"3.1 数据类型",'section':"第三部分 设计与实现",'content':"数据类型 #  "});index.add({'id':320,'href':'/note-cs/docs/basic/pl/scala/code/type/','title':"3.1 数据类型",'section':"第三部分 设计与实现",'content':"数据类型 #  "});index.add({'id':321,'href':'/note-cs/docs/basic/pl/swift/code/type/','title':"3.1 数据类型",'section':"第三部分 设计与实现",'content':"数据类型 #  "});index.add({'id':322,'href':'/note-cs/docs/skill/tool/','title':"4.1 工具",'section':"第四部分 技能树",'content':"工具 #  格式转换 #  富文本 -\u0026gt; markdown #   euangoddard/clipboard2markdown  http://euangoddard.github.io/clipboard2markdown/    pandoc #  https://pandoc.org/\n"});index.add({'id':323,'href':'/note-cs/docs/basic/os/type/android/appendix/tutorial/','title':"4.1 教程",'section':"第四部分 附录",'content':"教程 #  基础 #  进阶 #  "});index.add({'id':324,'href':'/note-cs/docs/basic/os/type/ios/appendix/tutorial/','title':"4.1 教程",'section':"第四部分 附录",'content':"教程 #  基础 #  进阶 #  "});index.add({'id':325,'href':'/note-cs/docs/basic/os/type/macos/appendix/tutorial/','title':"4.1 教程",'section':"第四部分 附录",'content':"教程 #  基础 #  进阶 #  "});index.add({'id':326,'href':'/note-cs/docs/basic/os/type/unix/appendix/tutorial/','title':"4.1 教程",'section':"第四部分 附录",'content':"教程 #  基础 #  进阶 #  "});index.add({'id':327,'href':'/note-cs/docs/basic/os/type/windows/appendix/tutorial/','title':"4.1 教程",'section':"第四部分 附录",'content':"教程 #  基础 #  进阶 #  "});index.add({'id':328,'href':'/note-cs/docs/basic/pl/csharp/appendix/tutorial/','title':"4.1 教程",'section':"第四部分 附录",'content':"教程 #  基础 #   进阶 #  "});index.add({'id':329,'href':'/note-cs/docs/basic/pl/erlang/appendix/tutorial/','title':"4.1 教程",'section':"第四部分 附录",'content':"教程 #  基础 #   进阶 #  "});index.add({'id':330,'href':'/note-cs/docs/basic/pl/haskell/appendix/tutorial/','title':"4.1 教程",'section':"第四部分 附录",'content':"教程 #  基础 #   进阶 #  "});index.add({'id':331,'href':'/note-cs/docs/basic/pl/kotlin/appendix/tutorial/','title':"4.1 教程",'section':"第四部分 附录",'content':"教程 #  基础 #   进阶 #  "});index.add({'id':332,'href':'/note-cs/docs/basic/pl/lua/appendix/tutorial/','title':"4.1 教程",'section':"第四部分 附录",'content':"教程 #  基础 #   X 分钟速成 Lua Lua 面向对象实现: dingshukai/lua-oop    进阶 #  "});index.add({'id':333,'href':'/note-cs/docs/basic/pl/objective-c/appendix/tutorial/','title':"4.1 教程",'section':"第四部分 附录",'content':"教程 #  基础 #   进阶 #  "});index.add({'id':334,'href':'/note-cs/docs/basic/pl/r/appendix/tutorial/','title':"4.1 教程",'section':"第四部分 附录",'content':"教程 #  基础 #   进阶 #  "});index.add({'id':335,'href':'/note-cs/docs/basic/pl/ruby/appendix/tutorial/','title':"4.1 教程",'section':"第四部分 附录",'content':"教程 #  基础 #   如何快速学习 Ruby on Rails？   进阶 #  "});index.add({'id':336,'href':'/note-cs/docs/basic/pl/scala/appendix/tutorial/','title':"4.1 教程",'section':"第四部分 附录",'content':"教程 #  基础 #   进阶 #  "});index.add({'id':337,'href':'/note-cs/docs/basic/pl/swift/appendix/tutorial/','title':"4.1 教程",'section':"第四部分 附录",'content':"教程 #  基础 #   进阶 #  "});index.add({'id':338,'href':'/note-cs/docs/direction/be/db/mysql/appendix/tutorial/','title':"4.1 教程",'section':"第四部分 附录",'content':"教程 #  基础 #  进阶 #  "});index.add({'id':339,'href':'/note-cs/docs/direction/be/db/postgresql/appendix/tutorial/','title':"4.1 教程",'section':"第四部分 附录",'content':"教程 #  基础 #  进阶 #  "});index.add({'id':340,'href':'/note-cs/docs/direction/be/db/redis/appendix/tutorial/','title':"4.1 教程",'section':"第四部分 附录",'content':"教程 #  基础 #  karlseguin/the-little-redis-book #  中文版\nilivebox/the-little-redis-book JasonLai256/the-little-redis-book 进阶 #  "});index.add({'id':341,'href':'/note-cs/docs/direction/be/platform/nodejs/appendix/tutorial/','title':"4.1 教程",'section':"第四部分 附录",'content':"教程 #  基础 #  进阶 #  "});index.add({'id':342,'href':'/note-cs/docs/direction/client/android/appendix/tutorial/','title':"4.1 教程",'section':"第四部分 附录",'content':"教程 #  基础 #  进阶 #  "});index.add({'id':343,'href':'/note-cs/docs/direction/client/ios/appendix/tutorial/','title':"4.1 教程",'section':"第四部分 附录",'content':"教程 #  基础 #  进阶 #  "});index.add({'id':344,'href':'/note-cs/docs/direction/client/xiaochengxu/appendix/tutorial/','title':"4.1 教程",'section':"第四部分 附录",'content':"教程 #  基础 #  进阶 #  "});index.add({'id':345,'href':'/note-cs/docs/direction/embedded/appendix/tutorial/','title':"4.1 教程",'section':"第四部分 附录",'content':"教程 #  基础 #  进阶 #  "});index.add({'id':346,'href':'/note-cs/docs/direction/fe/frame/angular/appendix/tutorial/','title':"4.1 教程",'section':"第四部分 附录",'content':"教程 #  基础 #  进阶 #  "});index.add({'id':347,'href':'/note-cs/docs/direction/fe/frame/react/appendix/tutorial/','title':"4.1 教程",'section':"第四部分 附录",'content':"教程 #  基础 #  进阶 #  "});index.add({'id':348,'href':'/note-cs/docs/direction/fe/frame/vue/appendix/tutorial/','title':"4.1 教程",'section':"第四部分 附录",'content':"教程 #  基础 #  进阶 #  "});index.add({'id':349,'href':'/note-cs/docs/direction/security/appendix/tutorial/','title':"4.1 教程",'section':"第四部分 附录",'content':"教程 #  基础 #  进阶 #  "});index.add({'id':350,'href':'/note-cs/docs/direction/se/arch/scene/circuit-breaker/attention/','title':"4.3 关注项目",'section':"熔断",'content':"关注 #  其他 #  resilience4j/resilience4j #  ehcache/ehcache3 #  ehcache 是 ​​ 一个用 Java 实现的使用简单，高速，实现线程安全的缓存管理类库， ehcache 提供了用内存，磁盘文件存储，以及分布式存储方式等多种灵活的 cache 管理方案。 http://www.ehcache.org\nNetflix/Hystrix #  Hystrix 是 Netflix OSS 的一部分，是微服务领域的领先的熔断工具。Hystrix 可以被视为白盒监控工具，而 Istio 可以被视为黑盒监控工具，\nIstio 是无缝衔接服务，istio 可以在不更改应用程序代码的情况下配置和使用。Hystrix 的使用需要更改每个服务来引入 Hystrix libraries。\n"});index.add({'id':351,'href':'/note-cs/docs/book/basic/','title':"5.1 计算机基础",'section':"第五部分 读书",'content':"计算机基础 #  计算机组成原理 #  操作系统 #  数据结构与算法 #  计算机网络 #  编程语言 #  数据库 #  编译原理 #  "});index.add({'id':352,'href':'/note-cs/docs/book/basic/cc/','title':"5.1.1 计算机组成原理",'section':"5.1 计算机基础",'content':"计算机组成原理 #  Computer Composition\n"});index.add({'id':353,'href':'/note-cs/docs/domain/cc/edge/5g-edge/','title':"5G 边缘计算",'section':"边缘计算",'content':"5G 边缘计算 #  5G 的 G 是英文 Generation 的缩写，也就是 “世代” 的意思\n简单说，5G 就是第五代移动通信系统\n5G 与边缘计算有什么关系？ #  5G 通信网络更加去中心化，需要在网络边缘部署小规模或者便携式数据中心，进行终端请求的本地化处理，以满足 URLLC 和 mMTC 的超低延时需求，因此边缘计算是 5G 核心技术之一。\n5G 的三大典型应用场景对网络性能的要求有显著差异，但为控制成本，运营商必然选择一张承载网 + 网络切片 / 边缘计算技术，实现在最少的资本投入下最丰富的网络功能。\n在 5G 时代，承载网的带宽瓶颈、时延抖动等性能瓶颈难以突破，引入边缘计算后将大量业务在网络边缘终结。\n5G 与边缘计算的关系 #  5G 为边缘计算产业的落地和发展提供了良好的网络基础， 主要体现在三大场景（eMBB，uRLLC 和 mMTC）的支持、核心网用户面功能的灵活部署以及 5G 网络能力开放等方面。\n“5G + MEC + AI”是 5G 在网络边缘更好使能各行各业的关键； 是运营商助力垂直行业数字化和智能化的新模式； 是运营商进入垂直行业的触点和重点场景； 也是 5G 应用是否成功的一个重要标志。\n5G 支持将网络能力开放给边缘应用。 无线网络信息服务、位置服务、QoS服务等网络能力，可以封装成边缘计算 PaaS 平台的 API，开放给应用。 5G 与边缘计算结合，是运营商使能边缘计算的新核心竞争力和最大独特优势。 同时，边缘计算也成为 5G 服务垂直行业，充分发挥 5G 新网络特性的重要利器之一。\n5G MEC 将云计算和 5G 核心网带到网络边缘，带来了新的流量模型和部署模型。 如果运营商还继续采用 4G 移动承载网的设计思路，在 5G 时代，运营商网络将面临边缘计算的困局。\nQoS（Quality of Service，服务质量）指一个网络能够利用各种基础技术，为指定的网络通信提供更好的服务能力，是网络的一种安全机制， 是用来解决网络延迟和阻塞等问题的一种技术。\n核心网 UPF 下移到企业园区 #  关键业务数据不出园区，更易提供低延迟承载方案； 运营商可以为每个用户配置单独的 UPF，给企业用户定制 5G 服务。\n开放 5G 通信服务的能力 #  运营商以 API 模式开放的 5G 通信服务可编程能力（如定位，无线通信能力，带宽管理等）， 可以集成到企业生产业务系统中，企业可以定制自己的 5G 创新应用。\n和企业网直接互联互通 #  下沉的 5G MEC 系统和企业网直接互联互通，使分布在企业和运营商两个网络系统上的业务系统可以实时地集成拉通， 加上 5G 新的面向行业应用的通信功能（低延迟 uRLLC、物联网 mMTC、无线超级上行和业务连续性等）， 各行业可以做出很多创新应用。\neMBB #  Enhanced Mobile Broadband\neMBB（特别是超级上行技术）增强移动带宽\n对于带宽要求较高的 AR/VR、直播\nCloud VR #  uRLLC #  ultra-Reliable and Low Latency Communications 超高可靠性低时延业务\n对于时延要求极高的工业控制\nTSN #  TSN（时间敏感网络）\nTSN 的主要目标是通过 IEEE 802（以太网）有线网络提供确定性服务。这意味着低时延、小抖动、低丢包率、有保证的数据包传输。\n5G 和 TSN 进行融合，5G 作为 TSN 网络的 bridge\n实现 TSN 网络 controller 和 5G AF 的协同\n低时延只是一方面吧，更重要的是时延确定； 工业通信（大部分是有线通信）会有这样的要求，5G 是想把工业通信的场景也 cover 进来\n奇速播 #  奇速播是专门应用于酒店、商场等场所，改善公共 WiFi 用户视频体验的新概念服务，为酒店、商场公共网络环境中的用户带来极致的超高清视频体验\n带宽 max 300MB；时延\u0026lt;20ms\nmMTC #  massive Machine Type Communications 大物联业务\n海量机器类通信，可以分别支持不同需求的边缘计算场景\n对于海量连接需求高的 IoT 设备接入\n 5G MEC 网络规划建议和网络架构参考模型 #  5G MEC 网络规划建议，供运营商网络设计时参考。\n 建议采用 ECA、ECN 和 ECI 模型分段设计网络，ECA 和 ECI 可以部署在不同的物理网络上（如两个运营商共享共建 5G 承载网）。 MEC 业务和网络隔离：MEC 内部的业务变化（如部署新的 UPF）和网络连接变化（如增加服务器），尽量少或不影响外部网络，即 MEC 系统和外部网络隔离。 网络方案规划要和运营商内部网络运维团队的界面分工相匹配，减少不同运维团队间的工作交叉，例如，如果 ECN 和 IP RAN 的运维是两个数通团队，网络功能设计就要尽量保持两个团队的专业运维界面清晰。 网络设计要满足 5G MEC 按需建设的增量模式，即增量部署 5G MEC 系统，要尽量减少对网络的影响。 建议 ECI 按逻辑网络来构建，统一控制管理，在跨越多个网络时也能保证快速建立网络连接和保证 SLA，支持 5G MEC 业务的迅速部署。   参考 #   终于有人把 5G 和边缘计算的关系说清楚了 5G 边缘计算跟我们有什么关系？  "});index.add({'id':354,'href':'/note-cs/docs/course/basic/','title':"6.1 计算机基础",'section':"第六部分 课程",'content':"计算机基础 #  计算机组成原理 #  操作系统 #  数据结构与算法 #  计算机网络 #  编程语言 #  数据库 #  编译原理 #  "});index.add({'id':355,'href':'/note-cs/docs/course/basic/cc/','title':"6.1.1 计算机组成原理",'section':"6.1 计算机基础",'content':"计算机组成原理 #  Computer Composition\n"});index.add({'id':356,'href':'/note-cs/docs/basic/os/type/android/','title':"Android",'section':"操作系统类型",'content':"Android #  "});index.add({'id':357,'href':'/note-cs/docs/direction/be/web/api-doc/','title':"API 文档",'section':"Web Service",'content':"API 文档 #  swagger-api/swagger-core #  swagger-api/swagger-ui #   apidoc/apidoc #  "});index.add({'id':358,'href':'/note-cs/docs/basic/pl/csharp/','title':"C#",'section':"1.5 编程语言",'content':"C# 学习笔记 #  "});index.add({'id':359,'href':'/note-cs/docs/course/basic/pl/cpp/','title':"C++",'section':"6.1.5 编程语言",'content':"C++ #  "});index.add({'id':360,'href':'/note-cs/docs/course/basic/pl/cpp/cpp-faq/','title':"C++ FAQ",'section':"C++",'content':"C++ FAQ #  学习进度 #   Copying permissions On-line sites that distribute this document C++-FAQ-Book versus (on-line) C++-FAQ Recent changes to this document Netiquette when posting to comp.lang.c++ Big Picture Issues Classes and objects References Inline functions Constructors Destructors Assignment operators Operator overloading Friends Input/output via \u0026lt;iostream\u0026gt; and \u0026lt;cstdio\u0026gt; Freestore management Exceptions and error handling Const correctness Inheritance \u0026mdash; basics Inheritance \u0026mdash; virtual functions Inheritance \u0026mdash; proper inheritance and substitutability Inheritance \u0026mdash; abstract base classes (ABCs) Inheritance \u0026mdash; what your mother never told you Inheritance \u0026mdash; private and protected inheritance Inheritance \u0026mdash; multiple and virtual inheritance Built-in / intrinsic / primitive data types Coding standards Learning OO/C++ Newbie Questions / Answers Learning C++ if you already know Smalltalk Reference and value semantics How to mix C and C++ Pointers to member functions Container classes Templates Serialization and Unserialization Class libraries Compiler dependencies Miscellaneous technical issues Miscellaneous environmental issues  "});index.add({'id':361,'href':'/note-cs/docs/direction/se/arch/principle/cap/','title':"CAP",'section':"原则",'content':"CAP #  P 是前提 #  在理论计算机科学中，CAP 定理（CAP theorem），又被称作布鲁尔定理（Brewer\u0026rsquo;s theorem），它指出对于一个 distributed data store 来说，不可能同时满足以下三点：\n 一致性（Consistency）  每次读取要么获得最近写入的数据，要么获得一个错误。   可用性（Availability）  每次请求都能获得一个非错误响应，但不保证返回的是最新写入的数据。   分区容错性（Partition tolerance）  以实际效果而言，分区相当于对通信的时限要求。系统如果不能在时限内达成数据一致性，就意味着发生了分区的情况，必须就当前操作在 C 和 A 之间做出选择。 尽管任意数量的消息被节点间的网络丢失（或延迟），系统仍继续运行。 分区指网络分区，通信的两台服务器之间网络断开，就发生了网络分区    一般选 AP #  也就是说，在存在网络分区的情况下，一致性和可用性必须二选一。\n比如：A 服务器 B 服务器同步数据，现在 A B 之间网络断掉了，那么现在发来 A 一个写入请求，但是 B 却没有相关的请求，显然，\n 如果 A 不写，保持一致性，那么我们就失去了 A 的服务， 但是如果 A 写了，跟 B 的数据就不一致了，我们自然就丧失了一致性。  这里的一致性（Consistency）是强一致性，意思是 AB 的数据时刻都是同步的， 如果我们放弃了强一致性，不代表我们的数据就是一定是不一致的了，我们可以让 A 先写入本地，等到通信恢复了再同步给 B，这就是所谓的最终一致性，长远的看我们的数据还是一致的，我们只是在某一个时间窗口里数据不一致罢了。 如果这个时间窗口小过了用户逻辑处理的时间。那么其实对于用户来说根本感觉不到。\n现实中的 CAP #  CAP 对实际工作缺乏指导性。\n实际系统主要有三种：\n 强调 availability 的 eventual consistency 系统，  比如 Amazon Dynamo 及他们的复制品；   强调一致性的系统，  典型的是基于 Paxos 的系统；   强调性能不顾其他的系统，  典型的是 Async replication 的主从备份系统。    参考 #   CAP 理论常被解释为一种 “三选二” 定律，这是否是一种误解？ 分布式事务中的最终一致具体应该如何实现？ 分布式系统中的数据一致性和性能怎么权衡？  "});index.add({'id':362,'href':'/note-cs/docs/direction/be/auth/sso/cas/','title':"CAS",'section':"SSO",'content':"CAS #  简介 #  集中式认证服务（英语：Central Authentication Service，缩写 CAS）是一种针对万维网的单点登录协议。它的目的是允许一个用户访问多个应用程序，而只需提供一次凭证（如用户名和密码）。它还允许 web 应用程序在没有获得用户的安全凭据（如密码）的情况下对用户进行身份验证。\u0026ldquo;CAS\u0026rdquo; 也指实现了该协议的软件包。\nCAS 是由耶鲁大学 的 Shawn Bayern 创始的，后来由耶鲁大学的 Drew Mazurek 维护。CAS1.0 实现了单点登录。 CAS2.0 引入了多级代理认证（Multi-tier proxy authentication）。CAS 其他几个版本已经有了新的功能。\n2004 年 12 月，CAS 成为 Jasig（英语：Jasig）的一个项目，2008 年该组织负责 CAS 的维护和发展。CAS 原名 \u0026ldquo;耶鲁大学 CAS\u0026rdquo;，现在则被称为 \u0026ldquo;Jasig CAS\u0026rdquo;。\n原理 #  Cas Server #    mermaid.initialize({ flowchart: { useMaxWidth:true } });  sequenceDiagram participant c as Client (The browser) participant ws as Web Server participant cs as CAS Server c-ws: 访问网站地址 Note over ws: 尝试从 cookie 获取 pToken 和 sToken alt pToken 和 sToken 同时存在 ws--cs: /validate 验证合法性 alt 正常登录 cs--ws: 返回用户信息 ws-c: 返回用户请求内容 else 不正常 cs--ws: 返回状态码 204 ws-c: 返回重定向到 CAS 登录接口 Note over c, cs: 后面流程参考底下 Loop 循环 end else 不同时存在 ws-c: 返回重定向到 CAS 登录接口 loop 访问 CAS 登录页面 c-cs: 登录 alt 登录成功 cs-c: 返回带 ticket 的重定向，并在浏览器写入 pToken 的 cookie c-ws: 带有 ticket 的请求 ws--cs: 使用 ticket 置换 sToken alt 合法 ticket cs--ws: 返回 sToken ws-c: 返回用户请求内容，并在浏览器写入 sToken 的 cookie else 非法 ticket ws-c: 返回重定向到 CAS 登录接口 end else 登录失败 cs-c: 返回错误提示页面 end end end Session Server + Cas Server #  sequenceDiagram participant c as Client (The browser) participant ws as Web Server participant cs as CAS Server participant ss as Session Server c-ws: 访问网站地址 Note over ws: 尝试从 cookie 获取 pToken 和 sToken alt pToken 和 sToken 同时存在 ws--ss: /validate 验证合法性 alt 正常登录 ss--ws: 返回用户信息 ws-c: 返回用户请求内容 else 不正常 ss--ws: 返回状态码 204 ws-c: 返回重定向到 CAS 登录接口 Note over c, ss: 后面流程参考底下 Loop 循环 end else 不同时存在 ws-c: 返回重定向到 CAS 登录接口 loop 访问 CAS 登录页面 c-cs: 登录 alt 登录成功 cs-c: 返回带 ticket 的重定向，并在浏览器写入 pToken 的 cookie c-ws: 带有 ticket 的请求 ws--cs: 使用 ticket 置换 sToken alt 合法 ticket cs--ws: 返回 sToken ws-c: 返回用户请求内容，并在浏览器写入 sToken 的 cookie else 非法 ticket ws-c: 返回重定向到 CAS 登录接口 end else 登录失败 ss-c: 返回错误提示页面 end end end 百度 UUAP #    用户访问接入 uuap 的下游系统 xx.baidu.com，例如 family.baidu.com。\n  下游系统后端 server 从 cookie 中获取 pToken 及 sToken，校验是否同时存在，不同时存在直接重定向用户到 uuap 登录接口认证。\n pToken：存在于 baidu.com（baidu-int.com）域名下，cookie 的名字为 UUAP_P_TOKEN，线下环境统一为 UUAP_P_TOKEN_OFFLINE sToken：存在于下游系统的域名下面、该值为 uuap 认证成功后签发的 ticket 参数、下游系统获取后将其存入您的域名下，有效期 30 天、该值通用名称为 UUAP_S_TOKEN\n   pToken 与 sToken\n 如果 pToken 与 sToken 同时存在，则将 pToken、sToken 及您的 appKey 作为参数，发送 POST 请求到 UUAP-SESSION 的 Session 登录校验校验用户是否正常登录，如果正常登录返回登录用户的基本信息，未正常登录则返回状态码 204，重定向用户到 uuap 登录接口认证 如果 pToken 与 sToken 不是同时存在，下游系统直接重定向用户到 uuap 登录接口认证。    如果 UUAP-SESSION 返回用户登录成功并且返回登录用户的基本信息，下游系统可允许用户访问受保护的内容。\n  如果 UUAP-SESSION 返回状态码 204，则按照 3-2 的步骤，下游系统直接通知前端跳转 UUAP-SSO 认证服务器认证。\n  下游系统携带 service 及 appKey 参数，访问 UUAP-SSO 的 uuap 登录接口接口请求用户认证。\n service：第 1 步中用户访问的下游系统的 url，请对该 url 进行 urlencode appKey：uuap 签发的下游系统唯一 id\n   UUAP-SSO 认证服务器认证通过会在 baidu 的根域名下植入 pToken 的 cookie，并且会在用户传递的 service 回调地址后面追加 ticket 参数通知用户跳转，下游系统 server 可获取该参数，调用 SToken 置换接口获取 SToken，将其以 cookie 的形式存入你们的域名下，该值就是 sToken。\n cookie 植入成功后要在之前访问 url 的基础上去除 ticket 参数让用户重新 302 访问一次，这样就能防止 server 看到访问 url 中存在 ticket 参数关键字陷入反复植入 sToken 的死循环，跳转后用户重新从第 1 步执行。    认证失败，跳转错误页面。\n   参考 #   mermaid  "});index.add({'id':363,'href':'/note-cs/docs/skill/tool/note/codelabs/','title':"Codelabs",'section':"笔记",'content':"Codelabs #  简介 #  Google Developers Codelabs #  中国内地访问 clmirror.storage.googleapis.com\n Hello Istio Codelab(with Google Kubernetes Engine)  googlecodelabs/tools #  Codelabs management \u0026amp; hosting tools\n"});index.add({'id':364,'href':'/note-cs/docs/domain/cc/others/saas/crm/','title':"CRM",'section':"SaaS",'content':"CRM #  "});index.add({'id':365,'href':'/note-cs/docs/basic/pl/shell/type/dash/','title':"Dash",'section':"1.3.4 Shell 类型",'content':"Dash #  Dash 与 Bash 的区别 #   定义函数  bash: function 在 bash 中为关键字\ndash: dash 中没有 function 这个关键字\n2.select var in list; do command; done\nbash: 支持\ndash: 不支持，替代方法：采用 while+read+case 来实现\necho {0..10}  bash: 支持 {n..m} 展开\ndash: 不支持，替代方法，采用 seq 外部命令\nhere string  bash: 支持 here string\ndash: 不支持，替代方法：可采用 here documents\n  \u0026amp;word 重定向标准输出和标准错误\n   bash: 当 word 为非数字时，\u0026gt;\u0026amp;word 变成重定向标准错误和标准输出到文件 word\ndash: \u0026gt;\u0026amp;word, word 不支持非数字，替代方法: \u0026gt;word 2\u0026gt;\u0026amp;1; 常见用法 \u0026gt;/dev/null 2\u0026gt;\u0026amp;1\n数组  bash: 支持数组，bash4 支持关联数组\ndash: 不支持数组，替代方法，采用变量名 + 序号来实现类似的效果\n子字符串扩展  bash: 支持 ${parameter:offset:length},${parameter:offset}\ndash: 不支持， 替代方法：采用 expr 或 cut 外部命令代替\n大小写转换  bash: 支持 ${parameter^pattern},${parameter^^pattern},${parameter,pattern},${parameter,,pattern}\ndash: 不支持，替代方法：采用 tr/sed/awk 等外部命令转换\n进程替换 \u0026lt;(command), \u0026gt;(command)  bash: 支持进程替换\ndash: 不支持，替代方法，通过临时文件中转\n[string1 = string2] 和 [ string1 == string2 ]  bash: 支持两者\ndash: 只支持 =\n[[ 加强版 test  bash: 支持 [[]], 可实现正则匹配等强大功能\ndash: 不支持 [[]], 替代方法，采用外部命令\nfor (( expr1 ; expr2 ; expr3 )) ; do list ; done  bash: 支持 C 语言格式的 for 循环\ndash: 不支持该格式的 for, 替代方法，用 while+$((expression)) 实现\nlet 命令和 ((expression))  bash: 有内置命令 let, 也支持 ((expression)) 方式\ndash: 不支持，替代方法，采用 $((expression)) 或者外部命令做计算\n$((expression))  bash: 支持 id++,id–,++id,–id 这样到表达式\ndash: 不支持 ++,–, 替代方法:id+=1,id-=1, id=id+1,id=id-1\n为什么 Ubuntu 要将 sh 链接到 dash #  因为 Ubuntu 不存在 sh。而系统很多脚本指定用 sh。 /bin/sh is meant for system scripts, which may or may not have come from older versions of Ubuntu and/or other systems.\n参考：https://askubuntu.com/questions/976485/what-is-the-point-of-sh-being-linked-to-dash\n"});index.add({'id':366,'href':'/note-cs/docs/skill/type/epub/','title':"epub",'section':"文档类型",'content':"epub #  "});index.add({'id':367,'href':'/note-cs/docs/skill/stream-media/debug/gdb/tutorial/','title':"GDB 教程",'section':"GDB",'content':"GDB 教程 #  "});index.add({'id':368,'href':'/note-cs/docs/course/basic/pl/go/','title':"go",'section':"6.1.5 编程语言",'content':"go #  "});index.add({'id':369,'href':'/note-cs/docs/course/basic/pl/go/go-wiki/','title':"go wiki",'section':"go",'content':"go wiki #  学习进度 #   Getting started with Go    Working with Go    Learning more about Go  Learning Go - A collection of resources for learning Go - beginner to advanced.  Best Practices for a New Go Developer - Insights from Go community members. Server programming - Building web, mobile, and API servers. More on concurrency More on error handling More on testing More on mobile - Android and iOS   Books - A list of Go books that have been published (ebook, paper) Blogs - Blogs about Go  Podcasts - Podcasts and episodes featuring Go   Videos, Talks and Presentations  GopherVids is a searchable index of videos about Go. GoTalks - A collection of talks from Go conferences and meetups. Screencasts   Articles - A collection of articles to help you learn more about Go. Training - Free and commercial, online and classroom training for Go. University Courses - A list of CS programs and classes using Go. Resources for non-English speakers      The Go Community    Using the go toolchain    Additional Go Programming Wikis  Why Go doesn\u0026rsquo;t Support Generics: A Summary of Go Generics Discussions - Start here before you join the debate. Concurrency  Timeouts - Abandon async calls that take too long LockOSThread MutexOrChannel - When to use one vs the other RaceDetector - How to detect and fix race conditions   Working with Databases  database/sql - Online tutorial for working with the database/sql package. TUGTBDDAwG - Guide to building data driven apps. SQLDrivers SQLInterface   From other languages  Go for Java Programmers Go for C++ Programmers   Strings  GoStrings String Matching   Comments CommonMistakes Errors GcToolchainTricks Hashing HttpFetch HttpStaticFiles InterfaceSlice Iota MethodSets PanicAndRecover Range RateLimiting Rationales SendingMail SignalHandling SimultaneousAssignment SliceTricks Switch TableDrivenTests      Online Services that work with Go    Troubleshooting Go Programs in Production  Understand the performance of your Go apps using the pprof package Heap Dumps  heapdump13 heapdump14 heapdump15        Contributing to the Go Project    Platform Specific Information    Release Specific Information    Questions  "});index.add({'id':370,'href':'/note-cs/docs/skill/tool/note/hugo/','title':"Hugo",'section':"笔记",'content':"Hugo 快速上手 #  简介 #  参考官网：https://gohugo.io\n"});index.add({'id':371,'href':'/note-cs/docs/domain/cc/virtual/hyperkit/','title':"HyperKit",'section':"虚拟化",'content':"HyperKit #  "});index.add({'id':372,'href':'/note-cs/docs/domain/cc/others/iaas/','title':"IaaS",'section':"其他",'content':"IaaS #  "});index.add({'id':373,'href':'/note-cs/docs/skill/tool/note/jupyter/','title':"Jupyter",'section':"笔记",'content':"Jupyter #  pipenv install jupyterlab alias python-jupyter=\u0026#34;/Users/yewang/.local/share/virtualenvs/yewang-jvfc4aCO/bin/python\u0026#34; alias jupyter=\u0026#34;python-jupyter -m jupyter\u0026#34; alias jlab=\u0026#34;jupyter lab\u0026#34; alias jlist=\u0026#34;jupyter kernelspec list\u0026#34; 参考：\n JupyterLab Installation  配置 #  # vi ~/.jupyter/jupyter_notebook_config.py # 绝对路径 c.NotebookApp.notebook_dir = \u0026#39;/Users/yewang/note/kingye/jupyter\u0026#39; Jupyter Notebook vs Jupyter Lab #   Jupyter Lab is a next-generation web-based user interface for Project Jupyter Jupyter Notebook Interface is a Web-based application for authoring documents that combine live-code with narrative text, equations and visualizations.  Jupyter Notebook 原名 IPython Notebook (version 3 or earlier)     Jupyter kernel #  jupyter kernelspec list jupyter kernelspec uninstall 参考：\n How to list all installed Jupyter kernels?  Go #  gopherdata/gophernotes #  go get -u github.com/gopherdata/gophernotes mkdir -p ~/Library/Jupyter/kernels/gophernotes # cp $GOPATH/src/github.com/gopherdata/gophernotes/kernel/* ~/Library/Jupyter/kernels/gophernotes cp /Users/yewang/.gvm/pkgsets/go1.15.10/global/pkg/mod/github.com/gopherdata/gophernotes@v0.7.2/kernel/* ~/Library/Jupyter/kernels/gophernotes  Java #  SpencerPark/IJava #  A Jupyter kernel for executing Java code.\n PHP #  Litipk/Jupyter-PHP #   要安装 zmq  php72 -m | grep   phpto72 php jupyter-php-installer.phar install -vvv  使用 -vvv 查看详细信息    Python #  IPython #   IPython Documentation  Installing the IPython kernel     编辑器 #  nteract/nteract #  The interactive computing suite for you!\n"});index.add({'id':374,'href':'/note-cs/docs/skill/stream-media/debug/lldb/','title':"LLDB",'section':"Debug",'content':"LLDB #  "});index.add({'id':375,'href':'/note-cs/docs/skill/stream-media/debug/lldb/tutorial/','title':"LLDB 教程",'section':"LLDB",'content':"LLDB 教程 #  "});index.add({'id':376,'href':'/note-cs/docs/domain/cc/virtual/multipass/','title':"Multipass",'section':"虚拟化",'content':"Multipass #  canonical/multipass Multipass orchestrates virtual Ubuntu instances https://multipass.run\n# Find available images multipass find # 创建一个 VM, 1GB 内存和 5GB 磁盘 multipass launch --name k3s --mem 1G --disk 5G # 使用本地 image multipass launch --name k3s --mem 1G --disk 5G file://~/ubuntu-20.04-server-cloudimg-amd64.img # 为 VM 启动一个 shell multipass shell k3s # 挂载 multipass mount ~/code myvm:/home/ubuntu/yewang/code # 设置代理 export http_proxy=\u0026#34;http://192.168.64.1:8081\u0026#34;; export HTTP_PROXY=\u0026#34;http://192.168.64.1:8081\u0026#34;; export https_proxy=\u0026#34;http://192.168.64.1:8081\u0026#34;; export HTTPS_PROXY=\u0026#34;http://192.168.64.1:8081\u0026#34; # 在其上安装 k3s curl -sfL https://get.k3s.io | sh – 网络 #  使用的是桥接模式，因为\n 主机可以 ping 通虚拟机  所以不是 NAT   虚拟机之间可以 ping 通  所以不是 NAT   虚拟机可以上网  所以不是 Host-Only    "});index.add({'id':377,'href':'/note-cs/docs/skill/stream-media/lorawan/chirpstack/network/','title':"Network",'section':"ChirpStack",'content':"ChirpStack Network Server #  ChirpStack Network Server is an open-source LoRaWAN network-server. https://www.chirpstack.io\n数据库 #     Schema Name Type Owner     public code_migration table chirpstack_ns   public device table chirpstack_ns   public device_activation table chirpstack_ns   public device_activation_id_seq sequence chirpstack_ns   public device_multicast_group table chirpstack_ns   public device_profile table chirpstack_ns   public device_queue table chirpstack_ns   public device_queue_id_seq sequence chirpstack_ns   public gateway table chirpstack_ns   public gateway_board table chirpstack_ns   public gateway_profile table chirpstack_ns   public gateway_profile_extra_channel table chirpstack_ns   public gateway_profile_extra_channel_id_seq sequence chirpstack_ns   public gateway_stats table chirpstack_ns   public gateway_stats_id_seq sequence chirpstack_ns   public gorp_migrations table chirpstack_ns   public multicast_group table chirpstack_ns   public multicast_queue table chirpstack_ns   public multicast_queue_id_seq sequence chirpstack_ns   public routing_profile table chirpstack_ns   public service_profile table chirpstack_ns    (21 rows)\n"});index.add({'id':378,'href':'/note-cs/docs/direction/be/auth/oauth/','title':"OAuth",'section':"认证与授权",'content':"OAuth #  版本 #  2.0 #  OAuth 2.0 协议参考 rfc6749\n1.0 #  参考：\n OAuth 1.0，1.0a 和 2.0 的之间的区别有哪些？   授权方式 #   授权码（authorization-code） 隐藏式（implicit） 密码式（password）： 客户端凭证（client credentials）  参考：\n 一口气说出 OAuth2.0 的四种授权方式   问答 #  为什么需要 Refresh Token #  这样的处理是为了职责的分离：\n refresh token 负责身份认证 access token 负责请求资源。   参考 #    Choosing an SSO Strategy: SAML vs OAuth2\n  rfc6749\n  为什么 OAuth2 里面在获取 access token 之前一定要先获取 code，然后再用 code 去获取 access token？\n  Oauth 为什么不直接返回用户信息，而是返回 Access Token，然后用 AT 再去请求用户信息？\n  百度 UUAP OAuth\n  "});index.add({'id':379,'href':'/note-cs/docs/direction/be/auth/openid/','title':"OpenID",'section':"认证与授权",'content':"OpenID #  OpenID vs OAuth #   OpenID 只用于身份认证（Authentication），允许你以同一个账户在多个网站登陆。它仅仅是为你的合法身份背书，当你以 Facebook 账号登陆某个站点之后，该站点无权访问你的在 Facebook 上的数据 OAuth 用于授权（Authorisation），允许被授权方访问授权方的用户数据  "});index.add({'id':380,'href':'/note-cs/docs/direction/be/web/rest/','title':"REST",'section':"Web Service",'content':"REST #  Representational state transfer (REST) is a software architectural style that defines a set of constraints to be used for creating Web services.\n"});index.add({'id':381,'href':'/note-cs/docs/skill/stream-media/stream-media/rtmp/','title':"RTMP",'section':"流媒体技术",'content':"RTMP #  Real-Time Messaging Protocol\n默认端口：1935\n握手 #  复杂握手 #   RTMP vs RTSP #  目前直播方案是：rtmp 推到 server，然后转 rtmp/http-flv/hls.\n 直播走的是互联网的路子，浏览器和 Flash 不支持 RTSP。 国内的 CDN 对 RTMP 做过优化，而 RTSP 没有。 网络中的路由器或防火墙可能对 RTSP 端口不开放。  参考：\n 为什么现在的视频直播不使用 RTSP 协议而是使用 RTMP？  "});index.add({'id':382,'href':'/note-cs/docs/skill/stream-media/stream-media/rtp/','title':"RTP",'section':"流媒体技术",'content':"RTP #  报文结构 #   Ver.（2 bits）是目前协议的版本号码，目前版号是 2。 P（1 bit）是用于 RTP 报文（packet）结束点的预留空间，视报文是否需要多余的填塞空间。 X（1 bit）是否在使用延伸空间于报文之中。 CC（4 bits）包含了 CSRC 数目用于修正标头（fixed header）。 M（1 bit）是用于应用等级以及其原型（profile）的定义。如果不为零表示目前的数据有特别的程序解译。 PT（7 bits）是指 payload 的格式并决定将如何去由应用程序加以解译。 SSRC 是同步化来源。  RTP Header #  前 12 个字节出现在每个 RTP 包中，仅仅在被混合器插入时，才出现 CSRC 识别符列表。\n RTP/PS/H.264 #  基于 RTP 的 PS 封装 首先按照 ISO/IEC 13818-1:2000 将视音频封装成 PS 包， 再将 PS 包以负载的方式封装成 RTP 包。\nPS 包 #  进行 PS 封装时，将每个视频帧封装为一个PS 包， 且每个关键帧的 PS 包中包含系统头（System Header）和 PSM（Program Stream Map）。\n系统头和 PSM 放置于 PS 包头之后，第一个 PES 包之前。\nRTP 包 #  首条数据结构：RTP Header + PS Header + PS System Header + PSM + PESV（Header + Payload）\n非首条数据结构：RTP Header + PS Header + PESV（Header + Payload）\n少了 PS System Header + PSM\n PESV: 视频 PESA: 音频   知道了 PS 包的结构，就可以用处理程序解析数据， 从而把原始流 ES（H264）从 PES 包中解析出来\nPES Payload 就是 H264 数据\nRTP 头部 #   去掉 12 字节的 RTP 头部，保存下来的就是 H264 PS 流， VLC 可播放\n 第 1 字节\n第 2 字节\n第 3-4 字节\n第 5-8 字节\n第 9-12 字节\nRTP Payload #   RTP Payload 中承载的即为 PS 数据 起始的 00 00 01 ba 代表 PS 包的开始 接下来跳过 9 个字节，暂时不关心它的内容 看第 10 个字节 fe，对应着二进制数据的 1111 1110  它的后三位为 110 为十进制的 6，即接下来的六个字节是扩展内容   跳过 6 个字节后，遇到了 00 00 01 bb，这时来到了 PS System Header 部分  PS 数据格式的标准文档可以参考这个 PDF：iso13818-1:2000.pdf   紧邻的 00 12 两个字节表示 System Header 的长度，换算为十进制，即为 18 个字节 在 header_length 后共有 6 个字节的数据 之后就是 stream_id 字段（码流种类）  system_id 值为 e0 0xE0: 视频流 0xC0: 音频流      payload type: PS (96) SSRC: Synchronization source  Synchronization Source identifier (32 bits)   CSRC: Contributing source  Contributing source IDs (32 bits each)     RTP -\u0026gt; RTSP/RTMP #   需要遇到 sps pps idr 才能生成\n NALU (NAL Units) 组成\n NALU 头（00 00 00 01 或者 00 00 01） sps (序列参数集) pps (图像参数集合) slice sei IDR 帧 I 帧（在图像运动变化较少时，I 帧后面是 7 个 P 帧，如果图像运动变化大时，一个序列就短了，I 帧后面可能是 3 个或者 4 个 P 帧） P 帧 B 帧等数据。  一个完整的 NALU 单元结构图\n参考：\n RTP 接收 28281 的收流生成流媒体的时间很长 H.264 码流结构 (H.264 Data Structure)   参考 #   海康摄像头 PS 流格式解析（RTP/PS/H264） 基于 GB28181 从海康 NVR 获取目录 / 点播 / 回播信令备忘 RTP 协议全解析（H264 码流和 PS 流）  "});index.add({'id':383,'href':'/note-cs/docs/skill/stream-media/stream-media/rtsp/','title':"RTSP",'section':"流媒体技术",'content':"RTSP #  Real Time Streaming Protocol\n默认端口：554\n方法 #  一般的顺序是：\n OPTIONS DESCRIBE SETUP PLAY TEARDOWN  OPTIONS #  请求返回服务器将接受的请求类型。\nC-\u0026gt;S: OPTIONS rtsp://example.com/media.mp4 RTSP/1.0 CSeq: 1 Require: implicit-play Proxy-Require: gzipped-messages S-\u0026gt;C: RTSP/1.0 200 OK CSeq: 1 Public: DESCRIBE, SETUP, TEARDOWN, PLAY, PAUSE DESCRIBE #  SETUP #  TEARDOWN #  PLAY #  PAUSE #   包详情 #  海康摄像头\nOPTIONS rtsp://172.17.11.155:554/h264/ch1/main/av_stream RTSP/1.0 CSeq: 2 User-Agent: LibVLC/2.2.4 (LIVE555 Streaming Media v2016.02.22) # OPTIONS ：这个是选项，问下服务器我到底有啥本领技能？ RTSP/1.0 200 OK CSeq: 2 Public: OPTIONS, DESCRIBE, PLAY, PAUSE, SETUP, TEARDOWN, SET_PARAMETER, GET_PARAMETER Date: Tue, May 23 2017 16:08:47 GMT # 服务器回复你，你有这么多技能：OPTIONS, DESCRIBE, PLAY, PAUSE, SETUP, TEARDOWN, SET_PARAMETER, GET_PARAMETER DESCRIBE rtsp://172.17.11.155:554/h264/ch1/main/av_stream RTSP/1.0 CSeq: 3 User-Agent: LibVLC/2.2.4 (LIVE555 Streaming Media v2016.02.22) Accept: application/sdp # DESCRIBE ：我想让服务器描述一下流的情况，你用sdp的格式告诉我吧 RTSP/1.0 401 Unauthorized CSeq: 3 WWW-Authenticate: Digest realm=\u0026#34;1868cb21d4df\u0026#34;, nonce=\u0026#34;cfbaf30c677edba80dbd7f0eb1df5db6\u0026#34;, stale=\u0026#34;FALSE\u0026#34; WWW-Authenticate: Basic realm=\u0026#34;1868cb21d4df\u0026#34; Date: Tue, May 23 2017 16:08:47 GMT # 服务器回答，你没有认证（用户密码），所以给你401吧 DESCRIBE rtsp://172.17.11.155:554/h264/ch1/main/av_stream RTSP/1.0 CSeq: 4 Authorization: Digest username=\u0026#34;admin\u0026#34;, realm=\u0026#34;1868cb21d4df\u0026#34;, nonce=\u0026#34;cfbaf30c677edba80dbd7f0eb1df5db6\u0026#34;, uri=\u0026#34;rtsp://172.17.11.155:554/h264/ch1/main/av_stream\u0026#34;, response=\u0026#34;8b9d4d3e6ae627b62f430874a8c6e333\u0026#34; User-Agent: LibVLC/2.2.4 (LIVE555 Streaming Media v2016.02.22) Accept: application/sdp # DESCRIBE ：我表示不服，再上诉：让服务器描述一下流的情况，你用sdp的格式告诉我吧 RTSP/1.0 200 OK CSeq: 4 Content-Type: application/sdp Content-Base: rtsp://172.17.11.155:554/h264/ch1/main/av_stream/ Content-Length: 598 v=0 o=- 1495555727123750 1495555727123750 IN IP4 172.17.10.7 s=Media Presentation e=NONE b=AS:5050 t=0 0 a=control:rtsp://172.17.11.155:554/h264/ch1/main/av_stream/ m=video 0 RTP/AVP 96 c=IN IP4 0.0.0.0 b=AS:5000 a=recvonly a=x-dimensions:1920,1080 a=control:rtsp://172.17.11.155:554/h264/ch1/main/av_stream/trackID=1 a=rtpmap:96 H264/90000 a=fmtp:96 profile-level-id=420029; packetization-mode=1; sprop-parameter-sets=Z00AKpWoHgCJ+WEAAAcIAAFfkAQ=,aO48gA== a=Media_header:MEDIAINFO=494D4B48010200000400000100000000000000000000000000000000000000000000000000000000; a=appversion:1.0 # 服务器答应了，然后把SDP发给我了 # 里面有各种信息：我看到只有一路视频，1080P的，H264编码； # 96是视频流ID, 这符合规范，mediainfo可能是sps pps的加密信息 SETUP rtsp://172.17.11.155:554/h264/ch1/main/av_stream/trackID=1 RTSP/1.0 CSeq: 5 Authorization: Digest username=\u0026#34;admin\u0026#34;, realm=\u0026#34;1868cb21d4df\u0026#34;, nonce=\u0026#34;cfbaf30c677edba80dbd7f0eb1df5db6\u0026#34;, uri=\u0026#34;rtsp://172.17.11.155:554/h264/ch1/main/av_stream/\u0026#34;, response=\u0026#34;a34897f9b42eb7f501d549f6fa558838\u0026#34; User-Agent: LibVLC/2.2.4 (LIVE555 Streaming Media v2016.02.22) Transport: RTP/AVP/TCP;unicast;interleaved=0-1 # SETUP ：为了透过防火墙，我想指定传输机制RTP/AVP/TCP告诉服务器 RTSP/1.0 200 OK CSeq: 5 Session: 313720730;timeout=60 Transport: RTP/AVP/TCP;unicast;interleaved=0-1;ssrc=72a9bdb8;mode=\u0026#34;play\u0026#34; Date: Tue, May 23 2017 16:08:47 GMT # 服务器准了，并告诉你可以play了 PLAY rtsp://172.17.11.155:554/h264/ch1/main/av_stream/ RTSP/1.0 CSeq: 6 Authorization: Digest username=\u0026#34;admin\u0026#34;, realm=\u0026#34;1868cb21d4df\u0026#34;, nonce=\u0026#34;cfbaf30c677edba80dbd7f0eb1df5db6\u0026#34;, uri=\u0026#34;rtsp://172.17.11.155:554/h264/ch1/main/av_stream/\u0026#34;, response=\u0026#34;13e073b1f7a0d1be0442491ba4613c35\u0026#34; User-Agent: LibVLC/2.2.4 (LIVE555 Streaming Media v2016.02.22) Session: 313720730 Range: npt=0.000- # PLAY ：我想告诉服务器以SETUP指定的机制开始发送数据； # 还可以用关键字Range指定play的范围 RTSP/1.0 200 OK CSeq: 6 Session: 313720730 RTP-Info: url=rtsp://172.17.11.155:554/h264/ch1/main/av_stream/trackID=1;seq=13657;rtptime=106503066 Date: Tue, May 23 2017 16:08:47 GMT # 服务器很听话，给到了初始的随机序列号和随机时间戳seq=13657;rtptime=106503066 GET_PARAMETER rtsp://172.17.11.155:554/h264/ch1/main/av_stream/ RTSP/1.0 CSeq: 7 Authorization: Digest username=\u0026#34;admin\u0026#34;, realm=\u0026#34;1868cb21d4df\u0026#34;, nonce=\u0026#34;cfbaf30c677edba80dbd7f0eb1df5db6\u0026#34;, uri=\u0026#34;rtsp://172.17.11.155:554/h264/ch1/main/av_stream/\u0026#34;, response=\u0026#34;5845426a0c6ce7ca7839ac9e639d7197\u0026#34; User-Agent: LibVLC/2.2.4 (LIVE555 Streaming Media v2016.02.22) Session: 313720730 # GET_PARAMETER ：我请求检查URL指定的演示与媒体的参数值。 # 没有实体体时，也许能用来测试用户与服务器的连通情况 $.. .`5Y.Y..r...gM.*......a......_..$....`5Z.Y..r...h.\u0026lt;.$....`5[.Y..r......y....$....`5\\.Y..r...|....sT...e....Z\u0026amp;x]A....UF...8..I..O...x.4ZC/|$.. # 一堆数据？ TEARDOWN rtsp://172.17.11.155:554/h264/ch1/main/av_stream/ RTSP/1.0 CSeq: 14 Authorization: Digest username=\u0026#34;admin\u0026#34;, realm=\u0026#34;1868cb21d4df\u0026#34;, nonce=\u0026#34;cfbaf30c677edba80dbd7f0eb1df5db6\u0026#34;, uri=\u0026#34;rtsp://172.17.11.155:554/h264/ch1/main/av_stream/\u0026#34;, response=\u0026#34;a52194fbc2c6433e1f1dbf33576a7f7c\u0026#34; User-Agent: LibVLC/2.2.4 (LIVE555 Streaming Media v2016.02.22) Session: 313720730 $..(......[.r.........l...................[. # TEARDOWN ：不玩了，就停止给定URL流发送数据，并释放相关资源 RTSP/1.0 200 OK CSeq: 14 Session: 313720730 Date: Tue, May 23 2017 16:15:10 GMT # 好的，服务器说：对你这个会话Session: 313720730， 我把它干掉 参考：\n RTSP 抓包详解   参考 #   WireShark 查看 vlc 播放 rtsp 流过程，抓包分离出 h264 流  "});index.add({'id':384,'href':'/note-cs/docs/basic/pl/ruby/advanced/frame/rainls/','title':"Ruby on Rails",'section':"2.7 框架",'content':"Ruby on Rails #  rails/rails "});index.add({'id':385,'href':'/note-cs/docs/domain/cc/others/saas/crm/salesforce/','title':"Salesforce",'section':"CRM",'content':"Salesforce #  "});index.add({'id':386,'href':'/note-cs/docs/direction/be/db/redis/source/type/string/','title':"String 实现",'section':"类型实现",'content':"Redis String 类型实现 #  Redis 中的字符串是一种 动态字符串，这意味着使用者可以修改，它的底层实现有点类似于 Java 中的 ArrayList，有一个字符数组，从源码的 sds.h/sdshdr 文件 中可以看到 Redis 底层对于字符串的定义 SDS，即 Simple Dynamic String 结构：\n/* Note: sdshdr5 is never used, we just access the flags byte directly. * However is here to document the layout of type 5 SDS strings. */ struct __attribute__ ((__packed__)) sdshdr5 { unsigned char flags; /* 3 lsb of type, and 5 msb of string length */ char buf[]; }; struct __attribute__ ((__packed__)) sdshdr8 { uint8_t len; /* used */ uint8_t alloc; /* excluding the header and null terminator */ unsigned char flags; /* 3 lsb of type, 5 unused bits */ char buf[]; }; struct __attribute__ ((__packed__)) sdshdr16 { uint16_t len; /* used */ uint16_t alloc; /* excluding the header and null terminator */ unsigned char flags; /* 3 lsb of type, 5 unused bits */ char buf[]; }; struct __attribute__ ((__packed__)) sdshdr32 { uint32_t len; /* used */ uint32_t alloc; /* excluding the header and null terminator */ unsigned char flags; /* 3 lsb of type, 5 unused bits */ char buf[]; }; struct __attribute__ ((__packed__)) sdshdr64 { uint64_t len; /* used */ uint64_t alloc; /* excluding the header and null terminator */ unsigned char flags; /* 3 lsb of type, 5 unused bits */ char buf[]; }; 你会发现同样一组结构 Redis 使用泛型定义了好多次，为什么不直接使用 int 类型呢？\n因为当字符串比较短的时候，len 和 alloc 可以使用 byte 和 short 来表示，Redis 为了对内存做极致的优化，不同长度的字符串使用不同的结构体来表示。\nSDS 与 C 字符串的区别 #  为什么不考虑直接使用 C 语言的字符串呢？\nC 字符串太简单 #  因为 C 语言这种简单的字符串表示方式 不符合 Redis 对字符串在安全性、效率以及功能方面的要求。\nC 语言使用了一个长度为 N+1 的字符数组来表示长度为 N 的字符串，并且字符数组最后一个元素总是 \u0026lsquo;\\0\u0026rsquo;。\n这样简单的数据结构可能会造成以下一些问题：\n 获取字符串长度为 O (N) 级别的操作 → 因为 C 不保存数组的长度，每次都需要遍历一遍整个数组； 不能很好的杜绝 缓冲区溢出 / 内存泄漏 的问题 → 跟上述问题原因一样，如果执行拼接 or 缩短字符串的操作，如果操作不当就很容易造成上述问题； C 字符串 只能保存文本数据 → 因为 C 语言中的字符串必须符合某种编码（比如 ASCII），例如中间出现的 \u0026lsquo;\\0\u0026rsquo; 可能会被判定为提前结束的字符串而识别不了；  以追加字符串的操作举例，Redis 源码如下：\n/* Append the specified binary-safe string pointed by \u0026#39;t\u0026#39; of \u0026#39;len\u0026#39; bytes to the * end of the specified sds string \u0026#39;s\u0026#39;. * * After the call, the passed sds string is no longer valid and all the * references must be substituted with the new pointer returned by the call. */ sds sdscatlen(sds s, const void *t, size_t len) { // 获取原字符串的长度  size_t curlen = sdslen(s); // 按需调整空间，如果容量不够容纳追加的内容，就会重新分配字节数组并复制原字符串的内容到新数组中  s = sdsMakeRoomFor(s,len); if (s == NULL) return NULL; // 内存不足  memcpy(s+curlen, t, len); // 追加目标字符串到字节数组中  sdssetlen(s, curlen+len); // 设置追加后的长度  s[curlen+len] = \u0026#39;\\0\u0026#39;; // 让字符串以 \\0 结尾，便于调试打印  return s; }  参考 #   5 种基本数据结构  "});index.add({'id':387,'href':'/note-cs/docs/domain/cc/virtual/vmware/','title':"VMware Fusion",'section':"虚拟化",'content':"VMware Fusion #  "});index.add({'id':388,'href':'/note-cs/docs/skill/stream-media/stream-media/webrtc/','title':"WebRTC",'section':"流媒体技术",'content':"WebRTC #  Web Real-Time Communication\n支持网页浏览器进行实时语音对话或视频对话的 API\n"});index.add({'id':389,'href':'/note-cs/docs/basic/pl/lua/appendix/tutorial/learn-lua-in-x-minutes/','title':"X 分钟速成 Lua",'section':"4.1 教程",'content':"X 分钟速成 Lua #  -- 单行注释以两个连字符开头 --[[ 多行注释 --]] ---------------------------------------------------- -- 1. 变量和流程控制 ---------------------------------------------------- num = 42 -- 所有的数字都是双精度浮点型。 -- 别害怕，64位的双精度浮点型数字中有52位用于 -- 保存精确的整型值; 对于52位以内的整型值， -- 不用担心精度问题。 s = \u0026#39;walternate\u0026#39; -- 和Python一样，字符串不可变。 t = \u0026#34;也可以用双引号\u0026#34; u = [[ 多行的字符串 以两个方括号 开始和结尾。]] t = nil -- 撤销t的定义; Lua 支持垃圾回收。 -- 块使用do/end之类的关键字标识： while num \u0026lt; 50 do num = num + 1 -- 不支持 ++ 或 += 运算符。 end -- If语句： if num \u0026gt; 40 then print(\u0026#39;over 40\u0026#39;) elseif s ~= \u0026#39;walternate\u0026#39; then -- ~= 表示不等于。 -- 像Python一样，用 == 检查是否相等 ；字符串同样适用。 io.write(\u0026#39;not over 40\\n\u0026#39;) -- 默认标准输出。 else -- 默认全局变量。 thisIsGlobal = 5 -- 通常使用驼峰。 -- 如何定义局部变量： local line = io.read() -- 读取标准输入的下一行。 -- ..操作符用于连接字符串： print(\u0026#39;Winter is coming, \u0026#39; .. line) end -- 未定义的变量返回nil。 -- 这不是错误： foo = anUnknownVariable -- 现在 foo = nil. aBoolValue = false --只有nil和false为假; 0和 \u0026#39;\u0026#39;均为真！ if not aBoolValue then print(\u0026#39;false\u0026#39;) end -- \u0026#39;or\u0026#39;和 \u0026#39;and\u0026#39;短路 -- 类似于C/js里的 a?b:c 操作符： ans = aBoolValue and \u0026#39;yes\u0026#39; or \u0026#39;no\u0026#39; --\u0026gt; \u0026#39;no\u0026#39; karlSum = 0 for i = 1, 100 do -- 范围包含两端 karlSum = karlSum + i end -- 使用 \u0026#34;100, 1, -1\u0026#34; 表示递减的范围： fredSum = 0 for j = 100, 1, -1 do fredSum = fredSum + j end -- 通常，范围表达式为begin, end[, step]. -- 循环的另一种结构： repeat print(\u0026#39;the way of the future\u0026#39;) num = num - 1 until num == 0 ---------------------------------------------------- -- 2. 函数。 ---------------------------------------------------- function fib(n) if n \u0026lt; 2 then return n end return fib(n - 2) + fib(n - 1) end -- 支持闭包及匿名函数： function adder(x) -- 调用adder时，会创建返回的函数， -- 并且会记住x的值： return function (y) return x + y end end a1 = adder(9) a2 = adder(36) print(a1(16)) --\u0026gt; 25 print(a2(64)) --\u0026gt; 100 -- 返回值、函数调用和赋值都可以 -- 使用长度不匹配的list。 -- 不匹配的接收方会被赋值nil； -- 不匹配的发送方会被丢弃。 x, y, z = 1, 2, 3, 4 -- x = 1、y = 2、z = 3, 而 4 会被丢弃。 function bar(a, b, c) print(a, b, c) return 4, 8, 15, 16, 23, 42 end x, y = bar(\u0026#39;zaphod\u0026#39;) --\u0026gt; 打印 \u0026#34;zaphod nil nil\u0026#34; -- 现在 x = 4, y = 8, 而值15..42被丢弃。 -- 函数是一等公民，可以是局部的，也可以是全局的。 -- 以下表达式等价： function f(x) return x * x end f = function (x) return x * x end -- 这些也是等价的： local function g(x) return math.sin(x) end local g; g = function (x) return math.sin(x) end -- 以上均因\u0026#39;local g\u0026#39;，使得g可以自引用。 local g = function(x) return math.sin(x) end -- 等价于 local function g(x)..., 但函数体中g不可自引用 -- 顺便提下，三角函数以弧度为单位。 -- 用一个字符串参数调用函数，可以省略括号： print \u0026#39;hello\u0026#39; --可以工作。 -- 调用函数时，如果只有一个table参数， -- 同样可以省略括号（table详情见下）： print {} -- 一样可以工作。 ---------------------------------------------------- -- 3. Table。 ---------------------------------------------------- -- Table = Lua唯一的组合数据结构; -- 它们是关联数组。 -- 类似于PHP的数组或者js的对象， -- 它们是哈希表或者字典，也可以当列表使用。 -- 按字典/map的方式使用Table： -- Dict字面量默认使用字符串类型的key： t = {key1 = \u0026#39;value1\u0026#39;, key2 = false} -- 字符串key可以使用类似js的点标记： print(t.key1) -- 打印 \u0026#39;value1\u0026#39;. t.newKey = {} -- 添加新的键值对。 t.key2 = nil -- 从table删除 key2。 -- 使用任何非nil的值作为key： u = {[\u0026#39;@!#\u0026#39;] = \u0026#39;qbert\u0026#39;, [{}] = 1729, [6.28] = \u0026#39;tau\u0026#39;} print(u[6.28]) -- 打印 \u0026#34;tau\u0026#34; -- 数字和字符串的key按值匹配的 -- table按id匹配。 a = u[\u0026#39;@!#\u0026#39;] -- 现在 a = \u0026#39;qbert\u0026#39;. b = u[{}] -- 我们或许期待的是 1729, 但是得到的是nil: -- b = nil ，因为没有找到。 -- 之所以没找到，是因为我们用的key与保存数据时用的不是同 -- 一个对象。 -- 所以字符串和数字是移植性更好的key。 -- 只需要一个table参数的函数调用不需要括号： function h(x) print(x.key1) end h{key1 = \u0026#39;Sonmi~451\u0026#39;} -- 打印\u0026#39;Sonmi~451\u0026#39;. for key, val in pairs(u) do -- 遍历Table print(key, val) end -- _G 是一个特殊的table，用于保存所有的全局变量 print(_G[\u0026#39;_G\u0026#39;] == _G) -- 打印\u0026#39;true\u0026#39;. -- 按列表/数组的方式使用： -- 列表字面量隐式添加整数键： v = {\u0026#39;value1\u0026#39;, \u0026#39;value2\u0026#39;, 1.21, \u0026#39;gigawatts\u0026#39;} for i = 1, #v do -- #v 是列表的大小 print(v[i]) -- 索引从 1 开始!! 太疯狂了！ end -- \u0026#39;list\u0026#39;并非真正的类型，v 其实是一个table， -- 只不过它用连续的整数作为key，可以像list那样去使用。 ---------------------------------------------------- -- 3.1 元表（metatable） 和元方法（metamethod）。 ---------------------------------------------------- -- table的元表提供了一种机制，支持类似操作符重载的行为。 -- 稍后我们会看到元表如何支持类似js prototype的行为。 f1 = {a = 1, b = 2} -- 表示一个分数 a/b. f2 = {a = 2, b = 3} -- 这会失败： -- s = f1 + f2 metafraction = {} function metafraction.__add(f1, f2) local sum = {} sum.b = f1.b * f2.b sum.a = f1.a * f2.b + f2.a * f1.b return sum end setmetatable(f1, metafraction) setmetatable(f2, metafraction) s = f1 + f2 -- 调用在f1的元表上的__add(f1, f2) 方法 -- f1, f2 没有关于元表的key，这点和js的prototype不一样。 -- 因此你必须用getmetatable(f1)获取元表。 -- 元表是一个普通的table， -- 元表的key是普通的Lua中的key，例如__add。 -- 但是下面一行代码会失败，因为s没有元表： -- t = s + s -- 下面提供的与类相似的模式可以解决这个问题： -- 元表的__index 可以重载用于查找的点操作符： defaultFavs = {animal = \u0026#39;gru\u0026#39;, food = \u0026#39;donuts\u0026#39;} myFavs = {food = \u0026#39;pizza\u0026#39;} setmetatable(myFavs, {__index = defaultFavs}) eatenBy = myFavs.animal -- 可以工作！感谢元表 -- 如果在table中直接查找key失败，会使用 -- 元表的__index 递归地重试。 -- __index的值也可以是function(tbl, key) -- 这样可以支持自定义查找。 -- __index、__add等的值，被称为元方法。 -- 这里是一个table元方法的清单： -- __add(a, b) for a + b -- __sub(a, b) for a - b -- __mul(a, b) for a * b -- __div(a, b) for a / b -- __mod(a, b) for a % b -- __pow(a, b) for a ^ b -- __unm(a) for -a -- __concat(a, b) for a .. b -- __len(a) for #a -- __eq(a, b) for a == b -- __lt(a, b) for a \u0026lt; b -- __le(a, b) for a \u0026lt;= b -- __index(a, b) \u0026lt;fn or a table\u0026gt; for a.b -- __newindex(a, b, c) for a.b = c -- __call(a, ...) for a(...) ---------------------------------------------------- -- 3.2 与类相似的table和继承。 ---------------------------------------------------- -- Lua没有内建的类；可以通过不同的方法，利用表和元表 -- 来实现类。 -- 下面是一个例子，解释在后面： Dog = {} -- 1. function Dog:new() -- 2. local newObj = {sound = \u0026#39;woof\u0026#39;} -- 3. self.__index = self -- 4. return setmetatable(newObj, self) -- 5. end function Dog:makeSound() -- 6. print(\u0026#39;I say \u0026#39; .. self.sound) end mrDog = Dog:new() -- 7. mrDog:makeSound() -- \u0026#39;I say woof\u0026#39; -- 8. -- 1. Dog看上去像一个类；其实它是一个table。 -- 2. 函数tablename:fn(...) 等价于 -- 函数tablename.fn(self, ...) -- 冒号（:）只是添加了self作为第一个参数。 -- 阅读7 \u0026amp; 8条 了解self变量是如何得到其值的。 -- 3. newObj是类Dog的一个实例。 -- 4. self = 被继承的类。通常self = Dog，不过继承可以改变它。 -- 如果把newObj的元表和__index都设置为self， -- newObj就可以得到self的函数。 -- 5. 备忘：setmetatable返回其第一个参数。 -- 6. 冒号（：）的作用和第2条一样，不过这里 -- self是一个实例，而不是类 -- 7. 等价于Dog.new(Dog)，所以在new()中，self = Dog。 -- 8. 等价于mrDog.makeSound(mrDog); self = mrDog。 ---------------------------------------------------- -- 继承的例子： LoudDog = Dog:new() -- 1. function LoudDog:makeSound() local s = self.sound .. \u0026#39; \u0026#39; -- 2. print(s .. s .. s) end seymour = LoudDog:new() -- 3. seymour:makeSound() -- \u0026#39;woof woof woof\u0026#39; -- 4. -- 1. LoudDog获得Dog的方法和变量列表。 -- 2. 因为new()的缘故，self拥有了一个\u0026#39;sound\u0026#39; key，参见第3条。 -- 3. 等价于LoudDog.new(LoudDog)，转换一下就是 -- Dog.new(LoudDog)，这是因为LoudDog没有\u0026#39;new\u0026#39; key， -- 但是它的元表中有 __index = Dog。 -- 结果: seymour的元表是LoudDog，并且 -- LoudDog.__index = Dog。所以有seymour.key -- = seymour.key, LoudDog.key, Dog.key -- 从其中第一个有指定key的table获取。 -- 4. 在LoudDog可以找到\u0026#39;makeSound\u0026#39;的key； -- 等价于LoudDog.makeSound(seymour)。 -- 如果有必要，子类也可以有new()，与基类相似： function LoudDog:new() local newObj = {} -- 初始化newObj self.__index = self return setmetatable(newObj, self) end ---------------------------------------------------- -- 4. 模块 ---------------------------------------------------- --[[ 我把这部分给注释了，这样脚本剩下的部分可以运行 -- 假设文件mod.lua的内容类似这样： local M = {} local function sayMyName() print(\u0026#39;Hrunkner\u0026#39;) end function M.sayHello() print(\u0026#39;Why hello there\u0026#39;) sayMyName() end return M -- 另一个文件可以使用mod.lua的功能： local mod = require(\u0026#39;mod\u0026#39;) -- 运行文件mod.lua. -- require是包含模块的标准做法。 -- require等价于: (针对没有被缓存的情况；参见后面的内容) local mod = (function () \u0026lt;contents of mod.lua\u0026gt; end)() -- mod.lua被包在一个函数体中，因此mod.lua的局部变量 -- 对外不可见。 -- 下面的代码可以工作，因为在这里mod = mod.lua 中的 M： mod.sayHello() -- Says hello to Hrunkner. -- 这是错误的；sayMyName只在mod.lua中存在： mod.sayMyName() -- 错误 -- require返回的值会被缓存，所以一个文件只会被运行一次， -- 即使它被require了多次。 -- 假设mod2.lua包含代码\u0026#34;print(\u0026#39;Hi!\u0026#39;)\u0026#34;。 local a = require(\u0026#39;mod2\u0026#39;) -- 打印Hi! local b = require(\u0026#39;mod2\u0026#39;) -- 不再打印; a=b. -- dofile与require类似，但是不缓存： dofile(\u0026#39;mod2\u0026#39;) --\u0026gt; Hi! dofile(\u0026#39;mod2\u0026#39;) --\u0026gt; Hi! (再次运行，与require不同) -- loadfile加载一个lua文件，但是并不运行它。 f = loadfile(\u0026#39;mod2\u0026#39;) -- Calling f() runs mod2.lua. -- loadstring是loadfile的字符串版本。 g = loadstring(\u0026#39;print(343)\u0026#39;) --返回一个函数。 g() -- 打印343; 在此之前什么也不打印。 --]] 参考：\n X 分钟速成 Lua  "});index.add({'id':390,'href':'/note-cs/docs/basic/pl/shell/command/xargs/','title':"xargs",'section':"1.3.1 Shell 命令",'content':"xargs #  xargs 命令的作用，是将标准输入转为命令行参数\n-L #  xargs -L 1 xargs --max-lines=1 # synonym for the -L option -L 参数指定多少行作为一个命令行参数。\n执行子目录里所有的 deploy.sh find . -name deploy.sh | xargs -L 1 sh\n-n #  -L 参数虽然解决了多行的问题，但是有时用户会在同一行输入多项。 -n 参数指定每次将多少项，作为命令行参数。\n参考 #   阮一峰 xargs 命令教程  "});index.add({'id':391,'href':'/note-cs/docs/direction/be/web/xml/','title':"XML",'section':"Web Service",'content':"XML #  "});index.add({'id':392,'href':'/note-cs/docs/direction/security/basic/xss/','title':"XSS",'section':"第一部分 基础入门",'content':"XSS #  Cross-site scripting 跨站脚本 (wiki)\nXSS 发生的原因 #  没有将用户输入的文本进行合适的过滤，就贸然插入到 HTML 中，这很容易造成注入漏洞。 攻击者可以利用漏洞，构造出恶意的代码指令，进而利用恶意代码危害数据安全。\n不仅仅是业务上的 “用户的 UGC 内容” 可以进行注入，包括 URL 上的参数等都可以是攻击的来源。在处理输入时，以下内容都不可信：\n 来自用户的 UGC 信息 来自第三方的链接 URL 参数 POST 参数 Referer （可能来自不可信的来源） Cookie （可能来自其他子域注入）  XSS 有哪些注入的方法 #   在 HTML 中内嵌的文本中，恶意内容以 script 标签形成注入。 在内联的 JavaScript 中，拼接的数据突破了原本的限制（字符串，变量，方法名等）。 在标签属性中，恶意内容包含引号，从而突破属性值的限制，注入其他属性或者标签。 在标签的 href、src 等属性中，包含 javascript: 等可执行代码。 在 onload、onerror、onclick 等事件中，注入不受控制代码。 在 style 属性和标签中，包含类似 background-image:url(\u0026quot;javascript:...\u0026quot;); 的代码（新版本浏览器已经可以防范）。 在 style 属性和标签中，包含类似 expression(...) 的 CSS 表达式代码（新版本浏览器已经可以防范）。   XSS 分类 #  存储型 #  存储型 XSS 的攻击步骤：\n 攻击者将恶意代码提交到目标网站的数据库中。 用户打开目标网站时，网站服务端将恶意代码从数据库取出，拼接在 HTML 中返回给浏览器。 用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行。 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。  这种攻击常见于带有用户保存数据的网站功能，如论坛发帖、商品评论、用户私信等。\n反射型 #  反射型 XSS 的攻击步骤：\n 攻击者构造出特殊的 URL，其中包含恶意代码。 用户打开带有恶意代码的 URL 时，网站服务端将恶意代码从 URL 中取出，拼接在 HTML 中返回给浏览器。 用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行。 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。  反射型 XSS 跟存储型 XSS 的区别是：\n 存储型 XSS 的恶意代码存在数据库里， 反射型 XSS 的恶意代码存在 URL 里。  反射型 XSS 漏洞常见于通过 URL 传递参数的功能，如网站搜索、跳转等。\n由于需要用户主动打开恶意的 URL 才能生效，攻击者往往会结合多种手段诱导用户点击。\nPOST 的内容也可以触发反射型 XSS，只不过其触发条件比较苛刻（需要构造表单提交页面，并引导用户点击），所以非常少见。\nDOM 型 #  DOM 型 XSS 的攻击步骤：\n 攻击者构造出特殊的 URL，其中包含恶意代码。 用户打开带有恶意代码的 URL。 用户浏览器接收到响应后解析执行，前端 JavaScript 取出 URL 中的恶意代码并执行。 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。  DOM 型 XSS 跟前两种 XSS 的区别：\n DOM 型 XSS 攻击中，取出和执行恶意代码由浏览器端完成，属于前端 JavaScript 自身的安全漏洞， 其他两种 XSS 都属于服务端的安全漏洞。   防止 XSS #  输入过滤 #  输入侧过滤能够在某些情况下解决特定的 XSS 问题，但会引入很大的不确定性和乱码问题。 在防范 XSS 攻击时应避免此类方法。\n当然，对于明确的输入类型，例如数字、URL、电话号码、邮件地址等等内容，进行输入过滤还是必要的。\n纯前端渲染 #  纯前端渲染，把代码和数据分隔开\n纯前端渲染的过程：\n 浏览器先加载一个静态 HTML，此 HTML 中不包含任何跟业务相关的数据。 然后浏览器执行 HTML 中的 JavaScript。 JavaScript 通过 Ajax 加载业务数据，调用 DOM API 更新到页面上。  在纯前端渲染中，我们会明确的告诉浏览器： 下面要设置的内容是文本（.innerText），还是属性（.setAttribute），还是样式（.style）等等。 浏览器不会被轻易的被欺骗，执行预期外的代码了。\n但纯前端渲染还需注意避免 DOM 型 XSS 漏洞（例如 onload 事件和 href 中的 javascript:xxx 等）。\n在很多内部、管理系统中，采用纯前端渲染是非常合适的。 但对于性能要求高，或有 SEO 需求的页面，我们仍然要面对拼接 HTML 的问题。\n对 HTML 做充分转义 #  对插入到页面中的数据进行转义， 通常是把 \u0026amp; \u0026lt; \u0026gt; \u0026quot; ' / 这几个字符转义掉， 确实能起到一定的 XSS 防护作用，但要完善 XSS 防护措施，我们要使用更完善更细致的转义策略。\nHTML 转义是非常复杂的，在不同的情况下要采用不同的转义规则。如果采用了错误的转义规则，很有可能会埋下 XSS 隐患。 应当尽量避免自己写转义库，而应当采用成熟的、业界通用的转义库。\n常用的模板引擎，如 doT.js、ejs、FreeMarker 等， Java 工程里，常用的转义库为 org.owasp.encoder。\n验证 href 的值 #  对于链接跳转，如 \u0026lt;a href=\u0026quot;xxx\u0026quot; 或 location.href=\u0026quot;xxx\u0026quot;，要检验其内容，禁止以 javascript: 开头的链接，和其他非法的 scheme。\n// 根据项目情况进行过滤，禁止掉 \u0026#34;javascript:\u0026#34; 链接、非法 scheme 等 allowSchemes = [\u0026#34;http\u0026#34;, \u0026#34;https\u0026#34;]; valid = isValid(getParameter(\u0026#34;redirect_to\u0026#34;), allowSchemes); if (valid) { \u0026lt;a href=\u0026#34;\u0026lt;%= escapeHTML(getParameter(\u0026#34;redirect_to\u0026#34;))%\u0026gt;\u0026#34;\u0026gt; 跳转... \u0026lt;/a\u0026gt; } else { \u0026lt;a href=\u0026#34;/404\u0026#34;\u0026gt; 跳转... \u0026lt;/a\u0026gt; } 不区分大小写，可以带空格 #   JavaScript 不区分大小写： jAvascRipt:alert('XSS') 可以带空格 %20： %20javascript:alert('XSS')   escapeEmbedJSON #  插入 JSON 的地方不能使用 escapeHTML()，因为转义 \u0026quot; 后，JSON 格式会被破坏。\n\u0026lt;script\u0026gt; var initData = \u0026lt;%= data.toJSON() %\u0026gt; \u0026lt;/script\u0026gt; 这样内联 JSON 也是不安全的\n 当 JSON 中包含 U+2028 或 U+2029 这两个字符时，不能作为 JavaScript 的字面量使用，否则会抛出语法错误。 当 JSON 中包含字符串 \u0026lt;/script\u0026gt; 时，当前的 script 标签将会被闭合，后面的字符串内容浏览器会按照 HTML 进行解析；通过增加下一个 \u0026lt;script\u0026gt; 标签等方法就可以完成注入。  \u0026lt;script\u0026gt; // 实现一个 escapeEmbedJSON() 函数，对内联 JSON 进行转义  var initData = \u0026lt;%= escapeEmbedJSON(data.toJSON()) %\u0026gt; \u0026lt;/script\u0026gt;  预防 DOM 型 XSS 攻击 #  在使用 .innerHTML、.outerHTML、document.write() 时要特别小心，不要把不可信的数据作为 HTML 插到页面上， 而应尽量使用 .textContent、.setAttribute() 等。\n如果用 Vue/React 技术栈，并且不使用 v-html/dangerouslySetInnerHTML 功能， 就在前端 render 阶段避免 innerHTML、outerHTML 的 XSS 隐患。\nDOM 中的内联事件监听器，如 location、onclick、onerror、onload、onmouseover 等， \u0026lt;a\u0026gt; 标签的 href 属性， JavaScript 的 eval()、setTimeout()、setInterval() 等， 都能把字符串作为代码运行。\n\u0026lt;!-- 内联事件监听器中包含恶意代码 --\u0026gt; ![](https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018b/3e724ce0.data:image/png,) \u0026lt;!-- 链接内包含恶意代码 --\u0026gt; \u0026lt;a href=\u0026#34;UNTRUSTED\u0026#34;\u0026gt;1\u0026lt;/a\u0026gt; \u0026lt;script\u0026gt; // setTimeout()/setInterval() 中调用恶意代码  setTimeout(\u0026#34;UNTRUSTED\u0026#34;); setInterval(\u0026#34;UNTRUSTED\u0026#34;); // location 调用恶意代码  location.href = \u0026#34;UNTRUSTED\u0026#34;; // eval() 中调用恶意代码  eval(\u0026#34;UNTRUSTED\u0026#34;); \u0026lt;/script\u0026gt;  Content Security Policy #  严格的 CSP 在 XSS 的防范中可以起到以下的作用：\n 禁止加载外域代码，防止复杂的攻击逻辑。 禁止外域提交，网站被攻击后，用户的数据不会泄露到外域。 禁止内联脚本执行（规则较严格，目前发现 GitHub 使用）。 禁止未授权的脚本执行（新特性，Google Map 移动版在使用）。 合理使用上报可以及时发现 XSS，利于尽快修复问题。  输入内容长度控制 #  对于不受信任的输入，都应该限定一个合理的长度。 虽然无法完全防止 XSS 发生，但可以增加 XSS 攻击的难度。\n其他安全措施 #   HTTP-only Cookie: 禁止 JavaScript 读取某些敏感 Cookie，攻击者完成 XSS 注入后也无法窃取此 Cookie。 验证码：防止脚本冒充用户提交危险操作。   XSS 的检测 #  jaVasCript:/*-/*`/*\\`/*\u0026#39;/*\u0026#34;/**/(/* */oNcliCk=alert() )//%0D%0A%0d%0a//\u0026lt;/stYle/\u0026lt;/titLe/\u0026lt;/teXtarEa/\u0026lt;/scRipt/--!\u0026gt;\\x3csVg/\u0026lt;sVg/oNloAd=alert()//\u0026gt;\\x3e 只要在网站的各输入框中提交这个字符串，或者把它拼接到 URL 参数上，就可以进行检测了。\n能够检测到存在于 HTML 属性、HTML 文字内容、HTML 注释、跳转链接、内联 JavaScript 字符串、内联 CSS 样式表等多种上下文中的 XSS 漏洞， 也能检测 eval()、setTimeout()、setInterval()、Function()、innerHTML、document.write() 等 DOM 型 XSS 漏洞， 并且能绕过一些 XSS 过滤器。\n自动扫描工具 #   Arachni Mozilla HTTP Observatory w3af   参考 #   在学习 XSS 前应该学习什么？ 前端安全系列（一）：如何防止 XSS 攻击？  "});index.add({'id':393,'href':'/note-cs/docs/domain/cc/cn/','title':"云原生",'section':"3.1 云计算",'content':"Cloud Native 云原生 #  什么是云原生 #  云原生定义 #  2018 年 CNCF 更新了云原生的定义。\n这是新定义中描述的代表技术，其中容器和微服务两项在不同时期的不同定义中都有出现，\n而服务网格这个在 2017 年才开始被社区接纳的新热点技术被非常醒目的列出来，和微服务并列，而不是我们通常认为的服务网格只是微服务在实施时的一种新的方式。\nCloud Native 翻译为云原生，是 Matt Stine 提出的一个概念，它是一个思想的集合，\n包括 DevOps、 持续交付（Continuous Delivery）、微服务（MicroServices）、敏捷基础设施（Agile Infrastructure）、康威定律（Conways Law）等，以及根据商业能力对公司进行重组。\nCloud Native 既包含\n 技术（微服务，敏捷基础设施）， 也包含管理（DevOps，持续交付，康威定律，重组等）。  Cloud Native 也可以说是一系列 Cloud 技术、企业管理方法的集合。\n参考：\n CNCF Cloud Native Definition v1.0  云原生代表技术 #  云原生的代表技术包括容器、服务网格、微服务、不可变基础设施和声明式 API。\n不可变基础设施 #  在传统的可变服务器基础架构中，服务器会不断更新和修改。\n使用此类基础架构的工程师和管理员可以通过 SSH 连接到他们的服务器，手动升级或降级软件包，逐个服务器地调整配置文件，以及将新代码直接部署到现有服务器上。\n换句话说，这些服务器是可变的；它们可以在创建后进行更改。\n不可变基础架构的好处包括基础架构中更高的一致性和可靠性，以及更简单，更可预测的部署过程。\n它可以缓解或完全防止可变基础架构中常见的问题，例如配置漂移和雪花服务器。\n宠物与牛群 #  pets 是独一无二，无法模仿，失去一个可能是毁灭性的。\n牛群中的众多群体中没有一个人是独一无二或不可或缺的。\n雪花服务器与凤凰服务器 #  snowflakes 服务器类似于宠物。它们是手工管理的服务器，经常更新和调整到位，从而形成独特的环境。\nPhoenix 服务器与牛类似。它们是始终从头开始构建的服务器，并且易于通过自动化过程重新创建（或 “从灰烬中升起”）。\n参考：\n 什么是不可变的基础设施？  Tutum #  tutum (now Docker)\n参考：\n 如何更好地使用容器技术实现不可变基础设施   云原生应用 #  理想的云原生应用应该是这个样子：业务需求的实现占主体，只有少量的非业务需求相关的功能。\n参考：\n 未来已来：云原生 Cloud Native  梳理后端架构演化史，回顾后端架构发展历程； 回顾云服务发展历程，探讨云原生概念； 梳理云原生实现方案 Service Mesh 的发展历程； 介绍 Service Mesh 的代表 Istio 的亮眼功能；   畅谈云原生（上）：云原生应用应该是什么样子？ 云原生与无服务器架构是云计算的未来吗？—— 云计算的演进   Service Mesh vs Serverless #  Service Mesh 技术和 Serverless 技术是工作在不同纬度的两个技术：\n Service Mesh 技术的关注点在于服务间通讯，其目标是剥离客户端 SDK，为应用减负，提供的能力主要包括安全性、路由、策略执行、流量管理等。 Serverless 技术的关注点在于服务运维，目标是客户无需关注服务运维，提供服务实例的自动伸缩，以及按照实际使用付费。  理论上 Service Mesh 技术和 Serverless 技术并没有冲突的地方，可以结合使用。事实上目前业界也开始出现这个趋势，而融合的方式有两种：\n在 Serverless 中引入 Service Mesh #  典型如 Knative 项目和 Knative 的 Google Cloud 托管版本 Google Cloud Run，通过引入对容器的支持和使用 Istio，Knative 将 Serverless 的支持扩展到 Function 之外，在极大的扩展 Serverless 适用范围的前提下，也将服务间通讯的能力引入到 Serverless。\n在 Service Mesh 中引入 Serverless #  典型如 Google Traffic Director 产品，在提供 Service Mesh 各种能力的同时，支持按照流量自动伸缩服务的实例数量，从而融入了部分 Serverless 的特性。\n对于 Serverless 和 Service Mesh 的结合，我们展望未来形态：\n未来应该会出现一种新型服务模式，Serverless 和 Service Mesh 合二为一。只要将服务部署上来，就自动可以得到 Service Mesh 的服务间通讯能力和 Serverless 的无服务器运维。\nService Mesh 发展趋势：云原生中流砥柱（下）\n"});index.add({'id':394,'href':'/note-cs/docs/direction/se/arch/principle/','title':"原则",'section':"2.1.2 架构设计",'content':"架构设计原则 #   BASE 是追求 CAP 的可用性 (A) ACID 是追求 CAP 的一致性 (C)  "});index.add({'id':395,'href':'/note-cs/docs/direction/be/db/redis/basic/practice/','title':"实践",'section':"第一部分 基础入门",'content':"实践 #   注意点 #  用 SET, 别用 SETNX, SETEX, PSETEX #  Since the SET command options can replace SETNX, SETEX, PSETEX, it is possible that in future versions of Redis these three commands will be deprecated and finally removed.\n"});index.add({'id':396,'href':'/note-cs/docs/direction/embedded/basic/practice/','title':"实践",'section':"第一部分 基础入门",'content':"实践 #  "});index.add({'id':397,'href':'/note-cs/docs/direction/security/basic/practice/','title':"实践",'section':"第一部分 基础入门",'content':"实践 #  "});index.add({'id':398,'href':'/note-cs/docs/basic/os/type/','title':"操作系统类型",'section':"1.2 操作系统",'content':"操作系统类型 #  "});index.add({'id':399,'href':'/note-cs/docs/direction/se/arch/scene/circuit-breaker/','title':"熔断",'section':"场景",'content':"熔断 #  断路器\n进入熔断状态后，后续对该服务接口的调用不再经过网络，直接执行本地的默认方法，达到服务降级的效果。\n参考 #  "});index.add({'id':400,'href':'/note-cs/docs/basic/pl/ruby/advanced/frame/rainls/version/','title':"版本",'section':"Ruby on Rails",'content':"版本 #  历史版本 #  v6.0 #   v5.0 #  v5.2 #   v4.0 #   v3.0 #   v2.0 #  "});index.add({'id':401,'href':'/note-cs/docs/basic/pl/shell/spec/baidu/','title':"百度 Shell 编程规范",'section':"1.3.2 编程规范",'content':"百度 Shell 编程规范 #    本文档适用于 Bash 3.0 及以上版本，不包括 4.0 新增特性\n  文档是 Bash 编程规范，不是 POSIX Shell 编程规范\n  章节分类和内容组织依据 Google Shell Style Guide\n  参考文档\n Google Shell Style Guide Chromium Project Shell Style Guidelines     "});index.add({'id':402,'href':'/note-cs/docs/basic/os/type/android/basic/spec/','title':"编程规范",'section':"第一部分 基础入门",'content':"编程规范 #  "});index.add({'id':403,'href':'/note-cs/docs/basic/os/type/ios/basic/spec/','title':"编程规范",'section':"第一部分 基础入门",'content':"编程规范 #  "});index.add({'id':404,'href':'/note-cs/docs/basic/os/type/macos/basic/spec/','title':"编程规范",'section':"第一部分 基础入门",'content':"编程规范 #  "});index.add({'id':405,'href':'/note-cs/docs/basic/os/type/unix/basic/spec/','title':"编程规范",'section':"第一部分 基础入门",'content':"编程规范 #  "});index.add({'id':406,'href':'/note-cs/docs/basic/os/type/windows/basic/spec/','title':"编程规范",'section':"第一部分 基础入门",'content':"编程规范 #  "});index.add({'id':407,'href':'/note-cs/docs/skill/stream-media/onvif/discovery/','title':"设备发现",'section':"ONVIF",'content':"设备发现 #  我们传统的 Web Services 服务调用的模式都是这样的：客户端在设计时就预先知道目标服务的地址（IP 地址或者域名），客户端基于这个地址进行服务调用。\n那如果客户端预先不知道目标服务的地址该怎么办？\nWS-Discovery（全称为 Web Services Dynamic Discovery）标准就是用于解决该问题的，遵循该标准，客户端预先不知道目标服务地址的情况下，可以动态地探测到可用的目标服务，以便进行服务调用。这个过程就是「设备发现」的过程。\nWS-Discovery 模式 #  WS-Discovery 定义了两种模式：Ad hoc 模式和 Managed 模式。\nAd hoc 模式 #   Ad hoc 模式：客户端以多播 (multicast) 的形式往多播组 (multicast group) 发送一个 Probe（探测）消息搜寻目标服务，在该探测消息中，包含相应的搜寻条件。如果目标服务满足该条件，则直接将响应 ProbeMatch 消息（服务自身相关的信息，包括地址）回复给客户端。  Message Exchanges in an ad hoc mode. Message exchanges in an ad hoc mode in the presence of a Discovery Proxy. Managed 模式 #   Managed 模式：即代理模式。Ad hoc 模式有个局限性，只能局限于一个较小的网络。Managed 模式就是为了解决这个问题的，在 Managed 模式下，一个维护所有可用目标服务的中心发现代理（Discovery Proxy）被建立起来，客户端只需要将探测消息发送到该发现代理就可以得到相应的目标服务信息。  Message exchanges in a managed mode. 官方技术规范：http://docs.oasis-open.org/ws-dd/discovery/1.1/os/wsdd-discovery-1.1-spec-os.html\n 传输方式 #  TCP/IP 有三种传输方式：单播 (Unicast)、多播 (Multicast) 和广播 (Broadcast)，在 IPv6 领域还有另一种方式：任播 (Anycast)。\n单播 Unicast #  单播 (Unicast)：一对一，双向通信，目的地址是对方主机地址。网络上绝大部分的数据都是以单播的形式传输的。如收发邮件、浏览网页等。\n多播 Multicast #  多播 (Multicast)：也叫组播，一对多，单向通信，目的地址是多播地址，主机可以通过 IGMP 协议请求加入或退出某个多播组 (multicast group)，数据只会转发给有需要（已加入组）的主机，不影响其他不需要（未加入组）的主机。如网上视频会议、网上视频点播、IPTV 等。\n多播地址（Multicast Address）有很多，各个行业都不一样，IPC 摄像头用的是 239.255.255.250（端口 3702）。\n多播地址的范围和分类可以见官方 IANA（互联网地址分配机构） 的说明：IPv4 Multicast Address Space Registry。\nWS-Discovery 协议用到了多播。\n广播 Broadcast #  广播 (Broadcast)：一对所有，单向通信，目的地址是广播地址，整个网络中所有主机均可以收到（不管你是否需要），如 ARP 地址解析、GARP 数据包等。广播会被限制在局域网范围内，禁止广播数据穿过路由器，防止广播数据影响大面积的主机。\n参考：单播、多播（组播）和广播的区别\n IPC 搜索实现 #  实现 socket 编程（UDP），通过 sendto 往多播地址发送探测消息（Probe），再使用 recvfrom 接收 IPC 的应答消息（ProbeMatch）\n组播 IP 地址 #  组播也是一种 IP 包，也有源 IP 地址，目的 IP 地址，\n 源 IP 地址为组播源的服务器 IP 地址， 目的地址为一个特殊的 IP 地址， 它位于 224.0.0.0 - 239.255.255.255 中，  由于 224.0.0.0/24 用于本地链路，即一跳的组播， 239.0.0.0/8 为私有组播地址， 所以实际的可用于在互联网上组播地址是 225.0.0.0/8 - 238.0.0.0/8    参考：\n 组播 IP 地址到底是谁的 IP？  "});index.add({'id':408,'href':'/note-cs/docs/basic/pl/shell/grammer/','title':"语法",'section':"Shell",'content':"语法 #  符号 #  ${} # $* 将所有的引用变量视为一个整体 $* # $@ 则仍旧保留每个引用变量的区段观念 # item=$1, list=\u0026#34;${@:2}\u0026#34; $@ "});index.add({'id':409,'href':'/note-cs/docs/domain/cc/edge/','title':"边缘计算",'section':"3.1 云计算",'content':"边缘计算 #  边缘计算的业务本质是云计算在数据中心之外边缘节点的延伸和演进， 以“边云协同”和“边缘智能”为核心能力发展方向；\n软件平台需要考虑导入云理念、云架构、云技术，提供端到端实时和协同式智能、可信赖、可动态重置等能力；\n硬件平台需要考虑异构计算能力，如鲲鹏、昇腾、ARM、X86、GPU、NPU、FPGA 等。\n边缘计算系统的落地形态 #  边缘计算产业联盟（ECC）将边缘计算系统的落地形态归纳为以下三种：\n 云边缘 边缘云 边缘网关  云边缘 #  云边缘形态的边缘计算，是云服务在边缘侧的延伸，逻辑上仍是云服务， 主要的能力提供依赖于云服务或需要与云服务紧密协同。\n主要应用在公有云场景，如华为云提供的 IEF 解决方案、AWS 提供的 Greengrass 解决方案等均属于此类。\nIntelligent EdgeFabric 智能边缘平台\n边缘云 #  边缘云形态的边缘计算，是在边缘侧构建中小规模云服务能力， 边缘服务能力主要由边缘云提供；\n边缘云的管理调度能力由部署在中心云的系统完成。 如运营商 MEC、CDN 等均属于此类。\n边缘网关 #  边缘网关形态的边缘计算，以云化技术与能力重构原有嵌入式网关系统， 边缘网关在边缘侧提供协议/接口转换、边缘计算等能力， 部署在云侧的控制器提供边缘节点的资源调度、应用管理与业务编排等能力。\n边缘网关主要应用在工业联网和车联网等场景中。\n 边缘计算的 CROSS 价值 #  Connection #  联接的海量(Connection)\n网络是系统互联与数据采集传输的基石。 伴随联接设备数量的剧增，网络灵活扩展、低成本运维和可靠性保障面临巨大挑战。\nReal-time #  业务的实时性(Real-time)\n工业系统检测、控制、执行，新兴的 VR/AR 等应用的实时性高， 部分场景实时性要求在 10ms 以内甚至更低，如果数据分析和处理全部在云端实现，难以满足业务的实时性要求，严重影响终端客户的业务体验。\nOptimization #  数据的优化(Optimization)\n当前工业现场与物联网末端存在大量的多样化异构数据，需要通过数据优化实现数据的聚合、数据的统一呈现与开放，以灵活高效地服务于边缘应用的智能。\nSmart #  应用的智能性(Smart)\n业务流程优化、运维自动化与业务创新驱动应用走向智能，边缘侧智能能够带来显著的效率与成本优势。\nSecurity #  安全与隐私保护(Security)\n安全跨越云计算和边缘计算之间的纵深，需要实施端到端防护。 网络边缘侧由于更贴近万物互联的设备，访问控制与威胁防护的广度和难度因此大幅提升。 边缘侧安全主要包含设备安全、网络安全、数据安全与应用安全。 此外，关键数据的完整性、保密性，大量生产或人身隐私数据的保护也是安全领域需要重点关注的内容。\n 边缘计算在网络中的位置 #  为实现边缘计算，需要在更底层的网络节点增加计算和转发能力，运营商组网结构将逐步演进，边缘计算能力持续提升。\n边缘计算节点部署方式 #   MEC 网络的四大挑战 #  现场 MEC #  现场 MEC（部署在企业园区）是 5G MEC 带来的一个新应用场景\n5G MEC 位于企业园区机房里面，一般为运营商代建和代维。\n企业借助 5G MEC 系统进行生产控制、远程监控、物流管理和智慧安防等生产活动。\n很多生产业务对延迟有严格要求， 如远程塔吊控制信息流的端到端延迟要小于 18ms， 即生产设备（塔吊等）通过无线基站，IP RAN 网络，5G MEC 系统到企业应用系统（远程控制）的端到端通信要保证低延迟。 对运营商网络的要求是，企业园区内的 5G 基站和 5G MEC 系统之间的网络，以及 5G MEC 到企业网的连接都要保证低时延。\n现场 MEC 场景对运营商的接入网提出了新的挑战，需要接入网提供低延迟 SLA 保证和数据不出园区。\n5G 核心网下移 #  UPF 随 MEC 下移，带动 UPF 相关业务端口下移（如 N4，N6，N9, 5GC OAM 等接口）到 5G 移动承载网。\n4G 核心网是集中部署在省或国家骨干网上， 4G 核心网网元间接口是由骨干网提供 VPN 来互通的，和 4G 移动承载网（IP RAN）没有关系。\n5G UPF 业务接口对外可靠通信是 5G MEC 对移动承载网（IP RAN）的新要求。 有些运营商采用 5GC 控制面集中到大区域的部署方案，这导致一些业务接口（如 N4 和 5GC OAM 接口）通信需要跨越移动承载网和骨干网两个网段。 由于 UPF 的大量分布式部署，以及 UPF 业务接口互通关系的复杂性， 增加了 5G 移动承载网的业务流量模型复杂度和多点通信的网络覆盖范围（基本上是全网范围）， 在 4G 时代的 L2+L3 网络设计是在汇聚层以上提供多点通信能力的。 同时，一些业务接口有传输延迟要求，如 N6，N9 这样的数据接口，这需要承载网提供 SLA 保证。\n5G 核心网下移使无线核心网承载从骨干网延伸到移动承载网， 对运营商 5G MEC 移动承载网络提出了支持复杂多点通信和 SLA 保证的新挑战。\n边云协同 #  5G MEC 包括下沉的 5G 核心网网元 UPF，和（云）计算应用。\n5G MEC 的 UPF 需要和中心云里 5G 核心网的控制面和管理应用系统通信\nMEC 的无缝 FMC 业务 #  MEC 连接设备和应用系统的接入方式是多样的，可以是 5G 接入，也可以是固网接入（包括 xPON，专线，WiFi 等），通信目标是连接所有相关应用部件，共同提供一个完整的 MEC 应用，即提供无缝的 FMC（固移融合）业务应用。\nMEC 的接入网就可能包括移动承载网和固定承载网，需要连接两个城域网网络平面。\n同时，MEC 和中心云（5GC，运营商云，第三方云）及相关业务云（可能部署在固网 MAN 上）间的通信， 有些会通过移动承载网，有些会通过固定承载网。 MEC 网络不局限于移动承载网，MEC 网络连接可能会涉及移动承载和固网承载两个城域网平面，以及 IP 骨干网。\nMEC 对网络提出了 FMC 通信新挑战，特别对于拥有移动承载城域网和固定承载城域网双平面的运营商， 在网络架构和网络互通方面都提出了新挑战。 中国三大运营商都有两个城域网平面。\n 运营商网络的边缘计算破局关键点 #  ECNI 的边缘计算网络模型 #  边缘计算产业联盟 ECC 在 2019 年和网络 5.0 联合成立了边缘计算网络基础设施联合工作组（ECNI）， 是业界第一个聚焦边缘计算网络的产业组织。\n2019 年 11 月，ECNI 发布了“运营商边缘计算网络技术白皮书”，是业界首个有关运营商边缘计算网络的白皮书。 此白皮书提出了一个新的边缘计算网络抽象模型， 将边缘计算网络分为三个逻辑网段来描述\n  ECA（Edge Computing Access，边缘计算接入网络）\n从用户系统到 MEC 所经过的网络基础设施；\n  ECN（Edge Computing Network，边缘计算内部网络）\nMEC 内部网络基础设施\n  ECI（Edge Computing Interconnect，边缘计算互联网络）\n从 MEC 到云计算系统（如公有云、私有云、通信云、用户自建云等）、其它 MEC、各类数据中心所经过的网络基础设施；\n  MEC 在物理网络中的位置不同，ECA 和 ECI 在物理网络中的映射也不一样；ECI 可能跨运营商多个网段。因此，ECA/ECN/ECI 网络模式能更好地描述复杂的 MEC 网络和多样性物理网络间的关系，本文后续都会采用该抽象模型来表述 MEC 网络问题。\nECA：最短路径 #  运营商应该为从基站到 MEC UPF 的 N3 业务流提供最短传输路径，特别是在现场 MEC 场景， N3 业务流应该通过在园区里的移动承载网路由器直接把业务流转发给 MEC UPF，而不应该让 N3 业务流在运营商的网络中绕行。\nECA 和 ECI：低延迟切片 #  ECA 切片：完整的接入网切片系统包括无线基站、移动承载网（基站到 EC 间）和 UPF 系统，即企业业务流到 MEC 所经过的所有网元，涉及 5G 无线网、网络和 5G 核心网。ECA 切片是基站到 MEC 间的 IP 网络切片。\nECI 切片：MEC 系统和企业网、中心云和其它 MEC 系统间，由于业务需要保证 SLA 和安全可靠，需要切片网络来进行互连，有可能跨多网段。\nECI：灵活多点通信 #  ECI 网络需要支持 5G MEC 和 5G 核心网（N4，OAM）、其它 MEC 系统（N6，N9）、互联网出口（N6）、锚点 UPF（N9）、运营商云、企业网、第三方云（OTT）等进行业务通信。\nECN：集成网络架构 #  运营商网和企业网：MEC 安全和互通 #  运营商角度，5G MEC 里面有非运营商的应用和网络连接，如 MEC 直接和企业网互通，不是电信安全域；同时 MEC 改变了原来移动承载网 IP RAN 的业务承载封闭性。企业角度，业务数据和业务应用经过外网和外部 IT 系统，即经过了企业非安全区，并且企业网增加了和运营商网络的互通点。\n网络支持云边协同 #  5G MEC 网络需要支持 5G UPF 的自动部署和在线扩缩容，比如 UPF VNF 增加 VM 数量来提高性能，MEC 网络能动态接受业务需求，自动下发网络配置，保证 UPF 的快速在线扩容，即网络支持云边协同。在 MEP 平台上部署的边缘计算应用，如果和中心云相关，也需要边云协同通信。另外，按业务要求快速打通云边间 VPN 通道是支持云边协同的基本通信需求。\n 参考 #   [pdf]5g mec ip 网络白皮书 - huawei carrier  "});index.add({'id':410,'href':'/note-cs/docs/skill/stream-media/communication/','title':"通信技术",'section':"4.5 流媒体",'content':"通信技术 #  通信技术发展 #  1G #  现代移动通信的发展史可追溯到上个世纪 70 年代，贝尔实验室突破性的提出了蜂窝网络概念。\n所谓蜂窝网络，就是将网络划分为若干个相邻的小区，整体形状酷似蜂窝，以实现频率复用，提升系统容量。\n1G 时代作为移动通信开天辟地的时代，群雄逐鹿，山头林立，通信标准也是五花八门。\n尽管 1G 标准各式各样，但 1G 时代的王者非摩托罗拉莫属。\n摩托罗拉不仅发明了第一步模拟移动电话大哥大，而且还是 AMPS 系统的主要设备供应商。\n2G：GSM 与 CDMA 之争 #  1G 时代，以 AMPS 和 TACS 为代表的模拟移动通信系统取得了巨大成功， 但由于采用落后的模拟和频分复用（FDMA）技术，存在容量有限、系统太多、系统不兼容、通话质量差、易被窃听、设备昂贵、无法全球漫游等众多缺点。\n随着人们对移动通信的要求越来越高，业界提出向 2G 数字时代发展，以代替 1G 模拟通信。\n2G 时代主要采用数字时分多址（TDMA）和码分多址（CDMA）两种技术，分别对应 GSM 和 CDMA 系统，这是一场由美国和欧洲为代表的两大利益集团之间的竞争。\n如上所述，以 AMPS 和 TACS 为代表 1G 时代几乎被美国垄断，也意味着美国掌握了标准话语权和产业主动权。\n进入 2G 时代，欧洲不甘落后于美国，考虑到欧盟国家太小，单打独斗难以与美国抗衡，于是吸取了 1G 时代各自为政的失败教训，于是欧盟联合起来成立了 GSM，以快速形成规模向全球推广，在 2G 时代占据主导优势。\n2G 时代，欧洲 GSM 快速领先，促进了欧洲无线产业的崛起，也为欧洲带来了显著的经济利益。诺基亚和爱立信是首当其冲的受益者，在 2G 时代飞速发展成为全球领先的通信设备商和手机厂商。1993 年，爱立信占全球数字蜂窝设备市场的 60％，诺基亚一跃成为全球第二大手机供应商。2000 年，诺基亚的出口额占芬兰商品和服务总额的 24％。\n美国输了，输掉的不是技术，而是速度与规模，也输掉了一个时代。\n这也间接影响了摩托罗拉的竞争力，当数字移动电话渐渐取代模拟移动电话之时，摩托罗拉同样错估了模拟手机的寿命，也错过了 2G 数字时代。\n1997 年，摩托罗拉终于走下神坛，其全球移动电话市场份额从 1997 年的 50% 暴跌到 17%。持续了 20 年辉煌的摩托罗拉终于被来自欧洲的诺基亚击垮。\n时分多址（TDMA） #  欧洲 - 时分多址（TDMA） - GSM\n码分多址（CDMA） #  美国 - 码分多址（CDMA） - CDMA\nCDMA，即码分多址，它通过不同的扩频码来实现多用户在同一时间同一频率上共享。从技术上讲，CDMA 比 TDMA 更具优势。\n3G：鼎足三分 #  3G 时代主要有 WCDMA、CDMA2000、TD-SCDMA 三种标准。\n 欧洲 + 日本 - 3GPP - WCDMA 美国 + 韩国 - 3GPP2 - CDMA2000 中国 - TD-SCDMA  欧洲与日本等原推行 GSM 标准的国家联合起来成立了 3GPP 组织 (3rd Generation Partnership Project)，负责制定全球第三代通信标准。\n随后，3GPP 小心翼翼地参考 CDMA 技术，以尽量绕过高通的专利，开发出了原理类似的 WCDMA。\n高通也赶紧不落人后地与韩国联合组成 3GPP2 (3rd Generation Partnership Project 2) 与 3GPP 抗衡，推出了 CDMA2000。\n既然你们都有一套自己的标准，当然，咱们中国也不能落于人后，也搞了一个 TD-SCDMA。\n也就是，3G 时代形成了欧、美、中三足鼎立的格局，谁也不服谁。\n但真正的赢家是谁？从某种角度讲，最后的赢家既不是欧洲，也不是美国，而是视野之外的日本。\n4G：LTE 一统江湖 #  WiMax #  是基于 IEEE 802.16 标准集的一系列无线通信标准。WiMax 于 2001 年 6 月成立，旨在促进该标准的一致性和互操作性。\nWiMax 采用 OFDM+MIMO 技术，解决了多径干扰，提升了频谱效率，大幅地增加系统吞吐量及传送距离。今天的 4G LTE 也采用了这两大关键技术。\n自 3GPP 首版 4G LTE 标准于 2008 年 12 月完成且于 2009 年 12 月全球首商用成功后，全球多数移动运营商果断的选择了不投资 WiMax，而是静候 LTE 的到来。\nWiMax 失败了，尽管超前于 LTE，但超前一步的往往是烈士。\nLTE #  LTE 的全称叫 Long Term Evolution，即长期演进，我不知道当时为何取这样的名字，但今天看来，仿佛是 3GPP 在向 WiMax 联盟隔空喊话：喂，兄弟，我们是长期演进的哦，你行不？\n于是乎，自 2008 年 12 月前后，已感到前途无望的 WiMax 阵营们纷纷退出，开始转向 LTE。\n经历了无数波折，在 4G 时代，LTE 标准终于一统江湖。\n 5G #  5G 的优势：\n 速率方面：从 4G 的 100Mbps 为单位，5G 可高达 10Gps，比 4G 快达 100 倍，轻松看 3D 影片或 4K 电影； 容量与能耗方面：为了物联网 (IoT)、智慧家庭等应用，5G 网络将能容纳更多设备连接、同时维持低功耗的续航能力； 低时延方面：工业 4.0 智慧工厂、车联网、远程医疗等应用，都必须超低时延。  回顾移动通信的发展史，从生态规模来看，美国在 1G 时代领先，但从 2G 到 3G，美国整整落后了两个时代，4G 赶超机会本来渺茫，但随着智能手机的横空出世，美国迎来了弯道超车的转折点。\n苹果推出了 IOS，Google 推出了安卓操作系统，如今全球大部分智能手机都运行于 iOS 和安卓系统。\niOS 和安卓系统打败了 2G 时代的诺基亚，也彻底打败了 3G 时代的日本 i-mode 模式。诺基亚手机没落了，日本通讯产业链全线败退，NEC、东芝、三洋退出手机领域，索尼、夏普、京瓷、松下市场份额大幅下滑，留给 NEC 和富士通等电信设备的市场也只是极少的份额。\n美国花了两个时代一路追赶，有过深刻的教训，也尝到了甜头，现在 5G 来了，当然不甘错过这次大好机遇，他们已多次表示要争夺全球 5G 领导地位。\n美国认为，5G 时代是建立在无线基础设施上的一次史无前例的创新时代，5G 将连接工厂、汽车、无人机等万物，并在万物互联的基础上加速机器学习和人工智能部署。谁能领导 5G，谁就站在了未来的信息时代的制高点。\n然鹅，朗讯、摩托罗拉、北电等美系设备商已全军覆灭，美国拿什么领导 5G？\n华为在 LTE 市场份额上早已全球第一，中国企业早已加大研发 5G。美国在逐渐掉队，而中国正在引领 5G。\n尽管美国也有高通、思科等通信巨头，但他们只提供芯片和路由器，并不提供无线设备。\n6G #  参考：\n IM 开发者的零基础通信技术入门 (五)：1G 到 5G，30 年移动通信技术演进史  "});index.add({'id':411,'href':'/note-cs/docs/course/basic/pl/go/gobyexample/','title':"通过例子学 Golang",'section':"go",'content':"通过例子学 Golang #  mmcgrana/gobyexample 点击阅读：Go by Example\n中文翻译 #  gobyexample-cn/gobyexample 点击阅读：通过例子学 Golang\n学习进度 #   Hello World 值 变量 常量 For 循环 If/Else 分支 Switch 分支结构 数组 切片 Map Range 遍历 函数 多返回值 变参函数 闭包 递归 指针 结构体 方法 接口 错误处理 协程 通道 通道缓冲 通道同步 通道方向 通道选择器 超时处理 非阻塞通道操作 通道的关闭 通道遍历 Timer Ticker 工作池 WaitGroup 速率限制 原子计数器 互斥锁 状态协程 排序 使用函数自定义排序 Panic Defer 组合函数 字符串函数 字符串格式化 正则表达式 JSON XML 时间 时间戳 时间的格式化和解析 随机数 数字解析 URL 解析 SHA1 哈希 Base64 编码 读文件 写文件 行过滤器 文件路径 目录 临时文件和目录 单元测试 命令行参数 命令行标志 命令行子命令 环境变量 HTTP 客户端 HTTP 服务端 Context 生成进程 执行进程 信号 退出  "});index.add({'id':412,'href':'/note-cs/docs/skill/type/mobi/','title':"mobi",'section':"文档类型",'content':"mobi #  mobi vs azw3 #  "});index.add({'id':413,'href':'/note-cs/docs/domain/cc/others/paas/','title':"PaaS",'section':"其他",'content':"PaaS #  "});index.add({'id':414,'href':'/note-cs/docs/skill/type/azw3/','title':"azw3",'section':"文档类型",'content':"azw3 #  azw3 vs azw #  "});index.add({'id':415,'href':'/note-cs/docs/domain/cc/others/saas/','title':"SaaS",'section':"其他",'content':"SaaS #  "});index.add({'id':416,'href':'/note-cs/docs/basic/pl/erlang/','title':"Erlang",'section':"1.5 编程语言",'content':"Erlang 学习笔记 #  Erlang/OTP #  erlang/otp "});index.add({'id':417,'href':'/note-cs/docs/domain/cc/others/paas/gae/','title':"GAE",'section':"PaaS",'content':"Google App Engine #  "});index.add({'id':418,'href':'/note-cs/docs/book/basic/pl/go-advanced-programming/','title':"Go 语言高级编程",'section':"5.1.5 编程语言",'content':"Go 语言高级编程 #  \n作者 #  柴树杉 #  国内第一批的 Go 语言爱好者，Go 语言代码贡献者，CGO 资深用户。同时对 WebAssembly 技术有一定研究，著有《WebAssembly 标准入门》。Github 账号为 chai2010。\n曹春晖 #  在 Web 领域工作多年，开源爱好者。对大型网站系统的架构和相关工具的实现很感兴趣，并且有一些研究成果。目前在滴滴平台技术部工作。\n 在线阅读 #  chai2010/advanced-go-programming-book https://chai2010.cn/advanced-go-programming-book/\n 参考 #  "});index.add({'id':419,'href':'/note-cs/docs/basic/pl/r/','title':"R",'section':"1.5 编程语言",'content':"R 学习笔记 #  "});index.add({'id':420,'href':'/note-cs/docs/basic/pl/csharp/basic/grammar/keyword/','title':"1.1.2 关键字",'section':"1.1 语法",'content':"关键字 #  "});index.add({'id':421,'href':'/note-cs/docs/basic/pl/erlang/basic/grammar/keyword/','title':"1.1.2 关键字",'section':"1.1 语法",'content':"关键字 #  "});index.add({'id':422,'href':'/note-cs/docs/basic/pl/haskell/basic/grammar/keyword/','title':"1.1.2 关键字",'section':"1.1 语法",'content':"关键字 #  "});index.add({'id':423,'href':'/note-cs/docs/basic/pl/kotlin/basic/grammar/keyword/','title':"1.1.2 关键字",'section':"1.1 语法",'content':"关键字 #  "});index.add({'id':424,'href':'/note-cs/docs/basic/pl/lua/basic/grammar/keyword/','title':"1.1.2 关键字",'section':"1.1 语法",'content':"关键字 #  "});index.add({'id':425,'href':'/note-cs/docs/basic/pl/objective-c/basic/grammar/keyword/','title':"1.1.2 关键字",'section':"1.1 语法",'content':"关键字 #  "});index.add({'id':426,'href':'/note-cs/docs/basic/pl/r/basic/grammar/keyword/','title':"1.1.2 关键字",'section':"1.1 语法",'content':"关键字 #  "});index.add({'id':427,'href':'/note-cs/docs/basic/pl/ruby/basic/grammar/keyword/','title':"1.1.2 关键字",'section':"1.1 语法",'content':"关键字 #  "});index.add({'id':428,'href':'/note-cs/docs/basic/pl/scala/basic/grammar/keyword/','title':"1.1.2 关键字",'section':"1.1 语法",'content':"关键字 #  "});index.add({'id':429,'href':'/note-cs/docs/basic/pl/swift/basic/grammar/keyword/','title':"1.1.2 关键字",'section':"1.1 语法",'content':"关键字 #  "});index.add({'id':430,'href':'/note-cs/docs/basic/os/','title':"1.2 操作系统",'section':"第一部分 基础",'content':"操作系统 #  "});index.add({'id':431,'href':'/note-cs/docs/basic/pl/csharp/basic/std/','title':"1.2 标准库",'section':"第一部分 基础入门",'content':"标准库 #  "});index.add({'id':432,'href':'/note-cs/docs/basic/pl/erlang/basic/std/','title':"1.2 标准库",'section':"第一部分 基础入门",'content':"标准库 #  "});index.add({'id':433,'href':'/note-cs/docs/basic/pl/haskell/basic/std/','title':"1.2 标准库",'section':"第一部分 基础入门",'content':"标准库 #  "});index.add({'id':434,'href':'/note-cs/docs/basic/pl/kotlin/basic/std/','title':"1.2 标准库",'section':"第一部分 基础入门",'content':"标准库 #  "});index.add({'id':435,'href':'/note-cs/docs/basic/pl/lua/basic/std/','title':"1.2 标准库",'section':"第一部分 基础入门",'content':"标准库 #  "});index.add({'id':436,'href':'/note-cs/docs/basic/pl/objective-c/basic/std/','title':"1.2 标准库",'section':"第一部分 基础入门",'content':"标准库 #  "});index.add({'id':437,'href':'/note-cs/docs/basic/pl/r/basic/std/','title':"1.2 标准库",'section':"第一部分 基础入门",'content':"标准库 #  "});index.add({'id':438,'href':'/note-cs/docs/basic/pl/ruby/basic/std/','title':"1.2 标准库",'section':"第一部分 基础入门",'content':"标准库 #  "});index.add({'id':439,'href':'/note-cs/docs/basic/pl/scala/basic/std/','title':"1.2 标准库",'section':"第一部分 基础入门",'content':"标准库 #  "});index.add({'id':440,'href':'/note-cs/docs/basic/pl/swift/basic/std/','title':"1.2 标准库",'section':"第一部分 基础入门",'content':"标准库 #  "});index.add({'id':441,'href':'/note-cs/docs/basic/pl/shell/spec/','title':"1.3.2 编程规范",'section':"Shell",'content':"编程规范 #  "});index.add({'id':442,'href':'/note-cs/docs/direction/se/arch/','title':"2.1.2 架构设计",'section':"2.1 软件工程",'content':"架构设计 #  "});index.add({'id':443,'href':'/note-cs/docs/direction/be/','title':"2.2 后端",'section':"第二部分 方向",'content':"后端开发 #   教程 #  xingshaocheng/architect-awesome #  后端架构师技术图谱\n"});index.add({'id':444,'href':'/note-cs/docs/basic/pl/csharp/advanced/algs/','title':"2.2 算法实现",'section':"第二部分 进阶实战",'content':"算法实现 #  "});index.add({'id':445,'href':'/note-cs/docs/basic/pl/erlang/advanced/algs/','title':"2.2 算法实现",'section':"第二部分 进阶实战",'content':"算法实现 #  "});index.add({'id':446,'href':'/note-cs/docs/basic/pl/haskell/advanced/algs/','title':"2.2 算法实现",'section':"第二部分 进阶实战",'content':"算法实现 #  "});index.add({'id':447,'href':'/note-cs/docs/basic/pl/kotlin/advanced/algs/','title':"2.2 算法实现",'section':"第二部分 进阶实战",'content':"算法实现 #  "});index.add({'id':448,'href':'/note-cs/docs/basic/pl/lua/advanced/algs/','title':"2.2 算法实现",'section':"第二部分 进阶实战",'content':"算法实现 #  "});index.add({'id':449,'href':'/note-cs/docs/basic/pl/objective-c/advanced/algs/','title':"2.2 算法实现",'section':"第二部分 进阶实战",'content':"算法实现 #  "});index.add({'id':450,'href':'/note-cs/docs/basic/pl/r/advanced/algs/','title':"2.2 算法实现",'section':"第二部分 进阶实战",'content':"算法实现 #  "});index.add({'id':451,'href':'/note-cs/docs/basic/pl/ruby/advanced/algs/','title':"2.2 算法实现",'section':"第二部分 进阶实战",'content':"算法实现 #  "});index.add({'id':452,'href':'/note-cs/docs/basic/pl/scala/advanced/algs/','title':"2.2 算法实现",'section':"第二部分 进阶实战",'content':"算法实现 #  "});index.add({'id':453,'href':'/note-cs/docs/basic/pl/swift/advanced/algs/','title':"2.2 算法实现",'section':"第二部分 进阶实战",'content':"算法实现 #  raywenderlich/swift-algorithm-club #  Algorithms and data structures in Swift, with explanations!\n"});index.add({'id':454,'href':'/note-cs/docs/direction/be/db/redis/','title':"2.2.1.2 Redis",'section':"2.2.1 数据库",'content':"Redis #  redis/redis "});index.add({'id':455,'href':'/note-cs/docs/direction/fe/css/','title':"2.2.2 CSS",'section':"2.3 前端",'content':"CSS #  "});index.add({'id':456,'href':'/note-cs/docs/direction/be/mq/','title':"2.2.2 消息队列",'section':"2.2 后端",'content':"消息队列 #  ZeroMQ 和 RabbitMQ/Kafka 不同，它只是一个异步消息库，在套接字的基础上提供了类似于消息代理的机制。使用 ZeroMQ 的话，需要对自己的业务代码进行改造，不利于服务解耦。\nRabbitMQ 支持 AMQP（二进制），STOMP（文本），MQTT（二进制），HTTP（里面包装其他协议）等协议。Kafka 使用自己的协议。\nKafka 自身服务和消费者都需要依赖 Zookeeper。\nRabbitMQ 在有大量消息堆积的情况下性能会下降，Kafka 不会。毕竟 AMQP 设计的初衷不是用来持久化海量消息的，而 Kafka 一开始是用来处理海量日志的。\n在同步发送场景中，三个消息中间件的表现区分明显：\n Kafka 的吞吐量高达 17.3w/s，不愧是高吞吐量消息中间件的行业老大。这主要取决于它的队列模式保证了写磁盘的过程是线性 IO。此时 broker 磁盘 IO 已达瓶颈。 RocketMQ 也表现不俗，吞吐量在 11.6w/s，磁盘 IO % util 已接近 100%。RocketMQ 的消息写入内存后即返回 ack，由单独的线程专门做刷盘的操作，所有的消息均是顺序写文件。 RabbitMQ 的吞吐量 5.95w/s，CPU 资源消耗较高。它支持 AMQP 协议，实现非常重量级，为了保证消息的可靠性在吞吐量上做了取舍。我们还做了 RabbitMQ 在消息持久化场景下的性能测试，吞吐量在 2.6w/s 左右。  在服务端处理同步发送的性能上，Kafka \u0026gt; RocketMQ \u0026gt; RabbitMQ。\n参考：\n Kafka、RabbitMQ、RocketMQ 消息中间件的对比 —— 消息发送性能   常见消息队列实现 #  apache/kafka #  apache/rocketmq #  阿里 RocketMQ 是站在巨人的肩膀上（kafka）\nrabbitmq/rabbitmq-server #  apache/activemq #   ZeroMQ #  zeromq/libzmq #  ZeroMQ core engine in C++, implements ZMTP/3.1\nzeromq/jeromq #  Pure Java ZeroMQ\nzeromq/netmq #  A 100% native C# implementation of ZeroMQ for .NET\nzeromq/pyzmq #  PyZMQ: Python bindings for zeromq\n 参考 #   RabbitMQ, ZeroMQ, Kafka 是一个层级的东西吗？  "});index.add({'id':457,'href':'/note-cs/docs/direction/be/mq/rocketmq/','title':"2.2.2.2 RocketMQ",'section':"2.2.2 消息队列",'content':"RocketMQ #  apache/rocketmq "});index.add({'id':458,'href':'/note-cs/docs/direction/fe/frame/react/','title':"2.2.3.2 React",'section':"2.2.3 框架",'content':"React #  "});index.add({'id':459,'href':'/note-cs/docs/direction/be/distributed/paxos/','title':"2.2.4.2 Paxos",'section':"2.2.4 分布式系统",'content':"Paxos #  Paxos 算法是分布式技术大师 Lamport 提出的，主要目的是通过这个算法，让参与分布式处理的每个参与者逐步达成一致意见。\nLamport 为了讲述这个算法，假想了一个叫做 Paxos 的希腊城邦进行选举的情景，这个算法也是因此而得名。 由于城邦的居民没有人愿意把全部时间和精力放在这种事情上，所以他们只能不定时的来参加提议，不定时来了解提议、投票进展，不定时的表达自己的投票意见。 Paxos 算法的目标就是让他们按照少数服从多数的方式，最终达成一致意见。\n算法过程 #   先明确哪个 “提议者” 是意见领袖有权提出提议，未来，“接受者” 们就主要处理这个 “提议者” 的提议了 选出的意见领袖提出提议，“接受者” 反馈意见。如果多数 “接受者” 接受了一个提议，那么提议就通过了   参考 #   如何浅显易懂地解说 Paxos 的算法？  "});index.add({'id':460,'href':'/note-cs/docs/direction/be/microservices/rpc/grpc/','title':"2.2.5.1.2 gRPC",'section':"2.2.5.1 RPC",'content':"gRPC #  grpc-go #  grpc/grpc-go The Go language implementation of gRPC. HTTP/2 based RPC\ngrpc-web #  grpc/grpc-web gRPC for Web Clients\n"});index.add({'id':461,'href':'/note-cs/docs/direction/client/ios/','title':"2.4.2 iOS",'section':"2.4 客户端",'content':"iOS #  "});index.add({'id':462,'href':'/note-cs/docs/basic/pl/csharp/code/keyword/','title':"3.2 关键字",'section':"第三部分 设计与实现",'content':"关键字 #  "});index.add({'id':463,'href':'/note-cs/docs/basic/pl/erlang/code/keyword/','title':"3.2 关键字",'section':"第三部分 设计与实现",'content':"关键字 #  "});index.add({'id':464,'href':'/note-cs/docs/basic/pl/haskell/code/keyword/','title':"3.2 关键字",'section':"第三部分 设计与实现",'content':"关键字 #  "});index.add({'id':465,'href':'/note-cs/docs/basic/pl/kotlin/code/keyword/','title':"3.2 关键字",'section':"第三部分 设计与实现",'content':"关键字 #  "});index.add({'id':466,'href':'/note-cs/docs/basic/pl/lua/code/keyword/','title':"3.2 关键字",'section':"第三部分 设计与实现",'content':"关键字 #  "});index.add({'id':467,'href':'/note-cs/docs/basic/pl/objective-c/code/keyword/','title':"3.2 关键字",'section':"第三部分 设计与实现",'content':"关键字 #  "});index.add({'id':468,'href':'/note-cs/docs/basic/pl/r/code/keyword/','title':"3.2 关键字",'section':"第三部分 设计与实现",'content':"关键字 #  "});index.add({'id':469,'href':'/note-cs/docs/basic/pl/ruby/code/keyword/','title':"3.2 关键字",'section':"第三部分 设计与实现",'content':"关键字 #  "});index.add({'id':470,'href':'/note-cs/docs/basic/pl/scala/code/keyword/','title':"3.2 关键字",'section':"第三部分 设计与实现",'content':"关键字 #  "});index.add({'id':471,'href':'/note-cs/docs/basic/pl/swift/code/keyword/','title':"3.2 关键字",'section':"第三部分 设计与实现",'content':"关键字 #  "});index.add({'id':472,'href':'/note-cs/docs/domain/bigdata/','title':"3.2 大数据",'section':"第三部分 领域",'content':"大数据 #  教程 #  data-scientist-roadmap #  MrMimic/data-scientist-roadmap I just found this data science skills roadmap, drew by Swami Chandrasekaran on his cool blog.\n"});index.add({'id':473,'href':'/note-cs/docs/basic/os/type/android/appendix/interview/','title':"4.2 面试题",'section':"第四部分 附录",'content':"面试题 #  基础题 #  进阶题 #  "});index.add({'id':474,'href':'/note-cs/docs/basic/os/type/ios/appendix/interview/','title':"4.2 面试题",'section':"第四部分 附录",'content':"面试题 #  基础题 #  进阶题 #  "});index.add({'id':475,'href':'/note-cs/docs/basic/os/type/macos/appendix/interview/','title':"4.2 面试题",'section':"第四部分 附录",'content':"面试题 #  基础题 #  进阶题 #  "});index.add({'id':476,'href':'/note-cs/docs/basic/os/type/unix/appendix/interview/','title':"4.2 面试题",'section':"第四部分 附录",'content':"面试题 #  基础题 #  进阶题 #  "});index.add({'id':477,'href':'/note-cs/docs/basic/os/type/windows/appendix/interview/','title':"4.2 面试题",'section':"第四部分 附录",'content':"面试题 #  基础题 #  进阶题 #  "});index.add({'id':478,'href':'/note-cs/docs/basic/pl/csharp/appendix/interview/','title':"4.2 面试题",'section':"第四部分 附录",'content':"面试题 #  基础题 #  进阶题 #  "});index.add({'id':479,'href':'/note-cs/docs/basic/pl/erlang/appendix/interview/','title':"4.2 面试题",'section':"第四部分 附录",'content':"面试题 #  基础题 #  进阶题 #  "});index.add({'id':480,'href':'/note-cs/docs/basic/pl/haskell/appendix/interview/','title':"4.2 面试题",'section':"第四部分 附录",'content':"面试题 #  基础题 #  进阶题 #  "});index.add({'id':481,'href':'/note-cs/docs/basic/pl/kotlin/appendix/interview/','title':"4.2 面试题",'section':"第四部分 附录",'content':"面试题 #  基础题 #  进阶题 #  "});index.add({'id':482,'href':'/note-cs/docs/basic/pl/lua/appendix/interview/','title':"4.2 面试题",'section':"第四部分 附录",'content':"面试题 #  基础题 #  进阶题 #  "});index.add({'id':483,'href':'/note-cs/docs/basic/pl/objective-c/appendix/interview/','title':"4.2 面试题",'section':"第四部分 附录",'content':"面试题 #  基础题 #  进阶题 #  "});index.add({'id':484,'href':'/note-cs/docs/basic/pl/r/appendix/interview/','title':"4.2 面试题",'section':"第四部分 附录",'content':"面试题 #  基础题 #  进阶题 #  "});index.add({'id':485,'href':'/note-cs/docs/basic/pl/ruby/appendix/interview/','title':"4.2 面试题",'section':"第四部分 附录",'content':"面试题 #  基础题 #  进阶题 #  "});index.add({'id':486,'href':'/note-cs/docs/basic/pl/scala/appendix/interview/','title':"4.2 面试题",'section':"第四部分 附录",'content':"面试题 #  基础题 #  进阶题 #  "});index.add({'id':487,'href':'/note-cs/docs/basic/pl/swift/appendix/interview/','title':"4.2 面试题",'section':"第四部分 附录",'content':"面试题 #  基础题 #  进阶题 #  "});index.add({'id':488,'href':'/note-cs/docs/direction/be/db/mysql/appendix/interview/','title':"4.2 面试题",'section':"第四部分 附录",'content':"面试题 #  基础题 #  进阶题 #  "});index.add({'id':489,'href':'/note-cs/docs/direction/be/db/postgresql/appendix/interview/','title':"4.2 面试题",'section':"第四部分 附录",'content':"面试题 #  基础题 #  进阶题 #  "});index.add({'id':490,'href':'/note-cs/docs/direction/be/db/redis/appendix/interview/','title':"4.2 面试题",'section':"第四部分 附录",'content':"面试题 #  基础题 #  进阶题 #  "});index.add({'id':491,'href':'/note-cs/docs/direction/be/platform/nodejs/appendix/interview/','title':"4.2 面试题",'section':"第四部分 附录",'content':"面试题 #  基础题 #  进阶题 #  "});index.add({'id':492,'href':'/note-cs/docs/direction/client/android/appendix/interview/','title':"4.2 面试题",'section':"第四部分 附录",'content':"面试题 #  基础题 #  进阶题 #  "});index.add({'id':493,'href':'/note-cs/docs/direction/client/ios/appendix/interview/','title':"4.2 面试题",'section':"第四部分 附录",'content':"面试题 #  基础题 #  进阶题 #  "});index.add({'id':494,'href':'/note-cs/docs/direction/client/xiaochengxu/appendix/interview/','title':"4.2 面试题",'section':"第四部分 附录",'content':"面试题 #  基础题 #  进阶题 #  "});index.add({'id':495,'href':'/note-cs/docs/direction/embedded/appendix/interview/','title':"4.2 面试题",'section':"第四部分 附录",'content':"面试题 #  基础题 #  进阶题 #  "});index.add({'id':496,'href':'/note-cs/docs/direction/fe/frame/angular/appendix/interview/','title':"4.2 面试题",'section':"第四部分 附录",'content':"面试题 #  基础题 #  进阶题 #  "});index.add({'id':497,'href':'/note-cs/docs/direction/fe/frame/react/appendix/interview/','title':"4.2 面试题",'section':"第四部分 附录",'content':"面试题 #  基础题 #  进阶题 #  "});index.add({'id':498,'href':'/note-cs/docs/direction/fe/frame/vue/appendix/interview/','title':"4.2 面试题",'section':"第四部分 附录",'content':"面试题 #  基础题 #  进阶题 #  "});index.add({'id':499,'href':'/note-cs/docs/direction/security/appendix/interview/','title':"4.2 面试题",'section':"第四部分 附录",'content':"面试题 #  基础题 #  进阶题 #  "});index.add({'id':500,'href':'/note-cs/docs/skill/stream-media/communication/4g/','title':"4G",'section':"通信技术",'content':"4G #  "});index.add({'id':501,'href':'/note-cs/docs/book/basic/os/','title':"5.1.2 操作系统",'section':"5.1 计算机基础",'content':"操作系统 #  "});index.add({'id':502,'href':'/note-cs/docs/book/be/','title':"5.2 后端",'section':"第五部分 读书",'content':"后端 #  "});index.add({'id':503,'href':'/note-cs/docs/skill/stream-media/communication/5g/','title':"5G",'section':"通信技术",'content':"5G #  5G 速度 #  世界上最快的 4G 网速（挪威，63.13Mbps）\n最快的宽带网速（新加坡，189Mbps）\n2019 年 1 月 24 日，华为发布业界标杆 5G 多模终端芯片巴龙 5000\n在 5G 峰值下载速率是 4G LTE 可体验速率的 10 倍\n5G 应用场景 #  国际电信联盟无线电通信局（ITU-R）定义了 5G 的三大典型应用场景为：\n 增强型移动宽带（eMBB） 超可靠低时延通信（uRLLC） 海量大规模连接物联网（mMTC）  增强型移动宽带（eMBB） #  eMBB 主要面向虚拟现实（VR）/ 增强现实（AR）、在线 4K 视频等高带宽需求业务\n超可靠低时延通信（uRLLC） #  mMTC 主要面向智慧城市、智能交通等高连接密度需求的业务\n海量大规模连接物联网（mMTC） #  uRLLC 主要面向车联网、无人驾驶、无人机等时延敏感的业务。\n 5G 架构 #  5G 核心网采用控制面（SMF：Session Management Function）和用户面 UPF 分离的 CUPS（Control and User Plane Separation ）架构\n5G 控制面集中部署，一个控制面（SMF）可以同时管理很多个 UPF 而不影响 5G 核心网的性能； 5G 用户面分散部署，UPF 可以按需灵活分布部署，部署到网络边缘支持边缘计算。\nUE 的不同业务，可以引导到本地 UPF（比如企业应用），或直接引导到锚点 UPF（普通的上网业务）， 中间可以动态插入 UL CL 进行按需动态分流。\n因此，在企业园区里面的基站，是可以同时支持本地企业应用和个人普通上网应用。\n UL CL (Uplink Classifier 上行链路分类器)  SMF #  Session Management Function\nUPF #  5G 用户面 UPF（User Plane Function）的下沉和灵活部署实现了数据流量本地卸载。\nCUPS #  MEP #  5G MEC 给运营商进入垂直行业带来了新的业务场景和商业模式。 运营商一般是用代建代维方式， 将 5G MEC 部署到企业园区，提供边缘云计算服务， 包括 IaaS，PaaS（即 MEP 平台），以及 SaaS（结合运营商的云计算服务）等更多的增值服务，\n收益从管道转向软件和服务。\n这样，运营商能深入垂直行业的 ICT 系统及应用领域，更好地为企业数字化、网络化和智能化提供全套的 ICT 服务和云计算应用，提供的业务比传统的企业专线业务，更深入全面和有客户粘性。 这就是为什么运营商都在积极拓展 5G MEC 企业业务的原因，得 5G MEC 服务者得企业客户。\nETSI #  欧洲电信标准研究所（ETSI）在 2014 年成立 MEC 工业专业组，关注运营商边缘计算的标准和工业使能， 并且在 2016 年，将 MEC 的定义从移动边缘计算（Mobile Edge Computing）改为外延更广的多接入边缘计算（Multi-Access Edge Computing）； 在运营商领域，MEC 一般被用来指代边缘计算系统。 在 5G 时代，MEC 是运营商助力垂直行业数字化和智能化的新应用模式。\n 5G 技术 #  5G 承载网 #  在无线侧有大量新技术实现对不同应用场景的支撑，但传输网络侧，硬件技术提升有限的情况下，需要对网络架构进行革新。\n5G 承载整体要求 #  5G 承载组网架构 #  多样化网络需求 #  边缘计算技术就是解决不同应用带来的多样化网络需求的核心技术之一\n在靠近接入网的机房增加计算能力，将能够\n 大幅降低业务时延 减少对传输网的带宽压力降低传输成本 进一步提高内容分发效率提升用户体验  传统网络结构中，信息的处理主要位于核心网的数据中心机房内，所有信息必须从网络边缘传输到核心网进行处理之后再返回网络边缘。\n5G 时代，传输网架构中引入边缘计算技术，在靠近接入侧的边缘机房部署网关、服务器等设备，增加计算能力，将低时延业务、局域性数据、低价值量数据等数据在边缘机房进行处理和传输，不需要通过传输网返回核心网，进而降低时延、减少回传压力、提升用户体验。\n 5G 应用 #  底层网络进步带来应用和商业模式的升级\n 4G vs 5G #  4G 核心网是集中部署模式，一般是一个省（或大区）部署一个 4G 核心网， 所以 4G 承载网的流量模型是南北向为主， 运营商倾向于采用比较简单的接入网设计， 如很多运营商采用 L2（VPN）+L3（VPN）组网模式，即接入网采用相对简单的 L2 VPN 网络。\n在 4G 时代，这些无线核心网流量是在 IP 骨干网上而不是在移动承载网上来承载的。\n5G 核心网是 CUPS 架构， 控制面集中部署，一般是一个省或一个大区部署一个， 而 UPF 是分布式部署的，一般一个城市会部署一个锚点 UPF（Anchor UPF）和很多 MEC UPF。\n5G MEC 经常连接到接入网（如现场 MEC），增加了对 5G 移动承载网接入网的功能要求\n5G MEC 网络需要一个功能更强大、支持企业业务的网络架构和方案，不能是 4G 现有移动承载网架构的简单带宽升级。\n"});index.add({'id':504,'href':'/note-cs/docs/course/basic/os/','title':"6.1.2 操作系统",'section':"6.1 计算机基础",'content':"操作系统 #  "});index.add({'id':505,'href':'/note-cs/docs/course/be/','title':"6.2 后端",'section':"第六部分 课程",'content':"后端 #  "});index.add({'id':506,'href':'/note-cs/docs/direction/se/arch/principle/acid/','title':"ACID",'section':"原则",'content':"ACID #   In computer science, ACID (atomicity, consistency, isolation, durability) is a set of properties of database transactions intended to guarantee validity even in the event of errors, power failures, etc. In the context of databases, a sequence of database operations that satisfies the ACID properties (and these can be perceived as a single logical operation on the data) is called a transaction.\n  ACID，是指数据库管理系统（DBMS）在写入或更新资料的过程中，为保证事务（transaction）是正确可靠的，所必须具备的四个特性：\n 原子性（Atomicity 又称不可分割性）  一个事务（transaction）中的所有操作，或者全部完成，或者全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。即，事务不可分割、不可约简。   一致性（Consistency）  在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设约束、触发器、级联回滚等。   隔离性（Isolation，又称独立性）  数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括未提交读（Read uncommitted）、提交读（read committed）、可重复读（repeatable read）和串行化（Serializable）。   持久性（Durability）  事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。     "});index.add({'id':507,'href':'/note-cs/docs/skill/stream-media/lorawan/chirpstack/application/','title':"Application",'section':"ChirpStack",'content':"ChirpStack Application Server #  ChirpStack Application Server is an open-source LoRaWAN application-server. https://www.chirpstack.io\n数据库 #     Schema Name Type Owner     public application table chirpstack_as   public application_id_seq sequence chirpstack_as   public code_migration table chirpstack_as   public device table chirpstack_as   public device_activation table chirpstack_as   public device_activation_id_seq sequence chirpstack_as   public device_keys table chirpstack_as   public device_multicast_group table chirpstack_as   public device_profile table chirpstack_as   public fuota_deployment table chirpstack_as   public fuota_deployment_device table chirpstack_as   public gateway table chirpstack_as   public gateway_ping table chirpstack_as   public gateway_ping_id_seq sequence chirpstack_as   public gateway_ping_rx table chirpstack_as   public gateway_ping_rx_id_seq sequence chirpstack_as   public gateway_profile table chirpstack_as   public gorp_migrations table chirpstack_as   public integration table chirpstack_as   public integration_id_seq sequence chirpstack_as   public multicast_group table chirpstack_as   public network_server table chirpstack_as   public network_server_id_seq sequence chirpstack_as   public organization table chirpstack_as   public organization_id_seq sequence chirpstack_as   public organization_user table chirpstack_as   public organization_user_id_seq sequence chirpstack_as   public remote_fragmentation_session table chirpstack_as   public remote_multicast_class_c_session table chirpstack_as   public remote_multicast_setup table chirpstack_as   public service_profile table chirpstack_as   public user table chirpstack_as   public user_id_seq sequence chirpstack_as    (33 rows)\n"});index.add({'id':508,'href':'/note-cs/docs/direction/se/arch/principle/base/','title':"BASE",'section':"原则",'content':"BASE #  Basically Available, Soft state, Eventual consistency\nBASE 理论是 CAP 理论中的 AP 的延伸，是对互联网大规模分布式系统的实践总结，强调可用性。\n基本可用 #   流量削峰  在不同的时间，出售不同区域的票，将访问请求错开，削弱请求峰值   延迟响应  在春运期间，自己提交的购票请求，往往会在队列中排队等待处理，可能几分钟或十几分钟后，系统才开始处理，然后响应处理结果   体验降级  比如用小图片来替代原始图片，通过降低图片的清晰度和大小，提升系统的处理能力。   过载保护  把接收到的请求放在指定的队列中排队处理，如果请求等待时间超时了（假设是 100ms），这个时候直接拒绝超时请求；再比如队列满了之后，就清除队列中一定数量的排队请求，保护系统不过载，实现系统的基本可用。    最终的一致 #   读时修复：在读取数据时，检测数据的不一致，进行修复。  比如 Cassandra 的 Read Repair 实现，具体来说，在向 Cassandra 系统查询数据的时候，如果检测到不同节点的副本数据不一致，系统就自动修复数据。   写时修复：在写入数据，检测数据的不一致时，进行修复。  比如 Cassandra 的 Hinted Handoff 实现。具体来说，Cassandra 集群的节点之间远程写数据的时候，如果写失败就将数据缓存下来，然后定时重传，修复数据的不一致性。 写时修复不需要做数据一致性对比，性能消耗比较低，对系统运行影响也不大，推荐在实现最终一致性时优先实现这种方式。   异步修复：这个是最常用的方式，通过定时对账检测副本数据的一致性，并修复。   "});index.add({'id':509,'href':'/note-cs/docs/basic/os/cpu/','title':"CPU",'section':"1.2 操作系统",'content':"CPU #  L1 Cache #  Intel Core i7 的组织结构：\n"});index.add({'id':510,'href':'/note-cs/docs/direction/security/basic/csrf/','title':"CSRF",'section':"第一部分 基础入门",'content':"CSRF #   参考 #   前端安全系列（二）：如何防止 CSRF 攻击？  "});index.add({'id':511,'href':'/note-cs/docs/direction/be/search/elasticsearch/','title':"Elasticsearch",'section':"搜索引擎",'content':"Elasticsearch #  Open Source, Distributed, RESTful Search Engine https://www.elastic.co/products/elasticsearch\n"});index.add({'id':512,'href':'/note-cs/docs/direction/be/frame/python/flask/','title':"flask",'section':"Python 框架",'content':"flask #  教程 #  realpython/discover-flask #  Full Stack Web Development with Flask.\n   Part Title Git Tag     1 Setting Up a Static Site (blog post) part1   2 Creating a login page (blog post) part2   3 User Authentication part3   4 Template Inheritance part4   5 Databases part5   6 List Comprehensions N/A   7 Unit Tests part7   8 Deploying to Heroku part8   9 SQLAlchemy part9   10 Configuration part10   11 Secret Key part11   12 Heroku Configuration Settings part12   13 Heroku Postgres Setup part13   14 Local PostgreSQL Setup part14   15 Managing Database Migrations part15   16 Database Downgrades with Flask-Migrate/Alembic part16   17 Virtualenvwrapper part17   18 Password Hashing part18   19 Blueprints part19   20 Blueprints Redux part20   21 User Authentication (part 2) part21   22 Unit Testing with Flask-Testing part22   23 Session Management with Flask-Login part23   24 Testing User Login and Logout part24   25 User Registration (functionality and unit tests) part25   26 Finalize Messaging System part26   27 Test Coverage with coverage.py part27   28 Flask Testing! part28   29 Flask Testing (increase test coverage) part29   30 Continuous Integration part30     "});index.add({'id':513,'href':'/note-cs/docs/basic/pl/go/','title':"Go",'section':"1.5 编程语言",'content':"Go 学习笔记 #  见：Go 学习笔记\n"});index.add({'id':514,'href':'/note-cs/docs/skill/stream-media/stream-media/h264/','title':"H264",'section':"流媒体技术",'content':"H264 #  H.264，又称为 MPEG-4 第 10 部分，高级视频编码（英语： MPEG-4 Part 10, Advanced Video Coding ，缩写为 MPEG-4 AVC）是一种面向块，基于运动补偿的视频编码标准（英语：Advanced Video Coding） 。\nAVC 和 XviD 都属于 MPEG-4 编码，但由于 AVC 属于 MPEG-4 Part 10，在技术特性上比属于 MPEG-4 Part2 的 XviD 要先进。\n它和 ITU-T H.264 标准是一致的，故又称为 H.264。\n裸流 #  H.264 原始码流（又称为 “裸流”）是由一个一个的 NALU 组成的。\nH264 码流可以分为两层\n VCL 层 NAL 层（Network abstraction layer, 叫网络抽象层），保存了 H264 相关的参数信息和图像信息  NAL 层由多个单元 NALU 组成    NALU #  NALU (NAL Units) 组成\n NALU 头（00 00 00 01 或者 00 00 01） sps (序列参数集) pps (图像参数集合) slice sei IDR 帧 I 帧（在图像运动变化较少时，I 帧后面是 7 个 P 帧，如果图像运动变化大时，一个序列就短了，I 帧后面可能是 3 个或者 4 个 P 帧） P 帧 B 帧等数据。  一个完整的 NALU 单元结构图\n参考：\n H.264 码流结构 (H.264 Data Structure)   其他 #  ITU-T #  国际电信联盟电信标准化部门（英语： ITU Telecommunication Standardization Sector，缩写 ITU-T ）是国际电信联盟管理下的专门制定远程通信相关国际标准的组织。该机构创建于 1993 年，前身是国际电报电话咨询委员会（法语： Comité Consultatif International Téléphonique et Télégraphique，英语：International Telegraph and Telephone Consultative Committee，缩写：CCITT ），总部设在瑞士日内瓦。\n由 ITU-T 指定的国际标准通常被称为 “建议书”（Recommendations），ITU-T 的各种建议书的分类由一个首字母来代表，称为系列，每个系列的建议书除了分类字母以外还有一个编号，例如 “V.90”。\n"});index.add({'id':515,'href':'/note-cs/docs/domain/cc/others/paas/heroku/','title':"Heroku",'section':"PaaS",'content':"Heroku #  "});index.add({'id':516,'href':'/note-cs/docs/skill/stream-media/stream-media/hls/','title':"HLS",'section':"流媒体技术",'content':"HLS #  HTTP Live Streaming\n"});index.add({'id':517,'href':'/note-cs/docs/skill/stream-media/stream-media/http-flv/','title':"HTTP FLV",'section':"流媒体技术",'content':"HTTP FLV #  Bilibili/flv.js #  HTML5 FLV Player\n"});index.add({'id':518,'href':'/note-cs/docs/direction/be/frame/java/','title':"Java 框架",'section':"2.2.3 后端框架",'content':"Java 框架 #  "});index.add({'id':519,'href':'/note-cs/docs/direction/be/auth/jwt/','title':"JWT",'section':"认证与授权",'content':"JWT #  JSON Web Tokens\n背景 #   JWT 原理 #  JWT 结构 #  JWT 由 Header, Payload, Signature 三部分组成\nconst token = base64urlEncoding(header) + '.' + base64urlEncoding(payload) + '.' + base64urlEncoding(signature)\neyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJsb2dnZWRJbkFzIjoiYWRtaW4iLCJpYXQiOjE0MjI3Nzk2Mzh9.gzSraSYS8EXBxLN_oWnFSRgCzcmJmMjLiuyu5CSpyHI\n  Header\n{ \u0026quot;alg\u0026quot; : \u0026quot;HS256\u0026quot;, \u0026quot;typ\u0026quot; : \u0026quot;JWT\u0026quot; }   Payload\n{ \u0026quot;loggedInAs\u0026quot; : \u0026quot;admin\u0026quot;, \u0026quot;iat\u0026quot; : 1422779638 }   Signature\nHMAC-SHA256( base64urlEncoding(header) + '.' + base64urlEncoding(payload), secret )   Authorization: Bearer eyJhbGci...\u0026lt;snip\u0026gt;...yu5CSpyHI\n JWT 优缺点 #  优点 #   JWT 把数据存储在客户端，服务端不需要存储  缺点 #   JWT 的 Token 无法主动失效   JWT 适用场景 #   参考 #   阮一峰：JSON Web Token 入门教程  "});index.add({'id':520,'href':'/note-cs/docs/direction/be/frame/php/laravel/','title':"Laravel",'section':"PHP 框架",'content':"Laravel #  "});index.add({'id':521,'href':'/note-cs/docs/direction/be/db/redis/source/type/list/','title':"List 实现",'section':"类型实现",'content':"Redis List 类型实现 #   参考 #   5 种基本数据结构  "});index.add({'id':522,'href':'/note-cs/docs/direction/be/search/lucene/','title':"Lucene",'section':"搜索引擎",'content':"Lucene #  https://lucene.apache.org/\napache/lucene-solr #  Apache Lucene is a high-performance, full featured text search engine library written in Java.\nApache Solr is an enterprise search platform written using Apache Lucene. Major features include full-text search, index replication and sharding, and result faceting and highlighting.\n 教程 #  zzboy/lucene #  lucene 技术细节\n"});index.add({'id':523,'href':'/note-cs/docs/skill/stream-media/stream-media/mpeg/','title':"MPEG",'section':"流媒体技术",'content':"MPEG #   MPEG-1：第一个官方的视讯音频压缩标准，随后在 Video CD 中被采用，其中的音频压缩的第三级（MPEG-1 Layer 3）简称 MP3，成为比较流行的音频压缩格式。 MPEG-2：广播质量的视讯、音频和传输协议。被用于无线 数字电视 - ATSC、DVB 以及 ISDB、数字卫星电视（例如 DirecTV）、数字 有线电视信号，以及 DVD 视频光盘技术中。 MPEG-3：原本目标是为 高清晰度电视（ HDTV）设计，随后发现 MPEG-2 已足够 HDTV 应用，故 MPEG-3 的研发便中止。 MPEG-4：2003 年发布的视讯压缩标准，主要是扩展 MPEG-1、MPEG-2 等标准以支持视频／音频对象（video/audio \u0026ldquo;objects\u0026rdquo;）的编码、3D 内容、低比特率编码（low bitrate encoding）和 数字版权管理（Digital Rights Management），其中第 10 部分由 ISO/IEC 和 ITU-T 联合发布，称为 H.264/MPEG-4 Part 10。 MPEG-7：MPEG-7 并不是一个视讯压缩标准，它是一个多媒体内容的描述标准。 MPEG-21：MPEG-21 是一个正在制定中的标准，它的目标是为未来多媒体的应用提供一个完整的平台。  "});index.add({'id':524,'href':'/note-cs/docs/skill/tool/note/onenote/','title':"OneNote",'section':"笔记",'content':"OneNote #  "});index.add({'id':525,'href':'/note-cs/docs/domain/cc/virtual/parallels/','title':"Parallels",'section':"虚拟化",'content':"Parallels #  "});index.add({'id':526,'href':'/note-cs/docs/direction/be/frame/php/','title':"PHP 框架",'section':"2.2.3 后端框架",'content':"PHP 框架 #  "});index.add({'id':527,'href':'/note-cs/docs/direction/be/devops/prometheus/','title':"Prometheus",'section':"2.2.6 DevOps",'content':"Prometheus #  prometheus/prometheus 教程 #  yunlzheng/prometheus-book #  Prometheus 操作指南 https://yunlzheng.gitbook.io/prometheus-book/\n"});index.add({'id':528,'href':'/note-cs/docs/skill/stream-media/stream-media/ps/','title':"PS",'section':"流媒体技术",'content':"PS #  Program stream\nPS 流的包结构是可变长度的， 一旦某一 PS 包的同步信息丢失，接收机无法确定下一包的同步位置，就会造成失步，导致严重的信息丢失。\n在信道环境较好，传输误码较低时，一般采用 PS 码流。\n TS #  MPEG transport stream (MPEG-TS, MTS)\n传输流，是由固定长度为 188 字节的包组成， 含有一个或多个 program, 一个 program 可以包含多个视频、音频、和文字信息的 ES 流； 每个 ES 流会有不同的 PID 标示。\n而又为了可以分析这些 ES 流，TS 有一些固定的 PID 用来间隔发送 program 和 ES 流信息的表格:\n PAT PMT 表  TS 流的包结构是固定长度的， 当传输误码破坏了某一 TS 包的同步信息时，接收机可在固定的位置检测它后面包中的同步信息，从而恢复同步，避免了信息丢失。\n在信道环境较为恶劣，传输误码较高时，一般采用 TS 码流。\nTS 流解码过程 #   获取 TS 中的 PAT 获取 TS 中的 PMT 根据 PMT 可以知道当前网络中传输的视频（音频）类型（H264），相应的 PID，PCR 的 PID 等信息。 设置 demux 模块的视频 Filter 为相应视频的 PID 和 stream type 等。 从视频 Demux Filter 后得到的 TS 数据包中的 payload 数据就是 one piece of PES， 在 TS header 中有一些关于此 payload 属于哪个 PES 的 第多少个数据包。 因此软件中应该将此 payload 中的数据 copy 到 PES 的 buffer 中，用于拼接一个 PES 包。 拼接好的 PES 包的包头会有 PTS，DTS 信息，去掉 PES 的 header 就是 ES。 直接将被拔掉 PES 包头的 ES 包送给 decoder 就可以进行解码。 解码出来的数据就是一帧一帧的视频数据，这些数据至少应当与 PES 中的 PTS 关联一下，以便进行视音频同步。   ES #  Elementary Stream\n基本码流，包含视频、音频或数据的连续码流。\nES -\u0026gt; PES -\u0026gt; PS/TS\n PES #  Packet Elementary Stream\n打包的基本码流\n将基本的码流 ES 流根据需要分成长度不等的数据包，并加上包头就形成了打包的基本码流 PES 流。\n"});index.add({'id':529,'href':'/note-cs/docs/direction/be/frame/python/','title':"Python 框架",'section':"2.2.3 后端框架",'content':"Python 框架 #  "});index.add({'id':530,'href':'/note-cs/docs/direction/be/frame/java/spring/','title':"Spring",'section':"Java 框架",'content':"Spring #  "});index.add({'id':531,'href':'/note-cs/docs/direction/be/frame/java/spring/spring-boot/','title':"Spring Boot",'section':"Spring",'content':"Spring Boot #  教程 #  ityouknow/spring-boot-examples #  Spring Boot 教程、技术栈示例代码，快速简单上手教程。\n"});index.add({'id':532,'href':'/note-cs/docs/direction/be/frame/java/spring/spring-cloud/','title':"Spring Cloud",'section':"Spring",'content':"Spring Cloud #  教程 #  ityouknow/spring-cloud-examples #  Spring Cloud 学习案例，服务发现、服务治理、链路追踪、服务监控等\n"});index.add({'id':533,'href':'/note-cs/docs/direction/be/frame/java/spring/spring-mvc/','title':"Spring MVC",'section':"Spring",'content':"Spring MVC #  "});index.add({'id':534,'href':'/note-cs/docs/direction/se/uml/','title':"UML",'section':"2.1 软件工程",'content':"UML #  泛化关系 (generalization) #   is-a 最终代码中，泛化关系表现为继承非抽象类  带空心三角形箭头的直线\n实现关系 (realize) #   最终代码中，实现关系表现为继承抽象类  带空心三角形箭头的虚线\n聚合关系 (aggregation) #   表示整体由部分构成的语义  例如一个部门由多个员工组成   整体和部分不是强依赖的，即使整体不存在了，部分仍然存在  例如， 部门撤销了，人员不会消失，他们依然存在    带空心菱形箭头的直线\n组合关系 (composition) #   表示整体由部分构成的语义  比如公司由多个部门组成   是一种强依赖的特殊聚合关系，如果整体不存在了，则部分也不存在了  例如， 公司不存在了，部门也将不存在了    带实心菱形箭头直线\n关联关系 (association) #   它一般用来定义对象之间静态的、天然的结构；通常与运行状态无关 所以，关联关系是一种 \u0026ldquo;强关联\u0026rdquo; 的关系  比如，乘车人和车票之间就是一种关联关系；学生和学校就是一种关联关系   在最终代码中，关联对象通常是以成员变量的形式实现的  带箭头的直线\n依赖关系 (dependency) #   描述一个对象在运行期间会用到另一个对象的关系 是一种临时性的关系，通常在运行期间产生，并且随着运行时的变化，依赖关系也可能发生变化 在最终代码中，依赖关系体现为类构造方法及类方法的传入参数，箭头的指向为调用关系  依赖关系除了临时知道对方外，还是 \u0026ldquo;使用\u0026rdquo; 对方的方法和属性；    带箭头的虚线\n"});index.add({'id':535,'href':'/note-cs/docs/domain/cc/virtual/virtualbox/','title':"VirtualBox",'section':"虚拟化",'content':"VirtualBox #  "});index.add({'id':536,'href':'/note-cs/docs/activity/istio-handbook/','title':"《Istio Handbook》写作",'section':"第七部分 学习活动",'content':"《Istio Handbook》写作 #  参考：\n servicemesher/istio-handbook   "});index.add({'id':537,'href':'/note-cs/docs/basic/os/memory/','title':"内存",'section':"1.2 操作系统",'content':"内存 #  "});index.add({'id':538,'href':'/note-cs/docs/skill/tool/note/storage/','title':"存储",'section':"笔记",'content':"存储 #  "});index.add({'id':539,'href':'/note-cs/docs/direction/be/db/postgresql/basic/practice/error/','title':"常见错误",'section':"实践",'content':"PostgreSQL 常见错误 #  权限 #  permission denied for relation #  解决 1:\n 以 superUser 进入数据库  psql -U postgres -d postgres   切换到 mydb 数据库  \\c mydb   赋予所有表的所有权限给 xiaoming  GRANT ALL PRIVILEGES ON ALL TABLES IN SCHEMA public TO xiaoming;   赋予 wechart 用户，tuser 表的所有权限  GRANT ALL PRIVILEGES ON tuser TO wechart;    解决 2：\nERROR: permission denied for relation hycom 权限被拒绝\n 检查数据库连接 检查数据库拥有者和配置的是否一样 访问不同的数据库分区 @TableName (\u0026ldquo;分区名。表名\u0026rdquo;) @TableField (exist = false) 取消数据库映射  "});index.add({'id':540,'href':'/note-cs/docs/domain/ai/ml/','title':"机器学习",'section':"3.3 人工智能",'content':"机器学习 #  "});index.add({'id':541,'href':'/note-cs/docs/domain/ai/dl/','title':"深度学习",'section':"3.3 人工智能",'content':"深度学习 #  "});index.add({'id':542,'href':'/note-cs/docs/direction/be/db/postgresql/basic/version/','title':"版本",'section':"第一部分 基础入门",'content':"PostgreSQL 版本 #  12 #  12.2 #   "});index.add({'id':543,'href':'/note-cs/docs/basic/pl/swift/basic/spec/baidu/','title':"百度 Swift 编程规范",'section':"1.3 编程规范",'content':"百度 Swift 编程规范 #  "});index.add({'id':544,'href':'/note-cs/docs/course/ai/baidu-aistudio/','title':"百度大脑",'section':"6.8 人工智能",'content':"百度大脑 #  "});index.add({'id':545,'href':'/note-cs/docs/basic/os/thread/','title':"线程",'section':"1.2 操作系统",'content':"线程 #  栈通常是连续增长的，由于每个进程中的各个线程共享虚拟内存空间，当有多个线程时，就需要为每个线程分配不同起始地址的栈。 这就需要在分配栈之前先预估每个线程栈的大小。\n如果线程数量非常多，就很容易栈溢出。\nSplit Stacks #  为了解决这个问题，就有了 Split Stacks 技术： 创建栈时，只分配一块比较小的内存，如果进行某次函数调用导致栈空间不足时，就会在其他地方分配一块新的栈空间。 新的空间不需要和老的栈空间连续。函数调用的参数会拷贝到新的栈空间中，接下来的函数执行都在新栈空间中进行。\nGolang 连续栈 #  Golang 的栈管理方式与此类似，但是为了更高的效率，使用了 Golang 连续栈。 实现方式也是先分配一块固定大小的栈，在栈空间不足时，分配一块更大的栈，并把旧的栈全部拷贝到新栈中。 这样避免了 Split Stacks 方法可能导致的频繁内存分配和释放。\n"});index.add({'id':546,'href':'/note-cs/docs/domain/cc/virtual/network/','title':"虚拟机网络",'section':"虚拟化",'content':"虚拟机网络 #  在 VMware 的 3 中网络模式中，NAT 模式是最简单的，基本不需要手动配置 IP 地址等相关参数。至于桥接模式则需要额外的 IP 地址，如果是在内网环境中还很容易，如果是 ADSL 宽带就比较麻烦了，ISP 一般是不会大方的多提供一个公网 IP 的。\n三种网络模式 #  桥接 #  特点：\n 如果主机可以上网，虚拟机可以上网 虚拟机之间可以 ping 通 虚拟机可以 ping 通主机 主机可以 ping 通虚拟机 如果主机不可以上网，所有 1-4 特点均无  应用场景：\n 虚拟机要求可以上网，且虚拟机完全模拟一台实体机  桥接网络是指本地物理网卡和虚拟网卡通过 VMnet0 虚拟交换机进行桥接，物理网卡和虚拟网卡在拓扑图上处于同等地位，那么物理网卡和虚拟网卡就相当于处于同一个网段，虚拟交换机就相当于一台现实网络中的交换机，所以两个网卡的 IP 地址也要设置为同一网段。\n所以当我们要在局域网使用虚拟机，对局域网其他 pc 提供服务时，例如提供 ftp，提供 ssh，提供 http 服务，那么就要选择桥接模式。\n例如大学宿舍里有一个路由器，宿舍里四个人连接这个路由器，路由器的 wanip 就不理会了，这个 ip 是动态获取的，而 lanip 默认是 192.168.1.1, 子网掩码是 255.255.255.0。而其他四个人是自动获取 ip，假设四个人的 ip 是:\nA:192.168.1.100/255.255.255.0, B:192.168.1.101/255.255.255.0, C:192.168.1.102/255.255.255.0, D:192.168.1.103/255.255.255.0\n那么虚拟机的 ip 可以设置的 ip 地址是 192.168.1.2-192.168.1.99,192.168.1.104-192.168.1.254 (网络地址全 0 和全 1 的除外，再除去 ABCD 四个人的 ip 地址)\n那么虚拟机的 ip 地址可以设置为 192.168.1.98/255.255.255.0, 设置了这个 ip 地址，ABCD 这四个人就可以通过 192.168.1.98 访问虚拟机了，如果虚拟机需要上外网，那么还需要配置虚拟机的路由地址，就是 192.168.1.1 了，这样，虚拟机就可以上外网了，但是，上网我们一般是通过域名去访问外网的，所以我们还需要为虚拟机配置一个 dns 服务器，我们可以简单点，把 dns 服务器地址配置为 google 的 dns 服务器：8.8.8.8, 到此，虚拟机就可以上网了。\nNAT #  特点：\n 如果主机可以上网，虚拟机可以上网 虚拟机之间不能 ping 通 虚拟机可以 ping 通主机（此时 ping 虚拟机的网关，即是 ping 主机） 主机不能 ping 通虚拟机  应用场景：\n 虚拟机只要求可以上网，无其它特殊要求，满足最一般需求  NAT 模式中，就是让虚拟机借助 NAT (网络地址转换) 功能，通过宿主机器所在的网络来访问公网。\nNAT 模式中，虚拟机的网卡和物理网卡的网络，不在同一个网络，虚拟机的网卡，是在 vmware 提供的一个虚拟网络。\nNAT 和桥接的比较:\n(1) NAT 模式和桥接模式虚拟机都可以上外网。\n(2) 由于 NAT 的网络在 vmware 提供的一个虚拟网络里，所以局域网其他主机是无法访问虚拟机的，而宿主机可以访问虚拟机， 虚拟机可以访问局域网的所有主机，因为真实的局域网相对于 NAT 的虚拟网络，就是 NAT 的虚拟网络的外网，不懂的人可以查查 NAT 的相关知识。\n(3) 桥接模式下，多个虚拟机之间可以互相访问；NAT 模式下，多个虚拟机之间也可以相互访问。\n如果你建一个虚拟机，只是给自己用，不需要给局域网其他人用，那么可以选择 NAT，毕竟 NAT 模式下的虚拟系统的 TCP/IP 配置信息是由 VMnet8 (NAT) 虚拟网络的 DHCP 服务器提供的，只要虚拟机的网路配置是 DHCP，那么你不需要进行任何其他的配置，只需要宿主机器能访问互联网即可，就可以让虚拟机联网了。\n例如你想建多个虚拟机集群，作为测试使用，而宿主机可能是一个笔记本，ip 不固定。这种应用场景，我们需要采用 nat 模式了，但是我们要考虑一个问题，虚拟机之间是需要互访的，默认采用 dhcp，虚拟机的 ip 每次重启，ip 都是不固定的，所以我们需要手工设置虚拟机的 ip 地址。\n但是我们对虚拟机网卡所在的虚拟网络的信息还一无所知，例如虚拟机网络的路由地址，子网掩码，所以我们需要先查下 nat 虚拟网络的信息。\n使用 vmware, 在 Edit-\u0026gt;Virtual Network Editor 中配置好虚拟网络信息后看到下图所示，注意 VMnet8，VMnet8 相当于是本机的一个路由，虚拟机设置 NAT 后就通过这个路由进行上网的，可以查看其网络地址，路由地址，子网掩码。\n选择 VMnet8-\u0026gt;NAT 设置，可以看到子网 ip 显示为 192.168.233.0，子网掩码是 255.255.255.0，那路由地址呢，其实就是网关 IP 了，都是同个东西，这里是 192.168.233.2。\n接下来就好办了，在对应的虚拟机设置好 ip，子网掩码，路由地址就可以上外网了，至于 dns 可以设置为 8.8.8.8.\nHost-Only #  特点：\n 虚拟机不可以上网 虚拟机之间可以 ping 通 虚拟机可以 ping 通主机 注意虚拟机与主机通信是通过主机的名为 VirtualBox Host-Only Network 的网卡，因此 ip 是该网卡 ip 192.168.56.1，而不是你现在正在上网所用的 ip 主机可以 ping 通虚拟机  应用场景：\n 在主机无法上网的情况下（主机可以上网的情况下可以用 host-only，也可以用桥接），需要搭建一个模拟局域网，所有机器可以互访  在 Host-Only 模式下，虚拟网络是一个全封闭的网络，它唯一能够访问的就是主机。其实 Host-Only 网络和 NAT 网络很相似，不同的地方就是 Host-Only 网络没有 NAT 服务，所以虚拟网络不能连接到 Internet。主机和虚拟机之间的通信是通过 VMware Network Adepter VMnet1 虚拟网卡来实现的。\nHost-Only 的宗旨就是建立一个与外界隔绝的内部网络，来提高内网的安全性。这个功能或许对普通用户来说没有多大意义，但大型服务商会常常利用这个功能。如果你想为 VMnet1 网段提供路由功能，那就需要使用 RRAS，而不能使用 XP 或 2000 的 ICS，因为 ICS 会把内网的 IP 地址改为 192.168.0.1，但虚拟机是不会给 VMnet1 虚拟网卡分配这个地址的，那么主机和虚拟机之间就不能通信了。\n"});index.add({'id':547,'href':'/note-cs/docs/basic/os/process/','title':"进程",'section':"1.2 操作系统",'content':"进程 #  进程虚拟地址空间 #   "});index.add({'id':548,'href':'/note-cs/docs/course/ai/baidu-aistudio/deep-learning-from-beginning/','title':"零基础实践深度学习",'section':"百度大脑",'content':"百度架构师手把手带你零基础实践深度学习 #  https://aistudio.baidu.com/aistudio/course/introduce/1297\n课程列表 #   预习课程  深度学习常用数学知识   第一章：零基础入门深度学习 第二章：一个案例吃透深度学习 第三章：深度学习实践应用 —— 计算机视觉 第四章：目标检测 YoloV3 第五章：深度学习实践应用 —— 自然语言处理 第六章：情感分类 第七章：深度学习实践应用 —— 推荐系统 第八章：深度学习高阶导入 拓展：【AI 实战案例项目集】  "});index.add({'id':549,'href':'/note-cs/docs/basic/pl/haskell/','title':"Haskell",'section':"1.5 编程语言",'content':"Haskell 学习笔记 #  "});index.add({'id':550,'href':'/note-cs/docs/direction/be/microservices/servicecomb/','title':"ServiceComb",'section':"2.2.5 微服务",'content':"ServiceComb #  子项目 #  ServiceComb 目前拥有三个主要的子项目\napache/servicecomb-java-chassis #  开箱即用 Java 语言 微服务 SDK，含服务契约、编程模型、运行模型与通信模型四个部分，具备负载均衡、容错熔断、限流降级、调用链追踪等全面微服务治理能力，服务治理能力与业务逻辑隔离。\napache/servicecomb-service-center #  基于 Etcd 的高性能、高可用、无状态的 Golang 版分布式服务注册与发现中心，可实时服务实例注册、实时服务实例推送和服务间契约测试等。\napache/servicecomb-pack #  Apache ServiceComb Pack (原 ServiceComb Saga) 是提供了分布式事务最终一致性解决方案，用户只需要通过注解方式定义事务的执行方法以及撤销方法，ServiceComb Pack 框架会自动保证分布式事务执行的最终一致性。\n其他 #  apache/servicecomb-mesher #  A high performance service mesh implementation written in go\nservicecomb-saga-actuator #  Apache ServiceComb Saga Actuator https://servicecomb.apache.org/\n参考：\n 如何评价华为新开源的 ServiceComb 微服务框架？  "});index.add({'id':551,'href':'/note-cs/docs/book/basic/pl/go-in-action/','title':"Go in Action",'section':"5.1.5 编程语言",'content':"Go in Action #  \n作者 #  William Kennedy\n"});index.add({'id':552,'href':'/note-cs/docs/book/others/practical-vim/','title':"Practical Vim",'section':"5.9 其他",'content':"Practical Vim, 2nd Edition #  \n作者 #  Drew Neil\n"});index.add({'id':553,'href':'/note-cs/docs/basic/algs/','title':"1.3 数据结构与算法",'section':"第一部分 基础",'content':"数据结构与算法 #  见：算法学习笔记\n"});index.add({'id':554,'href':'/note-cs/docs/basic/pl/csharp/basic/spec/','title':"1.3 编程规范",'section':"第一部分 基础入门",'content':"编程规范 #  "});index.add({'id':555,'href':'/note-cs/docs/basic/pl/erlang/basic/spec/','title':"1.3 编程规范",'section':"第一部分 基础入门",'content':"编程规范 #  "});index.add({'id':556,'href':'/note-cs/docs/basic/pl/haskell/basic/spec/','title':"1.3 编程规范",'section':"第一部分 基础入门",'content':"编程规范 #  "});index.add({'id':557,'href':'/note-cs/docs/basic/pl/kotlin/basic/spec/','title':"1.3 编程规范",'section':"第一部分 基础入门",'content':"编程规范 #  "});index.add({'id':558,'href':'/note-cs/docs/basic/pl/lua/basic/spec/','title':"1.3 编程规范",'section':"第一部分 基础入门",'content':"编程规范 #  "});index.add({'id':559,'href':'/note-cs/docs/basic/pl/objective-c/basic/spec/','title':"1.3 编程规范",'section':"第一部分 基础入门",'content':"编程规范 #  "});index.add({'id':560,'href':'/note-cs/docs/basic/pl/r/basic/spec/','title':"1.3 编程规范",'section':"第一部分 基础入门",'content':"编程规范 #  "});index.add({'id':561,'href':'/note-cs/docs/basic/pl/ruby/basic/spec/','title':"1.3 编程规范",'section':"第一部分 基础入门",'content':"编程规范 #  "});index.add({'id':562,'href':'/note-cs/docs/basic/pl/scala/basic/spec/','title':"1.3 编程规范",'section':"第一部分 基础入门",'content':"编程规范 #  "});index.add({'id':563,'href':'/note-cs/docs/basic/pl/swift/basic/spec/','title':"1.3 编程规范",'section':"第一部分 基础入门",'content':"编程规范 #  raywenderlich/swift-style-guide #  Swift 官方编码风格指导\n"});index.add({'id':564,'href':'/note-cs/docs/basic/pl/shell/snippet/','title':"1.3.3 代码片段",'section':"Shell",'content':"代码片段 #  if item in list #  list1=( a b c d ) list2=( b c ) # isIn $item $list function isIn() { item=$1 list=\u0026#34;${@:2}\u0026#34; for i in ${list[*]}; do if [[ $i == $item ]]; then return 0 fi done return 1 } for item in ${list1[*]}; do if isIn $item ${list2[*]}; then echo $item fi done  锁文件 #   [建议] 使用 pid 生成锁文件，并用 set -C 来做逻辑判断  lockfile=/tmp/mylock if (set -C;echo $$ \u0026gt;$lockfile) 2\u0026gt;/dev/null; then # set -C 使已存在的文件不能再被写 # echo 不旦生成了锁文件，而且还将pid放入其中 # 当此lock文件存在时，if返回失败，跳到else trap 'rm $lockfile; exit $?' INT TERM EXIT # trap保证了脚本异常中断时，释放锁文件（删） { my critical code... # 此处是正式的脚本代码 my critical code... my critical code... } rm $lockfile # 正式代码运行完了，释放锁文件 trap - INT TERM EXIT # 恢复trap的设置（如在脚本最后时，非必要恢复） exit 0 else # 锁文件生效，会跳到此处 echo \u0026quot;$lockfile exist, pid $(\u0026lt;$lockfile) is running.\u0026quot; # 打印错误信息 exit 1 fi "});index.add({'id':565,'href':'/note-cs/docs/direction/be/db/postgresql/','title':"2.2.1.3 PostgreSQL",'section':"2.2.1 数据库",'content':"PostgreSQL #  "});index.add({'id':566,'href':'/note-cs/docs/direction/be/mq/rabbitmq/','title':"2.2.2.3 RabbitMQ",'section':"2.2.2 消息队列",'content':"RabbitMQ #  rabbitmq/rabbitmq-server RabbitMQ 是一个 AMQP 实现，传统的 messaging queue 系统实现，基于 Erlang。老牌 MQ 产品了。AMQP 协议更多用在企业系统内，对数据一致性、稳定性和可靠性要求很高的场景，对性能和吞吐量还在其次。\n"});index.add({'id':567,'href':'/note-cs/docs/direction/be/frame/','title':"2.2.3 后端框架",'section':"2.2 后端",'content':"后端框架 #  "});index.add({'id':568,'href':'/note-cs/docs/direction/fe/frame/','title':"2.2.3 框架",'section':"2.3 前端",'content':"框架 #  "});index.add({'id':569,'href':'/note-cs/docs/direction/fe/frame/angular/','title':"2.2.3.3 Angular",'section':"2.2.3 框架",'content':"Angular #  "});index.add({'id':570,'href':'/note-cs/docs/direction/be/distributed/zookeeper/','title':"2.2.4.3 Zookeeper",'section':"2.2.4 分布式系统",'content':"Zookeeper #  "});index.add({'id':571,'href':'/note-cs/docs/direction/be/microservices/rpc/dubbo/','title':"2.2.5.1.3 Dubbo",'section':"2.2.5.1 RPC",'content':"Dubbo #  国内最早开源的 RPC 框架，由阿里巴巴公司开发并于 2011 年末对外开源，仅支持 Java 语言\n"});index.add({'id':572,'href':'/note-cs/docs/direction/fe/','title':"2.3 前端",'section':"第二部分 方向",'content':"前端开发 #  "});index.add({'id':573,'href':'/note-cs/docs/basic/pl/csharp/advanced/pkg/','title':"2.3 常用库",'section':"第二部分 进阶实战",'content':"常用库 #  "});index.add({'id':574,'href':'/note-cs/docs/basic/pl/erlang/advanced/pkg/','title':"2.3 常用库",'section':"第二部分 进阶实战",'content':"常用库 #  "});index.add({'id':575,'href':'/note-cs/docs/basic/pl/haskell/advanced/pkg/','title':"2.3 常用库",'section':"第二部分 进阶实战",'content':"常用库 #  "});index.add({'id':576,'href':'/note-cs/docs/basic/pl/kotlin/advanced/pkg/','title':"2.3 常用库",'section':"第二部分 进阶实战",'content':"常用库 #  "});index.add({'id':577,'href':'/note-cs/docs/basic/pl/lua/advanced/pkg/','title':"2.3 常用库",'section':"第二部分 进阶实战",'content':"常用库 #  "});index.add({'id':578,'href':'/note-cs/docs/basic/pl/objective-c/advanced/pkg/','title':"2.3 常用库",'section':"第二部分 进阶实战",'content':"常用库 #  "});index.add({'id':579,'href':'/note-cs/docs/basic/pl/r/advanced/pkg/','title':"2.3 常用库",'section':"第二部分 进阶实战",'content':"常用库 #  "});index.add({'id':580,'href':'/note-cs/docs/basic/pl/ruby/advanced/pkg/','title':"2.3 常用库",'section':"第二部分 进阶实战",'content':"常用库 #  "});index.add({'id':581,'href':'/note-cs/docs/basic/pl/scala/advanced/pkg/','title':"2.3 常用库",'section':"第二部分 进阶实战",'content':"常用库 #  "});index.add({'id':582,'href':'/note-cs/docs/basic/pl/swift/advanced/pkg/','title':"2.3 常用库",'section':"第二部分 进阶实战",'content':"常用库 #  "});index.add({'id':583,'href':'/note-cs/docs/domain/ai/','title':"3.3 人工智能",'section':"第三部分 领域",'content':"人工智能 #  "});index.add({'id':584,'href':'/note-cs/docs/basic/pl/csharp/code/runtime/','title':"3.3 运行时",'section':"第三部分 设计与实现",'content':"运行时 #  "});index.add({'id':585,'href':'/note-cs/docs/basic/pl/erlang/code/runtime/','title':"3.3 运行时",'section':"第三部分 设计与实现",'content':"运行时 #  "});index.add({'id':586,'href':'/note-cs/docs/basic/pl/haskell/code/runtime/','title':"3.3 运行时",'section':"第三部分 设计与实现",'content':"运行时 #  "});index.add({'id':587,'href':'/note-cs/docs/basic/pl/kotlin/code/runtime/','title':"3.3 运行时",'section':"第三部分 设计与实现",'content':"运行时 #  "});index.add({'id':588,'href':'/note-cs/docs/basic/pl/lua/code/runtime/','title':"3.3 运行时",'section':"第三部分 设计与实现",'content':"运行时 #  "});index.add({'id':589,'href':'/note-cs/docs/basic/pl/objective-c/code/runtime/','title':"3.3 运行时",'section':"第三部分 设计与实现",'content':"运行时 #  "});index.add({'id':590,'href':'/note-cs/docs/basic/pl/r/code/runtime/','title':"3.3 运行时",'section':"第三部分 设计与实现",'content':"运行时 #  "});index.add({'id':591,'href':'/note-cs/docs/basic/pl/ruby/code/runtime/','title':"3.3 运行时",'section':"第三部分 设计与实现",'content':"运行时 #  "});index.add({'id':592,'href':'/note-cs/docs/basic/pl/scala/code/runtime/','title':"3.3 运行时",'section':"第三部分 设计与实现",'content':"运行时 #  "});index.add({'id':593,'href':'/note-cs/docs/basic/pl/swift/code/runtime/','title':"3.3 运行时",'section':"第三部分 设计与实现",'content':"运行时 #  "});index.add({'id':594,'href':'/note-cs/docs/basic/pl/csharp/appendix/attention/','title':"4.3 关注项目",'section':"第四部分 附录",'content':"关注项目 #  "});index.add({'id':595,'href':'/note-cs/docs/basic/pl/erlang/appendix/attention/','title':"4.3 关注项目",'section':"第四部分 附录",'content':"关注项目 #  "});index.add({'id':596,'href':'/note-cs/docs/basic/pl/haskell/appendix/attention/','title':"4.3 关注项目",'section':"第四部分 附录",'content':"关注项目 #  "});index.add({'id':597,'href':'/note-cs/docs/basic/pl/kotlin/appendix/attention/','title':"4.3 关注项目",'section':"第四部分 附录",'content':"关注项目 #  "});index.add({'id':598,'href':'/note-cs/docs/basic/pl/lua/appendix/attention/','title':"4.3 关注项目",'section':"第四部分 附录",'content':"关注项目 #  ngx_http_lua_module #  openresty/lua-nginx-module ngx_http_lua_module - Embed the power of Lua into Nginx HTTP Servers.\nThis module is a core component of OpenResty. If you are using this module, then you are essentially using OpenResty.\nTurbo.lua #  kernelsauce/turbo Turbo is a framework built for LuaJIT 2 to simplify the task of building fast and scalable network applications. It uses a event-driven, non-blocking, no thread design to deliver excellent performance and minimal footprint to high-load applications while also providing excellent support for embedded uses.\nhttps://turbo.readthedocs.io/en/latest/\nPegasus.lua #  EvandroLG/pegasus.lua Pegasus.lua is an http server to work with web applications written in Lua language.\nhttp://evandrolg.github.io/pegasus.lua/\n"});index.add({'id':599,'href':'/note-cs/docs/basic/pl/objective-c/appendix/attention/','title':"4.3 关注项目",'section':"第四部分 附录",'content':"关注项目 #  "});index.add({'id':600,'href':'/note-cs/docs/basic/pl/r/appendix/attention/','title':"4.3 关注项目",'section':"第四部分 附录",'content':"关注项目 #  "});index.add({'id':601,'href':'/note-cs/docs/basic/pl/ruby/appendix/attention/','title':"4.3 关注项目",'section':"第四部分 附录",'content':"关注项目 #  "});index.add({'id':602,'href':'/note-cs/docs/basic/pl/scala/appendix/attention/','title':"4.3 关注项目",'section':"第四部分 附录",'content':"关注项目 #  "});index.add({'id':603,'href':'/note-cs/docs/basic/pl/swift/appendix/attention/','title':"4.3 关注项目",'section':"第四部分 附录",'content':"关注项目 #  "});index.add({'id':604,'href':'/note-cs/docs/domain/cc/cn/attention/','title':"4.3 关注项目",'section':"云原生",'content':"关注项目 #  cncf/landscape #  The Cloud Native Interactive Landscape filters and sorts hundreds of projects and products, and shows details including GitHub stars, funding or market cap, first and last commits, contributor counts, headquarters location, and recent tweets. https://l.cncf.io\nTrail Map #  CNCF Cloud Native Landscape #  \nCNCF Serverless Landscape #  \n dragonflyoss/Dragonfly #  Dragonfly is an intelligent P2P based image and file distribution system.\nhttps://d7y.io\n"});index.add({'id':605,'href':'/note-cs/docs/book/basic/algs/','title':"5.1.3 数据结构与算法",'section':"5.1 计算机基础",'content':"数据结构与算法 #  "});index.add({'id':606,'href':'/note-cs/docs/book/fe/','title':"5.3 前端",'section':"第五部分 读书",'content':"前端 #  "});index.add({'id':607,'href':'/note-cs/docs/course/basic/algs/','title':"6.1.3 数据结构与算法",'section':"6.1 计算机基础",'content':"数据结构与算法 #  "});index.add({'id':608,'href':'/note-cs/docs/course/fe/','title':"6.3 前端",'section':"第六部分 课程",'content':"前端 #  "});index.add({'id':609,'href':'/note-cs/docs/direction/se/arch/scene/release/ab-testing/','title':"A/B 测试",'section':"发布形式",'content':"A/B 测试 #  A/B testing\n 参考 #  "});index.add({'id':610,'href':'/note-cs/docs/domain/ai/ml/frame/','title':"AI 框架",'section':"机器学习",'content':"AI 框架 #  "});index.add({'id':611,'href':'/note-cs/docs/skill/stream-media/debug/','title':"Debug",'section':"4.5 流媒体",'content':"Debug #  "});index.add({'id':612,'href':'/note-cs/docs/skill/tool/note/gitbook/','title':"Gitbook",'section':"笔记",'content':"Gitbook #  gitbook serve #  serve 多个笔记本 #  \u0026ndash;port Port for server to listen on (Default is 4000)\n\u0026ndash;lrport Port for livereload server to listen on (Default is 35729)\nSo you can change both two ports and serve as many books as you want.\neg:\none:\ngitbook --lrport 35730 --port 4001 serve another:\ngitbook --lrport 35731 --port 4002 serve "});index.add({'id':613,'href':'/note-cs/docs/domain/cc/service-mesh/istio/','title':"Istio",'section':"Service Mesh",'content':"Istio #  见：Istio 学习笔记\n"});index.add({'id':614,'href':'/note-cs/docs/basic/pl/java/','title':"Java",'section':"1.5 编程语言",'content':"Java #  见：Java 学习笔记\n"});index.add({'id':615,'href':'/note-cs/docs/course/cc/kubernetes/','title':"Kubernetes",'section':"6.6 云计算",'content':"Kubernetes 课程 #  "});index.add({'id':616,'href':'/note-cs/docs/domain/cc/kubernetes/','title':"Kubernetes",'section':"3.1 云计算",'content':"Kubernetes #  见：Kubernetes 学习笔记\n"});index.add({'id':617,'href':'/note-cs/docs/activity/kubernetes-scheduler/','title':"Kubernetes 调度器源码学习",'section':"第七部分 学习活动",'content':"Kubernetes 调度器源码学习 #  参考：\n 笔记链接：https://docs.qq.com/sheet/DR01kdWZkUmFLc0Jh?tab=o3eynn Kubernetes 源码研习社  学习笔记 #  第 8 章 kube-scheduler 核心实现\n 8.1 kube-scheduler 命令行参数详解 8.2 kube-scheduler 架构设计详解 8.3 kube-scheduler 组件的启动流程 8.4 优先级与抢占机制 8.5 亲和性调度 8.6 内置调度算法 8.7 调度器核心实现 8.8 领导者选举机制  "});index.add({'id':618,'href':'/note-cs/docs/domain/cc/others/paas/openshift/','title':"OpenShift",'section':"PaaS",'content':"OpenShift #  Red Hat OpenShift is a leading hybrid cloud, enterprise Kubernetes application platform.\nOpenShift 在 Kubernetes 的基础上整合了应用的生命周期管理，包括 image 的编译，持续集成，部署以及更新。\nOpenshift 以前是 IaaS，现在 Openshift 自己宣称自己搭配 LXC 已经是 PaaS 了，VPS 不是云服务但可以类比为 IaaS。\nOpenshift 没有 root 权限\n参考：\n openshift 和普通 vps 的区别在哪儿？  "});index.add({'id':619,'href':'/note-cs/docs/domain/ai/ml/frame/paddlepaddle/','title':"PaddlePaddle",'section':"AI 框架",'content':"PaddlePaddle #  PArallel Distributed Deep LEarning: Machine Learning Framework from Industrial Practice （『飞桨』核心框架，深度学习 \u0026amp; 机器学习高性能单机、分布式训练和跨平台部署） http://www.paddlepaddle.org/\n"});index.add({'id':620,'href':'/note-cs/docs/domain/cc/service-mesh/','title':"Service Mesh",'section':"3.1 云计算",'content':"Service Mesh #  Service Mesh Comparison #  "});index.add({'id':621,'href':'/note-cs/docs/direction/be/web/soa/','title':"SOA",'section':"Web Service",'content':"SOA #  "});index.add({'id':622,'href':'/note-cs/docs/direction/be/web/soap/','title':"SOAP",'section':"Web Service",'content':"SOAP #  "});index.add({'id':623,'href':'/note-cs/docs/direction/be/auth/sso/','title':"SSO",'section':"认证与授权",'content':"SSO (Single sign-on) #  "});index.add({'id':624,'href':'/note-cs/docs/domain/ai/ml/frame/tensorflow/','title':"Tensorflow",'section':"AI 框架",'content':"Tensorflow #  PArallel Distributed Deep LEarning: Machine Learning Framework from Industrial Practice （『飞桨』核心框架，深度学习 \u0026amp; 机器学习高性能单机、分布式训练和跨平台部署） http://www.paddlepaddle.org/\n教程 #  lyhue1991/eat_tensorflow2_in_30_days #  tensorflow/models #  Models and examples built with TensorFlow\naymericdamien/TensorFlow-Examples #  TensorFlow Tutorial and Examples for Beginners (support TF v1 \u0026amp; v2)\n"});index.add({'id':625,'href':'/note-cs/docs/direction/be/devops/terraform/','title':"Terraform",'section':"2.2.6 DevOps",'content':"Terraform #  hashicorp/terraform Terraform enables you to safely and predictably create, change, and improve infrastructure. It is an open source tool that codifies APIs into declarative configuration files that can be shared amongst team members, treated as code, edited, reviewed, and versioned. https://www.terraform.io/\n"});index.add({'id':626,'href':'/note-cs/docs/activity/csapp/','title':"《深入理解计算机系统》学习",'section':"第七部分 学习活动",'content':"《深入理解计算机系统》学习 #  参考：\n https://talkgo.org/tag/深入理解计算机系统   打卡记录 #  "});index.add({'id':627,'href':'/note-cs/docs/domain/ai/ml/attention/','title':"关注项目",'section':"机器学习",'content':"关注项目 #  机器学习 #  tensorflow/tensorflow #  scikit-learn/scikit-learn #  scikit-learn: machine learning in Python https://scikit-learn.org\nphp-ai/php-ml #  PHP-ML - Machine Learning library for PHP https://php-ml.org/\n 深度学习 #  paddlepaddle/paddle #   机器人 #  gunthercox/ChatterBot #  ChatterBot is a machine learning, conversational dialog engine for creating chat bots https://chatterbot.readthedocs.io\n"});index.add({'id':628,'href':'/note-cs/docs/basic/os/type/android/basic/practice/','title':"实践",'section':"第一部分 基础入门",'content':"实践 #  "});index.add({'id':629,'href':'/note-cs/docs/basic/os/type/ios/basic/practice/','title':"实践",'section':"第一部分 基础入门",'content':"实践 #  "});index.add({'id':630,'href':'/note-cs/docs/basic/os/type/macos/basic/practice/','title':"实践",'section':"第一部分 基础入门",'content':"实践 #  "});index.add({'id':631,'href':'/note-cs/docs/basic/os/type/unix/basic/practice/','title':"实践",'section':"第一部分 基础入门",'content':"实践 #  "});index.add({'id':632,'href':'/note-cs/docs/basic/os/type/windows/basic/practice/','title':"实践",'section':"第一部分 基础入门",'content':"实践 #  "});index.add({'id':633,'href':'/note-cs/docs/direction/client/xiaochengxu/','title':"小程序",'section':"2.4 客户端",'content':"小程序 #  "});index.add({'id':634,'href':'/note-cs/docs/domain/cc/virtual/','title':"虚拟化",'section':"3.1 云计算",'content':"虚拟化 #  "});index.add({'id':635,'href':'/note-cs/docs/direction/se/arch/scene/release/canary-rollouts/','title':"金丝雀发布",'section':"发布形式",'content':"金丝雀发布 #  canary rollouts\n 参考 #  "});index.add({'id':636,'href':'/note-cs/docs/basic/pl/javascript/','title':"JavaScript",'section':"1.5 编程语言",'content':"JavaScript #  见：JavaScript 学习笔记\n"});index.add({'id':637,'href':'/note-cs/docs/basic/pl/kotlin/','title':"Kotlin",'section':"1.5 编程语言",'content':"Kotlin 学习笔记 #  "});index.add({'id':638,'href':'/note-cs/docs/basic/pl/lua/','title':"Lua",'section':"1.5 编程语言",'content':"Lua 学习笔记 #   Lua（发音： /ˈluːə/，葡萄牙语含义是月亮）是一个简洁、轻量、可扩展的 脚本语言。\nLua 有着相对简单的 C API 而很容易嵌入应用中。很多应用程序使用 Lua 作为自己的嵌入式脚本语言，以此来实现可配置性、可扩展性。\n 参考：Lua Wikipedia\n Lua 源码解析 #  "});index.add({'id':639,'href':'/note-cs/docs/basic/pl/shell/type/','title':"1.3.4 Shell 类型",'section':"Shell",'content':"Shell 类型 #  "});index.add({'id':640,'href':'/note-cs/docs/basic/pl/csharp/basic/others/','title':"1.4 其他",'section':"第一部分 基础入门",'content':"其他 #  "});index.add({'id':641,'href':'/note-cs/docs/basic/pl/erlang/basic/others/','title':"1.4 其他",'section':"第一部分 基础入门",'content':"其他 #  "});index.add({'id':642,'href':'/note-cs/docs/basic/pl/haskell/basic/others/','title':"1.4 其他",'section':"第一部分 基础入门",'content':"其他 #  "});index.add({'id':643,'href':'/note-cs/docs/basic/pl/kotlin/basic/others/','title':"1.4 其他",'section':"第一部分 基础入门",'content':"其他 #  "});index.add({'id':644,'href':'/note-cs/docs/basic/pl/lua/basic/others/','title':"1.4 其他",'section':"第一部分 基础入门",'content':"其他 #  Lua 包管理 #  LuaRocks #  luarocks/luarocks LuaRocks is the package manager for the Lua programming language.\n"});index.add({'id':645,'href':'/note-cs/docs/basic/pl/objective-c/basic/others/','title':"1.4 其他",'section':"第一部分 基础入门",'content':"其他 #  "});index.add({'id':646,'href':'/note-cs/docs/basic/pl/r/basic/others/','title':"1.4 其他",'section':"第一部分 基础入门",'content':"其他 #  "});index.add({'id':647,'href':'/note-cs/docs/basic/pl/ruby/basic/others/','title':"1.4 其他",'section':"第一部分 基础入门",'content':"其他 #  "});index.add({'id':648,'href':'/note-cs/docs/basic/pl/scala/basic/others/','title':"1.4 其他",'section':"第一部分 基础入门",'content':"其他 #  "});index.add({'id':649,'href':'/note-cs/docs/basic/pl/swift/basic/others/','title':"1.4 其他",'section':"第一部分 基础入门",'content':"其他 #  "});index.add({'id':650,'href':'/note-cs/docs/basic/network/','title':"1.4 计算机网络",'section':"第一部分 基础",'content':"计算机网络 #  见：网络学习笔记\n"});index.add({'id':651,'href':'/note-cs/docs/direction/be/mq/pulsar/','title':"2.2.2.4 Pulsar",'section':"2.2.2 消息队列",'content':"Pulsar #  apache/pulsar Apache Pulsar - distributed pub-sub messaging system\n"});index.add({'id':652,'href':'/note-cs/docs/direction/be/distributed/','title':"2.2.4 分布式系统",'section':"2.2 后端",'content':"分布式系统 #  Distributed System\n问答 #  分布式与集群的区别 #  参考：\n 知乎：分布式与集群的区别是什么？ 分布式架构（1） - 大白话讲解：分布式与集群的区别是什么？  "});index.add({'id':653,'href':'/note-cs/docs/direction/be/distributed/etcd/','title':"2.2.4.4 Etcd",'section':"2.2.4 分布式系统",'content':"Etcd #  "});index.add({'id':654,'href':'/note-cs/docs/direction/be/microservices/rpc/spring-cloud/','title':"2.2.5.1.4 Spring Cloud",'section':"2.2.5.1 RPC",'content':"Spring Cloud #  TarsCloud/Tars 国外 Pivotal 公司 2014 年对外开源的 RPC 框架，仅支持 Java 语言。\n Eureka：各个服务启动时，Eureka Client 都会将服务注册到 Eureka Server，并且 Eureka Client 还可以反过来从 Eureka Server 拉取注册表，从而知道其他服务在哪里 Ribbon：服务间发起请求的时候，基于 Ribbon 做负载均衡，从一个服务的多台机器中选择一台 Feign：基于 Feign 的动态代理机制，根据注解和选择的机器，拼接请求 URL 地址，发起请求 Hystrix：发起请求是通过 Hystrix 的线程池来走的，不同的服务走不同的线程池，实现了不同服务调用的隔离，避免了服务雪崩的问题 Zuul：如果前端、移动端要调用后端系统，统一从 Zuul 网关进入，由 Zuul 网关转发请求给对应的服务  Eureka #  Eureka 是微服务架构中的注册中心，专门负责服务的注册与发现。\n Eureka Client：负责将这个服务的信息注册到 Eureka Server 中 Eureka Server：注册中心，里面有一个注册表，保存了各个服务所在的机器和端口号  Feign #  Feign 的一个关键机制就是使用了动态代理。\nRibbon #  负载均衡\nRibbon 的负载均衡默认使用的最经典的 Round Robin 轮询算法\nHystrix #  Hystrix 是隔离、熔断以及降级的一个框架。\nHystrix 会搞很多个小小的线程池， 比如订单服务请求库存服务是一个线程池，请求仓储服务是一个线程池，请求积分服务是一个线程池。 每个线程池里的线程就仅仅用于请求那个服务。\n解决服务雪崩：\n  熔断\n比如在 5 分钟内请求积分服务直接就返回了，不要去走网络请求卡住几秒钟。 这个过程，就是所谓的熔断！\n  降级\n每次调用积分服务，你就在数据库里记录一条消息，说给某某用户增加了多少积分，因为积分服务挂了，导致没增加成功！这样等积分服务恢复了，你可以根据这些记录手工加一下积分。 这个过程，就是所谓的降级。\n  Zuul #  Netflix/zuul 微服务网关\n可以做统一的降级、限流、认证授权、安全等等\n"});index.add({'id':655,'href':'/note-cs/docs/basic/pl/csharp/advanced/snippet/','title':"2.4 代码片段",'section':"第二部分 进阶实战",'content':"代码片段 #  "});index.add({'id':656,'href':'/note-cs/docs/basic/pl/erlang/advanced/snippet/','title':"2.4 代码片段",'section':"第二部分 进阶实战",'content':"代码片段 #  "});index.add({'id':657,'href':'/note-cs/docs/basic/pl/haskell/advanced/snippet/','title':"2.4 代码片段",'section':"第二部分 进阶实战",'content':"代码片段 #  "});index.add({'id':658,'href':'/note-cs/docs/basic/pl/kotlin/advanced/snippet/','title':"2.4 代码片段",'section':"第二部分 进阶实战",'content':"代码片段 #  "});index.add({'id':659,'href':'/note-cs/docs/basic/pl/lua/advanced/snippet/','title':"2.4 代码片段",'section':"第二部分 进阶实战",'content':"代码片段 #  "});index.add({'id':660,'href':'/note-cs/docs/basic/pl/objective-c/advanced/snippet/','title':"2.4 代码片段",'section':"第二部分 进阶实战",'content':"代码片段 #  "});index.add({'id':661,'href':'/note-cs/docs/basic/pl/r/advanced/snippet/','title':"2.4 代码片段",'section':"第二部分 进阶实战",'content':"代码片段 #  "});index.add({'id':662,'href':'/note-cs/docs/basic/pl/ruby/advanced/snippet/','title':"2.4 代码片段",'section':"第二部分 进阶实战",'content':"代码片段 #  "});index.add({'id':663,'href':'/note-cs/docs/basic/pl/scala/advanced/snippet/','title':"2.4 代码片段",'section':"第二部分 进阶实战",'content':"代码片段 #  "});index.add({'id':664,'href':'/note-cs/docs/basic/pl/swift/advanced/snippet/','title':"2.4 代码片段",'section':"第二部分 进阶实战",'content':"代码片段 #  "});index.add({'id':665,'href':'/note-cs/docs/direction/client/','title':"2.4 客户端",'section':"第二部分 方向",'content':"客户端 #  "});index.add({'id':666,'href':'/note-cs/docs/book/basic/network/','title':"5.1.4 计算机网络",'section':"5.1 计算机基础",'content':"计算机网络 #  "});index.add({'id':667,'href':'/note-cs/docs/book/security/','title':"5.4 安全",'section':"第五部分 读书",'content':"安全 #  "});index.add({'id':668,'href':'/note-cs/docs/course/basic/network/','title':"6.1.4 计算机网络",'section':"6.1 计算机基础",'content':"计算机网络 #  "});index.add({'id':669,'href':'/note-cs/docs/course/security/','title':"6.4 安全",'section':"第六部分 课程",'content':"安全 #  "});index.add({'id':670,'href':'/note-cs/docs/direction/be/devops/ansible/','title':"Ansible",'section':"2.2.6 DevOps",'content':"Ansible #  ansible/ansible Ansible is a radically simple IT automation platform that makes your applications and systems easier to deploy and maintain. Automate everything from code deployment to network configuration to cloud management, in a language that approaches plain English, using SSH, with no agents to install on remote systems.\n"});index.add({'id':671,'href':'/note-cs/docs/domain/cc/others/paas/cloud-foundry/','title':"Cloud Foundry",'section':"PaaS",'content':"Cloud Foundry #  Cloud Foundry 提供了云、开发者框架和应用服务的选择，可以更快、更容易的构建、测试、发布和大规模部署应用程序。它是一个开源项目，可通过各种私有云发行版和公有云实例获得。\n组件 #  cloudfoundry/bosh #  Cloud Foundry BOSH is an open source tool for release engineering, deployment, lifecycle management, and monitoring of distributed systems.\ncloudfoundry/cli #  The official command line client for Cloud Foundry https://docs.cloudfoundry.org/cf-cli\ncloudfoundry/uaa #  CloudFoundry User Account and Authentication (UAA) Server\n Cloud Foundry 缺点 #  诸如 Cloud Foundry 的 PaaS，用户必须为不同语言、不同框架区分不同的打包方式，这个打包过程是非常具有灾难性的。 而现实往往更糟糕，当在本地跑的好好的应用，由于和远端环境的不一致，在打包后却需要在云端各种调试，最终才能让应用 “平稳” 运行。\n而 Docker 的出现改变了一切，它凭借镜像解决了这个问题。Docker 一不做二不休，干脆把完整的操作系统目录也打包进去，如此高的集成度，保证了云端和本地环境的高度一致，并且随时随地轻易地移植。\n参考：\n Kubernetes 如何打赢容器之战？  "});index.add({'id':672,'href':'/note-cs/docs/basic/pl/objective-c/','title':"Objective-C",'section':"1.5 编程语言",'content':"Objective-C 学习笔记 #  "});index.add({'id':673,'href':'/note-cs/docs/direction/be/web/wsdl/','title':"WSDL",'section':"Web Service",'content':"WSDL #  "});index.add({'id':674,'href':'/note-cs/docs/basic/pl/','title':"1.5 编程语言",'section':"第一部分 基础",'content':"编程语言 #  函数式编程 #  教程 #  MostlyAdequate/mostly-adequate-guide #  Mostly adequate guide to FP (in javascript)\n中文版 #  llh911001/mostly-adequate-guide-chinese 点击阅读\n"});index.add({'id':675,'href':'/note-cs/docs/direction/be/microservices/','title':"2.2.5 微服务",'section':"2.2 后端",'content':"微服务 #  "});index.add({'id':676,'href':'/note-cs/docs/direction/embedded/','title':"2.5 嵌入式",'section':"第二部分 方向",'content':"嵌入式开发 #  "});index.add({'id':677,'href':'/note-cs/docs/basic/pl/csharp/advanced/test/','title':"2.5 测试",'section':"第二部分 进阶实战",'content':"测试 #  "});index.add({'id':678,'href':'/note-cs/docs/basic/pl/erlang/advanced/test/','title':"2.5 测试",'section':"第二部分 进阶实战",'content':"测试 #  "});index.add({'id':679,'href':'/note-cs/docs/basic/pl/haskell/advanced/test/','title':"2.5 测试",'section':"第二部分 进阶实战",'content':"测试 #  "});index.add({'id':680,'href':'/note-cs/docs/basic/pl/kotlin/advanced/test/','title':"2.5 测试",'section':"第二部分 进阶实战",'content':"测试 #  "});index.add({'id':681,'href':'/note-cs/docs/basic/pl/lua/advanced/test/','title':"2.5 测试",'section':"第二部分 进阶实战",'content':"测试 #  "});index.add({'id':682,'href':'/note-cs/docs/basic/pl/objective-c/advanced/test/','title':"2.5 测试",'section':"第二部分 进阶实战",'content':"测试 #  "});index.add({'id':683,'href':'/note-cs/docs/basic/pl/r/advanced/test/','title':"2.5 测试",'section':"第二部分 进阶实战",'content':"测试 #  "});index.add({'id':684,'href':'/note-cs/docs/basic/pl/ruby/advanced/test/','title':"2.5 测试",'section':"第二部分 进阶实战",'content':"测试 #  "});index.add({'id':685,'href':'/note-cs/docs/basic/pl/scala/advanced/test/','title':"2.5 测试",'section':"第二部分 进阶实战",'content':"测试 #  "});index.add({'id':686,'href':'/note-cs/docs/basic/pl/swift/advanced/test/','title':"2.5 测试",'section':"第二部分 进阶实战",'content':"测试 #  "});index.add({'id':687,'href':'/note-cs/docs/skill/stream-media/','title':"4.5 流媒体",'section':"第四部分 技能树",'content':"流媒体 #  "});index.add({'id':688,'href':'/note-cs/docs/book/basic/pl/','title':"5.1.5 编程语言",'section':"5.1 计算机基础",'content':"编程语言 #  Go #     书名 作者 / 译者 出版时间 语言版本 豆瓣评分 其他说明     Go in Action         参考：\n golang/go/wiki/Books dariubs/GoBooks  List of Golang books    "});index.add({'id':689,'href':'/note-cs/docs/book/se/','title':"5.5 软件工程",'section':"第五部分 读书",'content':"软件工程 #  "});index.add({'id':690,'href':'/note-cs/docs/course/basic/pl/','title':"6.1.5 编程语言",'section':"6.1 计算机基础",'content':"编程语言 #  "});index.add({'id':691,'href':'/note-cs/docs/course/se/','title':"6.5 软件工程",'section':"第六部分 课程",'content':"软件工程 #  "});index.add({'id':692,'href':'/note-cs/docs/domain/cc/others/paas/appfog/','title':"AppFog",'section':"PaaS",'content':"AppFog #  "});index.add({'id':693,'href':'/note-cs/docs/domain/bigdata/flink/','title':"Flink",'section':"3.2 大数据",'content':"Flink #  "});index.add({'id':694,'href':'/note-cs/docs/domain/bigdata/hadoop/','title':"Hadoop",'section':"3.2 大数据",'content':"Hadoop #  HDFS #  Hadoop Distributed File System，是 Hadoop 的分布式文件系统\n每台机器上运行一个 DataNode 进程，负责管理一部分数据。\n有一台机器上运行了 NameNode 进程，负责管理整个 HDFS 集群的这么一个进程，里面存储了 HDFS 集群的所有元数据\n每次内存里改完了，写一条 edits log，元数据修改的操作日志到磁盘文件里，不修改磁盘文件内容，就是顺序追加\n每次 NameNode 重启的时候，把 edits log 里的操作日志读到内存里，就可以恢复元数据\nYARN #  MapReduce #  "});index.add({'id':695,'href':'/note-cs/docs/domain/bigdata/hadoop/hbase/','title':"HBase",'section':"Hadoop",'content':"HBase #  apache/hbase "});index.add({'id':696,'href':'/note-cs/docs/domain/bigdata/hadoop/hdfs/','title':"HDFS",'section':"Hadoop",'content':"HDFS #  "});index.add({'id':697,'href':'/note-cs/docs/domain/bigdata/hadoop/mapreduce/','title':"MapReduce",'section':"Hadoop",'content':"MapReduce #  "});index.add({'id':698,'href':'/note-cs/docs/direction/be/devops/packer/','title':"Packer",'section':"2.2.6 DevOps",'content':"Packer #  hashicorp/packer Packer is a tool for creating identical machine images for multiple platforms from a single source configuration. http://www.packer.io/\n"});index.add({'id':699,'href':'/note-cs/docs/basic/pl/php/','title':"PHP",'section':"1.5 编程语言",'content':"PHP #  见：PHP 学习笔记\n"});index.add({'id':700,'href':'/note-cs/docs/domain/bigdata/spark/','title':"Spark",'section':"3.2 大数据",'content':"Spark #  apache/spark "});index.add({'id':701,'href':'/note-cs/docs/direction/be/frame/php/swoole/','title':"Swoole",'section':"PHP 框架",'content':"Swoole #  swoole/swoole-src Coroutine-based concurrency library for PHP https://www.swoole.co.uk\nSwoole 使 PHP 开发人员可以编写高性能高并发的 TCP、UDP、Unix Socket、HTTP、 WebSocket 等服务，让 PHP 不再局限于 Web 领域。\n"});index.add({'id':702,'href':'/note-cs/docs/direction/be/db/tidb/','title':"TiDB",'section':"2.2.1 数据库",'content':"TiDB #  pingcap/tidb TiDB is a distributed HTAP database compatible with the MySQL protocol https://pingcap.com\nTiDB (\u0026ldquo;Ti\u0026rdquo; stands for Titanium) is an open-source NewSQL database that supports Hybrid Transactional and Analytical Processing (HTAP) workloads. It is MySQL compatible and features horizontal scalability, strong consistency, and high availability.\nTiDB 是 PingCAP 公司设计的开源分布式 HTAP (Hybrid Transactional and Analytical Processing) 数据库，结合了传统的 RDBMS 和 NoSQL 的最佳特性。TiDB 兼容 MySQL，支持无限的水平扩展，具备强一致性和高可用性。TiDB 的目标是为 OLTP (Online Transactional Processing) 和 OLAP (Online Analytical Processing) 场景提供一站式的解决方案。\n"});index.add({'id':703,'href':'/note-cs/docs/direction/be/web/uudi/','title':"UUDI",'section':"Web Service",'content':"UUDI #  "});index.add({'id':704,'href':'/note-cs/docs/direction/be/distributed/consistent-hashing/','title':"一致性哈希",'section':"2.2.4 分布式系统",'content':"一致性哈希 #  这篇论文中提出了一致性 hash 的概念。\nincubator-brpc doc - 一致性哈希\n一致性 hash 满足以下四个性质：\n 平衡性 (Balance) : 每个节点被选到的概率是 O (1/n)。 单调性 (Monotonicity) : 当新节点加入时， 不会有请求在老节点间移动， 只会从老节点移动到新节点。当有节点被删除时，也不会影响落在别的节点上的请求。 分散性 (Spread) : 当上游的机器看到不同的下游列表时 (在上线时及不稳定的网络中比较常见), 同一个请求尽量映射到少量的节点中。 负载 (Load) : 当上游的机器看到不同的下游列表的时候， 保证每台下游分到的请求数量尽量一致。  "});index.add({'id':705,'href':'/note-cs/docs/basic/os/type/android/basic/snippet/','title':"代码片段",'section':"第一部分 基础入门",'content':"代码片段 #  "});index.add({'id':706,'href':'/note-cs/docs/basic/os/type/ios/basic/snippet/','title':"代码片段",'section':"第一部分 基础入门",'content':"代码片段 #  "});index.add({'id':707,'href':'/note-cs/docs/basic/os/type/macos/basic/snippet/','title':"代码片段",'section':"第一部分 基础入门",'content':"代码片段 #  "});index.add({'id':708,'href':'/note-cs/docs/basic/os/type/unix/basic/snippet/','title':"代码片段",'section':"第一部分 基础入门",'content':"代码片段 #  "});index.add({'id':709,'href':'/note-cs/docs/basic/os/type/windows/basic/snippet/','title':"代码片段",'section':"第一部分 基础入门",'content':"代码片段 #  "});index.add({'id':710,'href':'/note-cs/docs/direction/be/distributed/transaction/','title':"分布式事务",'section':"2.2.4 分布式系统",'content':"分布式事务 #  微服务化带来的分布式事务问题 #  每一个服务内部的数据一致性仍由本地事务来保证。而整个业务层面的全局数据一致性要如何保障呢？\n解决方案 #  分布式事务的实现主要有以下 5 种方案：\n XA 方案 TCC 方案 本地消息表 可靠消息最终一致性方案 最大努力通知方案  如果你真的被问到，可以这么说，我们某某特别严格的场景，用的是 TCC 来保证强一致性；然后其他的一些场景基于阿里的 RocketMQ 来实现分布式事务。\n你找一个严格资金要求绝对不能错的场景，你可以说你是用的 TCC 方案；如果是一般的分布式事务场景，订单插入之后要调用库存服务更新库存，库存数据没有资金那么的敏感，可以用可靠消息最终一致性方案。\n友情提示一下，RocketMQ 3.2.6 之前的版本，是可以按照上面的思路来的，但是之后接口做了一些改变，我这里不再赘述了。\n当然如果你愿意，你可以参考可靠消息最终一致性方案来自己实现一套分布式事务，比如基于 RocketMQ 来玩儿。\n参考：\n 分布式事务了解吗？你们是如何解决分布式事务问题的？  XA 方案 #  两阶段提交方案\n有一个事务管理器的概念，负责协调多个数据库（资源管理器）的事务，事务管理器先问问各个数据库你准备好了吗？ 如果每个数据库都回复 ok，那么就正式提交事务，在各个数据库上执行操作；如果任何其中一个数据库回答不 ok，那么就回滚事务。\n这种分布式事务方案，比较适合单块应用里，跨多个库的分布式事务，而且因为严重依赖于数据库层面来搞定复杂的事务，效率很低，绝对不适合高并发的场景。\n如果要玩儿，那么基于 Spring + JTA 就可以搞定，自己随便搜个 demo 看看就知道了。\n这个方案，我们很少用，一般来说某个系统内部如果出现跨多个库的这么一个操作，是不合规的。\n TCC #  这种方案说实话几乎很少人使用， 因为这个事务回滚实际上是严重依赖于你自己写代码来回滚和补偿了，会造成补偿代码巨大，非常之恶心，业务代码是很难维护的。\n比如说我们，一般来说跟钱相关的，跟钱打交道的，支付、交易相关的场景，我们会用 TCC，严格保证分布式事务要么全部成功，要么全部自动回滚，严格保证资金的正确性，保证在资金上不会出现问题。\n而且最好是你的各个业务执行的时间都比较短。\nTCC 分布式事务框架，比如国内开源的\n ByteTCC himly tcc-transaction  Try #  首先你的业务的主流程以及各个接口提供的业务含义，不是说直接完成那个业务操作，而是完成一个 Try 的操作。\n这个操作，一般都是锁定某个资源，设置一个预备类的状态，冻结部分数据，等等，大概都是这类操作。\nConfirm #  Cancel #  参考：\n 拜托，面试请不要再问我 TCC 分布式事务的实现原理！   本地消息表 #  本地消息表其实是国外的 ebay 搞出来的这么一套思想。\n这个大概意思是这样的：\n A 系统在自己本地一个事务里操作同时，插入一条数据到消息表； 接着 A 系统将这个消息发送到 MQ 中去； B 系统接收到消息之后，在一个事务里，往自己本地消息表里插入一条数据，同时执行其他的业务操作，如果这个消息已经被处理过了，那么此时这个事务会回滚，这样保证不会重复处理消息； B 系统执行成功之后，就会更新自己本地消息表的状态以及 A 系统消息表的状态； 如果 B 系统处理失败了，那么就不会更新消息表状态，那么此时 A 系统会定时扫描自己的消息表，如果有未处理的消息，会再次发送到 MQ 中去，让 B 再次处理； 这个方案保证了最终一致性，哪怕 B 事务失败了，但是 A 会不断重发消息，直到 B 那边成功为止。  这个方案说实话最大的问题就在于严重依赖于数据库的消息表来管理事务啥的，如果是高并发场景咋办呢？咋扩展呢？所以一般确实很少用。\n 可靠消息最终一致性方案 #  这个的意思，就是干脆不要用本地的消息表了，直接基于 MQ 来实现事务。比如阿里的 RocketMQ 就支持消息事务。\n大概的意思就是：\n A 系统先发送一个 prepared 消息到 mq，如果这个 prepared 消息发送失败那么就直接取消操作别执行了； 如果这个消息发送成功过了，那么接着执行本地事务，如果成功就告诉 mq 发送确认消息，如果失败就告诉 mq 回滚消息； 如果发送了确认消息，那么此时 B 系统会接收到确认消息，然后执行本地的事务； mq 会自动定时轮询所有 prepared 消息回调你的接口，问你，这个消息是不是本地事务处理失败了，所以没发送确认的消息，是继续重试还是回滚？一般来说这里你就可以查下数据库看之前本地事务是否执行，如果回滚了，那么这里也回滚吧。这个就是避免可能本地事务执行成功了，而确认消息却发送失败了。 这个方案里，要是系统 B 的事务失败了咋办？重试咯，自动不断重试直到成功，如果实在是不行，要么就是针对重要的资金类业务进行回滚，比如 B 系统本地回滚后，想办法通知系统 A 也回滚；或者是发送报警由人工来手工回滚和补偿。 这个还是比较合适的，目前国内互联网公司大都是这么玩儿的，要不你就用 RocketMQ 支持的，要不你就自己基于类似 ActiveMQ？RabbitMQ？自己封装一套类似的逻辑出来，总之思路就是这样子的。   最大努力通知方案 #  这个方案的大致意思就是：\n 系统 A 本地事务执行完之后，发送个消息到 MQ； 这里会有个专门消费 MQ 的最大努力通知服务，这个服务会消费 MQ 然后写入数据库中记录下来，或者是放入个内存队列也可以，接着调用系统 B 的接口； 要是系统 B 执行成功就 ok 了；要是系统 B 执行失败了，那么最大努力通知服务就定时尝试重新调用系统 B，反复 N 次，最后还是不行就放弃。   开源实现 #  seata/seata #  TXC/GTS/Fescar/Seata 一脉相承\n 2014 年，阿里中间件团队发布 TXC（Taobao Transaction Constructor），为集团内应用提供分布式事务服务。 2016 年，TXC 经过产品化改造，以 GTS（Global Transaction Service） 的身份登陆阿里云，成为当时业界唯一一款云上分布式事务产品，在阿云里的公有云、专有云解决方案中，开始服务于众多外部客户。 2019 年起，基于 TXC 和 GTS 的技术积累，阿里中间件团队发起了开源项目 Fescar（Fast \u0026amp; EaSy Commit And Rollback, FESCAR），和社区一起建设这个分布式事务解决方案。 开源分布式事务 Fescar 更名为 Seata  华为 DTM #  分布式事务管理中间件（Distributed Transaction Management）是一款用于解决分布式环境下事务一致性问题的产品。在复杂环境下，事务可能会出现的各种异常，DTM 能够将开发者从处理这种异常中解放出来，聚焦于业务逻辑本身。\nDTM 支持 TCC（Try-Confirm-Cancel）事务模型，支持以注解的方式定义事务信息，实现事务高效便捷的接入。此外，DTM 具有处理高并发事务请求的能力，支持自动部署、弹性伸缩等全生命周期运维管控能力。\n参考 #   如何理解 TCC 分布式事务？  "});index.add({'id':711,'href':'/note-cs/docs/skill/tool/study/coding-online/','title':"在线编程",'section':"计算机学习",'content':"在线编程 #  "});index.add({'id':712,'href':'/note-cs/docs/basic/pl/csharp/basic/others/version/','title':"版本",'section':"1.4 其他",'content':"版本 #  版本历史 #  "});index.add({'id':713,'href':'/note-cs/docs/basic/pl/erlang/basic/others/version/','title':"版本",'section':"1.4 其他",'content':"版本 #  版本历史 #  "});index.add({'id':714,'href':'/note-cs/docs/basic/pl/haskell/basic/others/version/','title':"版本",'section':"1.4 其他",'content':"版本 #  版本历史 #  "});index.add({'id':715,'href':'/note-cs/docs/basic/pl/kotlin/basic/others/version/','title':"版本",'section':"1.4 其他",'content':"版本 #  版本历史 #  "});index.add({'id':716,'href':'/note-cs/docs/basic/pl/lua/basic/others/version/','title':"版本",'section':"1.4 其他",'content':"版本 #  版本历史 #  "});index.add({'id':717,'href':'/note-cs/docs/basic/pl/objective-c/basic/others/version/','title':"版本",'section':"1.4 其他",'content':"版本 #  版本历史 #  "});index.add({'id':718,'href':'/note-cs/docs/basic/pl/r/basic/others/version/','title':"版本",'section':"1.4 其他",'content':"版本 #  版本历史 #  "});index.add({'id':719,'href':'/note-cs/docs/basic/pl/ruby/basic/others/version/','title':"版本",'section':"1.4 其他",'content':"版本 #  版本历史 #  "});index.add({'id':720,'href':'/note-cs/docs/basic/pl/scala/basic/others/version/','title':"版本",'section':"1.4 其他",'content':"版本 #  版本历史 #  "});index.add({'id':721,'href':'/note-cs/docs/basic/pl/swift/basic/others/version/','title':"版本",'section':"1.4 其他",'content':"版本 #  版本历史 #  "});index.add({'id':722,'href':'/note-cs/docs/skill/tool/note/','title':"笔记",'section':"4.1 工具",'content':"笔记 #  "});index.add({'id':723,'href':'/note-cs/docs/skill/tool/study/','title':"计算机学习",'section':"4.1 工具",'content':"计算机学习 #  "});index.add({'id':724,'href':'/note-cs/docs/basic/pl/python/','title':"Python",'section':"1.5 编程语言",'content':"Python #  见：Python 学习笔记\n"});index.add({'id':725,'href':'/note-cs/docs/basic/pl/ruby/','title':"Ruby",'section':"1.5 编程语言",'content':"Ruby 学习笔记 #  "});index.add({'id':726,'href':'/note-cs/docs/basic/compile/','title':"1.6 编译原理",'section':"第一部分 基础",'content':"编译原理 #  "});index.add({'id':727,'href':'/note-cs/docs/direction/be/devops/','title':"2.2.6 DevOps",'section':"2.2 后端",'content':"DevOps #  不可变基础架构 #   不可变基础架构 Immutable Infrastructure  hashicorp/terraform  pulumi/pulumi  OpenStack - Heat AWS CloudFormation 阿里云 ROS Resource Orchestration Service 华为云 AOS Application Orchestration Service 百度云 COS Cloud Orchestration Service   可变基础架构 Mutable Infrastructure  ansible/ansible  saltstack/salt  chef/chef  puppetlabs/puppet     申明式 API #   声明性代码 Declarative  hashicorp/terraform  saltstack/salt  puppetlabs/puppet  AWS CloudFormation   程序性代码 Procedural  ansible/ansible  chef/chef      其他 #   prometheus/prometheus  jenkinsci/jenkins   "});index.add({'id':728,'href':'/note-cs/docs/direction/security/','title':"2.6 安全",'section':"第二部分 方向",'content':"安全 #  "});index.add({'id':729,'href':'/note-cs/docs/basic/pl/csharp/advanced/prof/','title':"2.6 性能",'section':"第二部分 进阶实战",'content':"性能 #  "});index.add({'id':730,'href':'/note-cs/docs/basic/pl/erlang/advanced/prof/','title':"2.6 性能",'section':"第二部分 进阶实战",'content':"性能 #  "});index.add({'id':731,'href':'/note-cs/docs/basic/pl/haskell/advanced/prof/','title':"2.6 性能",'section':"第二部分 进阶实战",'content':"性能 #  "});index.add({'id':732,'href':'/note-cs/docs/basic/pl/kotlin/advanced/prof/','title':"2.6 性能",'section':"第二部分 进阶实战",'content':"性能 #  "});index.add({'id':733,'href':'/note-cs/docs/basic/pl/lua/advanced/prof/','title':"2.6 性能",'section':"第二部分 进阶实战",'content':"性能 #  "});index.add({'id':734,'href':'/note-cs/docs/basic/pl/objective-c/advanced/prof/','title':"2.6 性能",'section':"第二部分 进阶实战",'content':"性能 #  "});index.add({'id':735,'href':'/note-cs/docs/basic/pl/r/advanced/prof/','title':"2.6 性能",'section':"第二部分 进阶实战",'content':"性能 #  "});index.add({'id':736,'href':'/note-cs/docs/basic/pl/ruby/advanced/prof/','title':"2.6 性能",'section':"第二部分 进阶实战",'content':"性能 #  "});index.add({'id':737,'href':'/note-cs/docs/basic/pl/scala/advanced/prof/','title':"2.6 性能",'section':"第二部分 进阶实战",'content':"性能 #  "});index.add({'id':738,'href':'/note-cs/docs/basic/pl/swift/advanced/prof/','title':"2.6 性能",'section':"第二部分 进阶实战",'content':"性能 #  "});index.add({'id':739,'href':'/note-cs/docs/book/basic/db/','title':"5.1.6 数据库",'section':"5.1 计算机基础",'content':"数据库 #  "});index.add({'id':740,'href':'/note-cs/docs/book/cc/','title':"5.6 云计算",'section':"第五部分 读书",'content':"云计算读书笔记 #  "});index.add({'id':741,'href':'/note-cs/docs/course/basic/db/','title':"6.1.6 数据库",'section':"6.1 计算机基础",'content':"数据库 #  "});index.add({'id':742,'href':'/note-cs/docs/course/cc/','title':"6.6 云计算",'section':"第六部分 课程",'content':"云计算 #  "});index.add({'id':743,'href':'/note-cs/docs/basic/pl/rust/','title':"Rust",'section':"1.5 编程语言",'content':"Rust #  见：Rust 学习笔记\n"});index.add({'id':744,'href':'/note-cs/docs/direction/se/arch/scene/release/','title':"发布形式",'section':"场景",'content':"发布形式 #   参考 #  "});index.add({'id':745,'href':'/note-cs/docs/domain/ai/dl/tutorial/','title':"教程",'section':"深度学习",'content':"教程 #  基础 #  《深度学习》(花书) #  MingchaoZhu/DeepLearning #  Python for《Deep Learning》，该书为《深度学习》(花书) 数学推导、原理剖析与源码级别代码实现\n 进阶 #   "});index.add({'id':746,'href':'/note-cs/docs/domain/ai/ml/tutorial/','title':"教程",'section':"机器学习",'content':"教程 #  基础 #  dive into deep learning #  d2l-ai/d2l-en 动手学深度学习 #  d2l-ai/d2l-zh  手写实现李航《统计学习方法》书中全部算法 #  dod-o/statistical-learning-method_code  机器学习白板推导系列 #  shuhuai007/machine-learning-session 【机器学习】【白板推导系列】【合集 1 ～ 23】\n机器学习白板系列 笔记 #  tsyw/MachineLearningNotes Bilibili - 机器学习白板系列\n 机器学习教程（小象学院） #   josephmisiti/awesome-machine-learning #   ZuzooVn/machine-learning-for-software-engineers #  A complete daily plan for studying to become a machine learning engineer.\n ageron/handson-ml #  A series of Jupyter notebooks that walk you through the fundamentals of Machine Learning and Deep Learning in python using Scikit-Learn and TensorFlow.\n fighting41love/funNLP #  NLP 民工的乐园：几乎最全的中文 NLP 资源库\n eriklindernoren/ML-From-Scratch #  Machine Learning From Scratch. Bare bones NumPy implementations of machine learning models and algorithms with a focus on accessibility. Aims to cover everything from linear regression to deep learning.\n trekhleb/homemade-machine-learning #  Python examples of popular machine learning algorithms with interactive Jupyter demos and math being explained.\n kailashahirwar/cheatsheets-ai #  Essential Cheat Sheets for deep learning and machine learning researchers\nhttps://medium.com/@kailashahirwar/essential-cheat-sheets-for-machine-learning-and-deep-learning-researchers-efb6a8ebd2e5\nhttps://aicheatsheets.com\n rasbt/python-machine-learning-book #  The \u0026ldquo;Python Machine Learning (1st edition)\u0026rdquo; book code repository and info resource\n afshinea/stanford-cs-229-machine-learning #  !Github stars\nVIP cheatsheets for Stanford\u0026rsquo;s CS 229 Machine Learning https://stanford.edu/~shervine/teaching/cs-229/\n ujjwalkarn/Machine-Learning-Tutorials #  machine learning and deep learning tutorials, articles and other resources http://ujjwalkarn.github.io/Machine-Learning-Tutorials/\n janishar/mit-deep-learning-book-pdf #  MIT Deep Learning Book in PDF format (complete and parts) by Ian Goodfellow, Yoshua Bengio and Aaron Courville\n 进阶 #  christophm/interpretable-ml-book #  Book about interpretable machine learning https://christophm.github.io/interpretable-ml-book/\nmingchaozhu/interpretablemlbook #  该书为《Interpretable Machine Learning》中文版。该书原作者是 Christoph Molnar，他是一名统计学家和机器学习者 @christophM。该书的项目 地址，这是一个很棒的工作。你可以在 releases 中下载本书英文版 pdf。\n我是 朱明超，同样，我也是一名机器学习者。关于此书的译本，我在翻译后进行了校正。如果你在英文原书中看到某些表述问题，可以参考我在中文书里的描述。当然，由于英文原书是较早前出版的，本书并不是完全基于英文书，作者 Christoph Molnar 在《Interpretable Machine Learning》的 网页版 中对内容不断填充，所以中文版的翻译主要基于网页版 (内容会多于英文书)。你可以在 releases 中下载本书中文版 pdf。\n hangtwenty/dive-into-machine-learning #  Dive into Machine Learning with Python Jupyter notebook and scikit-learn! http://hangtwenty.github.io/dive-into-machine-learning/\n RedditSota/state-of-the-art-result-for-machine-learning-problems #  This repository provides state of the art (SoTA) results for all machine learning problems.\n scutan90/DeepLearning-500-questions #  深度学习 500 问，以问答形式对常用的概率知识、线性代数、机器学习、深度学习、计算机视觉等热点问题进行阐述\nrushter/MLAlgorithms #  Minimal and clean examples of machine learning algorithms implementations\n "});index.add({'id':747,'href':'/note-cs/docs/direction/se/arch/scene/seckill/','title':"秒杀",'section':"场景",'content':"秒杀 #   参考 #  qiurunze123/miaosha #  秒杀系统设计与实现。互联网工程师进阶与分析\ncodingXiaxw/seckill #  Java 高并发秒杀系统 API\nGuoZhaoran/spikeSystem #  一个秒杀系统的例子分析\nzaiyunduan123/springboot-seckill #  基于 SpringBoot + MySQL + Redis + RabbitMQ + Guava 开发的高并发商品限时秒杀系统\n 前端技术 ：Bootstrap + jQuery + Thymeleaf 后端技术 ：SpringBoot + MyBatis + MySQL 中间件技术 : Druid + Redis + RabbitMQ + Guava  "});index.add({'id':748,'href':'/note-cs/docs/direction/mp/','title':"2.7 中台",'section':"第二部分 方向",'content':"中台 #  "});index.add({'id':749,'href':'/note-cs/docs/basic/pl/csharp/advanced/frame/','title':"2.7 框架",'section':"第二部分 进阶实战",'content':"框架 #  "});index.add({'id':750,'href':'/note-cs/docs/basic/pl/erlang/advanced/frame/','title':"2.7 框架",'section':"第二部分 进阶实战",'content':"框架 #  "});index.add({'id':751,'href':'/note-cs/docs/basic/pl/haskell/advanced/frame/','title':"2.7 框架",'section':"第二部分 进阶实战",'content':"框架 #  "});index.add({'id':752,'href':'/note-cs/docs/basic/pl/kotlin/advanced/frame/','title':"2.7 框架",'section':"第二部分 进阶实战",'content':"框架 #  "});index.add({'id':753,'href':'/note-cs/docs/basic/pl/lua/advanced/frame/','title':"2.7 框架",'section':"第二部分 进阶实战",'content':"框架 #  "});index.add({'id':754,'href':'/note-cs/docs/basic/pl/objective-c/advanced/frame/','title':"2.7 框架",'section':"第二部分 进阶实战",'content':"框架 #  "});index.add({'id':755,'href':'/note-cs/docs/basic/pl/r/advanced/frame/','title':"2.7 框架",'section':"第二部分 进阶实战",'content':"框架 #  "});index.add({'id':756,'href':'/note-cs/docs/basic/pl/ruby/advanced/frame/','title':"2.7 框架",'section':"第二部分 进阶实战",'content':"框架 #  "});index.add({'id':757,'href':'/note-cs/docs/basic/pl/scala/advanced/frame/','title':"2.7 框架",'section':"第二部分 进阶实战",'content':"框架 #  "});index.add({'id':758,'href':'/note-cs/docs/basic/pl/swift/advanced/frame/','title':"2.7 框架",'section':"第二部分 进阶实战",'content':"框架 #  "});index.add({'id':759,'href':'/note-cs/docs/book/basic/compile/','title':"5.1.7 编译原理",'section':"5.1 计算机基础",'content':"编译原理 #  "});index.add({'id':760,'href':'/note-cs/docs/book/bigdata/','title':"5.7 大数据",'section':"第五部分 读书",'content':"大数据 #  "});index.add({'id':761,'href':'/note-cs/docs/course/basic/compile/','title':"6.1.7 编译原理",'section':"6.1 计算机基础",'content':"编译原理 #  "});index.add({'id':762,'href':'/note-cs/docs/course/bigdata/','title':"6.7 大数据",'section':"第六部分 课程",'content':"大数据 #  "});index.add({'id':763,'href':'/note-cs/docs/direction/be/db/cassandra/','title':"Cassandra",'section':"2.2.1 数据库",'content':"Cassandra #  "});index.add({'id':764,'href':'/note-cs/docs/direction/be/db/mongodb/','title':"MongoDB",'section':"2.2.1 数据库",'content':"MongoDB #  教程 #  基础 #  karlseguin/the-little-mongodb-book #  The Little MongoDB Book 中文版\njustinyhuang/the-little-mongodb-book-cn ilivebox/the-little-mongodb-book 进阶 #  "});index.add({'id':765,'href':'/note-cs/docs/basic/pl/scala/','title':"Scala",'section':"1.5 编程语言",'content':"Scala 学习笔记 #  "});index.add({'id':766,'href':'/note-cs/docs/direction/se/arch/scene/','title':"场景",'section':"2.1.2 架构设计",'content':"场景 #  "});index.add({'id':767,'href':'/note-cs/docs/direction/se/arch/scene/cache/','title':"缓存",'section':"场景",'content':"缓存 #  热点数据集中失效问题\n 设置不同的失效时间 互斥锁  缓存穿透 #  查询不存在的数据\n 布隆过滤器 把这个空结果进行缓存。  缓存雪崩 #  当某一时刻发生大规模的缓存失效的情况，比如你的缓存服务宕机了，会有大量的请求进来直接打到 DB 上面。结果就是 DB 称不住，挂掉。\n解决 #   事前：使用集群缓存，保证缓存服务的高可用 事中：ehcache 本地缓存 + Hystrix 限流 \u0026amp; 降级，避免 MySQL 被打死 事后：开启 Redis 持久化机制，尽快恢复缓存集群  参考：\n ehcache/ehcache3    缓存击穿 #  在平常高并发的系统中，大量的请求同时查询一个 key 时，此时这个 key 正好失效了， 就会导致大量的请求都打到数据库上面去。\n缓存击穿实际上是缓存雪崩的一个特例\n解决 #  问题是多个线程同时去查询数据库的这条数据， 我们可以在第一个查询数据的请求上使用一个互斥锁来锁住它。 其他的线程走到这一步拿不到锁就等着，等第一个线程查询到了数据，然后做缓存。 后面的线程进来发现已经有缓存了，就直接走缓存。\n"});index.add({'id':768,'href':'/note-cs/docs/basic/pl/shell/','title':"Shell",'section':"1.5 编程语言",'content':"Shell 学习笔记 #  Shell 与 Linux 的关系 #  Shell 本质应该是 CLI，它是一个让用户通过命令行来实现和系统交互的接口。\n"});index.add({'id':769,'href':'/note-cs/docs/basic/pl/swift/','title':"Swift",'section':"1.5 编程语言",'content':"Swift 学习笔记 #  "});index.add({'id':770,'href':'/note-cs/docs/book/ai/','title':"5.8 人工智能",'section':"第五部分 读书",'content':"人工智能 #  "});index.add({'id':771,'href':'/note-cs/docs/course/ai/','title':"6.8 人工智能",'section':"第六部分 课程",'content':"人工智能 #  "});index.add({'id':772,'href':'/note-cs/docs/direction/be/mq/activemq/','title':"ActiveMQ",'section':"2.2.2 消息队列",'content':"ActiveMQ #  apache/activemq "});index.add({'id':773,'href':'/note-cs/docs/direction/be/microservices/rpc/brpc/','title':"brpc",'section':"2.2.5.1 RPC",'content':"brpc #  "});index.add({'id':774,'href':'/note-cs/docs/direction/be/devops/chef/','title':"Chef",'section':"2.2.6 DevOps",'content':"Chef #  chef/chef Chef Infra, a powerful automation platform that transforms infrastructure into code automating how infrastructure is configured, deployed and managed across any environment, at any scale http://www.chef.io/chef/\n"});index.add({'id':775,'href':'/note-cs/docs/direction/be/devops/Jenkins/','title':"Jenkins",'section':"2.2.6 DevOps",'content':"Jenkins #  jenkinsci/jenkins Jenkins automation server https://www.jenkins.io/\n"});index.add({'id':776,'href':'/note-cs/docs/direction/be/devops/pulumi/','title':"Pulumi",'section':"2.2.6 DevOps",'content':"Pulumi #  pulumi/pulumi Pulumi - Modern Infrastructure as Code. Any cloud, any language https://www.pulumi.com/\n"});index.add({'id':777,'href':'/note-cs/docs/direction/be/devops/puppet/','title':"Puppet",'section':"2.2.6 DevOps",'content':"Puppet #  puppetlabs/puppet Server automation framework and application https://puppet.com/open-source/#osp\n"});index.add({'id':778,'href':'/note-cs/docs/direction/be/devops/saltstack/','title':"SaltStack",'section':"2.2.6 DevOps",'content':"SaltStack #  saltstack/salt Software to automate the management and configuration of any infrastructure or application at scale. Get access to the Salt software package repository here: https://repo.saltstack.com/\n"});index.add({'id':779,'href':'/note-cs/docs/direction/be/mq/zeromq/','title':"ZeroMQ",'section':"2.2.2 消息队列",'content':"ZeroMQ #  ZeroMQ 只是一个网络编程的 Pattern 库，将常见的网络请求形式（分组管理，链接管理，发布订阅等）模式化、组件化，简而言之 socket 之上、MQ 之下。对于 MQ 来说，网络传输只是它的一部分，更多需要处理的是消息存储、路由、Broker 服务发现和查找、事务、消费模式（ack、重投等）、集群服务等。\n"});index.add({'id':780,'href':'/note-cs/docs/direction/be/auth/','title':"认证与授权",'section':"2.2 后端",'content':"认证与授权 #  "});index.add({'id':781,'href':'/note-cs/docs/book/others/','title':"5.9 其他",'section':"第五部分 读书",'content':"其他 #  "});index.add({'id':782,'href':'/note-cs/docs/course/others/','title':"6.9 其他",'section':"第六部分 课程",'content':"其他 #  "});index.add({'id':783,'href':'/note-cs/docs/direction/fe/frame/jquery/','title':"Jquery",'section':"2.2.3 框架",'content':"Jquery #  "});index.add({'id':784,'href':'/note-cs/docs/direction/be/microservices/rpc/motan/','title':"Motan",'section':"2.2.5.1 RPC",'content':"Motan #  微博内部使用的 RPC 框架，于 2016 年对外开源，仅支持 Java 语言。\n"});index.add({'id':785,'href':'/note-cs/docs/direction/be/microservices/rpc/tars/','title':"Tars",'section':"2.2.5.1 RPC",'content':"Tars #  Total Application Framework\nTarsCloud/Tars 腾讯内部使用的 RPC 框架，于 2017 年对外开源。\n目前支持 C++, Java 和 NodeJs 三种语言。\n"});index.add({'id':786,'href':'/note-cs/docs/direction/be/microservices/rpc/thrift/','title':"Thrift",'section':"2.2.5.1 RPC",'content':"Thrift #  最初是由 Facebook 开发的内部系统跨语言的 RPC 框架，2007 年贡献给了 Apache 基金，成为 Apache 开源项目之一，支持多种语言。\n"});index.add({'id':787,'href':'/note-cs/docs/direction/be/web/','title':"Web Service",'section':"2.2 后端",'content':"Web Service #  教程 #  kamranahmedse/developer-roadmap #  Roadmap to becoming a web developer in 2021\n"});index.add({'id':788,'href':'/note-cs/docs/direction/be/platform/','title':"平台",'section':"2.2 后端",'content':"平台 #  "});index.add({'id':789,'href':'/note-cs/docs/direction/be/mq/mqtt/','title':"MQTT",'section':"2.2.2 消息队列",'content':"MQTT #  mqtt 各种 broker 如何选择？\nAgent 和 Broker 的差别是什么？\n 经纪人（Broker）：是为促成他人交易，充当订约居间人，为委托方提供订约的信息、机会和条件的主体。  Broker 是一个独立主体，但没有自主决策能力，只负责订约过程。   代理人（Agent）：是行使被代理者的权力，完成相关的使命或者任务主体。  Agent 是一个独立主体，负责完成任务但不负责执行任务，Agent 具有一定的自主决策能力，如对服务请求的选择。   代理（Proxy）是指行为代理，不是一个主体。  Proxy 是完全的传递者，如请求和响应的转发，操作控制的传递。    "});index.add({'id':790,'href':'/note-cs/docs/direction/be/auth/sso/saml/','title':"SAML",'section':"SSO",'content':"SAML #  1.0 #  2.0 #  参考 #   How SAML Authentication Works  "});index.add({'id':791,'href':'/note-cs/docs/domain/cc/others/','title':"其他",'section':"3.1 云计算",'content':"其他 #  "});index.add({'id':792,'href':'/note-cs/docs/direction/be/search/','title':"搜索引擎",'section':"2.2 后端",'content':"搜索引擎 #  "});index.add({'id':793,'href':'/note-cs/docs/skill/type/','title':"文档类型",'section':"第四部分 技能树",'content':"文档类型 #  "});index.add({'id':794,'href':'/note-cs/docs/skill/stream-media/lorawan/chirpstack/','title':"ChirpStack",'section':"LoRaWan",'content':"ChirpStack #  ChirpStack Network Server #  ChirpStack Network Server is an open-source LoRaWAN network-server. https://www.chirpstack.io\n ChirpStack Application Server #  ChirpStack Application Server is an open-source LoRaWAN application-server. https://www.chirpstack.io\n"});index.add({'id':795,'href':'/note-cs/docs/skill/stream-media/lorawan/claa/','title':"CLAA",'section':"LoRaWan",'content':"CLAA #  The China LoRa Application Alliance\nCLAA IoT Ecosystem\n"});index.add({'id':796,'href':'/note-cs/docs/skill/stream-media/lorawan/','title':"LoRaWan",'section':"4.5 流媒体",'content':"LoRaWan #  "});index.add({'id':797,'href':'/note-cs/docs/skill/stream-media/ffmpeg/','title':"FFmpeg",'section':"4.5 流媒体",'content':"FFmpeg #  FFmpeg/FFmpeg Fast Forward Moving Picture Experts Group\nFFmpeg is a collection of libraries and tools to process multimedia content such as audio, video, subtitles and related metadata.\n安装 #  linux 安装 ffmpeg\nhttps://www.tecmint.com/install-ffmpeg-in-linux/\nffmpeg -re -i car-brand.MOV -rtsp_transport tcp -vcodec h264 -f rtsp rtsp://localhost/test ffplay #  # 添加到 ~/.zshrc function rtsp() { ffplay -analyzeduration 1000000 -fflags nobuffer -probesize 32 -sync ext $@ }  命令 #  ffmpeg -i rtsp://admin:root123@192.168.66.119/ -vcodec copy -acodec copy -rtsp_transport tcp -f rtsp rtsp://127.0.0.1/test.sdp # 音视频转码后推送 ffmpeg -i rtsp://admin:root123@192.168.66.119/ -vcodec libx264 -acodec libvo_aacenc -rtsp_transport tcp -f rtsp rtsp://127.0.0.1/test.sdp ffmpeg -re -i ./car-brand.MOV -stream_loop -1 -vcodec libx264 -acodec aac -f rtsp rtsp://10.159.11.167:8194/car-brand ffmpeg -re -i ./car-brand.MOV -rtsp_transport tcp -vcodec h264 -f rtsp rtsp://localhost/test ffmpeg -re -i ./car-brand.MOV -rtsp_transport udp -vcodec h264 -f rtsp rtsp://localhost/test ffmpeg -re -stream_loop -1 -i carbrand.MOV -rtsp_transport tcp -vcodec h264 -f rtsp rtsp://localhost/test1 ffmpeg -re -stream_loop -1 -i carbrand.MOV -c copy -f rtsp rtsp://localhost:8554/mystream ffmpeg 参数 #  # 参考文档 https://ffmpeg.org/ffmpeg.html Main options: # Force input or output file format. The format is normally auto detected for input files and guessed from the file extension for output files, so this option is not needed in most cases. -f fmt force format # Select an encoder (when used before an output file) # or a decoder (when used before an input file) for one or more streams. # codec is the name of a decoder/encoder # or a special value copy (output only) to indicate that the stream is not to be re-encoded. -c codec codec name -codec codec codec name # input file url -i url # Set number of times input stream shall be looped. Loop 0 means no loop, loop -1 means infinite loop. # -1 无限循环 -stream_loop number Video options: -r rate set frame rate (Hz value, fraction or abbreviation) -vcodec codec force video codec (\u0026#39;copy\u0026#39; to copy stream) Audio options: -acodec codec force audio codec (\u0026#39;copy\u0026#39; to copy stream) # Read input at native frame rate. Mainly used to simulate a grab device, or live input stream (e.g. when reading from a file). # 用来模拟一个摄像头或者实时流，不要在正式环境使用 -re  h264_nvenc vs libx264 vs h264 #  h264_nvenc uses the NVidia hardware assisted H.264 video encoder. libx264 is a software (CPU) based H.264 encoder.\n参考：\n What is the difference between libx264 and h264_nvenc?  "});index.add({'id':798,'href':'/note-cs/docs/skill/stream-media/gb28181/','title':"GB28181",'section':"4.5 流媒体",'content':"GB28181 #  GB28181 协议是设备端主动向服务端发起注册消息，并定时发送保活消息，服务端收到后就认为设备在线，超时收不到保活的话就认为设备离线了。客户端发起播放视频请求时，服务端给指定的设备发送 INVITE 请求，通知设备将指定的通道的视频推送到服务端，服务端再转发给客户端，用户就可以播放了。\nGB28181 传输协议是 RTP，去掉 RTP 头部，剩余数据为 H264 PS 流，可使用 VLC 直接播放\nGB28181 报文 #  国标 IPC 的 IP 为 192.168.10.8， IPC 本地 SIP 端口为 60719， SIP ID 为 34020000002000000719；\nSIP 服务器的 IP 为 192.168.10.10， SIP 服务器的端口为 57030， SIP ID 为 34020000002000000001。\n整个国标信令部分基于 UDP 协议进行传输。\n开发基于 resiprocate/resiprocate 注册（REGISTER） #  注销（CANCEL） #  心跳（Keepalive） #  INVITE #  云台控制（PTZ） #   GB28181 协议版本 #  2012 年，GB/T-28181 的第一版标准 #  国家为了规范安防行业的设备平台互联互通，在 2012 年出台了 GB/T-28181 的第一版标准\n协议对流媒体的规范还是比较好（H.264 + G711 封装成 PS 流，再经过 RTP 协议进行实时传输），但是控制方面有很多不足，相对于当前流行的 ONVIF 协议在控制信令上还是有很多不足。\n2014 年，修改补充文件 #  后续公安一所又感觉 2011 版本的协议不能满足方方面面的信令需求，于是增加了修改补充协议 这次的补充，完善之前协议各地方说辞有误或是不清晰的地方，还增加了不少的信令需求，如：回放、下载、配置、传输协议、设备控制（拉宽放大、缩小）等待一系列的功能。\n2016 年，GB/T-28181 - 2016 版本 #  2016 年公安部一所又推出了 GB/T-28181 - 2016 版本，此版本就是对之前的 2011 版和修改补充版进行合并，并增加一些信令，说明制定协议的同志们一直都在努力。\n这次的版本应该算是阶段性的版本了，短时间内应该不会修改了。\nUDP vs TCP 主动 vs TCP 被动 #  在 GB28181 的 2016 版中，对于媒体流的传输在原有 UDP 传输的基础中，增加了主动 tcp 和被动 tcp 的方式。\nRTP over UDP vs RTP over TCP\n# 默认 UDP m=audio 6000 RTP/AVP 8 # 指定 TCP m=video 6000 TCP/RTP/AVP 96 主动 TCP vs 被动 TCP\na=setup:active a=setup:passive UDP #  这个是普遍的传输方式\nGB28181 服务端在发 invite 时，在携带的 SDP 中包含了接收媒体的端口，设备端（被呼叫端）收到 invite 后，解析该端口，通过 UDP 将媒体流发向该端口。\nTCP 被动 #  GB28181 服务端在发 invite 时，在携带的 SDP 中包含了接收媒体的端口，并监听该端口的媒体数据，设备端（被呼叫端）收到 invite 后，解析该端口，通过 TCP 将媒体流发向该端口。\nTCP 主动 #  设备端（被呼叫端）告知服务端自己的媒体流 tcp 端口，服务端主动去连接设备端（被呼叫端）的该端口，获取数据。\n参考：\n GB28181 协议实现简介   GB28181 的协议栈实现 #  GB/T-28181 协议其实就是在国际上通用的 SIP 协议进行私有化定制， 流媒体方面就是在国际最流行的编码上进行封装（当然也有我们国家的编码标准 SVAC）。\nlibosip + libexosip + libxml 来实现 IPC 和平台协议功能，前面两者负责 sip 协议的实现，libxml 用来封装和解析实体信令。通过 3~4 年的市场应用感觉挺稳定的。\n流媒体方面：从编码中获取的 h.264 + g711 的视音频帧，进行 PS 媒体协议封装（自己写的 PS 封装协议），再经过 RTP 传输协议（自己实现）发送至平台。\n平台对收到的 RTP 流媒体进行解 RTP, 解 PS，再进行 h.264 + g711 的解码。\n SIP 协议 #  会话初始协议\nSIP 协议是一个应用层的点对点协议，用于初始、管理和终止网络中的语音和视频会话，是 GB28181 的核心之一。\n会话发起协议（ Session Initiation Protocol，缩写 SIP）是一个由 IETF MMUSIC 工作组开发的协议，作为标准被提议用于创建，修改和终止包括视频，语音，即时通信，在线游戏和虚拟现实等多种多媒体元素在内的交互式用户会话。2000 年 11 月，SIP 被正式批准成为 3GPP 信号协议之一，并成为 IMS 体系结构的一个永久单元。SIP 与 H.323 一样，是用于 VoIP 最主要的信令协议之一。\n  Antisip\n  List of SIP software\n  osip vs exosip #  osip #  oSIP is a free software library for VoIP applications implementing lower layers of Session Initiation Protocol (SIP).\noSIP 的开发开始于 2000 年 7 月，第一个版本在 2001 年 5 月发布。\noSIP 采用 ANSI C 编写，而且结构简单小巧，所以速度特别快。\n它并不提供高层的 SIP 会话 控制 API，它主要提供一些解析 SIP/SDP 消息的 API 和事务处理的状态机。\noSIP 不提供任何快速产生请求消息和响应消息的方法，所有请求消息和响应消息的形成必须调用一组 sip message api 来手动组装完成，\noSIP 的作者还开发了基于 oSIP 的 UA lib:exosip 和 proxy server lib:partysip\nSoftware using oSIP\n eXosip, the \u0026ldquo;eXtended osip\u0026rdquo; library. An extension of oSIP for softphone implementation written by Aymeric Moizard. GNU SIP Witch  exosip #   pjsip #  PJSIP 是一个开源的 SIP 协议库，它实现了 SIP、SDP、RTP、STUN、TURN 和 ICE。PJSIP 作为基于 SIP 的一个多媒体通信框架提供了非常清晰的 API，以及 NAT 穿越的功能。PJSIP 具有非常好的移植性，几乎支持现今所有系统：从桌面系统、嵌入式系统到智能手机。\nPJSIP 同时支持语音、视频、状态呈现和即时通讯。PJSIP 具有非常完善的文档，对开发者非常友好。\nPJSIP 由 Benny Prijono、Perry Ismangil 在 2005 年创建，之后不久，Nanang Izzuddin、Sauw Ming 加入开发团队。2006 年成立 Teluu Ltd.，成为开发和维护 PJSIP 的公司。PJSIP 采用双 License：GPLv2 以及商业许可证，开发者可以根据需要选择不同的 License。\n"});index.add({'id':799,'href':'/note-cs/docs/skill/stream-media/gb28181/sdp/','title':"SDP",'section':"GB28181",'content':"SDP #  Session Description Protocol\nSDP 本身并不提供媒体服务，它只是描述了媒体服务在哪，以及如何和那个媒体服务打交道。\n媒体传输相关的协议在 SIP 消息 SDP 段携带， 在服务器和客户端之间进行商议。\nSDP 协议的具体内容参看：RFC2327\n由于 Web 端、IOS、Android、PC、MAC 端的差异性导致它们对音视频的支持能力不同， 所以我们进行一些音视频会话之前，需要交互下彼此的音视频编解码能力、网络带宽和传输协议等信息， 这些需要协商的信息需要用 SDP 来描述。\nSDP 并不是传输协议，需要用 RTSP、SIP、HTTP 等协议进行承载传输、交换， 如果大家协调好了之后，就可以建立会话，完成真实的音视频码流传输，再完成解码和播放。\nSDP 一般用在媒体会话建立之前，可以适用于实时流媒体、点播、直播等领域，特别在音视频通话、视频会议、VoIP、视频监控等领域应用较多。 媒体码流一般基于 RTP 传输，服务质量用 RTCP 协议保障。\n但是 SDP 的交互不是所有音视频会话建立时都是必须的，假如双方提前约定好这些音视频会话创建需要的信息就不用这个步骤来交互彼此的 SDP 信息， 比如 HTTP-FLV、RTMP-FLV 直播和点播方案，因为一旦采用了这套方案，这些音视频会话建立需要的信息都是确定的， 但是这样会降低或者说没有充分发挥端到端的音视频能力，协商显得更加灵活点。\nSDP 作用 #  SDP 作用包括以下一些方面\n 建立会话的详细信息，包括名称，网络，带宽等信息 包含在会话中的媒体信息，包括：  媒体类型 (video, audio, etc) 传输协议 (RTP/UDP/IP, H.320, etc) 媒体格式 (H.261 video, MPEG video, etc) 多播或远端（单播）地址和端口   为接收媒体而需的信息 使用的带宽信息 可信赖的接洽信息  如果拓展，还可以描述会话的安全方案信息、服务质量信息等，其中 WebRTC 就在 SDP 的基础上进行了继续拓展\n协议包格式 #  Protocol: SIP/SDP\nFrame 238: 633 bytes on wire (5064 bits), 633 bytes captured (5064 bits) on interface 0 Ethernet II, Src: 98:df:82:6d:9e:52 (98:df:82:6d:9e:52), Dst: Apple_70:23:0d (88:e9:fe:70:23:0d) Internet Protocol Version 4, Src: 192.168.137.109, Dst: 192.168.137.105 User Datagram Protocol, Src Port: 5060, Dst Port: 5060 Session Initiation Protocol (200) Status-Line: SIP/2.0 200 OK Status-Code: 200 [Resent Packet: False] [Request Frame: 234] [Response Time (ms): 17] Message Header Via: SIP/2.0/UDP 192.168.64.3:15060;rport=5060;branch=z9hG4bK575396672;received=192.168.137.105 From: \u0026lt;sip:34020000002000000001@3402000000\u0026gt;;tag=139396672 To: \u0026lt;sip:34020000001320000001@3402000000\u0026gt;;tag=403895202 Call-ID: 325396492 CSeq: 3 INVITE Contact: \u0026lt;sip:34020000001320000001@192.168.64.3:41073\u0026gt; Content-Type: application/sdp User-Agent: IP Camera Content-Length: 191 Message Body Session Description Protocol Session Description Protocol Version (v): 0 Owner/Creator, Session Id (o): 34020000001320000001 1136 1136 IN IP4 192.168.137.109 Session Name (s): Play Connection Information (c): IN IP4 192.168.137.109 Time Description, active time (t): 0 0 Media Description, name and address (m): video 15060 RTP/AVP 96 Media Attribute (a): sendonly Media Attribute (a): rtpmap:96 PS/90000 Media Attribute (a): filesize:0 Unknown: y=0200000001 Version (v) #  Session Name (s) #  Media Description, name and address (m) #  Media Attribute (a) #  y #  GB28181 规定， y 用 10 位十进制数来表示 32 bit 的 SSRC\n 第 1 位为历史或者实时媒体流的标识位，0 为实时，1 为历史； 第 2 位到第 6 位取 20 位 SIP 监控域 ID 之中的 4-8 位作为域标识； 第 7-10 位作为域内媒体流标识，是一个与当前域内产生的媒体流 SSRC 值后 4 位不重复的四位十进制整数；  "});index.add({'id':800,'href':'/note-cs/docs/skill/stream-media/gb28181/sip/','title':"SIP",'section':"GB28181",'content':"SIP #  SIP 协议使用 RTP 协议传送音视频数据流，使用 SDP 协议进行媒体描述。\nCALL-ID #  SIP 的一次通话，可以通过 From, To, Call-ID 三元组来区分。\nCALL-ID 字段用于标识一个特定邀请以及与这个邀请相关的所有后续事务（即标识一个会话）\n 包内容 #  Message #  Session Initiation Protocol (MESSAGE) Request-Line: MESSAGE sip:34020000002000000001@3402000000 SIP/2.0 Message Header Via: SIP/2.0/UDP 192.168.137.109:5060;rport;branch=z9hG4bK1013136823 From: \u0026lt;sip:34020000001320000001@3402000000\u0026gt;;tag=676399389 To: \u0026lt;sip:34020000002000000001@3402000000\u0026gt; Call-ID: 1119613114 CSeq: 20 MESSAGE Content-Type: Application/MANSCDP+xml Max-Forwards: 70 User-Agent: IP Camera Content-Length: 178 Message Body \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;GB2312\u0026#34;?\u0026gt;\\n \u0026lt;Notify\u0026gt;\\n \u0026lt;CmdType\u0026gt;Keepalive\u0026lt;/CmdType\u0026gt;\\n \u0026lt;SN\u0026gt;123\u0026lt;/SN\u0026gt;\\n \u0026lt;DeviceID\u0026gt;34020000001320000001\u0026lt;/DeviceID\u0026gt;\\n \u0026lt;Status\u0026gt;OK\u0026lt;/Status\u0026gt;\\n \u0026lt;Info\u0026gt;\\n \u0026lt;/Info\u0026gt;\\n \u0026lt;/Notify\u0026gt;\\n Bye #  同一个会话，CSeq 要 +1\nInvite-\u0026gt;100-\u0026gt;200-\u0026gt;Ack -\u0026gt;Bye-\u0026gt;200\nBye 的包，From 和 To 要和 Ack 的一致（包括 tag），Call-ID 也要一致\n 包字段 #  SN（命令序列号） #  MANSCDP 消息中的 SN 值用于与请求命令的匹配处理,响应命令中的 SN 值应使用请求命令中的 SN 值。\n SIP Proxy #  SIP Proxy 有分为两种模式，一种是状态代理模式，另外一种是无状态代理模式。\nSIP 代理自己本身不能发起 INVITE 或者 BYE 请求，这样就不能满足 IP 语音通信的基本呼叫功能。\n双方终端通过多个 Proxy 代理以后，根据 Route Set 返回处理流程。 但是，在一些情况下，如果终端忽略了 Route Set 以后，直接通过呼叫方和被呼叫方，双方可能进行非法呼叫， 它们跳过了代理服务器，导致业务控制层很难对其进行管理。\n为了解决这个问题，引入了 B2BUA 机制，通过背靠背的方式来实现业务能力的管理和会话的管理\n开源实现 #  Kamalio #  kamailio/kamailio OpenSIPS #  OpenSIPS/opensips  B2BUA #  B2BUA 是一个逻辑实体，它由一个 UAS 和一个 UAC 两个部分构成，分别负责接收请求，处理请求和生成请求。 B2BUA 和 SIP 代理不同，它必须保持在 dialog 中所有创建的请求。只有这样，B2BUA 才能完全控制所有需要管理的会话。\nB2BUA 具体的构成如下：\nB2BUA 介于两个终端之间\n UAC 对 B2BUA 发起一个 INVITE 请求，在 B2BUA 端，B2BUA 是一个 UAS 来接收这个请求，创建了第一个会话来管理这个请求。双方保存了彼此的 Route Set 记录消息。 为了对另外一个终端发起 INVITE 请求，B2BUA 同时也扮演了一个 UAC 的角色，它创建了第二个会话，并且再次对下游终端发起 INVITE 请求。这里，UAC 需要从 UAS 端拷贝 SDP 消息和其他必要消息内容。然后，UAC 对下游终端发起 INVITE 请求。终端接收了 INVITE 请求，并且保存了 Route Set 数据记录。 为了响应 INVITE 请求，这里，下游终端就会变成一个 UAS 回复 B2BUA 200 OK。B2BUA 再次拷贝 200 OK 的消息，然后通过 UAS 再次返回到 UAC 终端。 UAC 终端收到 200 OK 以后，保存为 Route Set 数据内容。  为什么需要 B2BUA #  如果计费模块检测到双方呼叫费用出现超额的时候，这时，B2BUA 会切换成 UAC/UAC 的状态，同时对终端发送 BYE 消息。\n 教程 #   Session Initiation Protocol Tutorial (by tutorialspoint)   参考 #   B2BUA/SBC/Proxy 的 SIP 消息重构和 RFC7092 详解  "});index.add({'id':801,'href':'/note-cs/docs/skill/stream-media/voip/','title':"VoIP",'section':"4.5 流媒体",'content':"VoIP #  VoIP vs SIP #  In simple terms, VoIP means making or receiving phone calls over the internet or internal networks. SIP, on the other hand, is an application layer protocol that is used to establish, modify and terminate multimedia sessions such as VoIP calls.\nA major difference between VoIP and SIP is their scope. VoIP is not a discrete technology in its own right. Rather, it is actually a family of technologies used within modern telecommunication networks, whereas SIP is a signalling protocol used within the VoIP umbrella.\nA further difference is that, whilst VoIP sends only voice messages, SIP can carry all forms of media, not just voice messages. Transmitted via data networks, SIP trunks send packets, which may include voice, data, or video content. This means that SIP systems allow users to make voice and video calls online, often for free.\n参考：\n Key differences between SIP \u0026amp; VOIP  "});index.add({'id':802,'href':'/note-cs/docs/skill/stream-media/gb28181/protocal/','title':"协议详情",'section':"GB28181",'content':"GB28181 协议解析 #  点击在线查看标准完整文本： 公共安全视频监控联网系统信息传输、交换、控制技术要求。\n名词解释 #  SIP 服务器 #  SIP client #  具有注册登记、建立 / 终止会话连接、接收和播放视音频流等功能，主要包括用户界面、用户代理 (UA)、媒体解码模块和媒体通信模块。\nSIP device #  具有注册、建立 / 终止会话连接和控制、采集 / 编解码以及传送视音频流等的功能实体，主要包括用户代理 (UA)、媒体采集 / 编解码模块和媒体通信模块。\n联网系统中 SIP 设备的实现形式主要有支持 SIP 协议的网络摄像机、视频编 / 解码设备、数字硬盘录像机 (DVR) 和报警设备等。若 SIP 设备具有多路视音频编解码通道，每个通道宜成为一个 SIP 逻辑 UA, 具有唯一的 SIPURI, 并向 SIP 服务器注册。\nSIP 监控域 SIP surveil lance realm #  支持本标准规定的通信协议的监控网络，通常由 SIP 服务器和注册在 SIP 服务器上的监控资源、用户终端、网络等组成。\n注册服务器 register server #  IETF RFC 3261 规定的 SIP 逻辑实体，是具有接收注册请求、将请求中携带的信息进行保存并提供本域内位置服务的功能服务器。\n中心信令控制服务器 center control server #  具有向 SIP 客户端、SIP 设备、媒体服务器和网关提供注册、路由选择以及逻辑控制功能，并且提供接口与应用服务器通信。\n组成中心信令控制的逻辑实体包括代理服务器、注册服务器、重定向服务器、背靠背用户代理等的一种或者几种，是负责核心 SIP 信令应用处理的 SIP 服务器。\n媒体服务器 media server #  提供实时媒体流的转发服务，提供媒体的存储、历史媒体信息的检索和点播服务。\n媒体服务器接收来自 SIP 设备、网关或其他媒体服务器等设备的媒体数据，并根据指令，将这些数据转发到其他单个或者多个 SIP 客户端和媒体服务器。\n信令安全路由网关 secure signal routing gateway #  具有接收或转发域内外 SIP 信令功能，并且完成信令安全路由网关间路由信息的传递以及路由信令、信令身份标识的添加和鉴别等功能，是一种具有安全功能的 SIP 服务器。\n SIP 监控域互联结构 #   GB28181 通信协议结构 #   交互过程 #  客户端主动发起 #  趣解：\n第三方呼叫控制 #   编码规则 #  设备 ID, 通道 ID #  # 一共 20 位 34020000001320000001 省 市 区 单位 行业 设备类型 网络标识 设备序号 34 02 00 00 00 132 0 000001 "});index.add({'id':803,'href':'/note-cs/docs/skill/stream-media/gb28181/packet/','title':"数据包",'section':"GB28181",'content':"数据包 #  Register #  request: Register (no auth) #  Frame 2117: 442 bytes on wire (3536 bits), 442 bytes captured (3536 bits) on interface 0 Ethernet II, Src: 98:df:82:6d:9e:52 (98:df:82:6d:9e:52), Dst: Apple_70:23:0d (88:e9:fe:70:23:0d) Internet Protocol Version 4, Src: 192.168.137.109, Dst: 192.168.137.105 User Datagram Protocol, Src Port: 5060, Dst Port: 5060 Session Initiation Protocol (REGISTER) Request-Line: REGISTER sip:34020000002000000001@3402000000 SIP/2.0 Method: REGISTER Request-URI: sip:34020000002000000001@3402000000 [Resent Packet: True] [Suspected resend of frame: 1613] Message Header Via: SIP/2.0/UDP 192.168.137.109:5060;rport;branch=z9hG4bK1935014795 From: \u0026lt;sip:34020000001320000001@3402000000\u0026gt;;tag=496441511 To: \u0026lt;sip:34020000001320000001@3402000000\u0026gt; Call-ID: 1188137981 CSeq: 1 REGISTER Contact: \u0026lt;sip:34020000001320000001@192.168.137.109:5060\u0026gt; Max-Forwards: 70 User-Agent: IP Camera Expires: 3600 Content-Length: 0 response: 401 #  Frame 2121: 524 bytes on wire (4192 bits), 524 bytes captured (4192 bits) on interface 0 Ethernet II, Src: Apple_70:23:0d (88:e9:fe:70:23:0d), Dst: 98:df:82:6d:9e:52 (98:df:82:6d:9e:52) Internet Protocol Version 4, Src: 192.168.137.105, Dst: 192.168.137.109 User Datagram Protocol, Src Port: 5060, Dst Port: 5060 Session Initiation Protocol (401) Status-Line: SIP/2.0 401 Unauthorized Status-Code: 401 [Resent Packet: False] [Request Frame: 1613] [Response Time (ms): 15594] Message Header Via: SIP/2.0/UDP 192.168.137.109:5060;rport=47918;received=192.168.64.3;branch=z9hG4bK1935014795 From: \u0026lt;sip:34020000001320000001@3402000000\u0026gt;;tag=496441511 To: \u0026lt;sip:34020000001320000001@3402000000\u0026gt;;tag=697042285 CSeq: 1 REGISTER Call-ID: 1188137981 User-Agent: LiveGBS v200603 Contact: \u0026lt;sip:34020000002000000001@192.168.64.3:15060\u0026gt; Content-Length: 0 WWW-Authenticate: Digest realm=\u0026#34;3402000000\u0026#34;,qop=\u0026#34;auth\u0026#34;,nonce=\u0026#34;a1b6ba00d8cbaa8ce99d1d39b2905d12\u0026#34; request: register (auth) #  Frame 2122: 704 bytes on wire (5632 bits), 704 bytes captured (5632 bits) on interface 0 Ethernet II, Src: 98:df:82:6d:9e:52 (98:df:82:6d:9e:52), Dst: Apple_70:23:0d (88:e9:fe:70:23:0d) Internet Protocol Version 4, Src: 192.168.137.109, Dst: 192.168.137.105 User Datagram Protocol, Src Port: 5060, Dst Port: 5060 Session Initiation Protocol (REGISTER) Request-Line: REGISTER sip:34020000002000000001@3402000000 SIP/2.0 Method: REGISTER Request-URI: sip:34020000002000000001@3402000000 [Resent Packet: False] Message Header Via: SIP/2.0/UDP 192.168.137.109:5060;rport;branch=z9hG4bK2038639153 From: \u0026lt;sip:34020000001320000001@3402000000\u0026gt;;tag=496441511 To: \u0026lt;sip:34020000001320000001@3402000000\u0026gt; Call-ID: 1188137981 CSeq: 2 REGISTER Contact: \u0026lt;sip:34020000001320000001@192.168.137.109:5060\u0026gt; [truncated]Authorization: Digest username=\u0026#34;34020000001320000001\u0026#34;, realm=\u0026#34;3402000000\u0026#34;, nonce=\u0026#34;a1b6ba00d8cbaa8ce99d1d39b2905d12\u0026#34;, uri=\u0026#34;sip:34020000002000000001@3402000000\u0026#34;, response=\u0026#34;487b46591eae35a8d8f684db454ec471\u0026#34;, algorithm=MD5, cnonce Max-Forwards: 70 User-Agent: IP Camera Expires: 3600 Content-Length: 0 response: 200 #  Frame 2123: 463 bytes on wire (3704 bits), 463 bytes captured (3704 bits) on interface 0 Ethernet II, Src: Apple_70:23:0d (88:e9:fe:70:23:0d), Dst: 98:df:82:6d:9e:52 (98:df:82:6d:9e:52) Internet Protocol Version 4, Src: 192.168.137.105, Dst: 192.168.137.109 User Datagram Protocol, Src Port: 5060, Dst Port: 5060 Session Initiation Protocol (200) Status-Line: SIP/2.0 200 OK Status-Code: 200 [Resent Packet: False] [Request Frame: 2122] [Response Time (ms): 17] Message Header Via: SIP/2.0/UDP 192.168.137.109:5060;rport=60954;received=192.168.64.3;branch=z9hG4bK2038639153 From: \u0026lt;sip:34020000001320000001@3402000000\u0026gt;;tag=496441511 To: \u0026lt;sip:34020000001320000001@3402000000\u0026gt;;tag=410042311 CSeq: 2 REGISTER Call-ID: 1188137981 User-Agent: LiveGBS v200603 Contact: \u0026lt;sip:34020000002000000001@192.168.64.3:15060\u0026gt; Content-Length: 0 Date: 2020-06-09T14:09:01.830 Expires: 3600 remove 1 binding #  有 remove 1 binding, 然后重新 register 的现象\nMessage Header：\n CSeq 加 1， Contact 的 expires=0   Message #  request: sip server -\u0026gt; ipc #  Frame 2136: 571 bytes on wire (4568 bits), 571 bytes captured (4568 bits) on interface 0 Ethernet II, Src: Apple_70:23:0d (88:e9:fe:70:23:0d), Dst: 98:df:82:6d:9e:52 (98:df:82:6d:9e:52) Internet Protocol Version 4, Src: 192.168.137.105, Dst: 192.168.137.109 User Datagram Protocol, Src Port: 5060, Dst Port: 5060 Session Initiation Protocol (MESSAGE) Request-Line: MESSAGE sip:34020000001320000001@3402000000 SIP/2.0 Method: MESSAGE Request-URI: sip:34020000001320000001@3402000000 [Resent Packet: False] Message Header Via: SIP/2.0/UDP 192.168.64.3:15060;rport;branch=z9hG4bK268043391 From: \u0026lt;sip:34020000002000000001@3402000000\u0026gt;;tag=181043391 To: \u0026lt;sip:34020000001320000001@3402000000\u0026gt; Call-ID: 44043391 CSeq: 1 MESSAGE Content-Type: Application/MANSCDP+xml Max-Forwards: 70 User-Agent: LiveGBS v200603 Content-Length: 162 Message Body \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt;\\r\\n \u0026lt;Query\u0026gt;\\r\\n \u0026lt;CmdType\u0026gt;Catalog\u0026lt;/CmdType\u0026gt;\\r\\n \u0026lt;SN\u0026gt;445043391\u0026lt;/SN\u0026gt;\\r\\n \u0026lt;DeviceID\u0026gt;34020000001320000001\u0026lt;/DeviceID\u0026gt;\\r\\n \u0026lt;/Query\u0026gt;\\r\\n response: ipc -\u0026gt; sip server #  Frame 2137: 352 bytes on wire (2816 bits), 352 bytes captured (2816 bits) on interface 0 Ethernet II, Src: 98:df:82:6d:9e:52 (98:df:82:6d:9e:52), Dst: Apple_70:23:0d (88:e9:fe:70:23:0d) Internet Protocol Version 4, Src: 192.168.137.109, Dst: 192.168.137.105 User Datagram Protocol, Src Port: 5060, Dst Port: 5060 Session Initiation Protocol (200) Status-Line: SIP/2.0 200 OK Status-Code: 200 [Resent Packet: False] [Request Frame: 2136] [Response Time (ms): 5] Message Header Via: SIP/2.0/UDP 192.168.64.3:15060;rport=5060;branch=z9hG4bK268043391;received=192.168.137.105 From: \u0026lt;sip:34020000002000000001@3402000000\u0026gt;;tag=181043391 To: \u0026lt;sip:34020000001320000001@3402000000\u0026gt;;tag=2000290983 Call-ID: 44043391 CSeq: 1 MESSAGE User-Agent: IP Camera Content-Length: 0 request: ipc -\u0026gt; sip server #  Frame 2138: 1001 bytes on wire (8008 bits), 1001 bytes captured (8008 bits) on interface 0 Ethernet II, Src: 98:df:82:6d:9e:52 (98:df:82:6d:9e:52), Dst: Apple_70:23:0d (88:e9:fe:70:23:0d) Internet Protocol Version 4, Src: 192.168.137.109, Dst: 192.168.137.105 User Datagram Protocol, Src Port: 5060, Dst Port: 5060 Session Initiation Protocol (MESSAGE) Request-Line: MESSAGE sip:34020000002000000001@3402000000 SIP/2.0 Method: MESSAGE Request-URI: sip:34020000002000000001@3402000000 [Resent Packet: False] Message Header Via: SIP/2.0/UDP 192.168.137.109:5060;rport;branch=z9hG4bK461606833 From: \u0026lt;sip:34020000001320000001@3402000000\u0026gt;;tag=106117409 To: \u0026lt;sip:34020000002000000001@3402000000\u0026gt; Call-ID: 2113631911 CSeq: 20 MESSAGE Content-Type: Application/MANSCDP+xml Max-Forwards: 70 User-Agent: IP Camera Content-Length: 591 Message Body \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;GB2312\u0026#34;?\u0026gt;\\n \u0026lt;Response\u0026gt;\\n \u0026lt;CmdType\u0026gt;Catalog\u0026lt;/CmdType\u0026gt;\\n \u0026lt;SN\u0026gt;445043391\u0026lt;/SN\u0026gt;\\n \u0026lt;DeviceID\u0026gt;34020000001320000001\u0026lt;/DeviceID\u0026gt;\\n \u0026lt;SumNum\u0026gt;1\u0026lt;/SumNum\u0026gt;\\n \u0026lt;DeviceList Num=\u0026#34;1\u0026#34;\u0026gt;\\n \u0026lt;Item\u0026gt;\\n \u0026lt;DeviceID\u0026gt;34020000001320000001\u0026lt;/DeviceID\u0026gt;\\n \u0026lt;Name\u0026gt;Camera 01\u0026lt;/Name\u0026gt;\\n \u0026lt;Manufacturer\u0026gt;Hikvision\u0026lt;/Manufacturer\u0026gt;\\n \u0026lt;Model\u0026gt;IP Camera\u0026lt;/Model\u0026gt;\\n \u0026lt;Owner\u0026gt;Owner\u0026lt;/Owner\u0026gt;\\n \u0026lt;CivilCode\u0026gt;3402000000\u0026lt;/CivilCode\u0026gt;\\n \u0026lt;Address\u0026gt;Address\u0026lt;/Address\u0026gt;\\n \u0026lt;Parental\u0026gt;0\u0026lt;/Parental\u0026gt;\\n \u0026lt;ParentID\u0026gt;34020000002000000001\u0026lt;/ParentID\u0026gt;\\n \u0026lt;SafetyWay\u0026gt;0\u0026lt;/SafetyWay\u0026gt;\\n \u0026lt;RegisterWay\u0026gt;1\u0026lt;/RegisterWay\u0026gt;\\n \u0026lt;Secrecy\u0026gt;0\u0026lt;/Secrecy\u0026gt;\\n \u0026lt;Status\u0026gt;ON\u0026lt;/Status\u0026gt;\\n \u0026lt;/Item\u0026gt;\\n \u0026lt;/DeviceList\u0026gt;\\n \u0026lt;/Response\u0026gt;\\n request: sip server -\u0026gt; ipc #  Frame 2139: 360 bytes on wire (2880 bits), 360 bytes captured (2880 bits) on interface 0 Ethernet II, Src: Apple_70:23:0d (88:e9:fe:70:23:0d), Dst: 98:df:82:6d:9e:52 (98:df:82:6d:9e:52) Internet Protocol Version 4, Src: 192.168.137.105, Dst: 192.168.137.109 User Datagram Protocol, Src Port: 5060, Dst Port: 5060 Session Initiation Protocol (200) Status-Line: SIP/2.0 200 OK Status-Code: 200 [Resent Packet: False] [Request Frame: 2138] [Response Time (ms): 16] Message Header Via: SIP/2.0/UDP 192.168.137.109:5060;rport=60954;received=192.168.64.3;branch=z9hG4bK461606833 From: \u0026lt;sip:34020000001320000001@3402000000\u0026gt;;tag=106117409 To: \u0026lt;sip:34020000002000000001@3402000000\u0026gt;;tag=443043407 CSeq: 20 MESSAGE Call-ID: 2113631911 User-Agent: LiveGBS v200603 Content-Length: 0  Invite #  request: sip server -\u0026gt; ipc (SIP/SDP) #  Frame 288: 746 bytes on wire (5968 bits), 746 bytes captured (5968 bits) on interface 0 Ethernet II, Src: Apple_70:23:0d (88:e9:fe:70:23:0d), Dst: 98:df:82:6d:9e:52 (98:df:82:6d:9e:52) Internet Protocol Version 4, Src: 192.168.137.105, Dst: 192.168.137.109 User Datagram Protocol, Src Port: 5060, Dst Port: 5060 Session Initiation Protocol (INVITE) Request-Line: INVITE sip:34020000001320000001@3402000000 SIP/2.0 Method: INVITE Request-URI: sip:34020000001320000001@3402000000 [Resent Packet: False] Message Header Via: SIP/2.0/UDP 192.168.64.3:15060;rport;branch=z9hG4bK685516389 From: \u0026lt;sip:34020000002000000001@3402000000\u0026gt;;tag=171516389 To: \u0026lt;sip:34020000001320000001@3402000000\u0026gt; Call-ID: 16516245 CSeq: 4 INVITE Content-Type: APPLICATION/SDP Contact: \u0026lt;sip:34020000002000000001@192.168.64.3:15060\u0026gt; Max-Forwards: 70 User-Agent: LiveGBS v200603 Subject: 34020000001320000001:0200000001,34020000002020000001:0 Content-Length: 226 Message Body Session Description Protocol Session Description Protocol Version (v): 0 Owner/Creator, Session Id (o): 34020000002000000001 0 0 IN IP4 192.168.137.105 Session Name (s): Play Connection Information (c): IN IP4 192.168.137.105 Time Description, active time (t): 0 0 Media Description, name and address (m): video 30000 RTP/AVP 96 97 98 Media Attribute (a): recvonly Media Attribute (a): rtpmap:96 PS/90000 Media Attribute (a): rtpmap:97 MPEG4/90000 Media Attribute (a): rtpmap:98 H264/90000 Unknown: y=0200000001 response: 100 Trying (ipc -\u0026gt; sip server, SIP) #  Frame 295: 340 bytes on wire (2720 bits), 340 bytes captured (2720 bits) on interface 0 Ethernet II, Src: 98:df:82:6d:9e:52 (98:df:82:6d:9e:52), Dst: Apple_70:23:0d (88:e9:fe:70:23:0d) Internet Protocol Version 4, Src: 192.168.137.109, Dst: 192.168.137.105 User Datagram Protocol, Src Port: 5060, Dst Port: 5060 Session Initiation Protocol (100) Status-Line: SIP/2.0 100 Trying Status-Code: 100 [Resent Packet: False] [Request Frame: 288] [Response Time (ms): 16] Message Header Via: SIP/2.0/UDP 192.168.64.3:15060;rport=5060;branch=z9hG4bK685516389;received=192.168.137.105 From: \u0026lt;sip:34020000002000000001@3402000000\u0026gt;;tag=171516389 To: \u0026lt;sip:34020000001320000001@3402000000\u0026gt; Call-ID: 16516245 CSeq: 4 INVITE User-Agent: IP Camera Content-Length: 0 response: 200 (ipc -\u0026gt; sip server, SIP/SDP) #  Frame 297: 632 bytes on wire (5056 bits), 632 bytes captured (5056 bits) on interface 0 Ethernet II, Src: 98:df:82:6d:9e:52 (98:df:82:6d:9e:52), Dst: Apple_70:23:0d (88:e9:fe:70:23:0d) Internet Protocol Version 4, Src: 192.168.137.109, Dst: 192.168.137.105 User Datagram Protocol, Src Port: 5060, Dst Port: 5060 Session Initiation Protocol (200) Status-Line: SIP/2.0 200 OK Status-Code: 200 [Resent Packet: False] [Request Frame: 288] [Response Time (ms): 20] Message Header Via: SIP/2.0/UDP 192.168.64.3:15060;rport=5060;branch=z9hG4bK685516389;received=192.168.137.105 From: \u0026lt;sip:34020000002000000001@3402000000\u0026gt;;tag=171516389 To: \u0026lt;sip:34020000001320000001@3402000000\u0026gt;;tag=614786748 Call-ID: 16516245 CSeq: 4 INVITE Contact: \u0026lt;sip:34020000001320000001@192.168.64.3:55302\u0026gt; Content-Type: application/sdp User-Agent: IP Camera Content-Length: 191 Message Body Session Description Protocol Session Description Protocol Version (v): 0 Owner/Creator, Session Id (o): 34020000001320000001 2346 2346 IN IP4 192.168.137.109 Session Name (s): Play Connection Information (c): IN IP4 192.168.137.109 Time Description, active time (t): 0 0 Media Description, name and address (m): video 15060 RTP/AVP 96 Media Attribute (a): sendonly Media Attribute (a): rtpmap:96 PS/90000 Media Attribute (a): filesize:0 Unknown: y=0200000001  ACK #  request: sip server -\u0026gt; ipc (SIP) #  Frame 298: 430 bytes on wire (3440 bits), 430 bytes captured (3440 bits) on interface 0 Ethernet II, Src: Apple_70:23:0d (88:e9:fe:70:23:0d), Dst: 98:df:82:6d:9e:52 (98:df:82:6d:9e:52) Internet Protocol Version 4, Src: 192.168.137.105, Dst: 192.168.137.109 User Datagram Protocol, Src Port: 5060, Dst Port: 5060 Session Initiation Protocol (ACK) Request-Line: ACK sip:34020000001320000001@3402000000 SIP/2.0 Method: ACK Request-URI: sip:34020000001320000001@3402000000 [Resent Packet: False] [Request Frame: 288] [Response Time (ms): 61] Message Header Via: SIP/2.0/UDP 192.168.64.3:15060;rport;branch=z9hG4bK193516446 From: \u0026lt;sip:34020000002000000001@3402000000\u0026gt;;tag=171516389 To: \u0026lt;sip:34020000001320000001@3402000000\u0026gt;;tag=614786748 Call-ID: 16516245 CSeq: 4 ACK Contact: \u0026lt;sip:34020000002000000001@192.168.64.3:15060\u0026gt; Max-Forwards: 70 User-Agent: LiveGBS v200603 Content-Length: 0  RTP #  ipc -\u0026gt; sip server #  Sequence number 递增\nFrame 299: 1454 bytes on wire (11632 bits), 1454 bytes captured (11632 bits) on interface 0 Ethernet II, Src: 98:df:82:6d:9e:52 (98:df:82:6d:9e:52), Dst: Apple_70:23:0d (88:e9:fe:70:23:0d) Internet Protocol Version 4, Src: 192.168.137.109, Dst: 192.168.137.105 User Datagram Protocol, Src Port: 15060, Dst Port: 30000 Real-Time Transport Protocol [Stream setup by SDP (frame 288)] 10.. .... = Version: RFC 1889 Version (2) ..0. .... = Padding: False ...0 .... = Extension: False .... 0000 = Contributing source identifiers count: 0 0... .... = Marker: False Payload type: PS (96) Sequence number: 0 [Extended sequence number: 65536] Timestamp: 0 Synchronization Source identifier: 0x0bebc201 (200000001) Payload: 000001ba6e617c97940107599ffeffff01f2c2b4000001bb... "});index.add({'id':804,'href':'/note-cs/docs/skill/stream-media/gb28181/code/','title':"源码实现",'section':"GB28181",'content':"源码实现 #  名词解释 #   AOR：Address Of Record 是 header 中的 From 字段   开源实现 #  go #   StefanKopieczek/gossip  rainliu/gosips  1lann/go-sip  ghettovoice/gosip Inspired by:  StefanKopieczek/gossip 1lann/go-sip kirm/sip.js   cloudwebrtc/go-sip-ua Dependencies  ghettovoice/gosip SIP stack c-bata/go-prompt Console for b2bua pixelbender/go-sdp SDP    C #   pjsip/pjproject   C# #   GB28181/GB28181.Solution   C++ #   ossrs/srs  xiongziliang/ZLMediaKit   Node.js #   kirm/sip.js   二进制（前端开源，后端不开源） #   livegbs/GB28181-Server   "});index.add({'id':805,'href':'/note-cs/docs/skill/stream-media/onvif/gsoap/','title':"gsoap 生成 onvif 框架",'section':"ONVIF",'content':"gsoap 生成 onvif 框架 #  生成参数 #  wsdl2h #  -O4 #  aggressively optimizes the output by \u0026ldquo;schema slicing\u0026rdquo; to remove unused schema components, see our article Schema Slicing Methods to Reduce Development Costs of WSDL-Based Web Services for details;\n-P #  don\u0026rsquo;t create polymorphic types inherited from xsd__anyType;\nremoves the base class xsd__anyType from the generated C++ classes, which are normally added by wsdl2h if the xsd:anyType XSD type is used somewhere in a WSDL.\nHowever, for the ONVIF protocols we do not need to inherit the xsd__anyType class and we can reduce the generated code size accordingly;\n-x #  don\u0026rsquo;t generate _XML any/anyAttribute extensibility elements;\nremoves the unnecessary generated code for the extensibility elements xsd:any and attributes xsd:anyAttribue, since we do not need to support these in general, except for some specific cases see further below. An alternative is to use option -d to generate embedded DOM code which allows you to add any XML content via the generated xsd__anyType __any members that are DOM nodes;\nwsdl2h 其他参数：\n -h : help -s : don\u0026rsquo;t generate STL code (no std::string and no std::vector) -t : typemapfile  soapcpp2 #  -2 #  forces SOAP 1.2, which is required by ONVIF;\n-j #  For C++ projects you should generate C++ proxy classes using soapcpp2 option -j. Proxy classes are** easier to use** than the global functions that are generated without this option.\nsoapcpp2 其他参数:\n -h: help -x : don\u0026rsquo;t generate sample XML message files -d : use path to save files -p: save files with new prefix name instead of \u0026lsquo;soap\u0026rsquo; -C: generate client-side source code only -L: don\u0026rsquo;t generate soapClientLib/soapServerLib -I : use path(s) for #import (paths separated with \u0026lsquo;:')  生成过程要做的事情 #  执行前 #  修改 typemap.dat\nduration.h 毫秒级 （选了这个）\nchrono_duration.h 纳秒级\nTo automatically enable the first choice of serializer for xsd:duration, add the following line to typemap.dat if not already there:\nxsd__duration = #``import \u0026quot;custom/duration.h\u0026quot; | xsd__duration\nThis imports custom/duration.h into the wsdl2h-generated onvif.h binding interface.\n执行 wsdl2h 后 #     change #import \u0026quot;wsdd10.h\u0026quot; to #import \u0026quot;wsdd5.h\u0026quot; in onvif.h\nYou may want to change #import \u0026quot;wsdd10.h\u0026quot; to #import \u0026quot;wsdd5.h\u0026quot; in onvif.h, because ONVIF uses WS-Addressing 2005/08 whereas WS-Discovery declared in wsdd10.h assumes WS-Addressing 2004/08\n  添加 #import \u0026ldquo;wsse.h\u0026rdquo;\n执行 soapcpp2 后 #     Using WS-Security #    include\n gsoap/plugin/wsseapi.h    compile\n  gsoap/plugin/wsseapi.c\n  gsoap/plugin/smdevp.c\n  gsoap/plugin/mecevp.c\n  -DWITH_OPENSSL and -DWITH_DOM\n    link\n -lgsoapssl++ 或 compilegsoap/stdsoap2.cppandgsoap/dom.cpp\\    2.\nUsing WS-Discovery #  When the ONVIF remotediscovery WSDL is used to build an ONVIF application, WS-Discovery is required.\n include  gsoap/plugin/wsddapi.h   compile  gsoap/plugin/wsddapi.c      To support client-side WS-Discovery operations, we run soapcpp2 as follows as documented here:\nsoapcpp2 -a -x -L -pwsdd -I ~/gsoap-``2.8``/gsoap/``import ~/gsoap-``2.8``/gsoap/``import``/wsdd5.h\nThis generates wsddClient.cpp, which we will use later to compile with the project.\n编译参数 #  makefile\nCC = g++ CPPFLAG = -Wall -g -std=c++11 -w -fPIC -DWITH_NONAMESPACES -fno-use-cxa-atexit -fexceptions -DWITH_DOM -DWITH_OPENSSL -DSOAP_DEBUG BASE_DIR = . INCLUDE += -I$(BASE_DIR) -I$(BASE_DIR)/onvif -I$(BASE_DIR)/gsoap -I/usr/local/opt/openssl@1.0/include LIB = -lssl -lcrypto -L/usr/local/opt/openssl@1.0/lib GsoapSOURCE = $(BASE_DIR)/gsoap GsoapOBJ = $(GsoapSOURCE)/wsaapi.o $(GsoapSOURCE)/wsseapi.o $(GsoapSOURCE)/threads.o $(GsoapSOURCE)/duration.o \\  $(GsoapSOURCE)/smdevp.o $(GsoapSOURCE)/mecevp.o $(GsoapSOURCE)/dom.o $(GsoapSOURCE)/struct_timeval.o OnvifSOURCE = $(BASE_DIR)/onvif OnvifOBJ = $(OnvifSOURCE)/soapAdvancedSecurityServiceBindingProxy.o $(OnvifSOURCE)/soapDeviceBindingProxy.o $(OnvifSOURCE)/soapDeviceIOBindingProxy.o \\  $(OnvifSOURCE)/soapImagingBindingProxy.o $(OnvifSOURCE)/soapMediaBindingProxy.o $(OnvifSOURCE)/soapPTZBindingProxy.o \\  $(OnvifSOURCE)/soapPullPointSubscriptionBindingProxy.o $(OnvifSOURCE)/soapRemoteDiscoveryBindingProxy.o SRC = $(GsoapSOURCE)/stdsoap2.o $(OnvifSOURCE)/soapC.o $(OnvifSOURCE)/wsddClient.o $(BASE_DIR)/main.o $(GsoapOBJ) $(OnvifOBJ) OBJECTS = $(patsubst %.cpp,%.o,$(SRC)) TARGET = starry-eyes all: $(TARGET) $(TARGET):$(OBJECTS) $(CC) $(CPPFLAG) $(OBJECTS) $(INCLUDE) $(LIB) -o $(TARGET) $(OBJECTS):%.o : %.cpp $(CC) -c $(CPPFLAG) $(INCLUDE) $\u0026lt; -o $@ clean: rm -rf $(OBJECTS) 遇到的主要问题是这个错误：\nUndefined symbols for architecture x86_64: \u0026#34;soap_s2xsd__dateTime(soap*, char const*, timeval*)\u0026#34;, referenced from: soap_in_saml2__AuthnStatementType(soap*, char const*, saml2__AuthnStatementType*, char const*) in soapC.o soap_in_saml2__ConditionsType(soap*, char const*, saml2__ConditionsType*, char const*) in soapC.o soap_in_saml2__SubjectConfirmationDataType(soap*, char const*, saml2__SubjectConfirmationDataType*, char const*) in soapC.o soap_in_saml2__AssertionType(soap*, char const*, saml2__AssertionType*, char const*) in soapC.o soap_in_saml1__AuthenticationStatementType(soap*, char const*, saml1__AuthenticationStatementType*, char const*) in soapC.o soap_in_saml1__ConditionsType(soap*, char const*, saml1__ConditionsType*, char const*) in soapC.o soap_in_saml1__AssertionType(soap*, char const*, saml1__AssertionType*, char const*) in soapC.o ... soap_s2xsd__dateTime 这个函数在框架生成的 soapC.cpp 中有多次调用，之前 onvif wsdl 生成的框架里是没有的。\n后面找到是 gsoap 的 struct_timeval.c 中实现的，加入编译后，问题解决。\n参考：https://www.genivia.com/examples/onvif/index.html\n 生成过程详情 #  1. 修改 typemap.dat，取消注释\nxsdduration = #import \u0026ldquo;custom/duration.h\u0026rdquo; | xsdduration\n2. 执行 wsdl2h 生成 onvif.h\nwsdl2h -O4 -P -x -o onvif.h \\  http://www.onvif.org/onvif/ver10/device/wsdl/devicemgmt.wsdl \\  http://www.onvif.org/onvif/ver10/events/wsdl/event.wsdl \\  http://www.onvif.org/onvif/ver10/deviceio.wsdl \\  http://www.onvif.org/onvif/ver20/imaging/wsdl/imaging.wsdl \\  http://www.onvif.org/onvif/ver10/media/wsdl/media.wsdl \\  http://www.onvif.org/onvif/ver20/ptz/wsdl/ptz.wsdl \\  http://www.onvif.org/onvif/ver10/network/wsdl/remotediscovery.wsdl \\  http://www.onvif.org/ver10/advancedsecurity/wsdl/advancedsecurity.wsdl 3. 修改 onvif.h，change #import \u0026quot;wsdd10.h\u0026quot; to #import \u0026quot;wsdd5.h\n4. 修改 onvif.h，添加 #import \u0026ldquo;wsse.h\u0026rdquo;\n5. 执行 soapcpp2 生成框架代码\n6. 执行 soapcpp2 -pwsdd 生成 wsddClient.cpp\nsoapcpp2 -2 -C -j -x -I ~/code/onvif/app-gsoap-2.8.98/gsoap:~/code/onvif/app-gsoap-2.8.98/gsoap/import:~/code/onvif/app-gsoap-2.8.98/gsoap/custom onvif.h -d onvif/ soapcpp2 -a -x -L -pwsdd -I ~/code/onvif/app-gsoap-2.8.98/gsoap/import ~/code/onvif/app-gsoap-2.8.98/gsoap/import/wsdd5.h -d onvif/ "});index.add({'id':806,'href':'/note-cs/docs/skill/stream-media/onvif/','title':"ONVIF",'section':"4.5 流媒体",'content':"ONVIF #  官网：www.onvif.org\n"});index.add({'id':807,'href':'/note-cs/docs/skill/stream-media/easydarwin/','title':"EasyDarwin",'section':"4.5 流媒体",'content':"EasyDarwin #  EasyDarwin 是基于 Apple 的开源项目 Darwin Streaming Server 衍生而来的， Darwin 本身支持的是 RTSP 流媒体协议\nmacosforge/dss #  Darwin Streaming Server is Apple\u0026rsquo;s open source version of the QuickTime Streaming Server technology allowing you to send streaming media across the Internet using the industry standard RTP and RTSP protocols.\n EasyDarwin 生态 #   EasyDarwin 开源流媒体服务器：www.EasyDarwin.org EasyDSS 商用流媒体解决方案：www.EasyDSS.com, 点播与直播服务器  EasyBMS EasyRMS, 录播服务器   EasyNVR 无插件直播方案：www.EasyNVR.com, 摄像机互联网直播服务  EasyGB28181Server #  EasyNVR 采用的是 Onvif 协议接入云平台， 而 EasyGB28181Server 则是以 GB/T28181 方式接入云平台\nEasyGB28181Server 交互流程\n 启动 EasyGB28181Server, 接受摄像机的注册； EasyGB28181Server 将接收到的摄像机信息写入到 Redis 的设备列表； 与摄像机维持心跳； 打开网页客户端，即可看到所有的设备列表； 单击列表中的任一设备，EasyDSS 则向 EasyGB28181 服务器请求音视频； EasyGB28181Server 在收到 EasyDSS 的请求后，在 Redis 中找到负载最小的 EasyGB28181StreamServer; EasyGB28181Server 向找到的 EasyGB28181StreamServer 发送接收摄像机流的请求 EasyGB28181StreamServer 返回自身的外网 IP 和收流的端口 EasyGB28181Server 通知摄像机向 EasyGB28181StreamServer 的 IP 和 Port 发送音视频流 EasyGB28181StreamServer 收到摄像机的音视频后，将 PS 流转换为 ES 流，再转换为 RTMP 协议，传到 EasyDSS; EasyDSS 再将 RTMP 流转发给网页客户端；  至此，EasyGB28181Server + EasyGB28181StreamServer + EasyDSS 的整个流程完成；\n"});index.add({'id':808,'href':'/note-cs/docs/skill/stream-media/srs/','title':"SRS",'section':"4.5 流媒体",'content':"SRS #  ossrs/srs SRS is a RTMP/HLS/WebRTC/SRT/GB28181 streaming cluster, high efficiency, stable and simple.\n配置信息 #  "});index.add({'id':809,'href':'/note-cs/docs/skill/stream-media/zlmediakit/','title':"ZLMediaKit",'section':"4.5 流媒体",'content':"ZLMediaKit #  xiongziliang/ZLMediaKit # h264推流 ffmpeg -re -i \u0026#34;/path/to/test.mp4\u0026#34; -vcodec h264 -acodec aac -f rtsp -rtsp_transport tcp rtsp://127.0.0.1/live/test ffmpeg -re -stream_loop -1 -i carbrand.MOV -vcodec h264 -acodec aac -f rtp_mpegts rtp://127.0.0.1:10000 rtsp __defaultVhost__ rtp 55667788 CodecH264[1920/1080/50] rtsp://127.0.0.1/rtp/55667788 "});index.add({'id':810,'href':'/note-cs/docs/skill/stream-media/stream-media/','title':"流媒体技术",'section':"4.5 流媒体",'content':"流媒体技术 #  视频编码 #   H.264 H.265 H.266 Apple Pro Res (MOV 格式的专用编码)  音频编码 #   AAC MP3 WAV FLAC（无损） APE（无损）  参考：\n 音频编码格式的比较  视频容器 / 视频格式 #  一个格式却可以有不同的编码\n AVI (Audio Video Interleaved 音视频交错格式) RMVB FLV (Flash Video) MOV WMV (Windows Media Video) MP4 MKV  MP4 #  MP4 或称 MPEG-4 第 14 部分（英语：MPEG-4 Part 14）是一种标准的数字多媒体容器格式。MPEG-4 第 14 部分的扩展名为.mp4，以存储数字音频及数字视频为主，但也可以存储字幕和静止图像。因其可容纳支持比特流的视频流（如高级视频编码），MP4 可以在网络传输时使用流式传输。\nMKV #  MKV 格式是民间流行的一种视频格式，以它兼容众多视频编码见长，可以是 DivX、XviD、RealVideo、H264、MPEG2、VC1 等等。但是由于是民间格式，没有版权限制，又易于播放，所以官方发布的视频影片都不采用 mkv，网上制作下载常见。\n 视频传输协议 #   RTP/RTCP RTMP HLS (HTTP Live Streaming)   流媒体传输协议 #  流媒体协议的作用：流同步，播放控制，质量控制，多端跨平台播放等 直播三要素：低延时，高可用，质量反馈和检测\n常见流媒体协议类型\n常见流媒体协议适用场景\nRTP/RTCP/RTSP #  封装：\n ps ts  视频：\n H.264 H.265 VP9  音频：\n aac g711.a  RTSP\n 基于 TCP 基于文本的双向实时传输协议，类似 HTTP 每个会话都含有状态，保持长连接，请求信令按顺序（HTTP 无状态）  RTP/RTCP\n 基于 UDP   RTMP #  Real-Time Messaging Protocol\n Adobe 的私有协议，性能相对 HTTP 比较低下。 数据和信令在一条通道。 长连接 基于 TCP   HLS #  HTTP Live Streaming\n 基于 HTTP，性能不错 延时常常大于 10 秒，无法做直播互动  HLS 是由苹果公司提出基于 HTTP 的 流媒体网络传输协议。是苹果公司 QuickTime X 和 iPhone 软件系统的一部分。它的工作原理是把整个流分成一个个小的基于 HTTP 的文件来下载，每次只下载一些。当媒体流正在播放时，客户端可以选择从许多不同的备用源中以不同的速率下载同样的资源，允许流媒体会话适应不同的数据速率。在开始一个流媒体会话时，客户端会下载一个包含元数据的 extended M3U (m3u8) playlist 文件，用于寻找可用的媒体流。\nHLS 只请求基本的 HTTP 报文，与实时传输协议（RTP）不同，HLS 可以穿过任何允许 HTTP 数据通过的防火墙或者代理服务器。它也很容易使用内容分发网络来传输媒体流。\nHLS 基于 HTTP 协议实现，传输内容包括两部分，一是 M3U8 描述文件，二是 TS 媒体文件。\n为什么要用 TS 而不是 MP4？ #  这是因为两个 TS 片段可以无缝拼接，播放器能连续播放， 而 MP4 文件由于编码方式的原因，两段 MP4 不能无缝拼接，播放器连续播放两个 MP4 文件会出现破音和画面间断，影响用户体验。\n而且如果要在一段长达一小时的视频中跳转，如果使用单个 MP4 格式的视频文件，并且也是用 HTTP 协议，那么需要代理服务器支持 HTTP range request 获取大文件中的一部分。 这样的话，对于代理服务器的性能来说要求较高。 而 HTTP Live Streaming 则只需要根据列表文件中的时间轴找出对应的 TS 片段下载即可， 不需要 range request，对代理服务器的要求小很多。 所有代理服务器都支持小文件的高效缓存。\n 流媒体协议 #  RTP/RTCP #  RTP(Real-time Transport Protocol) 是用于 Internet 上针对多媒体数据流的一种传输协议。\nRTCP 为 RTP 媒体流提供信道外控制。 RTCP 定期在流多媒体会话参加者之间传输控制数据。 RTCP 的主要功能是为 RTP 所提供的服务质量提供反馈。\nRTP 使用一个 偶数 UDP port， 而 RTCP 则使用 RTP 的下一个 port，也就是一个奇数 port。\nRTSP #  RTMP #  H264 #  H265 #  TS #  MPEG2-TS 传输流 （MPEG-2 Transport Stream；又称 MPEG-TS、MTS、TS） 是一种传输和存储包含视频、音频与通信协议各种数据的标准格式，用于数字电视广播系统，如 DVB、ATSC、ISDB、IPTV 等等。\nRTP Payload type #  有效负载 (载荷) 类型\n有些负载类型由于诞生的较晚，没有具体的 PT 值，只能使用动态（dynamic）PT 值，即 96 到 127， 这就是为什么大家普遍指定 H264 的 PT 值为 96。\nPayload identifiers 96–127 are used for payloads defined dynamically during a session. It is recommended to dynamically assigned port numbers, although port numbers 5004 and 5005 have been registered for use of the profile when a dynamically assigned port is not required.\nMP2T (Payload type: 33)\nRFC 2250: RTP Payload Format for MPEG1/MPEG2 Video\n参考：\n RTP 有效负载 (载荷) 类型 (RTP Payload Type)  "});index.add({'id':811,'href':'/note-cs/docs/skill/stream-media/stream-media/live-tech/','title':"直播技术",'section':"流媒体技术",'content':"直播技术 #   摄像头视频采集，原始视频数据：RGB/YUV 话筒音频采集，原始音频数据：PCM 视频文件编码，RGB/YUV -\u0026gt; H.264/H.265 音频文件编码，PCM -\u0026gt; AAC 编码为有流媒体特性的多媒体容器格式（Multimedia Container Format）， 如 FLV/TS/RTMP Package 推流到流媒体服务器  应用层：HLS/RTSP/RTMP 传输层：RTP/RTCP 网络层：RSVP   服务端处理  转码/录制/截图/鉴黄 生成拉流 URL   拉流到客户端  应用层：HLS/RTMP 传输层：RTP/RTCP 网络层：RSVP   解复用，多媒体容器格式（FLV/TS/RTMP Package）的流 -\u0026gt; 音视频数据（H.264/AAC） 解码视频文件为 YUV/RGB，解码音频文件为 PCM  硬解码（GPU 解码，CPU 辅助） 软解码（CPU 解码）   音画同步 视频数据（YUV/RGB）发送到视频输出设备，音频数据（PCM）发送到音频输出设备  "});index.add({'id':812,'href':'/note-cs/docs/skill/stream-media/stream-media/video-codec/','title':"视频编码",'section':"流媒体技术",'content':"视频编码 #      年份 标准 制定组织 解除著作权保护（DRM-free） 主要应用     1984 H.120 ITU-T 是    1990 H.261 ITU-T 是 视频会议、视频通话   1993 MPEG-1 第二部分 ISO／IEC 是 影音光盘（VCD）   1995 H.262/MPEG-2 第二部分 ISO／IEC、ITU-T 否 DVD 影碟（DVD-Video）、 蓝光（ Blu-Ray）影碟、数字视频广播（DVB）、SVCD   1996 H.263 ITU-T  视频会议、视频通话、 3G 手机视频（3GP）   1999 MPEG-4 第二部分 ISO／IEC 否    2003 H.264/MPEG-4 AVC ISO／IEC、ITU-T 否 蓝光（ Blu-Ray）影碟、数字视频广播（DVB）、iPod 视频、 高清 DVD（HD DVD）   2013 H.265/High Efficiency Video Coding ISO/IEC、ITU-T 否 尚未普及     AVC (H.264) #  H.264，又称为 MPEG-4 第 10 部分，高级视频编码（英语： MPEG-4 Part 10, Advanced Video Coding ，缩写为 MPEG-4 AVC）是一种面向块，基于运动补偿的视频编码标准（英语：Advanced Video Coding） 。\n HEVC (H.265) #  高效率视频编码（ High Efficiency Video Coding，简称 HEVC），又称为 H.265 和 MPEG-H 第 2 部分，是一种视频压缩标准，被视为是 ITU-T H.264/MPEG-4 AVC 标准的继任者。\n比起 H.264/AVC，H.265/HEVC 提供了更多不同的工具来降低码率， 以编码单位来说，H.264 中每个宏块（macroblock/MB）大小都是固定的 16x16 像素，而 H.265 的编码单位可以选择从最小的 8x8 到最大的 64x64。 那么，在相同的图象质量下，相比于 H.264，通过 H.265 编码的视频大小将减少大约 39%-44%；\nVVC (H.266) #  Versatile Video Coding, MPEG-I Part 3\n 应用 #  CD #  Compact Disc\n激光唱片，镭射唱片\nCD 在 1982 年面世，至今仍然是商业录音的标准存储设备。\n在 CD 尚未发明之前，音响系统都是属于模拟信号， 音乐的来源大多是 30 公分直径的密纹唱片、收音机以及录音机等，CD 发明之前没有数字音响。\nVCD #  Video Compact Disc\n影音光盘，又称影音压缩光盘，是一种在光盘（Compact Disc）上存储视频信息的标准。\nVCD 标准由索尼、飞利浦、 JVC、 松下电器等电器生产厂商联合于 1993 年制定，属于数字光盘的白皮书标准。\nDVD #  Digital Versatile Disc\nDVD 原是 Digital Video Disc（数字视频光盘）的首字母缩略字，因初推出时大多厂商只针对视频方面的宣传及推出产品，而且当时的电脑产业对高容量的存储媒体没有太大需求。 后因定位更改，于 1995 年规格正式确立时，重新定义为 Digital Versatile Disc（数字多用途光盘），但旧称的 Digital Video Disc 也有人继续沿用。现在一般都只以 “DVD” 作为其称呼。\nHD DVD #  High Definition Digital Versatile Disc\nHD DVD（英语：High Definition DVD ，“高清晰度 DVD” 或 “高清 DVD”）是一种以蓝光镭射技术存储数字格式信息于光盘上的产品，现已发展成高清晰度 DVD 标准，由 HD DVD 推广协会负责制定及开发。HD DVD 与其竞争对手 Blu-ray Disc（简写为 “BD”，蓝光光盘）有些许些相似之处，光盘均是和 CD 同样大小（直径 120mm）的光学数字格式存储介质，使用 405 纳米波长的蓝色镭射。\nHD DVD 由东芝、 NEC、 三洋电机等企业组成的 HD DVD 推广协会负责推广，惠普（同时支持 BD）、 微软及英特尔等相继加入 HD DVD 阵营，其中的主流片厂环球影业亦是成员之一。\n但在 2008 年，随着原先支持 HD DVD 的华纳公司宣布脱离 HD DVD，以及美国数家连锁卖场决定支持蓝光产品，东芝公司终在 2008 年 2 月 19 日正式宣布将终止 HD DVD 事业。\nBD 蓝光光盘 #  Blu-ray Disc\n蓝光光盘是由索尼及松下电器等企业组成的蓝光光盘联盟（Blu-ray Disc Association）策划的次世代光盘规格，并以索尼为首于 2006 年开始全面推动相关产品。\nUHD-BD #  超高清蓝光光盘（英语： Ultra HD Blu-ray ）是改良型蓝光光盘的数字光盘数据存储格式。 超高清蓝光光盘的碟片尺寸规格虽与传统的 CD、DVD 及现有的蓝光光盘相同，并且采用和传统蓝光盘相似的碟片和光头。 但影音的格式有出入而专用的播放器的软硬件不兼容，需使用支持读取超高清蓝光光盘播放器才可播放，而以新的格式可以用和传统蓝光相同容量下，播放更高清晰度的影片或延长播放时间。 超高清蓝光光盘支持 4KUHD（分辨率：3840×2160）视频，帧速率高达每秒 60 帧，使用高效率视频编码（H.265）进行编码。\n"});})();