'use strict';(function(){const indexCfg={cache:true};indexCfg.doc={id:'id',field:['title','content'],store:['title','href'],};const index=FlexSearch.create('balance',indexCfg);window.bookSearchIndex=index;index.add({'id':0,'href':'/note-cs/docs/basic/computer-composition/','title':"1.1 计算机组成原理",'content':"计算机组成原理 "});index.add({'id':1,'href':'/note-cs/docs/others/tool/dev/github/','title':"GitHub",'content':"GitHub 开源库 素材 / 规范 徽章 shields.io 如：\n 角落标志 tholman/github-corners http://tholman.com/github-corners/\n如：  GitHub Apps  Run persistently and can react to events quickly. Work great when persistent data is needed. Work best with API requests that aren't time consuming. Run on a server or compute infrastructure that you provide.  参考：\n Strengths of GitHub Actions and GitHub Apps  Mergify Stop merging your pull requests manually.\nWe save your time by automatically merging, commenting, rebasing, updating, labeling, backporting, closing, assigning, your pull requests.\nMergifyio/mergify-engine Engine for Mergify https://mergify.io\nNetlify [wei/pull] Pull Keep your forks up-to-date via automated PRs\nwei/pull probot/weekly-digest 自动生成周报到 issue\nGitHub Actions  Provide automation that can perform continuous integration and continuous deployment. Can run directly on runner machines or in Docker containers. Can include access to a clone of your repository, enabling deployment and publishing tools, code formatters, and command line tools to access your code. Don't require you to deploy code or serve an app. Have a simple interface to create and use secrets, which enables actions to interact with third-party services without needing to store the credentials of the person using the action.   Github 工具开发 webhook NetEaseGame/git-webhook 使用 Python Flask + SQLAchemy + Celery + Redis + React 开发的用于迅速搭建并使用 WebHook 进行自动化部署和运维，支持 Github / GitLab / Gogs / GitOsc。 https://webhook.hust.cc/\n若觉得 git-webhook 部署依然比较复杂，可以尝试更为简洁的 cli 版本 hustcc/webhookit  github-webhook-handler Node.js web handler / middleware for processing GitHub Webhooks\n go-playground/webhooks Webhook receiver for GitHub, Bitbucket, GitLab, Gogs\n hustcc/webhookit Simple git webhook cli tool for automation tasks, bind git webhook to action.\n gorda/issue-man  Building apps 参考：\n Building apps  Building actions 参考：\n Building actions  "});index.add({'id':2,'href':'/note-cs/docs/basic/os/linux/','title':"Linux",'content':"Linux 见：Linux 学习笔记\n"});index.add({'id':3,'href':'/note-cs/docs/others/tool/dev/vscode/','title':"VSCode",'content':"VSCode 推荐插件 PicGo/vs-picgo https://github.com/PicGo/vs-picgo\nformat autopep8 设置每行最大长度\n\u0026quot;python.formatting.autopep8Args\u0026quot;: [ \u0026quot;--max-line-length=200\u0026quot; ] 教程  帮你高效使用 VS Code 的秘诀  参考 "});index.add({'id':4,'href':'/note-cs/docs/basic/language/objective-c/appendix/tutorial/','title':"教程",'content':"教程 基础 进阶 高阶 "});index.add({'id':5,'href':'/note-cs/docs/basic/language/scala/appendix/tutorial/','title':"教程",'content':"教程 基础 进阶 高阶 "});index.add({'id':6,'href':'/note-cs/docs/basic/os/android/appendix/tutorial/','title':"教程",'content':"教程 基础 进阶 高阶 "});index.add({'id':7,'href':'/note-cs/docs/basic/os/ios/appendix/tutorial/','title':"教程",'content':"教程 基础 进阶 高阶 "});index.add({'id':8,'href':'/note-cs/docs/basic/os/macos/appendix/tutorial/','title':"教程",'content':"教程 基础 进阶 高阶 "});index.add({'id':9,'href':'/note-cs/docs/basic/os/unix/appendix/tutorial/','title':"教程",'content':"教程 基础 进阶 高阶 "});index.add({'id':10,'href':'/note-cs/docs/basic/os/windows/appendix/tutorial/','title':"教程",'content':"教程 基础 进阶 高阶 "});index.add({'id':11,'href':'/note-cs/docs/direction/client/android/appendix/tutorial/','title':"教程",'content':"教程 基础 进阶 高阶 "});index.add({'id':12,'href':'/note-cs/docs/direction/client/ios/appendix/tutorial/','title':"教程",'content':"教程 基础 进阶 高阶 "});index.add({'id':13,'href':'/note-cs/docs/direction/client/xiaochengxu/appendix/tutorial/','title':"教程",'content':"教程 基础 进阶 高阶 "});index.add({'id':14,'href':'/note-cs/docs/domain/ai/tutorial/','title':"教程",'content':"教程 基础 视频 shuhuai007/Machine-Learning-Session 【机器学习】【白板推导系列】【合集 1 ～ 23】\n视频内容电子化  tsyw/MachineLearningNotes  Bilibili - 机器学习白板系列   机器学习教程（小象学院）  josephmisiti/awesome-machine-learning  ZuzooVn/machine-learning-for-software-engineers A complete daily plan for studying to become a machine learning engineer.\n ageron/handson-ml A series of Jupyter notebooks that walk you through the fundamentals of Machine Learning and Deep Learning in python using Scikit-Learn and TensorFlow.\n fighting41love/funNLP NLP 民工的乐园：几乎最全的中文 NLP 资源库\n eriklindernoren/ML-From-Scratch Machine Learning From Scratch. Bare bones NumPy implementations of machine learning models and algorithms with a focus on accessibility. Aims to cover everything from linear regression to deep learning.\n trekhleb/homemade-machine-learning Python examples of popular machine learning algorithms with interactive Jupyter demos and math being explained.\n kailashahirwar/cheatsheets-ai Essential Cheat Sheets for deep learning and machine learning researchers\nhttps://medium.com/@kailashahirwar/essential-cheat-sheets-for-machine-learning-and-deep-learning-researchers-efb6a8ebd2e5\nhttps://aicheatsheets.com\n rasbt/python-machine-learning-book The \u0026ldquo;Python Machine Learning (1st edition)\u0026rdquo; book code repository and info resource\n afshinea/stanford-cs-229-machine-learning !Github stars[](https://img.shields.io/github/stars/afshinea/stanford-cs-229-machine-learning.svg)\nVIP cheatsheets for Stanford's CS 229 Machine Learning https://stanford.edu/~shervine/teaching/cs-229/\n ujjwalkarn/Machine-Learning-Tutorials machine learning and deep learning tutorials, articles and other resources http://ujjwalkarn.github.io/Machine-Learning-Tutorials/\n janishar/mit-deep-learning-book-pdf MIT Deep Learning Book in PDF format (complete and parts) by Ian Goodfellow, Yoshua Bengio and Aaron Courville\n 进阶 hangtwenty/dive-into-machine-learning Dive into Machine Learning with Python Jupyter notebook and scikit-learn! http://hangtwenty.github.io/dive-into-machine-learning/\n RedditSota/state-of-the-art-result-for-machine-learning-problems This repository provides state of the art (SoTA) results for all machine learning problems.\n rushter/MLAlgorithms Minimal and clean examples of machine learning algorithms implementations\n 高阶 "});index.add({'id':15,'href':'/note-cs/docs/basic/language/objective-c/basic/practice/','title':"最佳实践",'content':"最佳实践 "});index.add({'id':16,'href':'/note-cs/docs/direction/client/android/basic/practice/','title':"最佳实践",'content':"最佳实践 "});index.add({'id':17,'href':'/note-cs/docs/direction/client/ios/basic/practice/','title':"最佳实践",'content':"最佳实践 "});index.add({'id':18,'href':'/note-cs/docs/direction/client/xiaochengxu/basic/practice/','title':"最佳实践",'content':"最佳实践 "});index.add({'id':19,'href':'/note-cs/docs/basic/language/objective-c/basic/practice/spec/baidu/','title':"百度",'content':"百度 Objective-C 编码规范 (2019 版) "});index.add({'id':20,'href':'/note-cs/docs/basic/','title':"第一部分 基础",'content':""});index.add({'id':21,'href':'/note-cs/docs/basic/language/objective-c/basic/','title':"第一部分 基础入门",'content':""});index.add({'id':22,'href':'/note-cs/docs/basic/language/scala/basic/','title':"第一部分 基础入门",'content':""});index.add({'id':23,'href':'/note-cs/docs/basic/os/android/basic/','title':"第一部分 基础入门",'content':""});index.add({'id':24,'href':'/note-cs/docs/basic/os/ios/basic/','title':"第一部分 基础入门",'content':""});index.add({'id':25,'href':'/note-cs/docs/basic/os/macos/basic/','title':"第一部分 基础入门",'content':""});index.add({'id':26,'href':'/note-cs/docs/basic/os/unix/basic/','title':"第一部分 基础入门",'content':""});index.add({'id':27,'href':'/note-cs/docs/basic/os/windows/basic/','title':"第一部分 基础入门",'content':""});index.add({'id':28,'href':'/note-cs/docs/direction/client/android/basic/','title':"第一部分 基础入门",'content':""});index.add({'id':29,'href':'/note-cs/docs/direction/client/ios/basic/','title':"第一部分 基础入门",'content':""});index.add({'id':30,'href':'/note-cs/docs/direction/client/xiaochengxu/basic/','title':"第一部分 基础入门",'content':""});index.add({'id':31,'href':'/note-cs/docs/basic/language/objective-c/basic/practice/spec/','title':"编程规范",'content':"编程规范 "});index.add({'id':32,'href':'/note-cs/docs/direction/client/android/basic/practice/spec/','title':"编程规范",'content':"编程规范 "});index.add({'id':33,'href':'/note-cs/docs/direction/client/ios/basic/practice/spec/','title':"编程规范",'content':"编程规范 "});index.add({'id':34,'href':'/note-cs/docs/direction/client/xiaochengxu/basic/practice/spec/','title':"编程规范",'content':"编程规范 "});index.add({'id':35,'href':'/note-cs/docs/basic/os/','title':"1.2 操作系统",'content':"操作系统 "});index.add({'id':36,'href':'/note-cs/docs/basic/compile/make/makefile/','title':"makefile",'content':"makefile 简介 Makefile 用于定义如何创建目标文件，比如如何从源码到可执行文件。创建这一工具的目标是 减少不必要的编译或者任务。传说 Stuart Feldman 在 1976 年花了一个周末写出来的， 而今仍然使用广泛，特别是在 Unix 和 Linux 系统上。\n基础 语法  注释：# 文件名： 必须是 Makefile  区分大小写   make \u0026lt;target\u0026gt; 生成 target  重命名：make -f \u0026quot;filename\u0026quot; \u0026lt;target\u0026gt;   只认识 TAB，不认识空格  但是在 GNU Make 3.82 之后, 可以通过设置参数 .RECIPEPREFIX 进行修改   shell 符号  @：不把命令打印到 stdout -：发生错误了也没关系    target 声明  创建一个 target： targets : prerequisites recipe  prerequisites(依赖) 是可选的, recipe(做法) 也可以多个或者不给 targets 和 prerequisites 都可以是多个, 以空格分割 file2.txt file3.txt: file0.txt file1.txt touch file2.txt touch file3.txt    target 的声明顺序并不重要  上面的依赖可以下面再声明   如果声明重复的 target，make 会给一个 warning，后面会覆盖前面的  但是如果不定义任何 recipe, 就不会冲突, 只是多了依赖关系 file2.txt: file0.txt file3.txt    Phony(假的) Targets  意思是 tagets 并不是文件, 可以想象成一个任务的名字而已 因为不是文件, 无法比对是否有更新, 所以每次 make 都会执行 依赖于 phony target 的 target 也会每次 make 都执行, 即使 target 是文件   .PHONY  如果定义的 phony target 与文件名重名, 可以用 .PHONY 显式地指明哪些 targets 是 phony    常用 phony target  all clean install uninstall  变量与通配符  $^: 代表 prerequisites # 即便分开定义依赖, $^ 依然能拿到 # 非常智能的, ex1.txt 会被找到, file0.txt 会被去重 process: ex1.txt file0.txt @echo $^  $@: 代表 target, 如果 target 为多个, $@ 代表当前执行的那个 $\u0026lt;: prerequisite 中的第一个 $?: 需要更新的 prerequisite 文件列表 $+: 所有依赖, 包括重复的 $|: 竖线后面的 order-only prerequisites $*: target % 那部分, 包括路径 a.%.b: # $* match 的target % 那部分, 包括路径, 比如 `make dir/a.foo.b` 会打出 `dir/foo` @echo $*   模式匹配  make 会找到最具体的匹配  make small/foo.png 则会匹配下面这个规则（在这之前要先有 small/foo.svg 这个文件） %.png: %.svg inkscape --export-png $^ small/%.png: %.svg inkscape --export-png --export-dpi 30 $^    make 已经有一些内置的规则, 比如从 *.c 到 *.o  变量   变量都是字符串类型\n# 这俩是一样一样的 name = Ted name2=\u0026#34;Sarah\u0026#34;   设置变量，按以下顺序由高到低:\n 命令行参数. 比如试试 make echo name3=JICHAO Makefile 里面的 shell 中的环境变量 make 预设的一些变量    ?=\n# 如果 name 被设置过了, 就不设置了 name ?= Jean   override\n# 用 override 可以防止命令行参数设置的覆盖 override name = David ``   +\n# 用加号可以连接 (中间用空格分割) name4 +=grey   内置的变量\necho_inbuilt: echo $(CC) echo ${CXX)} echo $(FC) echo ${CFLAGS)} echo $(CPPFLAGS) echo ${CXXFLAGS} echo $(LDFLAGS) echo ${LDLIBS}   :=\n 等号声明时 recursively expanded 递归扩展 加个冒号可以声明 Simply expanded variables 即时扩展变量, 即只在声明时扩展一次  # var3 声明时找不到 var4, var3 会扩展成 `and good luck`，直接忽视 var4 var3 := $(var4) and good luck # var5 是正常的，扩展为 `good night and good luck` var5 = $(var4) and good luck var4 := good night   函数   函数调用格式\n$(func arg0,arg1,arg2...)   wildcard：将后面的通配符变成一串文件路径\n  patsubst：做替换\n# 把所有 markdown 后缀的文件重命名为 md 后缀 substitue: * @echo $(patsubst %.markdown,%.md,$* $^)   指令  include：引入别的 Makefile 文件 流程控制语句顶格写 sport = tennis # 流程控制语句 (如if else 等等) 顶格写 report: ifeq ($(sport),tennis) @echo \u0026#39;game, set, match\u0026#39; else @echo \u0026#34;They think it\u0026#39;s all over; it is now\u0026#34; endif    分支和变体 GNU make  进阶  原理 "});index.add({'id':37,'href':'/note-cs/docs/basic/language/objective-c/appendix/interview/basic/','title':"基础",'content':"基础面试题 "});index.add({'id':38,'href':'/note-cs/docs/basic/language/scala/appendix/interview/basic/','title':"基础",'content':"基础面试题 "});index.add({'id':39,'href':'/note-cs/docs/basic/os/android/appendix/interview/basic/','title':"基础",'content':"基础面试题 "});index.add({'id':40,'href':'/note-cs/docs/basic/os/ios/appendix/interview/basic/','title':"基础",'content':"基础面试题 "});index.add({'id':41,'href':'/note-cs/docs/basic/os/macos/appendix/interview/basic/','title':"基础",'content':"基础面试题 "});index.add({'id':42,'href':'/note-cs/docs/basic/os/unix/appendix/interview/basic/','title':"基础",'content':"基础面试题 "});index.add({'id':43,'href':'/note-cs/docs/basic/os/windows/appendix/interview/basic/','title':"基础",'content':"基础面试题 "});index.add({'id':44,'href':'/note-cs/docs/direction/client/android/appendix/interview/basic/','title':"基础",'content':"基础面试题 "});index.add({'id':45,'href':'/note-cs/docs/direction/client/ios/appendix/interview/basic/','title':"基础",'content':"基础面试题 "});index.add({'id':46,'href':'/note-cs/docs/direction/client/xiaochengxu/appendix/interview/basic/','title':"基础",'content':"基础面试题 "});index.add({'id':47,'href':'/note-cs/docs/basic/language/objective-c/priciple/','title':"第二部分 原理",'content':""});index.add({'id':48,'href':'/note-cs/docs/basic/language/scala/priciple/','title':"第二部分 原理",'content':""});index.add({'id':49,'href':'/note-cs/docs/basic/os/android/priciple/','title':"第二部分 原理",'content':""});index.add({'id':50,'href':'/note-cs/docs/basic/os/ios/priciple/','title':"第二部分 原理",'content':""});index.add({'id':51,'href':'/note-cs/docs/basic/os/macos/priciple/','title':"第二部分 原理",'content':""});index.add({'id':52,'href':'/note-cs/docs/basic/os/unix/priciple/','title':"第二部分 原理",'content':""});index.add({'id':53,'href':'/note-cs/docs/basic/os/windows/priciple/','title':"第二部分 原理",'content':""});index.add({'id':54,'href':'/note-cs/docs/direction/','title':"第二部分 方向",'content':""});index.add({'id':55,'href':'/note-cs/docs/direction/client/android/design/','title':"第二部分 设计",'content':""});index.add({'id':56,'href':'/note-cs/docs/direction/client/ios/design/','title':"第二部分 设计",'content':""});index.add({'id':57,'href':'/note-cs/docs/direction/client/xiaochengxu/design/','title':"第二部分 设计",'content':""});index.add({'id':58,'href':'/note-cs/docs/basic/language/objective-c/appendix/interview/advanced/','title':"进阶",'content':"进阶面试题 "});index.add({'id':59,'href':'/note-cs/docs/basic/language/scala/appendix/interview/advanced/','title':"进阶",'content':"进阶面试题 "});index.add({'id':60,'href':'/note-cs/docs/basic/os/android/appendix/interview/advanced/','title':"进阶",'content':"进阶面试题 "});index.add({'id':61,'href':'/note-cs/docs/basic/os/ios/appendix/interview/advanced/','title':"进阶",'content':"进阶面试题 "});index.add({'id':62,'href':'/note-cs/docs/basic/os/macos/appendix/interview/advanced/','title':"进阶",'content':"进阶面试题 "});index.add({'id':63,'href':'/note-cs/docs/basic/os/unix/appendix/interview/advanced/','title':"进阶",'content':"进阶面试题 "});index.add({'id':64,'href':'/note-cs/docs/basic/os/windows/appendix/interview/advanced/','title':"进阶",'content':"进阶面试题 "});index.add({'id':65,'href':'/note-cs/docs/direction/client/android/appendix/interview/advanced/','title':"进阶",'content':"进阶面试题 "});index.add({'id':66,'href':'/note-cs/docs/direction/client/ios/appendix/interview/advanced/','title':"进阶",'content':"进阶面试题 "});index.add({'id':67,'href':'/note-cs/docs/direction/client/xiaochengxu/appendix/interview/advanced/','title':"进阶",'content':"进阶面试题 "});index.add({'id':68,'href':'/note-cs/docs/basic/language/objective-c/appendix/interview/','title':"面试题",'content':"面试题 基础题 进阶题 高阶题 "});index.add({'id':69,'href':'/note-cs/docs/basic/language/scala/appendix/interview/','title':"面试题",'content':"面试题 基础题 进阶题 高阶题 "});index.add({'id':70,'href':'/note-cs/docs/basic/os/android/appendix/interview/','title':"面试题",'content':"面试题 基础题 进阶题 高阶题 "});index.add({'id':71,'href':'/note-cs/docs/basic/os/ios/appendix/interview/','title':"面试题",'content':"面试题 基础题 进阶题 高阶题 "});index.add({'id':72,'href':'/note-cs/docs/basic/os/macos/appendix/interview/','title':"面试题",'content':"面试题 基础题 进阶题 高阶题 "});index.add({'id':73,'href':'/note-cs/docs/basic/os/unix/appendix/interview/','title':"面试题",'content':"面试题 基础题 进阶题 高阶题 "});index.add({'id':74,'href':'/note-cs/docs/basic/os/windows/appendix/interview/','title':"面试题",'content':"面试题 基础题 进阶题 高阶题 "});index.add({'id':75,'href':'/note-cs/docs/direction/client/android/appendix/interview/','title':"面试题",'content':"面试题 基础题 进阶题 高阶题 "});index.add({'id':76,'href':'/note-cs/docs/direction/client/ios/appendix/interview/','title':"面试题",'content':"面试题 基础题 进阶题 高阶题 "});index.add({'id':77,'href':'/note-cs/docs/direction/client/xiaochengxu/appendix/interview/','title':"面试题",'content':"面试题 基础题 进阶题 高阶题 "});index.add({'id':78,'href':'/note-cs/docs/basic/data-structure/','title':"1.3 数据结构",'content':"数据结构 见：算法学习笔记\n"});index.add({'id':79,'href':'/note-cs/docs/basic/compile/make/cmake/','title':"cmake",'content':"cmake "});index.add({'id':80,'href':'/note-cs/docs/basic/os/macos/','title':"MacOS",'content':"MacOS "});index.add({'id':81,'href':'/note-cs/docs/basic/os/windows/','title':"Windows",'content':"Windows "});index.add({'id':82,'href':'/note-cs/docs/basic/language/objective-c/source/','title':"第三部分 源码实现",'content':""});index.add({'id':83,'href':'/note-cs/docs/basic/language/scala/source/','title':"第三部分 源码实现",'content':""});index.add({'id':84,'href':'/note-cs/docs/basic/os/android/source/','title':"第三部分 源码实现",'content':""});index.add({'id':85,'href':'/note-cs/docs/basic/os/ios/source/','title':"第三部分 源码实现",'content':""});index.add({'id':86,'href':'/note-cs/docs/basic/os/macos/source/','title':"第三部分 源码实现",'content':""});index.add({'id':87,'href':'/note-cs/docs/basic/os/unix/source/','title':"第三部分 源码实现",'content':""});index.add({'id':88,'href':'/note-cs/docs/basic/os/windows/source/','title':"第三部分 源码实现",'content':""});index.add({'id':89,'href':'/note-cs/docs/direction/client/android/source/','title':"第三部分 源码实现",'content':""});index.add({'id':90,'href':'/note-cs/docs/direction/client/ios/source/','title':"第三部分 源码实现",'content':""});index.add({'id':91,'href':'/note-cs/docs/direction/client/xiaochengxu/source/','title':"第三部分 源码实现",'content':""});index.add({'id':92,'href':'/note-cs/docs/domain/','title':"第三部分 领域",'content':""});index.add({'id':93,'href':'/note-cs/docs/basic/language/objective-c/appendix/interview/expert/','title':"高阶",'content':"高阶面试题 "});index.add({'id':94,'href':'/note-cs/docs/basic/language/scala/appendix/interview/expert/','title':"高阶",'content':"高阶面试题 "});index.add({'id':95,'href':'/note-cs/docs/basic/os/android/appendix/interview/expert/','title':"高阶",'content':"高阶面试题 "});index.add({'id':96,'href':'/note-cs/docs/basic/os/ios/appendix/interview/expert/','title':"高阶",'content':"高阶面试题 "});index.add({'id':97,'href':'/note-cs/docs/basic/os/macos/appendix/interview/expert/','title':"高阶",'content':"高阶面试题 "});index.add({'id':98,'href':'/note-cs/docs/basic/os/unix/appendix/interview/expert/','title':"高阶",'content':"高阶面试题 "});index.add({'id':99,'href':'/note-cs/docs/basic/os/windows/appendix/interview/expert/','title':"高阶",'content':"高阶面试题 "});index.add({'id':100,'href':'/note-cs/docs/direction/client/android/appendix/interview/expert/','title':"高阶",'content':"高阶面试题 "});index.add({'id':101,'href':'/note-cs/docs/direction/client/ios/appendix/interview/expert/','title':"高阶",'content':"高阶面试题 "});index.add({'id':102,'href':'/note-cs/docs/direction/client/xiaochengxu/appendix/interview/expert/','title':"高阶",'content':"高阶面试题 "});index.add({'id':103,'href':'/note-cs/docs/basic/network/','title':"1.4 计算机网络",'content':"计算机网络 见：网络学习笔记\n"});index.add({'id':104,'href':'/note-cs/docs/basic/os/unix/','title':"Unix",'content':"Unix "});index.add({'id':105,'href':'/note-cs/docs/others/','title':"第四部分 其他",'content':""});index.add({'id':106,'href':'/note-cs/docs/basic/language/objective-c/appendix/','title':"第四部分 附录",'content':""});index.add({'id':107,'href':'/note-cs/docs/basic/language/scala/appendix/','title':"第四部分 附录",'content':""});index.add({'id':108,'href':'/note-cs/docs/basic/os/android/appendix/','title':"第四部分 附录",'content':""});index.add({'id':109,'href':'/note-cs/docs/basic/os/ios/appendix/','title':"第四部分 附录",'content':""});index.add({'id':110,'href':'/note-cs/docs/basic/os/macos/appendix/','title':"第四部分 附录",'content':""});index.add({'id':111,'href':'/note-cs/docs/basic/os/unix/appendix/','title':"第四部分 附录",'content':""});index.add({'id':112,'href':'/note-cs/docs/basic/os/windows/appendix/','title':"第四部分 附录",'content':""});index.add({'id':113,'href':'/note-cs/docs/direction/client/android/appendix/','title':"第四部分 附录",'content':""});index.add({'id':114,'href':'/note-cs/docs/direction/client/ios/appendix/','title':"第四部分 附录",'content':""});index.add({'id':115,'href':'/note-cs/docs/direction/client/xiaochengxu/appendix/','title':"第四部分 附录",'content':""});index.add({'id':116,'href':'/note-cs/docs/others/skill/debug/gdb/','title':"GDB",'content':"GDB "});index.add({'id':117,'href':'/note-cs/docs/basic/compile/make/','title':"make",'content':"make 教程  learn make in y minutes 跟我一起写 Makefile GNU make manual  "});index.add({'id':118,'href':'/note-cs/docs/basic/language/objective-c/basic/practice/snippet/','title':"代码片段",'content':"代码片段 "});index.add({'id':119,'href':'/note-cs/docs/direction/client/android/basic/practice/snippet/','title':"代码片段",'content':"代码片段 "});index.add({'id':120,'href':'/note-cs/docs/direction/client/ios/basic/practice/snippet/','title':"代码片段",'content':"代码片段 "});index.add({'id':121,'href':'/note-cs/docs/direction/client/xiaochengxu/basic/practice/snippet/','title':"代码片段",'content':"代码片段 "});index.add({'id':122,'href':'/note-cs/docs/others/tool/dev/vscode/shortcuts/','title':"快捷键",'content':"VScode 快捷键 MacOS  选择  选中所有同一个词：cmd + shift + L  编辑  格式化：opt + shift + f  Windows  选择  选中所有同一个词：ctrl + shift + L   "});index.add({'id':123,'href':'/note-cs/docs/basic/language/scala/basic/spec/baidu/','title':"百度",'content':"百度 Scala 编码规范 前言 就目前 Baidu 内部情况 (2018.10)，Scala 这门语言主要用于计算团队内部的和 Spark 相关项目研发、社区贡献工作以及公司的 Spark 用户使用 Scala API 编写 Spark 作业三个用途，所以本文主体沿用如下两部分并稍作修改：\n Apache Spark 开源社区 Scala 编程指南:\nApache Spark 有超过 1000 位贡献者，就我们所知，应该是目前大数据领域里最大的开源项目且是最活跃的 Scala 项目，结合 Baidu 内部现状，本文主体沿用此部分中和 Spark 社区相关内容，去除部分项目专用细节。 scala 官方 style guide 里的格式部分已包含在 Spark 项目文档中，这里摘录部分官方 style guide 作为 Apache Spark 社区的编程指南补充。  "});index.add({'id':124,'href':'/note-cs/docs/others/tool/study/tutorial/','title':"编程学习网站",'content':"编程学习网站 基础 Codecademy Programiz  算法 Codewars  进阶 Codeplace 通过实际应用来学习编程。\n"});index.add({'id':125,'href':'/note-cs/docs/basic/os/ios/','title':"iOS",'content':"iOS "});index.add({'id':126,'href':'/note-cs/docs/basic/compile/','title':"1.5 编译原理",'content':"编译原理 "});index.add({'id':127,'href':'/note-cs/docs/direction/backend/','title':"2.1 后端",'content':"后端开发 见：后端开发学习笔记\n"});index.add({'id':128,'href':'/note-cs/docs/domain/cloud-computing/','title':"3.1 云计算",'content':"云计算 "});index.add({'id':129,'href':'/note-cs/docs/others/skill/','title':"4.1 技能树",'content':"技能树 "});index.add({'id':130,'href':'/note-cs/docs/basic/os/android/','title':"Android",'content':"Android "});index.add({'id':131,'href':'/note-cs/docs/direction/client/android/','title':"Android",'content':"Android "});index.add({'id':132,'href':'/note-cs/docs/direction/architecture/cap/','title':"CAP",'content':"CAP P 是前提 在理论计算机科学中，CAP 定理（CAP theorem），又被称作布鲁尔定理（Brewer's theorem），它指出对于一个distributed data store 来说，不可能同时满足以下三点：\n 一致性（Consistency）  每次读取要么获得最近写入的数据，要么获得一个错误。   可用性（Availability）  每次请求都能获得一个非错误响应，但不保证返回的是最新写入的数据。   分区容错性（Partition tolerance）  以实际效果而言，分区相当于对通信的时限要求。系统如果不能在时限内达成数据一致性，就意味着发生了分区的情况，必须就当前操作在 C 和 A 之间做出选择。 尽管任意数量的消息被节点间的网络丢失（或延迟），系统仍继续运行。    一般选 AP 也就是说，在存在网络分区的情况下，一致性和可用性必须二选一。\n比如：A 服务器 B 服务器同步数据，现在 A B 之间网络断掉了，那么现在发来 A 一个写入请求，但是 B 却没有相关的请求，显然，\n 如果 A 不写，保持一致性，那么我们就失去了 A 的服务， 但是如果 A 写了，跟 B 的数据就不一致了，我们自然就丧失了一致性。  这里的一致性（Consistency）是强一致性，意思是 AB 的数据时刻都是同步的，\n如果我们放弃了强一致性，不代表我们的数据就是一定是不一致的了，我们可以让 A 先写入本地，等到通信恢复了再同步给 B，这就是所谓的最终一致性，长远的看我们的数据还是一致的，我们只是在某一个时间窗口里数据不一致罢了。\n如果这个时间窗口小过了用户逻辑处理的时间。那么其实对于用户来说根本感觉不到。\n现实中的 CAP CAP 对实际工作缺乏指导性。\n实际系统主要有三种：\n 强调 availability 的 eventual consistency 系统，  比如 Amazon Dynamo 及他们的复制品；   强调一致性的系统，  典型的是基于 Paxos 的系统；   强调性能不顾其他的系统，  典型的是 Async replication 的主从备份系统。    参考  CAP 理论常被解释为一种 “三选二” 定律，这是否是一种误解？ 分布式事务中的最终一致具体应该如何实现？ 分布式系统中的数据一致性和性能怎么权衡？ 如何浅显易懂地解说 Paxos 的算法？  "});index.add({'id':133,'href':'/note-cs/docs/domain/cloud-computing/saas/crm/','title':"CRM",'content':"CRM "});index.add({'id':134,'href':'/note-cs/docs/others/skill/debug/gdb/tutorial/','title':"GDB 教程",'content':"GDB 教程 "});index.add({'id':135,'href':'/note-cs/docs/others/tool/dev/git/','title':"git",'content':"git git module git submodule foreach git reset --hard HEAD git submodule update git submodule foreach \u0026#34;git checkout master; git pull\u0026#34; git submodule foreach git clean -f "});index.add({'id':136,'href':'/note-cs/docs/basic/language/go/','title':"Go",'content':"Go 学习笔记 见：Go 学习笔记\n"});index.add({'id':137,'href':'/note-cs/docs/domain/cloud-computing/virtual/hyperkit/','title':"HyperKit",'content':"HyperKit "});index.add({'id':138,'href':'/note-cs/docs/domain/cloud-computing/iaas/','title':"IaaS",'content':"IaaS "});index.add({'id':139,'href':'/note-cs/docs/others/skill/debug/lldb/','title':"LLDB",'content':"LLDB "});index.add({'id':140,'href':'/note-cs/docs/others/skill/debug/lldb/tutorial/','title':"LLDB 教程",'content':"LLDB 教程 "});index.add({'id':141,'href':'/note-cs/docs/direction/architecture/paxos/','title':"Paxos",'content':"Paxos "});index.add({'id':142,'href':'/note-cs/docs/basic/language/python/','title':"Python",'content':"Python 见：Python 学习笔记\n"});index.add({'id':143,'href':'/note-cs/docs/basic/language/rust/','title':"Rust",'content':"Rust 见：Rust 学习笔记\n"});index.add({'id':144,'href':'/note-cs/docs/domain/cloud-computing/saas/crm/salesforce/','title':"Salesforce",'content':"Salesforce "});index.add({'id':145,'href':'/note-cs/docs/domain/cloud-computing/virtual/vmware/','title':"VMware Fusion",'content':"VMware Fusion "});index.add({'id':146,'href':'/note-cs/docs/others/tool/dev/vscode/debug/','title':"VSCode Debug",'content':"VSCode Debug 参考：\n  USER GUIDE - Debugging\n  Debug C++ in Visual Studio Code\n  "});index.add({'id':147,'href':'/note-cs/docs/direction/architecture/circuit-breaker/attention/','title':"关注",'content':"关注 其他 resilience4j/resilience4j Netflix/Hystrix "});index.add({'id':148,'href':'/note-cs/docs/domain/ai/attention/','title':"关注",'content':"关注 机器学习 tensorflow/tensorflow  scikit-learn/scikit-learn  scikit-learn: machine learning in Python https://scikit-learn.org\nphp-ai/php-ml  PHP-ML - Machine Learning library for PHP https://php-ml.org/\n 深度学习 paddlepaddle/paddle   机器人 gunthercox/ChatterBot  ChatterBot is a machine learning, conversational dialog engine for creating chat bots https://chatterbot.readthedocs.io\n"});index.add({'id':149,'href':'/note-cs/docs/others/tool/recommend/','title':"推荐软件",'content':"推荐软件 MacOS  开发 iTerm Keyboard Maestro  参考  jaywcjlove/awesome-mac   Windows  todo iOS  todo Android  todo Linux  todo  "});index.add({'id':150,'href':'/note-cs/docs/direction/architecture/circuit-breaker/','title':"熔断",'content':"熔断 断路器\n参考 "});index.add({'id':151,'href':'/note-cs/docs/basic/language/scala/basic/spec/','title':"编程规范",'content':"编程规范 "});index.add({'id':152,'href':'/note-cs/docs/basic/os/android/basic/spec/','title':"编程规范",'content':"编程规范 "});index.add({'id':153,'href':'/note-cs/docs/basic/os/ios/basic/spec/','title':"编程规范",'content':"编程规范 "});index.add({'id':154,'href':'/note-cs/docs/basic/os/macos/basic/spec/','title':"编程规范",'content':"编程规范 "});index.add({'id':155,'href':'/note-cs/docs/basic/os/unix/basic/spec/','title':"编程规范",'content':"编程规范 "});index.add({'id':156,'href':'/note-cs/docs/basic/os/windows/basic/spec/','title':"编程规范",'content':"编程规范 "});index.add({'id':157,'href':'/note-cs/docs/others/tool/study/','title':"计算机学习",'content':"计算机学习 "});index.add({'id':158,'href':'/note-cs/docs/others/skill/onvif/discovery/','title':"设备发现",'content':"设备发现 我们传统的 Web Services 服务调用的模式都是这样的：客户端在设计时就预先知道目标服务的地址（IP 地址或者域名），客户端基于这个地址进行服务调用。\n那如果客户端预先不知道目标服务的地址该怎么办？\nWS-Discovery（全称为 Web Services Dynamic Discovery）标准就是用于解决该问题的，遵循该标准，客户端预先不知道目标服务地址的情况下，可以动态地探测到可用的目标服务，以便进行服务调用。这个过程就是「设备发现」的过程。\nWS-Discovery 模式 WS-Discovery 定义了两种模式：Ad hoc 模式和 Managed 模式。\nAd hoc 模式  Ad hoc 模式：客户端以多播 (multicast) 的形式往多播组 (multicast group) 发送一个 Probe（探测）消息搜寻目标服务，在该探测消息中，包含相应的搜寻条件。如果目标服务满足该条件，则直接将响应 ProbeMatch 消息（服务自身相关的信息，包括地址）回复给客户端。  Managed 模式  Managed 模式：即代理模式。Ad hoc 模式有个局限性，只能局限于一个较小的网络。Managed 模式就是为了解决这个问题的，在 Managed 模式下，一个维护所有可用目标服务的中心发现代理（Discovery Proxy）被建立起来，客户端只需要将探测消息发送到该发现代理就可以得到相应的目标服务信息。  官方技术规范：http://docs.oasis-open.org/ws-dd/discovery/1.1/os/wsdd-discovery-1.1-spec-os.html\n 传输方式 TCP/IP 有三种传输方式：单播 (Unicast)、多播 (Multicast) 和广播 (Broadcast)，在 IPv6 领域还有另一种方式：任播 (Anycast)。\n单播 Unicast 单播 (Unicast)：一对一，双向通信，目的地址是对方主机地址。网络上绝大部分的数据都是以单播的形式传输的。如收发邮件、浏览网页等。\n多播 Multicast 多播 (Multicast)：也叫组播，一对多，单向通信，目的地址是多播地址，主机可以通过 IGMP 协议请求加入或退出某个多播组 (multicast group)，数据只会转发给有需要（已加入组）的主机，不影响其他不需要（未加入组）的主机。如网上视频会议、网上视频点播、IPTV 等。\n多播地址（Multicast Address）有很多，各个行业都不一样，IPC 摄像头用的是 239.255.255.250（端口 3702）。\n多播地址的范围和分类可以见官方 IANA（互联网地址分配机构） 的说明：IPv4 Multicast Address Space Registry。\nWS-Discovery 协议用到了多播。\n广播 Broadcast 广播 (Broadcast)：一对所有，单向通信，目的地址是广播地址，整个网络中所有主机均可以收到（不管你是否需要），如 ARP 地址解析、GARP 数据包等。广播会被限制在局域网范围内，禁止广播数据穿过路由器，防止广播数据影响大面积的主机。\n参考：单播、多播（组播）和广播的区别\n IPC 搜索实现： 实现 socket 编程（UDP），通过 sendto 往多播地址发送探测消息（Probe），再使用 recvfrom 接收 IPC 的应答消息（ProbeMatch）\n"});index.add({'id':159,'href':'/note-cs/docs/domain/cloud-computing/paas/','title':"PaaS",'content':"PaaS "});index.add({'id':160,'href':'/note-cs/docs/domain/cloud-computing/saas/','title':"SaaS",'content':"SaaS "});index.add({'id':161,'href':'/note-cs/docs/basic/language/','title':"1.6 编程语言",'content':"编程语言 "});index.add({'id':162,'href':'/note-cs/docs/domain/cloud-computing/paas/gae/','title':"GAE",'content':"Google App Engine "});index.add({'id':163,'href':'/note-cs/docs/others/tool/dev/','title':"开发者工具",'content':"开发者工具 "});index.add({'id':164,'href':'/note-cs/docs/basic/database/','title':"1.7 数据库",'content':"数据库 见：数据库学习笔记\n"});index.add({'id':165,'href':'/note-cs/docs/direction/frontend/','title':"2.2 前端",'content':"前端开发 见：前端开发学习笔记\n"});index.add({'id':166,'href':'/note-cs/docs/domain/bigdata/','title':"3.2 大数据",'content':"大数据 "});index.add({'id':167,'href':'/note-cs/docs/direction/architecture/acid/','title':"ACID",'content':"ACID  In computer science, ACID (atomicity, consistency, isolation, durability) is a set of properties of database transactions intended to guarantee validity even in the event of errors, power failures, etc. In the context of databases, a sequence of database operations that satisfies the ACID properties (and these can be perceived as a single logical operation on the data) is called a transaction.\n  ACID，是指数据库管理系统（DBMS）在写入或更新资料的过程中，为保证事务（transaction）是正确可靠的，所必须具备的四个特性：\n 原子性（Atomicity 又称不可分割性）  一个事务（transaction）中的所有操作，或者全部完成，或者全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。即，事务不可分割、不可约简。   一致性（Consistency）  在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设约束、触发器、级联回滚等。   隔离性（isolation，又称独立性）  数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括未提交读（Read uncommitted）、提交读（read committed）、可重复读（repeatable read）和串行化（Serializable）。   持久性（Durability）  事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。     ACID 是追求 CAP 的一致性 "});index.add({'id':168,'href':'/note-cs/docs/direction/architecture/base/','title':"BASE",'content':"BASE Basically Available, Soft state, Eventual consistency\nBASE 理论是 CAP 理论中的 AP 的延伸，是对互联网大规模分布式系统的实践总结，强调可用性。\n基本可用  流量削峰  在不同的时间，出售不同区域的票，将访问请求错开，削弱请求峰值   延迟响应  在春运期间，自己提交的购票请求，往往会在队列中排队等待处理，可能几分钟或十几分钟后，系统才开始处理，然后响应处理结果   体验降级  比如用小图片来替代原始图片，通过降低图片的清晰度和大小，提升系统的处理能力。   过载保护  把接收到的请求放在指定的队列中排队处理，如果请求等待时间超时了（假设是 100ms），这个时候直接拒绝超时请求；再比如队列满了之后，就清除队列中一定数量的排队请求，保护系统不过载，实现系统的基本可用。    最终的一致  读时修复：在读取数据时，检测数据的不一致，进行修复。  比如 Cassandra 的 Read Repair 实现，具体来说，在向 Cassandra 系统查询数据的时候，如果检测到不同节点的副本数据不一致，系统就自动修复数据。   写时修复：在写入数据，检测数据的不一致时，进行修复。  比如 Cassandra 的 Hinted Handoff 实现。具体来说，Cassandra 集群的节点之间远程写数据的时候，如果写失败就将数据缓存下来，然后定时重传，修复数据的不一致性。 写时修复不需要做数据一致性对比，性能消耗比较低，对系统运行影响也不大，推荐在实现最终一致性时优先实现这种方式。   异步修复：这个是最常用的方式，通过定时对账检测副本数据的一致性，并修复。   BASE 是追求 CAP 的可用性 "});index.add({'id':169,'href':'/note-cs/docs/domain/cloud-computing/paas/heroku/','title':"Heroku",'content':"Heroku "});index.add({'id':170,'href':'/note-cs/docs/direction/client/ios/','title':"iOS",'content':"iOS "});index.add({'id':171,'href':'/note-cs/docs/basic/language/objective-c/','title':"Objective-C",'content':"Objective-C 学习笔记 "});index.add({'id':172,'href':'/note-cs/docs/domain/cloud-computing/virtual/parallels/','title':"Parallels",'content':"Parallels "});index.add({'id':173,'href':'/note-cs/docs/direction/architecture/raft/','title':"Raft",'content':"Raft "});index.add({'id':174,'href':'/note-cs/docs/basic/language/scala/','title':"Scala",'content':"Scala 学习笔记 "});index.add({'id':175,'href':'/note-cs/docs/domain/cloud-computing/virtual/virtualbox/','title':"VirtualBox",'content':"VirtualBox "});index.add({'id':176,'href':'/note-cs/docs/basic/language/scala/basic/practice/','title':"最佳实践",'content':"Scala 最佳实践 "});index.add({'id':177,'href':'/note-cs/docs/basic/os/android/basic/practice/','title':"最佳实践",'content':"最佳实践 "});index.add({'id':178,'href':'/note-cs/docs/basic/os/ios/basic/practice/','title':"最佳实践",'content':"最佳实践 "});index.add({'id':179,'href':'/note-cs/docs/basic/os/macos/basic/practice/','title':"最佳实践",'content':"最佳实践 "});index.add({'id':180,'href':'/note-cs/docs/basic/os/unix/basic/practice/','title':"最佳实践",'content':"最佳实践 "});index.add({'id':181,'href':'/note-cs/docs/basic/os/windows/basic/practice/','title':"最佳实践",'content':"最佳实践 "});index.add({'id':182,'href':'/note-cs/docs/domain/cloud-computing/virtual/network/','title':"虚拟机网络",'content':"虚拟机网络 在 VMware 的 3 中网络模式中，NAT 模式是最简单的，基本不需要手动配置 IP 地址等相关参数。至于桥接模式则需要额外的 IP 地址，如果是在内网环境中还很容易，如果是 ADSL 宽带就比较麻烦了，ISP 一般是不会大方的多提供一个公网 IP 的。\n三种网络模式 桥接 桥接网络是指本地物理网卡和虚拟网卡通过 VMnet0 虚拟交换机进行桥接，物理网卡和虚拟网卡在拓扑图上处于同等地位，那么物理网卡和虚拟网卡就相当于处于同一个网段，虚拟交换机就相当于一台现实网络中的交换机，所以两个网卡的 IP 地址也要设置为同一网段。\n所以当我们要在局域网使用虚拟机，对局域网其他 pc 提供服务时，例如提供 ftp，提供 ssh，提供 http 服务，那么就要选择桥接模式。\n例如大学宿舍里有一个路由器，宿舍里四个人连接这个路由器，路由器的 wanip 就不理会了，这个 ip 是动态获取的，而 lanip 默认是 192.168.1.1, 子网掩码是 255.255.255.0。而其他四个人是自动获取 ip，假设四个人的 ip 是:\nA:192.168.1.100/255.255.255.0, B:192.168.1.101/255.255.255.0, C:192.168.1.102/255.255.255.0, D:192.168.1.103/255.255.255.0\n那么虚拟机的 ip 可以设置的 ip 地址是 192.168.1.2-192.168.1.99,192.168.1.104-192.168.1.254 (网络地址全 0 和全 1 的除外，再除去 ABCD 四个人的 ip 地址)\n那么虚拟机的 ip 地址可以设置为 192.168.1.98/255.255.255.0, 设置了这个 ip 地址，ABCD 这四个人就可以通过 192.168.1.98 访问虚拟机了，如果虚拟机需要上外网，那么还需要配置虚拟机的路由地址，就是 192.168.1.1 了，这样，虚拟机就可以上外网了，但是，上网我们一般是通过域名去访问外网的，所以我们还需要为虚拟机配置一个 dns 服务器，我们可以简单点，把 dns 服务器地址配置为 google 的 dns 服务器：8.8.8.8, 到此，虚拟机就可以上网了。\nNAT NAT 模式中，就是让虚拟机借助 NAT (网络地址转换) 功能，通过宿主机器所在的网络来访问公网。\nNAT 模式中，虚拟机的网卡和物理网卡的网络，不在同一个网络，虚拟机的网卡，是在 vmware 提供的一个虚拟网络。\nNAT 和桥接的比较:\n(1) NAT 模式和桥接模式虚拟机都可以上外网。\n(2) 由于 NAT 的网络在 vmware 提供的一个虚拟网络里，所以局域网其他主机是无法访问虚拟机的，而宿主机可以访问虚拟机，虚拟机可以访问局域网的所有主机，因为真实的局域网相对于 NAT 的虚拟网络，就是 NAT 的虚拟网络的外网，不懂的人可以查查 NAT 的相关知识。\n(3) 桥接模式下，多个虚拟机之间可以互相访问；NAT 模式下，多个虚拟机之间也可以相互访问。\n如果你建一个虚拟机，只是给自己用，不需要给局域网其他人用，那么可以选择 NAT，毕竟 NAT 模式下的虚拟系统的 TCP/IP 配置信息是由 VMnet8 (NAT) 虚拟网络的 DHCP 服务器提供的，只要虚拟机的网路配置是 DHCP，那么你不需要进行任何其他的配置，只需要宿主机器能访问互联网即可，就可以让虚拟机联网了。\n例如你想建多个虚拟机集群，作为测试使用，而宿主机可能是一个笔记本，ip 不固定。这种应用场景，我们需要采用 nat 模式了，但是我们要考虑一个问题，虚拟机之间是需要互访的，默认采用 dhcp，虚拟机的 ip 每次重启，ip 都是不固定的，所以我们需要手工设置虚拟机的 ip 地址。\n但是我们对虚拟机网卡所在的虚拟网络的信息还一无所知，例如虚拟机网络的路由地址，子网掩码，所以我们需要先查下 nat 虚拟网络的信息。\n使用 vmware, 在 Edit-\u0026gt;Virtual Network Editor 中配置好虚拟网络信息后看到下图所示，注意 VMnet8，VMnet8 相当于是本机的一个路由，虚拟机设置 NAT 后就通过这个路由进行上网的，可以查看其网络地址，路由地址，子网掩码。\n选择 VMnet8-\u0026gt;NAT 设置，可以看到子网 ip 显示为 192.168.233.0，子网掩码是 255.255.255.0，那路由地址呢，其实就是网关 IP 了，都是同个东西，这里是 192.168.233.2。\n接下来就好办了，在对应的虚拟机设置好 ip，子网掩码，路由地址就可以上外网了，至于 dns 可以设置为 8.8.8.8.\nHost-Only 在 Host-Only 模式下，虚拟网络是一个全封闭的网络，它唯一能够访问的就是主机。其实 Host-Only 网络和 NAT 网络很相似，不同的地方就是 Host-Only 网络没有 NAT 服务，所以虚拟网络不能连接到 Internet。主机和虚拟机之间的通信是通过 VMware Network Adepter VMnet1 虚拟网卡来实现的。\nHost-Only 的宗旨就是建立一个与外界隔绝的内部网络，来提高内网的安全性。这个功能或许对普通用户来说没有多大意义，但大型服务商会常常利用这个功能。如果你想为 VMnet1 网段提供路由功能，那就需要使用 RRAS，而不能使用 XP 或 2000 的 ICS，因为 ICS 会把内网的 IP 地址改为 192.168.0.1，但虚拟机是不会给 VMnet1 虚拟网卡分配这个地址的，那么主机和虚拟机之间就不能通信了。\n"});index.add({'id':183,'href':'/note-cs/docs/direction/client/','title':"2.3 客户端",'content':"客户端 "});index.add({'id':184,'href':'/note-cs/docs/domain/ai/','title':"3.3 人工智能",'content':"人工智能 "});index.add({'id':185,'href':'/note-cs/docs/direction/architecture/release/ab-testing/','title':"A/B 测试",'content':"A/B 测试 A/B testing\n 参考 "});index.add({'id':186,'href':'/note-cs/docs/others/skill/debug/','title':"Debug",'content':"Debug "});index.add({'id':187,'href':'/note-cs/docs/domain/cloud-computing/paas/openshift/','title':"OpenShift",'content':"OpenShift Red Hat OpenShift is a leading hybrid cloud, enterprise Kubernetes application platform. OpenShift 在 Kubernetes 的基础上整合了应用的生命周期管理，包括 image 的编译，持续集成，部署以及更新。\nOpenshift 以前是 IaaS，现在 Openshift 自己宣称自己搭配 LXC 已经是 PaaS 了，VPS 不是云服务但可以类比为 IaaS。\nOpenshift 没有 root 权限 参考：openshift 和普通 vps 的区别在哪儿？\n"});index.add({'id':188,'href':'/note-cs/docs/domain/ai/frame/paddlepaddle/','title':"PaddlePaddle",'content':"PaddlePaddle  PArallel Distributed Deep LEarning: Machine Learning Framework from Industrial Practice （『飞桨』核心框架，深度学习 \u0026amp; 机器学习高性能单机、分布式训练和跨平台部署） http://www.paddlepaddle.org/\n"});index.add({'id':189,'href':'/note-cs/docs/basic/language/scala/basic/snippet/','title':"代码片段",'content':"代码片段 "});index.add({'id':190,'href':'/note-cs/docs/basic/os/android/basic/snippet/','title':"代码片段",'content':"代码片段 "});index.add({'id':191,'href':'/note-cs/docs/basic/os/ios/basic/snippet/','title':"代码片段",'content':"代码片段 "});index.add({'id':192,'href':'/note-cs/docs/basic/os/macos/basic/snippet/','title':"代码片段",'content':"代码片段 "});index.add({'id':193,'href':'/note-cs/docs/basic/os/unix/basic/snippet/','title':"代码片段",'content':"代码片段 "});index.add({'id':194,'href':'/note-cs/docs/basic/os/windows/basic/snippet/','title':"代码片段",'content':"代码片段 "});index.add({'id':195,'href':'/note-cs/docs/direction/client/xiaochengxu/','title':"小程序",'content':"小程序 "});index.add({'id':196,'href':'/note-cs/docs/domain/ai/frame/','title':"框架",'content':"框架 "});index.add({'id':197,'href':'/note-cs/docs/basic/language/scala/basic/practice/baidu/','title':"百度",'content':"百度 Scala 最佳实践 "});index.add({'id':198,'href':'/note-cs/docs/domain/cloud-computing/virtual/','title':"虚拟化",'content':"虚拟化 "});index.add({'id':199,'href':'/note-cs/docs/direction/architecture/release/canary-rollouts/','title':"金丝雀发布",'content':"金丝雀发布 canary rollouts\n 参考 "});index.add({'id':200,'href':'/note-cs/docs/direction/embedded/','title':"2.4 嵌入式",'content':"嵌入式开发 "});index.add({'id':201,'href':'/note-cs/docs/domain/cloud-computing/paas/cloud-foundry/','title':"Cloud Foundry",'content':"Cloud Foundry "});index.add({'id':202,'href':'/note-cs/docs/direction/middle-platform/','title':"2.5 中台",'content':"中台 "});index.add({'id':203,'href':'/note-cs/docs/others/tool/','title':"4.2 工具",'content':"工具 "});index.add({'id':204,'href':'/note-cs/docs/domain/cloud-computing/paas/appfog/','title':"AppFog",'content':"AppFog "});index.add({'id':205,'href':'/note-cs/docs/others/tool/study/coding-online/','title':"在线编程",'content':"在线编程 "});index.add({'id':206,'href':'/note-cs/docs/direction/architecture/','title':"2.6 架构设计",'content':"架构设计  参考 "});index.add({'id':207,'href':'/note-cs/docs/direction/architecture/release/','title':"发布形式",'content':"发布形式  参考 "});index.add({'id':208,'href':'/note-cs/docs/direction/architecture/seckill/','title':"秒杀",'content':"秒杀  参考 codingXiaxw/seckill  Java 高并发秒杀系统 API\n"});index.add({'id':209,'href':'/note-cs/docs/direction/architecture/tutorial/','title':"教程",'content':"教程 基础 系统设计入门  学习如何设计可扩展的系统将会有助于你成为一个更好的工程师。\n系统设计是一个很宽泛的话题。在互联网上，关于系统设计原则的资源也是多如牛毛。\n这个仓库就是这些资源的组织收集，它可以帮助你学习如何构建可扩展的系统。\n 进阶 "});index.add({'id':210,'href':'/note-cs/docs/others/skill/lorawan/','title':"LoRaWan",'content':"LoRaWan "});index.add({'id':211,'href':'/note-cs/docs/others/skill/onvif/','title':"ONVIF",'content':"ONVIF 官网：www.onvif.org\n"});index.add({'id':212,'href':'/note-cs/categories/','title':"Categories",'content':""});index.add({'id':213,'href':'/note-cs/docs/','title':"Docs",'content':""});index.add({'id':214,'href':'/note-cs/tags/','title':"Tags",'content':""});index.add({'id':215,'href':'/note-cs/','title':"首页",'content':""});})();