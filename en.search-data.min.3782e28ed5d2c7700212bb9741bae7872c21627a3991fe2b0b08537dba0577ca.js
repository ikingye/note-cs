'use strict';(function(){const indexCfg={cache:true};indexCfg.doc={id:'id',field:['title','content'],store:['title','href'],};const index=FlexSearch.create('balance',indexCfg);window.bookSearchIndex=index;index.add({'id':0,'href':'/note-cs/docs/os/linux/','title':"Linux",'content':"Linux 见：Linux 学习笔记\n"});index.add({'id':1,'href':'/note-cs/docs/tool/editor/vscode/','title':"VSCode",'content':"VSCode 推荐插件 PicGo/vs-picgo https://github.com/PicGo/vs-picgo\n"});index.add({'id':2,'href':'/note-cs/docs/language/objective-c/appendix/tutorial/','title':"教程",'content':"教程 基础 进阶 高阶 "});index.add({'id':3,'href':'/note-cs/docs/language/scala/appendix/tutorial/','title':"教程",'content':"教程 基础 进阶 高阶 "});index.add({'id':4,'href':'/note-cs/docs/os/android/appendix/tutorial/','title':"教程",'content':"教程 基础 进阶 高阶 "});index.add({'id':5,'href':'/note-cs/docs/os/ios/appendix/tutorial/','title':"教程",'content':"教程 基础 进阶 高阶 "});index.add({'id':6,'href':'/note-cs/docs/os/linux/appendix/tutorial/','title':"教程",'content':"教程 基础 进阶 高阶 "});index.add({'id':7,'href':'/note-cs/docs/os/macos/appendix/tutorial/','title':"教程",'content':"教程 基础 进阶 高阶 "});index.add({'id':8,'href':'/note-cs/docs/os/unix/appendix/tutorial/','title':"教程",'content':"教程 基础 进阶 高阶 "});index.add({'id':9,'href':'/note-cs/docs/os/windows/appendix/tutorial/','title':"教程",'content':"教程 基础 进阶 高阶 "});index.add({'id':10,'href':'/note-cs/docs/language/objective-c/basic/practice/','title':"最佳实践",'content':"最佳实践 "});index.add({'id':11,'href':'/note-cs/docs/language/objective-c/basic/practice/spec/baidu/','title':"百度",'content':"百度 Objective-C 编码规范 (2019 版) "});index.add({'id':12,'href':'/note-cs/docs/language/objective-c/basic/','title':"第一部分 基础入门",'content':""});index.add({'id':13,'href':'/note-cs/docs/language/scala/basic/','title':"第一部分 基础入门",'content':""});index.add({'id':14,'href':'/note-cs/docs/os/android/basic/','title':"第一部分 基础入门",'content':""});index.add({'id':15,'href':'/note-cs/docs/os/ios/basic/','title':"第一部分 基础入门",'content':""});index.add({'id':16,'href':'/note-cs/docs/os/linux/basic/','title':"第一部分 基础入门",'content':""});index.add({'id':17,'href':'/note-cs/docs/os/macos/basic/','title':"第一部分 基础入门",'content':""});index.add({'id':18,'href':'/note-cs/docs/os/unix/basic/','title':"第一部分 基础入门",'content':""});index.add({'id':19,'href':'/note-cs/docs/os/windows/basic/','title':"第一部分 基础入门",'content':""});index.add({'id':20,'href':'/note-cs/docs/language/objective-c/basic/practice/spec/','title':"编程规范",'content':"编程规范 "});index.add({'id':21,'href':'/note-cs/docs/computer-composition/','title':"计算机组成原理",'content':"计算机组成原理 "});index.add({'id':22,'href':'/note-cs/docs/compile/make/makefile/','title':"makefile",'content':"makefile 简介 Makefile 用于定义如何创建目标文件，比如如何从源码到可执行文件。创建这一工具的目标是 减少不必要的编译或者任务。传说 Stuart Feldman 在 1976 年花了一个周末写出来的， 而今仍然使用广泛，特别是在 Unix 和 Linux 系统上。\n基础 语法  注释：# 文件名： 必须是 Makefile  区分大小写   make \u0026lt;target\u0026gt; 生成 target  重命名：make -f \u0026quot;filename\u0026quot; \u0026lt;target\u0026gt;   只认识 TAB，不认识空格  但是在 GNU Make 3.82 之后, 可以通过设置参数 .RECIPEPREFIX 进行修改   shell 符号  @：不把命令打印到 stdout -：发生错误了也没关系    target 声明  创建一个 target： targets : prerequisites recipe  prerequisites(依赖) 是可选的, recipe(做法) 也可以多个或者不给 targets 和 prerequisites 都可以是多个, 以空格分割 file2.txt file3.txt: file0.txt file1.txt touch file2.txt touch file3.txt    target 的声明顺序并不重要  上面的依赖可以下面再声明   如果声明重复的 target，make 会给一个 warning，后面会覆盖前面的  但是如果不定义任何 recipe, 就不会冲突, 只是多了依赖关系 file2.txt: file0.txt file3.txt    Phony(假的) Targets  意思是 tagets 并不是文件, 可以想象成一个任务的名字而已 因为不是文件, 无法比对是否有更新, 所以每次 make 都会执行 依赖于 phony target 的 target 也会每次 make 都执行, 即使 target 是文件   .PHONY  如果定义的 phony target 与文件名重名, 可以用 .PHONY 显式地指明哪些 targets 是 phony    常用 phony target  all clean install uninstall  变量与通配符  $^: 代表 prerequisites # 即便分开定义依赖, $^ 依然能拿到 # 非常智能的, ex1.txt 会被找到, file0.txt 会被去重 process: ex1.txt file0.txt @echo $^  $@: 代表 target, 如果 target 为多个, $@ 代表当前执行的那个 $\u0026lt;: prerequisite 中的第一个 $?: 需要更新的 prerequisite 文件列表 $+: 所有依赖, 包括重复的 $|: 竖线后面的 order-only prerequisites $*: target % 那部分, 包括路径 a.%.b: # $* match 的target % 那部分, 包括路径, 比如 `make dir/a.foo.b` 会打出 `dir/foo` @echo $*   模式匹配  make 会找到最具体的匹配  make small/foo.png 则会匹配下面这个规则（在这之前要先有 small/foo.svg 这个文件） %.png: %.svg inkscape --export-png $^ small/%.png: %.svg inkscape --export-png --export-dpi 30 $^    make 已经有一些内置的规则, 比如从 *.c 到 *.o  变量   变量都是字符串类型\n# 这俩是一样一样的 name = Ted name2=\u0026#34;Sarah\u0026#34;   设置变量，按以下顺序由高到低:\n 命令行参数. 比如试试 make echo name3=JICHAO Makefile 里面的 shell 中的环境变量 make 预设的一些变量    ?=\n# 如果 name 被设置过了, 就不设置了 name ?= Jean   override\n# 用 override 可以防止命令行参数设置的覆盖 override name = David ``   +\n# 用加号可以连接 (中间用空格分割) name4 +=grey   内置的变量\necho_inbuilt: echo $(CC) echo ${CXX)} echo $(FC) echo ${CFLAGS)} echo $(CPPFLAGS) echo ${CXXFLAGS} echo $(LDFLAGS) echo ${LDLIBS}   :=\n 等号声明时 recursively expanded 递归扩展 加个冒号可以声明 Simply expanded variables 即时扩展变量, 即只在声明时扩展一次  # var3 声明时找不到 var4, var3 会扩展成 `and good luck`，直接忽视 var4 var3 := $(var4) and good luck # var5 是正常的，扩展为 `good night and good luck` var5 = $(var4) and good luck var4 := good night   函数   函数调用格式\n$(func arg0,arg1,arg2...)   wildcard：将后面的通配符变成一串文件路径\n  patsubst：做替换\n# 把所有 markdown 后缀的文件重命名为 md 后缀 substitue: * @echo $(patsubst %.markdown,%.md,$* $^)   指令  include：引入别的 Makefile 文件 流程控制语句顶格写 sport = tennis # 流程控制语句 (如if else 等等) 顶格写 report: ifeq ($(sport),tennis) @echo \u0026#39;game, set, match\u0026#39; else @echo \u0026#34;They think it\u0026#39;s all over; it is now\u0026#34; endif    分支和变体 GNU make  进阶  原理 "});index.add({'id':23,'href':'/note-cs/docs/language/objective-c/appendix/interview/basic/','title':"基础",'content':"基础面试题 "});index.add({'id':24,'href':'/note-cs/docs/language/scala/appendix/interview/basic/','title':"基础",'content':"基础面试题 "});index.add({'id':25,'href':'/note-cs/docs/os/android/appendix/interview/basic/','title':"基础",'content':"基础面试题 "});index.add({'id':26,'href':'/note-cs/docs/os/ios/appendix/interview/basic/','title':"基础",'content':"基础面试题 "});index.add({'id':27,'href':'/note-cs/docs/os/linux/appendix/interview/basic/','title':"基础",'content':"基础面试题 "});index.add({'id':28,'href':'/note-cs/docs/os/macos/appendix/interview/basic/','title':"基础",'content':"基础面试题 "});index.add({'id':29,'href':'/note-cs/docs/os/unix/appendix/interview/basic/','title':"基础",'content':"基础面试题 "});index.add({'id':30,'href':'/note-cs/docs/os/windows/appendix/interview/basic/','title':"基础",'content':"基础面试题 "});index.add({'id':31,'href':'/note-cs/docs/os/','title':"操作系统",'content':"操作系统 "});index.add({'id':32,'href':'/note-cs/docs/language/objective-c/priciple/','title':"第二部分 原理",'content':""});index.add({'id':33,'href':'/note-cs/docs/language/scala/priciple/','title':"第二部分 原理",'content':""});index.add({'id':34,'href':'/note-cs/docs/os/android/priciple/','title':"第二部分 原理",'content':""});index.add({'id':35,'href':'/note-cs/docs/os/ios/priciple/','title':"第二部分 原理",'content':""});index.add({'id':36,'href':'/note-cs/docs/os/linux/priciple/','title':"第二部分 原理",'content':""});index.add({'id':37,'href':'/note-cs/docs/os/macos/priciple/','title':"第二部分 原理",'content':""});index.add({'id':38,'href':'/note-cs/docs/os/unix/priciple/','title':"第二部分 原理",'content':""});index.add({'id':39,'href':'/note-cs/docs/os/windows/priciple/','title':"第二部分 原理",'content':""});index.add({'id':40,'href':'/note-cs/docs/language/objective-c/appendix/interview/advanced/','title':"进阶",'content':"进阶面试题 "});index.add({'id':41,'href':'/note-cs/docs/language/scala/appendix/interview/advanced/','title':"进阶",'content':"进阶面试题 "});index.add({'id':42,'href':'/note-cs/docs/os/android/appendix/interview/advanced/','title':"进阶",'content':"进阶面试题 "});index.add({'id':43,'href':'/note-cs/docs/os/ios/appendix/interview/advanced/','title':"进阶",'content':"进阶面试题 "});index.add({'id':44,'href':'/note-cs/docs/os/linux/appendix/interview/advanced/','title':"进阶",'content':"进阶面试题 "});index.add({'id':45,'href':'/note-cs/docs/os/macos/appendix/interview/advanced/','title':"进阶",'content':"进阶面试题 "});index.add({'id':46,'href':'/note-cs/docs/os/unix/appendix/interview/advanced/','title':"进阶",'content':"进阶面试题 "});index.add({'id':47,'href':'/note-cs/docs/os/windows/appendix/interview/advanced/','title':"进阶",'content':"进阶面试题 "});index.add({'id':48,'href':'/note-cs/docs/language/objective-c/appendix/interview/','title':"面试题",'content':"面试题 基础题 进阶题 高阶题 "});index.add({'id':49,'href':'/note-cs/docs/language/scala/appendix/interview/','title':"面试题",'content':"面试题 基础题 进阶题 高阶题 "});index.add({'id':50,'href':'/note-cs/docs/os/android/appendix/interview/','title':"面试题",'content':"面试题 基础题 进阶题 高阶题 "});index.add({'id':51,'href':'/note-cs/docs/os/ios/appendix/interview/','title':"面试题",'content':"面试题 基础题 进阶题 高阶题 "});index.add({'id':52,'href':'/note-cs/docs/os/linux/appendix/interview/','title':"面试题",'content':"面试题 基础题 进阶题 高阶题 "});index.add({'id':53,'href':'/note-cs/docs/os/macos/appendix/interview/','title':"面试题",'content':"面试题 基础题 进阶题 高阶题 "});index.add({'id':54,'href':'/note-cs/docs/os/unix/appendix/interview/','title':"面试题",'content':"面试题 基础题 进阶题 高阶题 "});index.add({'id':55,'href':'/note-cs/docs/os/windows/appendix/interview/','title':"面试题",'content':"面试题 基础题 进阶题 高阶题 "});index.add({'id':56,'href':'/note-cs/docs/compile/make/cmake/','title':"cmake",'content':"cmake "});index.add({'id':57,'href':'/note-cs/docs/os/macos/','title':"MacOS",'content':"MacOS "});index.add({'id':58,'href':'/note-cs/docs/os/windows/','title':"Windows",'content':"Windows "});index.add({'id':59,'href':'/note-cs/docs/data-structure/','title':"数据结构",'content':"数据结构 见：算法学习笔记\n"});index.add({'id':60,'href':'/note-cs/docs/language/objective-c/source/','title':"第三部分 源码实现",'content':""});index.add({'id':61,'href':'/note-cs/docs/language/scala/source/','title':"第三部分 源码实现",'content':""});index.add({'id':62,'href':'/note-cs/docs/os/android/source/','title':"第三部分 源码实现",'content':""});index.add({'id':63,'href':'/note-cs/docs/os/ios/source/','title':"第三部分 源码实现",'content':""});index.add({'id':64,'href':'/note-cs/docs/os/linux/source/','title':"第三部分 源码实现",'content':""});index.add({'id':65,'href':'/note-cs/docs/os/macos/source/','title':"第三部分 源码实现",'content':""});index.add({'id':66,'href':'/note-cs/docs/os/unix/source/','title':"第三部分 源码实现",'content':""});index.add({'id':67,'href':'/note-cs/docs/os/windows/source/','title':"第三部分 源码实现",'content':""});index.add({'id':68,'href':'/note-cs/docs/language/objective-c/appendix/interview/expert/','title':"高阶",'content':"高阶面试题 "});index.add({'id':69,'href':'/note-cs/docs/language/scala/appendix/interview/expert/','title':"高阶",'content':"高阶面试题 "});index.add({'id':70,'href':'/note-cs/docs/os/android/appendix/interview/expert/','title':"高阶",'content':"高阶面试题 "});index.add({'id':71,'href':'/note-cs/docs/os/ios/appendix/interview/expert/','title':"高阶",'content':"高阶面试题 "});index.add({'id':72,'href':'/note-cs/docs/os/linux/appendix/interview/expert/','title':"高阶",'content':"高阶面试题 "});index.add({'id':73,'href':'/note-cs/docs/os/macos/appendix/interview/expert/','title':"高阶",'content':"高阶面试题 "});index.add({'id':74,'href':'/note-cs/docs/os/unix/appendix/interview/expert/','title':"高阶",'content':"高阶面试题 "});index.add({'id':75,'href':'/note-cs/docs/os/windows/appendix/interview/expert/','title':"高阶",'content':"高阶面试题 "});index.add({'id':76,'href':'/note-cs/docs/mq/mqtt/mosquitto/','title':"mosquitto",'content':"mosquitto 物联网（Internet of Things，IoT）最近曝光率越来越高。虽然 HTTP 是网页的事实标准，不过机器之间（Machine-to-Machine，M2M）的大规模沟通需要不同的模式：之前的请求 / 回答（Request/Response）模式不再合适，取而代之的是发布 / 订阅（Publish/Subscribe）模式。这就是轻量级、可扩展的 MQTT（Message Queuing Telemetry Transport）可以施展拳脚的舞台。\nMQTT 是基于二进制消息的发布 / 订阅编程模式的消息协议，最早由 IBM 提出的，如今已经成为 OASIS 规范。由于规范很简单，非常适合需要低功耗和网络带宽有限的 IoT 场景，比如：\n 遥感数据 汽车 智能家居 智慧城市 医疗医护  安装 MacOS brew install mosquitto\n参考：https://mosquitto.org/download/\n"});index.add({'id':77,'href':'/note-cs/docs/mq/mqtt/','title':"MQTT",'content':"MQTT mqtt 各种 broker 如何选择？\nAgent 和 Broker 的差别是什么？\n 经纪人（Broker）：是为促成他人交易，充当订约居间人，为委托方提供订约的信息、机会和条件的主体。  Broker 是一个独立主体，但没有自主决策能力，只负责订约过程。   代理人（Agent）：是行使被代理者的权力，完成相关的使命或者任务主体。  Agent 是一个独立主体，负责完成任务但不负责执行任务，Agent 具有一定的自主决策能力，如对服务请求的选择。   代理（Proxy）是指行为代理，不是一个主体。  Proxy 是完全的传递者，如请求和响应的转发，操作控制的传递。    "});index.add({'id':78,'href':'/note-cs/docs/os/unix/','title':"Unix",'content':"Unix "});index.add({'id':79,'href':'/note-cs/docs/mq/','title':"消息队列",'content':"消息队列 "});index.add({'id':80,'href':'/note-cs/docs/language/objective-c/appendix/','title':"第四部分 附录",'content':""});index.add({'id':81,'href':'/note-cs/docs/language/scala/appendix/','title':"第四部分 附录",'content':""});index.add({'id':82,'href':'/note-cs/docs/os/android/appendix/','title':"第四部分 附录",'content':""});index.add({'id':83,'href':'/note-cs/docs/os/ios/appendix/','title':"第四部分 附录",'content':""});index.add({'id':84,'href':'/note-cs/docs/os/linux/appendix/','title':"第四部分 附录",'content':""});index.add({'id':85,'href':'/note-cs/docs/os/macos/appendix/','title':"第四部分 附录",'content':""});index.add({'id':86,'href':'/note-cs/docs/os/unix/appendix/','title':"第四部分 附录",'content':""});index.add({'id':87,'href':'/note-cs/docs/os/windows/appendix/','title':"第四部分 附录",'content':""});index.add({'id':88,'href':'/note-cs/docs/network/','title':"计算机网络",'content':"计算机网络 见：网络学习笔记\n"});index.add({'id':89,'href':'/note-cs/docs/debug/gdb/','title':"GDB",'content':"GDB "});index.add({'id':90,'href':'/note-cs/docs/compile/make/','title':"make",'content':"make 教程  learn make in y minutes 跟我一起写 Makefile GNU make manual  "});index.add({'id':91,'href':'/note-cs/docs/language/objective-c/basic/practice/snippet/','title':"代码片段",'content':"代码片段 "});index.add({'id':92,'href':'/note-cs/docs/tool/editor/vscode/shortcuts/','title':"快捷键",'content':"VScode 快捷键 编辑 格式化： opt + shift + f\n"});index.add({'id':93,'href':'/note-cs/docs/language/scala/basic/spec/baidu/','title':"百度",'content':"百度 Scala 编码规范 前言 就目前 Baidu 内部情况 (2018.10)，Scala 这门语言主要用于计算团队内部的和 Spark 相关项目研发、社区贡献工作以及公司的 Spark 用户使用 Scala API 编写 Spark 作业三个用途，所以本文主体沿用如下两部分并稍作修改：\n Apache Spark 开源社区 Scala 编程指南:\nApache Spark 有超过 1000 位贡献者，就我们所知，应该是目前大数据领域里最大的开源项目且是最活跃的 Scala 项目，结合 Baidu 内部现状，本文主体沿用此部分中和 Spark 社区相关内容，去除部分项目专用细节。 scala 官方 style guide 里的格式部分已包含在 Spark 项目文档中，这里摘录部分官方 style guide 作为 Apache Spark 社区的编程指南补充。  "});index.add({'id':94,'href':'/note-cs/docs/study/tutorial/','title':"编程学习网站",'content':"编程学习网站 基础 Codecademy Programiz  算法 Codewars  进阶 Codeplace 通过实际应用来学习编程。\n"});index.add({'id':95,'href':'/note-cs/docs/compile/','title':"编译原理",'content':"编译原理 "});index.add({'id':96,'href':'/note-cs/docs/os/ios/','title':"iOS",'content':"iOS "});index.add({'id':97,'href':'/note-cs/docs/os/android/','title':"Android",'content':"Android "});index.add({'id':98,'href':'/note-cs/docs/cloud-computing/saas/crm/','title':"CRM",'content':"CRM "});index.add({'id':99,'href':'/note-cs/docs/debug/gdb/tutorial/','title':"GDB 教程",'content':"GDB 教程 "});index.add({'id':100,'href':'/note-cs/docs/tool/dev/git/','title':"git",'content':"git git module git submodule foreach git reset --hard HEAD git submodule update git submodule foreach \u0026#34;git checkout master; git pull\u0026#34; git submodule foreach git clean -f "});index.add({'id':101,'href':'/note-cs/docs/language/go/','title':"Go",'content':"Go 学习笔记 见：Go 学习笔记\n"});index.add({'id':102,'href':'/note-cs/docs/virtual/hyperkit/','title':"HyperKit",'content':"HyperKit "});index.add({'id':103,'href':'/note-cs/docs/cloud-computing/iaas/','title':"IaaS",'content':"IaaS "});index.add({'id':104,'href':'/note-cs/docs/debug/lldb/','title':"LLDB",'content':"LLDB "});index.add({'id':105,'href':'/note-cs/docs/debug/lldb/tutorial/','title':"LLDB 教程",'content':"LLDB 教程 "});index.add({'id':106,'href':'/note-cs/docs/language/python/','title':"Python",'content':"Python 见：Python 学习笔记\n"});index.add({'id':107,'href':'/note-cs/docs/language/rust/','title':"Rust",'content':"Rust 见：Rust 学习笔记\n"});index.add({'id':108,'href':'/note-cs/docs/cloud-computing/saas/crm/salesforce/','title':"Salesforce",'content':"Salesforce "});index.add({'id':109,'href':'/note-cs/docs/virtual/vmware/','title':"VMware Fusion",'content':"VMware Fusion "});index.add({'id':110,'href':'/note-cs/docs/tool/editor/vscode/debug/','title':"VSCode Debug",'content':"VSCode Debug 参考：\n  USER GUIDE - Debugging\n  Debug C++ in Visual Studio Code\n  "});index.add({'id':111,'href':'/note-cs/docs/cloud-computing/','title':"云计算",'content':"云计算 "});index.add({'id':112,'href':'/note-cs/docs/tool/dev/','title':"开发者工具",'content':"开发者工具 "});index.add({'id':113,'href':'/note-cs/docs/language/scala/basic/spec/','title':"编程规范",'content':"编程规范 "});index.add({'id':114,'href':'/note-cs/docs/os/android/basic/spec/','title':"编程规范",'content':"编程规范 "});index.add({'id':115,'href':'/note-cs/docs/os/ios/basic/spec/','title':"编程规范",'content':"编程规范 "});index.add({'id':116,'href':'/note-cs/docs/os/linux/basic/spec/','title':"编程规范",'content':"编程规范 "});index.add({'id':117,'href':'/note-cs/docs/os/macos/basic/spec/','title':"编程规范",'content':"编程规范 "});index.add({'id':118,'href':'/note-cs/docs/os/unix/basic/spec/','title':"编程规范",'content':"编程规范 "});index.add({'id':119,'href':'/note-cs/docs/os/windows/basic/spec/','title':"编程规范",'content':"编程规范 "});index.add({'id':120,'href':'/note-cs/docs/language/','title':"编程语言",'content':"编程语言 "});index.add({'id':121,'href':'/note-cs/docs/domain/onvif/discovery/','title':"设备发现",'content':"设备发现 我们传统的 Web Services 服务调用的模式都是这样的：客户端在设计时就预先知道目标服务的地址（IP 地址或者域名），客户端基于这个地址进行服务调用。\n那如果客户端预先不知道目标服务的地址该怎么办？\nWS-Discovery（全称为 Web Services Dynamic Discovery）标准就是用于解决该问题的，遵循该标准，客户端预先不知道目标服务地址的情况下，可以动态地探测到可用的目标服务，以便进行服务调用。这个过程就是「设备发现」的过程。\nWS-Discovery 模式 WS-Discovery 定义了两种模式：Ad hoc 模式和 Managed 模式。\nAd hoc 模式  Ad hoc 模式：客户端以多播 (multicast) 的形式往多播组 (multicast group) 发送一个 Probe（探测）消息搜寻目标服务，在该探测消息中，包含相应的搜寻条件。如果目标服务满足该条件，则直接将响应 ProbeMatch 消息（服务自身相关的信息，包括地址）回复给客户端。  Managed 模式  Managed 模式：即代理模式。Ad hoc 模式有个局限性，只能局限于一个较小的网络。Managed 模式就是为了解决这个问题的，在 Managed 模式下，一个维护所有可用目标服务的中心发现代理（Discovery Proxy）被建立起来，客户端只需要将探测消息发送到该发现代理就可以得到相应的目标服务信息。  官方技术规范：http://docs.oasis-open.org/ws-dd/discovery/1.1/os/wsdd-discovery-1.1-spec-os.html\n 传输方式 TCP/IP 有三种传输方式：单播 (Unicast)、多播 (Multicast) 和广播 (Broadcast)，在 IPv6 领域还有另一种方式：任播 (Anycast)。\n单播 Unicast 单播 (Unicast)：一对一，双向通信，目的地址是对方主机地址。网络上绝大部分的数据都是以单播的形式传输的。如收发邮件、浏览网页等。\n多播 Multicast 多播 (Multicast)：也叫组播，一对多，单向通信，目的地址是多播地址，主机可以通过 IGMP 协议请求加入或退出某个多播组 (multicast group)，数据只会转发给有需要（已加入组）的主机，不影响其他不需要（未加入组）的主机。如网上视频会议、网上视频点播、IPTV 等。\n多播地址（Multicast Address）有很多，各个行业都不一样，IPC 摄像头用的是 239.255.255.250（端口 3702）。\n多播地址的范围和分类可以见官方 IANA（互联网地址分配机构） 的说明：IPv4 Multicast Address Space Registry。\nWS-Discovery 协议用到了多播。\n广播 Broadcast 广播 (Broadcast)：一对所有，单向通信，目的地址是广播地址，整个网络中所有主机均可以收到（不管你是否需要），如 ARP 地址解析、GARP 数据包等。广播会被限制在局域网范围内，禁止广播数据穿过路由器，防止广播数据影响大面积的主机。\n参考：单播、多播（组播）和广播的区别\n IPC 搜索实现： 实现 socket 编程（UDP），通过 sendto 往多播地址发送探测消息（Probe），再使用 recvfrom 接收 IPC 的应答消息（ProbeMatch）\n"});index.add({'id':122,'href':'/note-cs/docs/cloud-computing/paas/','title':"PaaS",'content':"PaaS "});index.add({'id':123,'href':'/note-cs/docs/cloud-computing/saas/','title':"SaaS",'content':"SaaS "});index.add({'id':124,'href':'/note-cs/docs/cloud-computing/paas/gae/','title':"GAE",'content':"Google App Engine "});index.add({'id':125,'href':'/note-cs/docs/cloud-computing/paas/heroku/','title':"Heroku",'content':"Heroku "});index.add({'id':126,'href':'/note-cs/docs/language/objective-c/','title':"Objective-C",'content':"Objective-C 学习笔记 "});index.add({'id':127,'href':'/note-cs/docs/virtual/parallels/','title':"Parallels",'content':"Parallels "});index.add({'id':128,'href':'/note-cs/docs/language/scala/','title':"Scala",'content':"Scala 学习笔记 "});index.add({'id':129,'href':'/note-cs/docs/domain/webservice/soap/','title':"SOAP",'content':"SOAP "});index.add({'id':130,'href':'/note-cs/docs/virtual/virtualbox/','title':"VirtualBox",'content':"VirtualBox "});index.add({'id':131,'href':'/note-cs/docs/domain/webservice/','title':"Web Service",'content':"Web Service "});index.add({'id':132,'href':'/note-cs/docs/database/','title':"数据库",'content':"数据库 见：数据库学习笔记\n"});index.add({'id':133,'href':'/note-cs/docs/language/scala/basic/practice/','title':"最佳实践",'content':"Scala 最佳实践 "});index.add({'id':134,'href':'/note-cs/docs/os/android/basic/practice/','title':"最佳实践",'content':"最佳实践 "});index.add({'id':135,'href':'/note-cs/docs/os/ios/basic/practice/','title':"最佳实践",'content':"最佳实践 "});index.add({'id':136,'href':'/note-cs/docs/os/linux/basic/practice/','title':"最佳实践",'content':"最佳实践 "});index.add({'id':137,'href':'/note-cs/docs/os/macos/basic/practice/','title':"最佳实践",'content':"最佳实践 "});index.add({'id':138,'href':'/note-cs/docs/os/unix/basic/practice/','title':"最佳实践",'content':"最佳实践 "});index.add({'id':139,'href':'/note-cs/docs/os/windows/basic/practice/','title':"最佳实践",'content':"最佳实践 "});index.add({'id':140,'href':'/note-cs/docs/debug/','title':"Debug",'content':"Debug "});index.add({'id':141,'href':'/note-cs/docs/cloud-computing/paas/openshift/','title':"OpenShift",'content':"OpenShift Red Hat OpenShift is a leading hybrid cloud, enterprise Kubernetes application platform. OpenShift 在 Kubernetes 的基础上整合了应用的生命周期管理，包括 image 的编译，持续集成，部署以及更新。\nOpenshift 以前是 IaaS，现在 Openshift 自己宣称自己搭配 LXC 已经是 PaaS 了，VPS 不是云服务但可以类比为 IaaS。\nOpenshift 没有 root 权限 参考：openshift 和普通 vps 的区别在哪儿？\n"});index.add({'id':142,'href':'/note-cs/docs/language/scala/basic/snippet/','title':"代码片段",'content':"代码片段 "});index.add({'id':143,'href':'/note-cs/docs/os/android/basic/snippet/','title':"代码片段",'content':"代码片段 "});index.add({'id':144,'href':'/note-cs/docs/os/ios/basic/snippet/','title':"代码片段",'content':"代码片段 "});index.add({'id':145,'href':'/note-cs/docs/os/linux/basic/snippet/','title':"代码片段",'content':"代码片段 "});index.add({'id':146,'href':'/note-cs/docs/os/macos/basic/snippet/','title':"代码片段",'content':"代码片段 "});index.add({'id':147,'href':'/note-cs/docs/os/unix/basic/snippet/','title':"代码片段",'content':"代码片段 "});index.add({'id':148,'href':'/note-cs/docs/os/windows/basic/snippet/','title':"代码片段",'content':"代码片段 "});index.add({'id':149,'href':'/note-cs/docs/language/scala/basic/practice/baidu/','title':"百度",'content':"百度 Scala 最佳实践 "});index.add({'id':150,'href':'/note-cs/docs/virtual/','title':"虚拟化",'content':"虚拟化 "});index.add({'id':151,'href':'/note-cs/docs/cloud-computing/paas/cloud-foundry/','title':"Cloud Foundry",'content':"Cloud Foundry "});index.add({'id':152,'href':'/note-cs/docs/cloud-computing/paas/appfog/','title':"AppFog",'content':"AppFog "});index.add({'id':153,'href':'/note-cs/docs/study/coding-online/','title':"在线编程",'content':"在线编程 "});index.add({'id':154,'href':'/note-cs/docs/study/','title':"学习",'content':"计算机学习 "});index.add({'id':155,'href':'/note-cs/docs/tool/','title':"工具",'content':"工具 "});index.add({'id':156,'href':'/note-cs/docs/tool/editor/','title':"编辑器",'content':"编辑器 "});index.add({'id':157,'href':'/note-cs/docs/domain/lorawan/','title':"LoRaWan",'content':"LoRaWan "});index.add({'id':158,'href':'/note-cs/docs/domain/onvif/','title':"ONVIF",'content':"ONVIF 官网：www.onvif.org\n"});index.add({'id':159,'href':'/note-cs/docs/domain/','title':"领域",'content':"领域 "});index.add({'id':160,'href':'/note-cs/categories/','title':"Categories",'content':""});index.add({'id':161,'href':'/note-cs/docs/','title':"Docs",'content':""});index.add({'id':162,'href':'/note-cs/tags/','title':"Tags",'content':""});index.add({'id':163,'href':'/note-cs/','title':"首页",'content':""});})();