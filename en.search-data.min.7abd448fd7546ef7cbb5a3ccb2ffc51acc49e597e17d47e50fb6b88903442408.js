'use strict';(function(){const indexCfg={cache:true};indexCfg.doc={id:'id',field:['title','content'],store:['title','href'],};const index=FlexSearch.create('balance',indexCfg);window.bookSearchIndex=index;index.add({'id':0,'href':'/note-cs/docs/basic/computer-composition/','title':"1.1 计算机组成原理",'content':"计算机组成原理 "});index.add({'id':1,'href':'/note-cs/docs/others/tool/dev/github/','title':"GitHub",'content':"GitHub shields.io 如： tholman/github-corners  http://tholman.com/github-corners/\n如： "});index.add({'id':2,'href':'/note-cs/docs/basic/os/linux/','title':"Linux",'content':"Linux 见：Linux 学习笔记\n"});index.add({'id':3,'href':'/note-cs/docs/others/tool/dev/vscode/','title':"VSCode",'content':"VSCode 推荐插件 PicGo/vs-picgo https://github.com/PicGo/vs-picgo\n"});index.add({'id':4,'href':'/note-cs/docs/basic/language/objective-c/appendix/tutorial/','title':"教程",'content':"教程 基础 进阶 高阶 "});index.add({'id':5,'href':'/note-cs/docs/basic/language/scala/appendix/tutorial/','title':"教程",'content':"教程 基础 进阶 高阶 "});index.add({'id':6,'href':'/note-cs/docs/basic/os/android/appendix/tutorial/','title':"教程",'content':"教程 基础 进阶 高阶 "});index.add({'id':7,'href':'/note-cs/docs/basic/os/ios/appendix/tutorial/','title':"教程",'content':"教程 基础 进阶 高阶 "});index.add({'id':8,'href':'/note-cs/docs/basic/os/macos/appendix/tutorial/','title':"教程",'content':"教程 基础 进阶 高阶 "});index.add({'id':9,'href':'/note-cs/docs/basic/os/unix/appendix/tutorial/','title':"教程",'content':"教程 基础 进阶 高阶 "});index.add({'id':10,'href':'/note-cs/docs/basic/os/windows/appendix/tutorial/','title':"教程",'content':"教程 基础 进阶 高阶 "});index.add({'id':11,'href':'/note-cs/docs/direction/client/android/appendix/tutorial/','title':"教程",'content':"教程 基础 进阶 高阶 "});index.add({'id':12,'href':'/note-cs/docs/direction/client/ios/appendix/tutorial/','title':"教程",'content':"教程 基础 进阶 高阶 "});index.add({'id':13,'href':'/note-cs/docs/direction/client/xiaochengxu/appendix/tutorial/','title':"教程",'content':"教程 基础 进阶 高阶 "});index.add({'id':14,'href':'/note-cs/docs/basic/language/objective-c/basic/practice/','title':"最佳实践",'content':"最佳实践 "});index.add({'id':15,'href':'/note-cs/docs/direction/client/android/basic/practice/','title':"最佳实践",'content':"最佳实践 "});index.add({'id':16,'href':'/note-cs/docs/direction/client/ios/basic/practice/','title':"最佳实践",'content':"最佳实践 "});index.add({'id':17,'href':'/note-cs/docs/direction/client/xiaochengxu/basic/practice/','title':"最佳实践",'content':"最佳实践 "});index.add({'id':18,'href':'/note-cs/docs/basic/language/objective-c/basic/practice/spec/baidu/','title':"百度",'content':"百度 Objective-C 编码规范 (2019 版) "});index.add({'id':19,'href':'/note-cs/docs/basic/','title':"第一部分 基础",'content':""});index.add({'id':20,'href':'/note-cs/docs/basic/language/objective-c/basic/','title':"第一部分 基础入门",'content':""});index.add({'id':21,'href':'/note-cs/docs/basic/language/scala/basic/','title':"第一部分 基础入门",'content':""});index.add({'id':22,'href':'/note-cs/docs/basic/os/android/basic/','title':"第一部分 基础入门",'content':""});index.add({'id':23,'href':'/note-cs/docs/basic/os/ios/basic/','title':"第一部分 基础入门",'content':""});index.add({'id':24,'href':'/note-cs/docs/basic/os/macos/basic/','title':"第一部分 基础入门",'content':""});index.add({'id':25,'href':'/note-cs/docs/basic/os/unix/basic/','title':"第一部分 基础入门",'content':""});index.add({'id':26,'href':'/note-cs/docs/basic/os/windows/basic/','title':"第一部分 基础入门",'content':""});index.add({'id':27,'href':'/note-cs/docs/direction/client/android/basic/','title':"第一部分 基础入门",'content':""});index.add({'id':28,'href':'/note-cs/docs/direction/client/ios/basic/','title':"第一部分 基础入门",'content':""});index.add({'id':29,'href':'/note-cs/docs/direction/client/xiaochengxu/basic/','title':"第一部分 基础入门",'content':""});index.add({'id':30,'href':'/note-cs/docs/basic/language/objective-c/basic/practice/spec/','title':"编程规范",'content':"编程规范 "});index.add({'id':31,'href':'/note-cs/docs/direction/client/android/basic/practice/spec/','title':"编程规范",'content':"编程规范 "});index.add({'id':32,'href':'/note-cs/docs/direction/client/ios/basic/practice/spec/','title':"编程规范",'content':"编程规范 "});index.add({'id':33,'href':'/note-cs/docs/direction/client/xiaochengxu/basic/practice/spec/','title':"编程规范",'content':"编程规范 "});index.add({'id':34,'href':'/note-cs/docs/basic/os/','title':"1.2 操作系统",'content':"操作系统 "});index.add({'id':35,'href':'/note-cs/docs/basic/compile/make/makefile/','title':"makefile",'content':"makefile 简介 Makefile 用于定义如何创建目标文件，比如如何从源码到可执行文件。创建这一工具的目标是 减少不必要的编译或者任务。传说 Stuart Feldman 在 1976 年花了一个周末写出来的， 而今仍然使用广泛，特别是在 Unix 和 Linux 系统上。\n基础 语法  注释：# 文件名： 必须是 Makefile  区分大小写   make \u0026lt;target\u0026gt; 生成 target  重命名：make -f \u0026quot;filename\u0026quot; \u0026lt;target\u0026gt;   只认识 TAB，不认识空格  但是在 GNU Make 3.82 之后, 可以通过设置参数 .RECIPEPREFIX 进行修改   shell 符号  @：不把命令打印到 stdout -：发生错误了也没关系    target 声明  创建一个 target： targets : prerequisites recipe  prerequisites(依赖) 是可选的, recipe(做法) 也可以多个或者不给 targets 和 prerequisites 都可以是多个, 以空格分割 file2.txt file3.txt: file0.txt file1.txt touch file2.txt touch file3.txt    target 的声明顺序并不重要  上面的依赖可以下面再声明   如果声明重复的 target，make 会给一个 warning，后面会覆盖前面的  但是如果不定义任何 recipe, 就不会冲突, 只是多了依赖关系 file2.txt: file0.txt file3.txt    Phony(假的) Targets  意思是 tagets 并不是文件, 可以想象成一个任务的名字而已 因为不是文件, 无法比对是否有更新, 所以每次 make 都会执行 依赖于 phony target 的 target 也会每次 make 都执行, 即使 target 是文件   .PHONY  如果定义的 phony target 与文件名重名, 可以用 .PHONY 显式地指明哪些 targets 是 phony    常用 phony target  all clean install uninstall  变量与通配符  $^: 代表 prerequisites # 即便分开定义依赖, $^ 依然能拿到 # 非常智能的, ex1.txt 会被找到, file0.txt 会被去重 process: ex1.txt file0.txt @echo $^  $@: 代表 target, 如果 target 为多个, $@ 代表当前执行的那个 $\u0026lt;: prerequisite 中的第一个 $?: 需要更新的 prerequisite 文件列表 $+: 所有依赖, 包括重复的 $|: 竖线后面的 order-only prerequisites $*: target % 那部分, 包括路径 a.%.b: # $* match 的target % 那部分, 包括路径, 比如 `make dir/a.foo.b` 会打出 `dir/foo` @echo $*   模式匹配  make 会找到最具体的匹配  make small/foo.png 则会匹配下面这个规则（在这之前要先有 small/foo.svg 这个文件） %.png: %.svg inkscape --export-png $^ small/%.png: %.svg inkscape --export-png --export-dpi 30 $^    make 已经有一些内置的规则, 比如从 *.c 到 *.o  变量   变量都是字符串类型\n# 这俩是一样一样的 name = Ted name2=\u0026#34;Sarah\u0026#34;   设置变量，按以下顺序由高到低:\n 命令行参数. 比如试试 make echo name3=JICHAO Makefile 里面的 shell 中的环境变量 make 预设的一些变量    ?=\n# 如果 name 被设置过了, 就不设置了 name ?= Jean   override\n# 用 override 可以防止命令行参数设置的覆盖 override name = David ``   +\n# 用加号可以连接 (中间用空格分割) name4 +=grey   内置的变量\necho_inbuilt: echo $(CC) echo ${CXX)} echo $(FC) echo ${CFLAGS)} echo $(CPPFLAGS) echo ${CXXFLAGS} echo $(LDFLAGS) echo ${LDLIBS}   :=\n 等号声明时 recursively expanded 递归扩展 加个冒号可以声明 Simply expanded variables 即时扩展变量, 即只在声明时扩展一次  # var3 声明时找不到 var4, var3 会扩展成 `and good luck`，直接忽视 var4 var3 := $(var4) and good luck # var5 是正常的，扩展为 `good night and good luck` var5 = $(var4) and good luck var4 := good night   函数   函数调用格式\n$(func arg0,arg1,arg2...)   wildcard：将后面的通配符变成一串文件路径\n  patsubst：做替换\n# 把所有 markdown 后缀的文件重命名为 md 后缀 substitue: * @echo $(patsubst %.markdown,%.md,$* $^)   指令  include：引入别的 Makefile 文件 流程控制语句顶格写 sport = tennis # 流程控制语句 (如if else 等等) 顶格写 report: ifeq ($(sport),tennis) @echo \u0026#39;game, set, match\u0026#39; else @echo \u0026#34;They think it\u0026#39;s all over; it is now\u0026#34; endif    分支和变体 GNU make  进阶  原理 "});index.add({'id':36,'href':'/note-cs/docs/basic/language/objective-c/appendix/interview/basic/','title':"基础",'content':"基础面试题 "});index.add({'id':37,'href':'/note-cs/docs/basic/language/scala/appendix/interview/basic/','title':"基础",'content':"基础面试题 "});index.add({'id':38,'href':'/note-cs/docs/basic/os/android/appendix/interview/basic/','title':"基础",'content':"基础面试题 "});index.add({'id':39,'href':'/note-cs/docs/basic/os/ios/appendix/interview/basic/','title':"基础",'content':"基础面试题 "});index.add({'id':40,'href':'/note-cs/docs/basic/os/macos/appendix/interview/basic/','title':"基础",'content':"基础面试题 "});index.add({'id':41,'href':'/note-cs/docs/basic/os/unix/appendix/interview/basic/','title':"基础",'content':"基础面试题 "});index.add({'id':42,'href':'/note-cs/docs/basic/os/windows/appendix/interview/basic/','title':"基础",'content':"基础面试题 "});index.add({'id':43,'href':'/note-cs/docs/direction/client/android/appendix/interview/basic/','title':"基础",'content':"基础面试题 "});index.add({'id':44,'href':'/note-cs/docs/direction/client/ios/appendix/interview/basic/','title':"基础",'content':"基础面试题 "});index.add({'id':45,'href':'/note-cs/docs/direction/client/xiaochengxu/appendix/interview/basic/','title':"基础",'content':"基础面试题 "});index.add({'id':46,'href':'/note-cs/docs/basic/language/objective-c/priciple/','title':"第二部分 原理",'content':""});index.add({'id':47,'href':'/note-cs/docs/basic/language/scala/priciple/','title':"第二部分 原理",'content':""});index.add({'id':48,'href':'/note-cs/docs/basic/os/android/priciple/','title':"第二部分 原理",'content':""});index.add({'id':49,'href':'/note-cs/docs/basic/os/ios/priciple/','title':"第二部分 原理",'content':""});index.add({'id':50,'href':'/note-cs/docs/basic/os/macos/priciple/','title':"第二部分 原理",'content':""});index.add({'id':51,'href':'/note-cs/docs/basic/os/unix/priciple/','title':"第二部分 原理",'content':""});index.add({'id':52,'href':'/note-cs/docs/basic/os/windows/priciple/','title':"第二部分 原理",'content':""});index.add({'id':53,'href':'/note-cs/docs/direction/','title':"第二部分 方向",'content':""});index.add({'id':54,'href':'/note-cs/docs/direction/client/android/design/','title':"第二部分 设计",'content':""});index.add({'id':55,'href':'/note-cs/docs/direction/client/ios/design/','title':"第二部分 设计",'content':""});index.add({'id':56,'href':'/note-cs/docs/direction/client/xiaochengxu/design/','title':"第二部分 设计",'content':""});index.add({'id':57,'href':'/note-cs/docs/basic/language/objective-c/appendix/interview/advanced/','title':"进阶",'content':"进阶面试题 "});index.add({'id':58,'href':'/note-cs/docs/basic/language/scala/appendix/interview/advanced/','title':"进阶",'content':"进阶面试题 "});index.add({'id':59,'href':'/note-cs/docs/basic/os/android/appendix/interview/advanced/','title':"进阶",'content':"进阶面试题 "});index.add({'id':60,'href':'/note-cs/docs/basic/os/ios/appendix/interview/advanced/','title':"进阶",'content':"进阶面试题 "});index.add({'id':61,'href':'/note-cs/docs/basic/os/macos/appendix/interview/advanced/','title':"进阶",'content':"进阶面试题 "});index.add({'id':62,'href':'/note-cs/docs/basic/os/unix/appendix/interview/advanced/','title':"进阶",'content':"进阶面试题 "});index.add({'id':63,'href':'/note-cs/docs/basic/os/windows/appendix/interview/advanced/','title':"进阶",'content':"进阶面试题 "});index.add({'id':64,'href':'/note-cs/docs/direction/client/android/appendix/interview/advanced/','title':"进阶",'content':"进阶面试题 "});index.add({'id':65,'href':'/note-cs/docs/direction/client/ios/appendix/interview/advanced/','title':"进阶",'content':"进阶面试题 "});index.add({'id':66,'href':'/note-cs/docs/direction/client/xiaochengxu/appendix/interview/advanced/','title':"进阶",'content':"进阶面试题 "});index.add({'id':67,'href':'/note-cs/docs/basic/language/objective-c/appendix/interview/','title':"面试题",'content':"面试题 基础题 进阶题 高阶题 "});index.add({'id':68,'href':'/note-cs/docs/basic/language/scala/appendix/interview/','title':"面试题",'content':"面试题 基础题 进阶题 高阶题 "});index.add({'id':69,'href':'/note-cs/docs/basic/os/android/appendix/interview/','title':"面试题",'content':"面试题 基础题 进阶题 高阶题 "});index.add({'id':70,'href':'/note-cs/docs/basic/os/ios/appendix/interview/','title':"面试题",'content':"面试题 基础题 进阶题 高阶题 "});index.add({'id':71,'href':'/note-cs/docs/basic/os/macos/appendix/interview/','title':"面试题",'content':"面试题 基础题 进阶题 高阶题 "});index.add({'id':72,'href':'/note-cs/docs/basic/os/unix/appendix/interview/','title':"面试题",'content':"面试题 基础题 进阶题 高阶题 "});index.add({'id':73,'href':'/note-cs/docs/basic/os/windows/appendix/interview/','title':"面试题",'content':"面试题 基础题 进阶题 高阶题 "});index.add({'id':74,'href':'/note-cs/docs/direction/client/android/appendix/interview/','title':"面试题",'content':"面试题 基础题 进阶题 高阶题 "});index.add({'id':75,'href':'/note-cs/docs/direction/client/ios/appendix/interview/','title':"面试题",'content':"面试题 基础题 进阶题 高阶题 "});index.add({'id':76,'href':'/note-cs/docs/direction/client/xiaochengxu/appendix/interview/','title':"面试题",'content':"面试题 基础题 进阶题 高阶题 "});index.add({'id':77,'href':'/note-cs/docs/basic/data-structure/','title':"1.3 数据结构",'content':"数据结构 见：算法学习笔记\n"});index.add({'id':78,'href':'/note-cs/docs/basic/compile/make/cmake/','title':"cmake",'content':"cmake "});index.add({'id':79,'href':'/note-cs/docs/basic/os/macos/','title':"MacOS",'content':"MacOS "});index.add({'id':80,'href':'/note-cs/docs/basic/os/windows/','title':"Windows",'content':"Windows "});index.add({'id':81,'href':'/note-cs/docs/basic/language/objective-c/source/','title':"第三部分 源码实现",'content':""});index.add({'id':82,'href':'/note-cs/docs/basic/language/scala/source/','title':"第三部分 源码实现",'content':""});index.add({'id':83,'href':'/note-cs/docs/basic/os/android/source/','title':"第三部分 源码实现",'content':""});index.add({'id':84,'href':'/note-cs/docs/basic/os/ios/source/','title':"第三部分 源码实现",'content':""});index.add({'id':85,'href':'/note-cs/docs/basic/os/macos/source/','title':"第三部分 源码实现",'content':""});index.add({'id':86,'href':'/note-cs/docs/basic/os/unix/source/','title':"第三部分 源码实现",'content':""});index.add({'id':87,'href':'/note-cs/docs/basic/os/windows/source/','title':"第三部分 源码实现",'content':""});index.add({'id':88,'href':'/note-cs/docs/direction/client/android/source/','title':"第三部分 源码实现",'content':""});index.add({'id':89,'href':'/note-cs/docs/direction/client/ios/source/','title':"第三部分 源码实现",'content':""});index.add({'id':90,'href':'/note-cs/docs/direction/client/xiaochengxu/source/','title':"第三部分 源码实现",'content':""});index.add({'id':91,'href':'/note-cs/docs/domain/','title':"第三部分 领域",'content':""});index.add({'id':92,'href':'/note-cs/docs/basic/language/objective-c/appendix/interview/expert/','title':"高阶",'content':"高阶面试题 "});index.add({'id':93,'href':'/note-cs/docs/basic/language/scala/appendix/interview/expert/','title':"高阶",'content':"高阶面试题 "});index.add({'id':94,'href':'/note-cs/docs/basic/os/android/appendix/interview/expert/','title':"高阶",'content':"高阶面试题 "});index.add({'id':95,'href':'/note-cs/docs/basic/os/ios/appendix/interview/expert/','title':"高阶",'content':"高阶面试题 "});index.add({'id':96,'href':'/note-cs/docs/basic/os/macos/appendix/interview/expert/','title':"高阶",'content':"高阶面试题 "});index.add({'id':97,'href':'/note-cs/docs/basic/os/unix/appendix/interview/expert/','title':"高阶",'content':"高阶面试题 "});index.add({'id':98,'href':'/note-cs/docs/basic/os/windows/appendix/interview/expert/','title':"高阶",'content':"高阶面试题 "});index.add({'id':99,'href':'/note-cs/docs/direction/client/android/appendix/interview/expert/','title':"高阶",'content':"高阶面试题 "});index.add({'id':100,'href':'/note-cs/docs/direction/client/ios/appendix/interview/expert/','title':"高阶",'content':"高阶面试题 "});index.add({'id':101,'href':'/note-cs/docs/direction/client/xiaochengxu/appendix/interview/expert/','title':"高阶",'content':"高阶面试题 "});index.add({'id':102,'href':'/note-cs/docs/basic/network/','title':"1.4 计算机网络",'content':"计算机网络 见：网络学习笔记\n"});index.add({'id':103,'href':'/note-cs/docs/basic/os/unix/','title':"Unix",'content':"Unix "});index.add({'id':104,'href':'/note-cs/docs/others/','title':"第四部分 其他",'content':""});index.add({'id':105,'href':'/note-cs/docs/basic/language/objective-c/appendix/','title':"第四部分 附录",'content':""});index.add({'id':106,'href':'/note-cs/docs/basic/language/scala/appendix/','title':"第四部分 附录",'content':""});index.add({'id':107,'href':'/note-cs/docs/basic/os/android/appendix/','title':"第四部分 附录",'content':""});index.add({'id':108,'href':'/note-cs/docs/basic/os/ios/appendix/','title':"第四部分 附录",'content':""});index.add({'id':109,'href':'/note-cs/docs/basic/os/macos/appendix/','title':"第四部分 附录",'content':""});index.add({'id':110,'href':'/note-cs/docs/basic/os/unix/appendix/','title':"第四部分 附录",'content':""});index.add({'id':111,'href':'/note-cs/docs/basic/os/windows/appendix/','title':"第四部分 附录",'content':""});index.add({'id':112,'href':'/note-cs/docs/direction/client/android/appendix/','title':"第四部分 附录",'content':""});index.add({'id':113,'href':'/note-cs/docs/direction/client/ios/appendix/','title':"第四部分 附录",'content':""});index.add({'id':114,'href':'/note-cs/docs/direction/client/xiaochengxu/appendix/','title':"第四部分 附录",'content':""});index.add({'id':115,'href':'/note-cs/docs/others/skill/debug/gdb/','title':"GDB",'content':"GDB "});index.add({'id':116,'href':'/note-cs/docs/basic/compile/make/','title':"make",'content':"make 教程  learn make in y minutes 跟我一起写 Makefile GNU make manual  "});index.add({'id':117,'href':'/note-cs/docs/basic/language/objective-c/basic/practice/snippet/','title':"代码片段",'content':"代码片段 "});index.add({'id':118,'href':'/note-cs/docs/direction/client/android/basic/practice/snippet/','title':"代码片段",'content':"代码片段 "});index.add({'id':119,'href':'/note-cs/docs/direction/client/ios/basic/practice/snippet/','title':"代码片段",'content':"代码片段 "});index.add({'id':120,'href':'/note-cs/docs/direction/client/xiaochengxu/basic/practice/snippet/','title':"代码片段",'content':"代码片段 "});index.add({'id':121,'href':'/note-cs/docs/others/tool/dev/vscode/shortcuts/','title':"快捷键",'content':"VScode 快捷键 MacOS  选择  选中所有同一个词：cmd + shift + L  编辑  格式化：opt + shift + f  Windows  选择  选中所有同一个词：ctrl + shift + L   "});index.add({'id':122,'href':'/note-cs/docs/basic/language/scala/basic/spec/baidu/','title':"百度",'content':"百度 Scala 编码规范 前言 就目前 Baidu 内部情况 (2018.10)，Scala 这门语言主要用于计算团队内部的和 Spark 相关项目研发、社区贡献工作以及公司的 Spark 用户使用 Scala API 编写 Spark 作业三个用途，所以本文主体沿用如下两部分并稍作修改：\n Apache Spark 开源社区 Scala 编程指南:\nApache Spark 有超过 1000 位贡献者，就我们所知，应该是目前大数据领域里最大的开源项目且是最活跃的 Scala 项目，结合 Baidu 内部现状，本文主体沿用此部分中和 Spark 社区相关内容，去除部分项目专用细节。 scala 官方 style guide 里的格式部分已包含在 Spark 项目文档中，这里摘录部分官方 style guide 作为 Apache Spark 社区的编程指南补充。  "});index.add({'id':123,'href':'/note-cs/docs/others/tool/study/tutorial/','title':"编程学习网站",'content':"编程学习网站 基础 Codecademy Programiz  算法 Codewars  进阶 Codeplace 通过实际应用来学习编程。\n"});index.add({'id':124,'href':'/note-cs/docs/basic/os/ios/','title':"iOS",'content':"iOS "});index.add({'id':125,'href':'/note-cs/docs/basic/compile/','title':"1.5 编译原理",'content':"编译原理 "});index.add({'id':126,'href':'/note-cs/docs/direction/backend/','title':"2.1 后端",'content':"后端开发 见：后端开发学习笔记\n"});index.add({'id':127,'href':'/note-cs/docs/domain/cloud-computing/','title':"3.1 云计算",'content':"云计算 "});index.add({'id':128,'href':'/note-cs/docs/others/skill/','title':"4.1 技能树",'content':"技能树 "});index.add({'id':129,'href':'/note-cs/docs/basic/os/android/','title':"Android",'content':"Android "});index.add({'id':130,'href':'/note-cs/docs/direction/client/android/','title':"Android",'content':"Android "});index.add({'id':131,'href':'/note-cs/docs/direction/architecture/cap/','title':"CAP",'content':"CAP P 是前提 在理论计算机科学中，CAP 定理（CAP theorem），又被称作布鲁尔定理（Brewer's theorem），它指出对于一个distributed data store 来说，不可能同时满足以下三点：\n 一致性（Consistency）  每次读取要么获得最近写入的数据，要么获得一个错误。   可用性（Availability）  每次请求都能获得一个非错误响应，但不保证返回的是最新写入的数据。   分区容错性（Partition tolerance）  以实际效果而言，分区相当于对通信的时限要求。系统如果不能在时限内达成数据一致性，就意味着发生了分区的情况，必须就当前操作在 C 和 A 之间做出选择。 尽管任意数量的消息被节点间的网络丢失（或延迟），系统仍继续运行。    一般选 AP 也就是说，在存在网络分区的情况下，一致性和可用性必须二选一。\n比如：A 服务器 B 服务器同步数据，现在 A B 之间网络断掉了，那么现在发来 A 一个写入请求，但是 B 却没有相关的请求，显然，\n 如果 A 不写，保持一致性，那么我们就失去了 A 的服务， 但是如果 A 写了，跟 B 的数据就不一致了，我们自然就丧失了一致性。  这里的一致性（Consistency）是强一致性，意思是 AB 的数据时刻都是同步的，\n如果我们放弃了强一致性，不代表我们的数据就是一定是不一致的了，我们可以让 A 先写入本地，等到通信恢复了再同步给 B，这就是所谓的最终一致性，长远的看我们的数据还是一致的，我们只是在某一个时间窗口里数据不一致罢了。\n如果这个时间窗口小过了用户逻辑处理的时间。那么其实对于用户来说根本感觉不到。\n现实中的 CAP CAP 对实际工作缺乏指导性。\n实际系统主要有三种：\n 强调 availability 的 eventual consistency 系统，  比如 Amazon Dynamo 及他们的复制品；   强调一致性的系统，  典型的是基于 Paxos 的系统；   强调性能不顾其他的系统，  典型的是 Async replication 的主从备份系统。    参考  CAP 理论常被解释为一种 “三选二” 定律，这是否是一种误解？ 分布式事务中的最终一致具体应该如何实现？ 分布式系统中的数据一致性和性能怎么权衡？ 如何浅显易懂地解说 Paxos 的算法？  "});index.add({'id':132,'href':'/note-cs/docs/domain/cloud-computing/saas/crm/','title':"CRM",'content':"CRM "});index.add({'id':133,'href':'/note-cs/docs/others/skill/debug/gdb/tutorial/','title':"GDB 教程",'content':"GDB 教程 "});index.add({'id':134,'href':'/note-cs/docs/others/tool/dev/git/','title':"git",'content':"git git module git submodule foreach git reset --hard HEAD git submodule update git submodule foreach \u0026#34;git checkout master; git pull\u0026#34; git submodule foreach git clean -f "});index.add({'id':135,'href':'/note-cs/docs/basic/language/go/','title':"Go",'content':"Go 学习笔记 见：Go 学习笔记\n"});index.add({'id':136,'href':'/note-cs/docs/domain/cloud-computing/virtual/hyperkit/','title':"HyperKit",'content':"HyperKit "});index.add({'id':137,'href':'/note-cs/docs/domain/cloud-computing/iaas/','title':"IaaS",'content':"IaaS "});index.add({'id':138,'href':'/note-cs/docs/others/skill/debug/lldb/','title':"LLDB",'content':"LLDB "});index.add({'id':139,'href':'/note-cs/docs/others/skill/debug/lldb/tutorial/','title':"LLDB 教程",'content':"LLDB 教程 "});index.add({'id':140,'href':'/note-cs/docs/direction/architecture/paxos/','title':"Paxos",'content':"Paxos "});index.add({'id':141,'href':'/note-cs/docs/basic/language/python/','title':"Python",'content':"Python 见：Python 学习笔记\n"});index.add({'id':142,'href':'/note-cs/docs/basic/language/rust/','title':"Rust",'content':"Rust 见：Rust 学习笔记\n"});index.add({'id':143,'href':'/note-cs/docs/domain/cloud-computing/saas/crm/salesforce/','title':"Salesforce",'content':"Salesforce "});index.add({'id':144,'href':'/note-cs/docs/domain/cloud-computing/virtual/vmware/','title':"VMware Fusion",'content':"VMware Fusion "});index.add({'id':145,'href':'/note-cs/docs/others/tool/dev/vscode/debug/','title':"VSCode Debug",'content':"VSCode Debug 参考：\n  USER GUIDE - Debugging\n  Debug C++ in Visual Studio Code\n  "});index.add({'id':146,'href':'/note-cs/docs/others/tool/recommend/','title':"推荐软件",'content':"推荐软件 MacOS  开发 iTerm Keyboard Maestro  参考  jaywcjlove/awesome-mac   Windows  todo iOS  todo Android  todo Linux  todo  "});index.add({'id':147,'href':'/note-cs/docs/basic/language/scala/basic/spec/','title':"编程规范",'content':"编程规范 "});index.add({'id':148,'href':'/note-cs/docs/basic/os/android/basic/spec/','title':"编程规范",'content':"编程规范 "});index.add({'id':149,'href':'/note-cs/docs/basic/os/ios/basic/spec/','title':"编程规范",'content':"编程规范 "});index.add({'id':150,'href':'/note-cs/docs/basic/os/macos/basic/spec/','title':"编程规范",'content':"编程规范 "});index.add({'id':151,'href':'/note-cs/docs/basic/os/unix/basic/spec/','title':"编程规范",'content':"编程规范 "});index.add({'id':152,'href':'/note-cs/docs/basic/os/windows/basic/spec/','title':"编程规范",'content':"编程规范 "});index.add({'id':153,'href':'/note-cs/docs/others/tool/study/','title':"计算机学习",'content':"计算机学习 "});index.add({'id':154,'href':'/note-cs/docs/others/skill/onvif/discovery/','title':"设备发现",'content':"设备发现 我们传统的 Web Services 服务调用的模式都是这样的：客户端在设计时就预先知道目标服务的地址（IP 地址或者域名），客户端基于这个地址进行服务调用。\n那如果客户端预先不知道目标服务的地址该怎么办？\nWS-Discovery（全称为 Web Services Dynamic Discovery）标准就是用于解决该问题的，遵循该标准，客户端预先不知道目标服务地址的情况下，可以动态地探测到可用的目标服务，以便进行服务调用。这个过程就是「设备发现」的过程。\nWS-Discovery 模式 WS-Discovery 定义了两种模式：Ad hoc 模式和 Managed 模式。\nAd hoc 模式  Ad hoc 模式：客户端以多播 (multicast) 的形式往多播组 (multicast group) 发送一个 Probe（探测）消息搜寻目标服务，在该探测消息中，包含相应的搜寻条件。如果目标服务满足该条件，则直接将响应 ProbeMatch 消息（服务自身相关的信息，包括地址）回复给客户端。  Managed 模式  Managed 模式：即代理模式。Ad hoc 模式有个局限性，只能局限于一个较小的网络。Managed 模式就是为了解决这个问题的，在 Managed 模式下，一个维护所有可用目标服务的中心发现代理（Discovery Proxy）被建立起来，客户端只需要将探测消息发送到该发现代理就可以得到相应的目标服务信息。  官方技术规范：http://docs.oasis-open.org/ws-dd/discovery/1.1/os/wsdd-discovery-1.1-spec-os.html\n 传输方式 TCP/IP 有三种传输方式：单播 (Unicast)、多播 (Multicast) 和广播 (Broadcast)，在 IPv6 领域还有另一种方式：任播 (Anycast)。\n单播 Unicast 单播 (Unicast)：一对一，双向通信，目的地址是对方主机地址。网络上绝大部分的数据都是以单播的形式传输的。如收发邮件、浏览网页等。\n多播 Multicast 多播 (Multicast)：也叫组播，一对多，单向通信，目的地址是多播地址，主机可以通过 IGMP 协议请求加入或退出某个多播组 (multicast group)，数据只会转发给有需要（已加入组）的主机，不影响其他不需要（未加入组）的主机。如网上视频会议、网上视频点播、IPTV 等。\n多播地址（Multicast Address）有很多，各个行业都不一样，IPC 摄像头用的是 239.255.255.250（端口 3702）。\n多播地址的范围和分类可以见官方 IANA（互联网地址分配机构） 的说明：IPv4 Multicast Address Space Registry。\nWS-Discovery 协议用到了多播。\n广播 Broadcast 广播 (Broadcast)：一对所有，单向通信，目的地址是广播地址，整个网络中所有主机均可以收到（不管你是否需要），如 ARP 地址解析、GARP 数据包等。广播会被限制在局域网范围内，禁止广播数据穿过路由器，防止广播数据影响大面积的主机。\n参考：单播、多播（组播）和广播的区别\n IPC 搜索实现： 实现 socket 编程（UDP），通过 sendto 往多播地址发送探测消息（Probe），再使用 recvfrom 接收 IPC 的应答消息（ProbeMatch）\n"});index.add({'id':155,'href':'/note-cs/docs/domain/cloud-computing/paas/','title':"PaaS",'content':"PaaS "});index.add({'id':156,'href':'/note-cs/docs/domain/cloud-computing/saas/','title':"SaaS",'content':"SaaS "});index.add({'id':157,'href':'/note-cs/docs/basic/language/','title':"1.6 编程语言",'content':"编程语言 "});index.add({'id':158,'href':'/note-cs/docs/domain/cloud-computing/paas/gae/','title':"GAE",'content':"Google App Engine "});index.add({'id':159,'href':'/note-cs/docs/others/tool/dev/','title':"开发者工具",'content':"开发者工具 "});index.add({'id':160,'href':'/note-cs/docs/basic/database/','title':"1.7 数据库",'content':"数据库 见：数据库学习笔记\n"});index.add({'id':161,'href':'/note-cs/docs/direction/frontend/','title':"2.2 前端",'content':"前端开发 见：前端开发学习笔记\n"});index.add({'id':162,'href':'/note-cs/docs/domain/bigdata/','title':"3.2 大数据",'content':"大数据 "});index.add({'id':163,'href':'/note-cs/docs/direction/architecture/acid/','title':"ACID",'content':"ACID  In computer science, ACID (atomicity, consistency, isolation, durability) is a set of properties of database transactions intended to guarantee validity even in the event of errors, power failures, etc. In the context of databases, a sequence of database operations that satisfies the ACID properties (and these can be perceived as a single logical operation on the data) is called a transaction.\n  ACID，是指数据库管理系统（DBMS）在写入或更新资料的过程中，为保证事务（transaction）是正确可靠的，所必须具备的四个特性：\n 原子性（Atomicity 又称不可分割性）  一个事务（transaction）中的所有操作，或者全部完成，或者全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。即，事务不可分割、不可约简。   一致性（Consistency）  在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设约束、触发器、级联回滚等。   隔离性（isolation，又称独立性）  数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括未提交读（Read uncommitted）、提交读（read committed）、可重复读（repeatable read）和串行化（Serializable）。   持久性（Durability）  事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。     ACID 是追求 CAP 的一致性 "});index.add({'id':164,'href':'/note-cs/docs/direction/architecture/base/','title':"BASE",'content':"BASE Basically Available, Soft state, Eventual consistency\nBASE 理论是 CAP 理论中的 AP 的延伸，是对互联网大规模分布式系统的实践总结，强调可用性。\n基本可用  流量削峰  在不同的时间，出售不同区域的票，将访问请求错开，削弱请求峰值   延迟响应  在春运期间，自己提交的购票请求，往往会在队列中排队等待处理，可能几分钟或十几分钟后，系统才开始处理，然后响应处理结果   体验降级  比如用小图片来替代原始图片，通过降低图片的清晰度和大小，提升系统的处理能力。   过载保护  把接收到的请求放在指定的队列中排队处理，如果请求等待时间超时了（假设是 100ms），这个时候直接拒绝超时请求；再比如队列满了之后，就清除队列中一定数量的排队请求，保护系统不过载，实现系统的基本可用。    最终的一致  读时修复：在读取数据时，检测数据的不一致，进行修复。  比如 Cassandra 的 Read Repair 实现，具体来说，在向 Cassandra 系统查询数据的时候，如果检测到不同节点的副本数据不一致，系统就自动修复数据。   写时修复：在写入数据，检测数据的不一致时，进行修复。  比如 Cassandra 的 Hinted Handoff 实现。具体来说，Cassandra 集群的节点之间远程写数据的时候，如果写失败就将数据缓存下来，然后定时重传，修复数据的不一致性。 写时修复不需要做数据一致性对比，性能消耗比较低，对系统运行影响也不大，推荐在实现最终一致性时优先实现这种方式。   异步修复：这个是最常用的方式，通过定时对账检测副本数据的一致性，并修复。   BASE 是追求 CAP 的可用性 "});index.add({'id':165,'href':'/note-cs/docs/domain/cloud-computing/paas/heroku/','title':"Heroku",'content':"Heroku "});index.add({'id':166,'href':'/note-cs/docs/direction/client/ios/','title':"iOS",'content':"iOS "});index.add({'id':167,'href':'/note-cs/docs/basic/language/objective-c/','title':"Objective-C",'content':"Objective-C 学习笔记 "});index.add({'id':168,'href':'/note-cs/docs/domain/cloud-computing/virtual/parallels/','title':"Parallels",'content':"Parallels "});index.add({'id':169,'href':'/note-cs/docs/direction/architecture/raft/','title':"Raft",'content':"Raft "});index.add({'id':170,'href':'/note-cs/docs/basic/language/scala/','title':"Scala",'content':"Scala 学习笔记 "});index.add({'id':171,'href':'/note-cs/docs/domain/cloud-computing/virtual/virtualbox/','title':"VirtualBox",'content':"VirtualBox "});index.add({'id':172,'href':'/note-cs/docs/basic/language/scala/basic/practice/','title':"最佳实践",'content':"Scala 最佳实践 "});index.add({'id':173,'href':'/note-cs/docs/basic/os/android/basic/practice/','title':"最佳实践",'content':"最佳实践 "});index.add({'id':174,'href':'/note-cs/docs/basic/os/ios/basic/practice/','title':"最佳实践",'content':"最佳实践 "});index.add({'id':175,'href':'/note-cs/docs/basic/os/macos/basic/practice/','title':"最佳实践",'content':"最佳实践 "});index.add({'id':176,'href':'/note-cs/docs/basic/os/unix/basic/practice/','title':"最佳实践",'content':"最佳实践 "});index.add({'id':177,'href':'/note-cs/docs/basic/os/windows/basic/practice/','title':"最佳实践",'content':"最佳实践 "});index.add({'id':178,'href':'/note-cs/docs/direction/client/','title':"2.3 客户端",'content':"客户端 "});index.add({'id':179,'href':'/note-cs/docs/domain/ai/','title':"3.3 人工智能",'content':"人工智能 "});index.add({'id':180,'href':'/note-cs/docs/others/skill/debug/','title':"Debug",'content':"Debug "});index.add({'id':181,'href':'/note-cs/docs/domain/cloud-computing/paas/openshift/','title':"OpenShift",'content':"OpenShift Red Hat OpenShift is a leading hybrid cloud, enterprise Kubernetes application platform. OpenShift 在 Kubernetes 的基础上整合了应用的生命周期管理，包括 image 的编译，持续集成，部署以及更新。\nOpenshift 以前是 IaaS，现在 Openshift 自己宣称自己搭配 LXC 已经是 PaaS 了，VPS 不是云服务但可以类比为 IaaS。\nOpenshift 没有 root 权限 参考：openshift 和普通 vps 的区别在哪儿？\n"});index.add({'id':182,'href':'/note-cs/docs/basic/language/scala/basic/snippet/','title':"代码片段",'content':"代码片段 "});index.add({'id':183,'href':'/note-cs/docs/basic/os/android/basic/snippet/','title':"代码片段",'content':"代码片段 "});index.add({'id':184,'href':'/note-cs/docs/basic/os/ios/basic/snippet/','title':"代码片段",'content':"代码片段 "});index.add({'id':185,'href':'/note-cs/docs/basic/os/macos/basic/snippet/','title':"代码片段",'content':"代码片段 "});index.add({'id':186,'href':'/note-cs/docs/basic/os/unix/basic/snippet/','title':"代码片段",'content':"代码片段 "});index.add({'id':187,'href':'/note-cs/docs/basic/os/windows/basic/snippet/','title':"代码片段",'content':"代码片段 "});index.add({'id':188,'href':'/note-cs/docs/direction/client/xiaochengxu/','title':"小程序",'content':"小程序 "});index.add({'id':189,'href':'/note-cs/docs/basic/language/scala/basic/practice/baidu/','title':"百度",'content':"百度 Scala 最佳实践 "});index.add({'id':190,'href':'/note-cs/docs/domain/cloud-computing/virtual/','title':"虚拟化",'content':"虚拟化 "});index.add({'id':191,'href':'/note-cs/docs/direction/embedded/','title':"2.4 嵌入式",'content':"嵌入式开发 "});index.add({'id':192,'href':'/note-cs/docs/domain/cloud-computing/paas/cloud-foundry/','title':"Cloud Foundry",'content':"Cloud Foundry "});index.add({'id':193,'href':'/note-cs/docs/direction/middle-platform/','title':"2.5 中台",'content':"中台 "});index.add({'id':194,'href':'/note-cs/docs/others/tool/','title':"4.2 工具",'content':"工具 "});index.add({'id':195,'href':'/note-cs/docs/domain/cloud-computing/paas/appfog/','title':"AppFog",'content':"AppFog "});index.add({'id':196,'href':'/note-cs/docs/others/tool/study/coding-online/','title':"在线编程",'content':"在线编程 "});index.add({'id':197,'href':'/note-cs/docs/direction/architecture/','title':"2.6 架构设计",'content':"架构设计  参考 "});index.add({'id':198,'href':'/note-cs/docs/direction/architecture/seckill/','title':"秒杀",'content':"秒杀  参考 codingXiaxw/seckill  Java 高并发秒杀系统 API\n"});index.add({'id':199,'href':'/note-cs/docs/direction/architecture/tutorial/','title':"教程",'content':"教程 基础 系统设计入门  学习如何设计可扩展的系统将会有助于你成为一个更好的工程师。\n系统设计是一个很宽泛的话题。在互联网上，关于系统设计原则的资源也是多如牛毛。\n这个仓库就是这些资源的组织收集，它可以帮助你学习如何构建可扩展的系统。\n 进阶 "});index.add({'id':200,'href':'/note-cs/docs/others/skill/lorawan/','title':"LoRaWan",'content':"LoRaWan "});index.add({'id':201,'href':'/note-cs/docs/others/skill/onvif/','title':"ONVIF",'content':"ONVIF 官网：www.onvif.org\n"});index.add({'id':202,'href':'/note-cs/categories/','title':"Categories",'content':""});index.add({'id':203,'href':'/note-cs/docs/','title':"Docs",'content':""});index.add({'id':204,'href':'/note-cs/tags/','title':"Tags",'content':""});index.add({'id':205,'href':'/note-cs/','title':"首页",'content':""});})();