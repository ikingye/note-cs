'use strict';(function(){const indexCfg={cache:true};indexCfg.doc={id:'id',field:['title','content'],store:['title','href'],};const index=FlexSearch.create('balance',indexCfg);window.bookSearchIndex=index;index.add({'id':0,'href':'/note-cs/docs/domain/cc/container/docker/image/alpine/','title':"alpine",'content':"alpine 安装 telnet apk add busybox-extras\n"});index.add({'id':1,'href':'/note-cs/docs/domain/cc/container/docker/','title':"Docker",'content':"Docker 基础 "});index.add({'id':2,'href':'/note-cs/docs/domain/cc/container/docker/image/','title':"Docker 镜像",'content':"Docker 镜像 docker push 上传到 私有仓库 docker build -t human-attribute:20200415_1585818439123 . docker tag human-attribute:20200415_1585818439123 ote-harbor.baidu.com/aiedge/human-attribute:20200415_1585818439123 docker push ote-harbor.baidu.com/aiedge/human-attribute:20200415_1585818439123 "});index.add({'id':3,'href':'/note-cs/docs/others/tool/dev/github/','title':"GitHub",'content':"GitHub 学习 Github Github Learning Lab Introduction to GitHub 开源库 素材 / 规范 徽章 shields.io 如：\n Github star 历史 timqian/star-history  https://star-history.t9t.io/\nvesoft-inc/github-statistics  A react static app for displaying github repo statistiscs like Star History, Fork History and more.\nhttps://vesoft-inc.github.io/github-statistics/\nantonmedv/spark  \nseladb/startrack-js  GitHub star history and stats - based on JavaScript only!\nhttps://seladb.github.io/StarTrack-js/\nelliotreborn/github-stars  技术栈的 star 趋势数据\n Github PR 统计 开源相关工作岗位 t9tio/open-source-jobs A list of Open Source projects offering jobs. https://oo.t9t.io/organizations\n 角落标志 tholman/github-corners  http://tholman.com/github-corners/\n如：  GitHub Apps  Run persistently and can react to events quickly. Work great when persistent data is needed. Work best with API requests that aren\u0026rsquo;t time consuming. Run on a server or compute infrastructure that you provide.  参考：\n Strengths of GitHub Actions and GitHub Apps  Mergify Stop merging your pull requests manually.\nWe save your time by automatically merging, commenting, rebasing, updating, labeling, backporting, closing, assigning, your pull requests.\nMergifyio/mergify-engine  Engine for Mergify https://mergify.io\nNetlify [wei/pull] Pull Keep your forks up-to-date via automated PRs\nwei/pull probot/weekly-digest  自动生成周报到 issue\nGitHub Actions  Provide automation that can perform continuous integration and continuous deployment. Can run directly on runner machines or in Docker containers. Can include access to a clone of your repository, enabling deployment and publishing tools, code formatters, and command line tools to access your code. Don\u0026rsquo;t require you to deploy code or serve an app. Have a simple interface to create and use secrets, which enables actions to interact with third-party services without needing to store the credentials of the person using the action.   Github 工具开发 webhook NetEaseGame/git-webhook  使用 Python Flask + SQLAchemy + Celery + Redis + React 开发的用于迅速搭建并使用 WebHook 进行自动化部署和运维，支持 Github / GitLab / Gogs / GitOsc。 https://webhook.hust.cc/\n若觉得 git-webhook 部署依然比较复杂，可以尝试更为简洁的 cli 版本 hustcc/webhookit  github-webhook-handler  Node.js web handler / middleware for processing GitHub Webhooks\n go-playground/webhooks  Webhook receiver for GitHub, Bitbucket, GitLab, Gogs\n hustcc/webhookit  Simple git webhook cli tool for automation tasks, bind git webhook to action.\n gorda/issue-man   Building apps 参考：\n Building apps  Building actions 参考：\n Building actions  "});index.add({'id':4,'href':'/note-cs/docs/book/basic/pl/go-in-action/chinese/','title':"Go 语言实战",'content':"Go 语言实战 \n译者 李兆海，多年专注于后端分布式网络服务开发，曾使用过多个流行后端技术和相关架构实践，是 Go 语言和 Docker 的早期使用者和推广者，《第 1 本 Docker 书》的译者。作为项目技术负责人，成功开发了百万用户级直播系统。\n"});index.add({'id':5,'href':'/note-cs/docs/direction/fe/html/','title':"HTML",'content':"HTML "});index.add({'id':6,'href':'/note-cs/docs/basic/os/linux/','title':"Linux",'content':"Linux 见：Linux 学习笔记\n"});index.add({'id':7,'href':'/note-cs/docs/others/tool/dev/vscode/','title':"VSCode",'content':"VSCode 推荐插件 PicGo/vs-picgo https://github.com/PicGo/vs-picgo\nformat autopep8 设置每行最大长度\n\u0026quot;python.formatting.autopep8Args\u0026quot;: [ \u0026quot;--max-line-length=200\u0026quot; ] 教程  帮你高效使用 VS Code 的秘诀  参考 "});index.add({'id':8,'href':'/note-cs/docs/basic/pl/java/basic/grammar/keyword/','title':"关键字",'content':"Java 关键字 "});index.add({'id':9,'href':'/note-cs/docs/basic/pl/java/basic/grammar/','title':"基本语法",'content':"Java 基本语法 "});index.add({'id':10,'href':'/note-cs/docs/basic/db/mysql/basic/practice/','title':"实践",'content':"实践 "});index.add({'id':11,'href':'/note-cs/docs/basic/db/postgresql/basic/practice/','title':"实践",'content':"PostgreSQL 实践 "});index.add({'id':12,'href':'/note-cs/docs/basic/pl/c/basic/practice/','title':"实践",'content':"实践 "});index.add({'id':13,'href':'/note-cs/docs/basic/pl/javascript/basic/practice/','title':"实践",'content':"实践 "});index.add({'id':14,'href':'/note-cs/docs/basic/pl/objective-c/basic/practice/','title':"实践",'content':"实践 "});index.add({'id':15,'href':'/note-cs/docs/direction/be/frame/nodejs/basic/practice/','title':"实践",'content':"实践 "});index.add({'id':16,'href':'/note-cs/docs/direction/client/android/basic/practice/','title':"实践",'content':"实践 "});index.add({'id':17,'href':'/note-cs/docs/direction/client/ios/basic/practice/','title':"实践",'content':"实践 "});index.add({'id':18,'href':'/note-cs/docs/direction/client/xiaochengxu/basic/practice/','title':"实践",'content':"实践 "});index.add({'id':19,'href':'/note-cs/docs/direction/fe/frame/angular/basic/practice/','title':"实践",'content':"实践 "});index.add({'id':20,'href':'/note-cs/docs/direction/fe/frame/react/basic/practice/','title':"实践",'content':"实践 "});index.add({'id':21,'href':'/note-cs/docs/direction/fe/frame/vue/basic/practice/','title':"实践",'content':"实践 "});index.add({'id':22,'href':'/note-cs/docs/basic/db/postgresql/basic/quick-start/','title':"快速上手",'content':"PostgreSQL 快速上手 安装 MacOS  安装：brew install postgresql 启动：brew services start postgresql 创建用户名数据库：createdb  基础命令 登录 PostgreSQL 控制台：psql psql -U [user] -d [database] -h [host] -p [port]\n默认 psql\nuser：当前mac用户 database：用户同名数据库 主机：localhost 端口号：5432，postgresql的默认端口是5432 \\l 使用 \\l 命令列出所有的数据库，看到已存在用户同名数据库、postgres 数据库。 但是 postgres 数据库的所有者是当前用户，没有 postgres 用户。\n 创建 postgres 用户：CREATE USER postgres WITH PASSWORD 'password'; 删除默认生成的 postgres 数据库：DROP DATABASE postgres; 创建属于 postgres 用户的 postgres 数据库：CREATE DATABASE postgres OWNER postgres; 将数据库所有权限赋予 postgres 用户：GRANT ALL PRIVILEGES ON DATABASE postgres to postgres; 给 postgres 用户添加创建数据库的属性：ALTER ROLE postgres CREATEDB;  常用控制台命令 \\password：设置当前登录用户的密码 \\h：查看SQL命令的解释，比如\\h select。 \\?：查看psql命令列表。 \\l：列出所有数据库。 \\c [database_name]：连接其他数据库。 \\d：列出当前数据库的所有表格。 \\d [table_name]：列出某一张表格的结构。 \\du：列出所有用户。 \\e：打开文本编辑器。 \\conninfo：列出当前数据库和连接的信息。 \\password [user]: 修改用户密码 \\q：退出 查询 \\x 类似 mysql 的 \\G\n# \\x Expanded display is on. # \\x Expanded display is off. 参考：\n Display select results vertically in psql, as is done by MySQL\u0026rsquo;s \\G   权限 GRANT GRANT on the database is not what you need. Grant on the tables directly.\nGranting privileges on the database mostly is used to grant or revoke connect privileges. This allows you to specify who may do stuff in the database if they have sufficient other permissions.\nGRANT ALL PRIVILEGES ON TABLE side_adzone TO jerry; 参考：\n Permission denied for relation  "});index.add({'id':23,'href':'/note-cs/docs/basic/db/mysql/basic/practice/optimize/','title':"性能优化",'content':"Mysql 性能优化 存储引擎 使用 Innodb 存储引擎 没有特殊要求（即 Innodb 无法满足的功能如：列存储，存储空间数据等）的情况下，所有表必须使用 Innodb 存储引擎（MySQL5.5 之前默认使用 Myisam，5.6 以后默认的为 Innodb）。\nInnodb 支持事务，支持行级锁，更好的恢复性，高并发下性能更好。\n 编码 统一使用 UTF8 库和表的字符集统一使用 UTF8\n 表 控制单表数据量的大小 建议在 500 万以内。500 万并不是 MySQL 数据库的限制，过大会造成修改表结构，备份，恢复都会有很大的问题。\n可以用历史数据归档（应用于日志数据），分库分表（应用于业务数据）等手段来控制数据量大小\n谨慎使用 MySQL 分区表 分区表在物理上表现为多个文件，在逻辑上表现为一个表；\n谨慎选择分区键，跨分区查询效率可能更低；\n建议采用物理分表的方式管理大数据。\n冷热数据分离，减小表的宽度  MySQL 限制每个表最多存储 4096 列，并且每一行数据的大小不能超过 65535 字节。\n 减少磁盘 IO, 保证热数据的内存缓存命中率（表越宽，把表装载进内存缓冲池时所占用的内存也就越大，也会消耗更多的 IO）；\n更有效的利用缓存，避免读入无用的冷数据；\n经常一起使用的列放到一个表中（避免更多的关联操作）。\n优先选择小的数据类型 列的字段越大，建立索引时所需要的空间也就越大，这样一页中所能存储的索引节点的数量也就越少也越少，在遍历时所需要的 IO 次数也就越多，索引的性能也就越差。\n如：\n 将 IP 地址转换成整形数据 对于非负型的数据 (如自增 ID, 整型 IP) 来说，要优先使用无符号整型来存储  列定义为 NOT NULL 索引 NULL 列需要额外的空间来保存，所以要占用更多的空间。\n进行比较和计算时要对 NULL 值做特别的处理。\n 索引 限制每张表上的索引数量 建议单张表索引不超过 5 个 索引并不是越多越好！索引可以提高效率同样可以降低效率。\n索引可以增加查询效率，但同样也会降低插入和更新的效率，甚至有些情况下会降低查询效率。\n因为 MySQL 优化器在选择如何优化查询时，会根据统一信息，对每一个可以用到的索引来进行评估，以生成出一个最好的执行计划，如果同时有很多个索引都可以用于查询，就会增加 MySQL 优化器生成执行计划的时间，同样会降低查询性能。\n必须有个主键 Innodb 是一种索引组织表：数据的存储的逻辑顺序和索引的顺序是相同的。每个表都可以有多个索引，但是表的存储顺序只能有一种。\nInnodb 是按照主键索引的顺序来组织表的\n 不要使用更新频繁的列作为主键，不适用多列主键（相当于联合索引） 不要使用 UUID,MD5,HASH, 字符串列作为主键（无法保证数据的顺序增长） 主键建议使用自增 ID 值   开发 避免数据类型的隐式转换 避免使用双 % 号的查询条件 联合索引 在定义联合索引时，如果 a 列要用到范围查找的话，就要把 a 列放到联合索引的右侧。\n一个 SQL 只能利用到复合索引中的一列进行范围查询。如：有 a,b,c 列的联合索引，在查询条件中有 a 列的范围查询，则在 b,c 列上的索引将不会被用到。\n使用 left join 替代 not in 操作 使用 left join 或 not exists 来优化 not in 操作，因为 not in 也通常会使用索引失效。\n 参考  MySQL 高性能优化规范建议  "});index.add({'id':24,'href':'/note-cs/docs/basic/db/mysql/appendix/tutorial/','title':"教程",'content':"教程 基础 进阶 高阶 "});index.add({'id':25,'href':'/note-cs/docs/basic/db/postgresql/appendix/tutorial/','title':"教程",'content':"教程 基础 进阶 高阶 "});index.add({'id':26,'href':'/note-cs/docs/basic/db/redis/appendix/tutorial/','title':"教程",'content':"教程 基础 进阶 高阶 "});index.add({'id':27,'href':'/note-cs/docs/basic/os/android/appendix/tutorial/','title':"教程",'content':"教程 基础 进阶 高阶 "});index.add({'id':28,'href':'/note-cs/docs/basic/os/ios/appendix/tutorial/','title':"教程",'content':"教程 基础 进阶 高阶 "});index.add({'id':29,'href':'/note-cs/docs/basic/os/macos/appendix/tutorial/','title':"教程",'content':"教程 基础 进阶 高阶 "});index.add({'id':30,'href':'/note-cs/docs/basic/os/unix/appendix/tutorial/','title':"教程",'content':"教程 基础 进阶 高阶 "});index.add({'id':31,'href':'/note-cs/docs/basic/os/windows/appendix/tutorial/','title':"教程",'content':"教程 基础 进阶 高阶 "});index.add({'id':32,'href':'/note-cs/docs/basic/pl/c/appendix/tutorial/','title':"教程",'content':"教程 基础  learn c in y minutes  进阶 高阶 "});index.add({'id':33,'href':'/note-cs/docs/basic/pl/cpp/appendix/tutorial/','title':"教程",'content':"教程 基础  learn c++ in y minutes  进阶 高阶 综合  C++ 后台开发有哪些练基础的开源项目？  yedf/handy     "});index.add({'id':34,'href':'/note-cs/docs/basic/pl/csharp/appendix/tutorial/','title':"教程",'content':"教程 基础 进阶 高阶 "});index.add({'id':35,'href':'/note-cs/docs/basic/pl/java/appendix/tutorial/','title':"教程",'content':"Java 教程 基础  进阶 doocs/advanced-java  互联网 Java 工程师进阶知识完全扫盲：涵盖高并发、分布式、高可用、微服务、海量数据处理等领域知识，后端同学必看，前端同学也可学习 https://doocs.github.io/advanced-java\nSnailclimb/JavaGuide  【Java 学习 + 面试指南】 一份涵盖大部分 Java 程序员所需要掌握的核心知识。\nEffective Java  第 3 版中文版：sjsdfg.github.io/effective-java-3rd-chinese   Java 编程思想  第 5 版中文版：lingcoder.github.io/OnJava8   redspider1/concurrent  Java 多线程系列文章 在线阅读\n高阶 源码阅读 seaswalker/spring-analysis  Spring 源码阅读\nseaswalker/JDK  JDK 源码阅读笔记\n 综合 博客  farmerjohngit/myblog    sorenduan/awesome-java-books  Java 技术书籍大全\n"});index.add({'id':36,'href':'/note-cs/docs/basic/pl/javascript/appendix/turorial/','title':"教程",'content':"教程 基础 ruanyf/jstraining  全栈工程师培训材料，帮助学习者掌握 JavaScript 全栈开发的基本知识，承担简单 Web 应用的前后端开发。\n一共四讲，适合两天的训练营。\n 进阶  高阶 "});index.add({'id':37,'href':'/note-cs/docs/basic/pl/kotlin/appendix/tutorial/','title':"教程",'content':"教程 基础 进阶 高阶 "});index.add({'id':38,'href':'/note-cs/docs/basic/pl/lua/appendix/tutorial/','title':"教程",'content':"教程 基础 进阶 高阶 "});index.add({'id':39,'href':'/note-cs/docs/basic/pl/objective-c/appendix/tutorial/','title':"教程",'content':"教程 基础 进阶 高阶 "});index.add({'id':40,'href':'/note-cs/docs/basic/pl/php/appendix/tutorial/','title':"教程",'content':"教程 基础 进阶 高阶 "});index.add({'id':41,'href':'/note-cs/docs/basic/pl/ruby/appendix/tutorial/','title':"教程",'content':"教程 基础 进阶 高阶 "});index.add({'id':42,'href':'/note-cs/docs/basic/pl/rust/appendix/tutorial/','title':"教程",'content':"教程 基础 进阶 高阶 "});index.add({'id':43,'href':'/note-cs/docs/basic/pl/scala/appendix/tutorial/','title':"教程",'content':"教程 基础 进阶 高阶 "});index.add({'id':44,'href':'/note-cs/docs/basic/pl/swift/appendix/tutorial/','title':"教程",'content':"教程 基础 进阶 高阶 "});index.add({'id':45,'href':'/note-cs/docs/direction/be/frame/nodejs/appendix/tutorial/','title':"教程",'content':"教程 基础 进阶 高阶 "});index.add({'id':46,'href':'/note-cs/docs/direction/client/android/appendix/tutorial/','title':"教程",'content':"教程 基础 进阶 高阶 "});index.add({'id':47,'href':'/note-cs/docs/direction/client/ios/appendix/tutorial/','title':"教程",'content':"教程 基础 进阶 高阶 "});index.add({'id':48,'href':'/note-cs/docs/direction/client/xiaochengxu/appendix/tutorial/','title':"教程",'content':"教程 基础 进阶 高阶 "});index.add({'id':49,'href':'/note-cs/docs/direction/embedded/appendix/tutorial/','title':"教程",'content':"教程 基础 进阶 高阶 "});index.add({'id':50,'href':'/note-cs/docs/direction/fe/frame/angular/appendix/tutorial/','title':"教程",'content':"教程 基础 进阶 高阶 "});index.add({'id':51,'href':'/note-cs/docs/direction/fe/frame/react/appendix/tutorial/','title':"教程",'content':"教程 基础 进阶 高阶 "});index.add({'id':52,'href':'/note-cs/docs/direction/fe/frame/vue/appendix/tutorial/','title':"教程",'content':"教程 基础 进阶 高阶 "});index.add({'id':53,'href':'/note-cs/docs/direction/security/appendix/tutorial/','title':"教程",'content':"教程 基础 进阶 高阶 "});index.add({'id':54,'href':'/note-cs/docs/domain/cc/knative/appendix/tutorial/','title':"教程",'content':"教程 基础 Getting Started with Knative - Building Modern Serverless Workloads on Kubernetes Getting Started with Knative 是一本由 Pivotal 公司赞助 O’Reilly 出品的免费电子书\n社区翻译版本：Knative 入门 —— 构建基于 Kubernetes 的现代化 Serverless 应用\n进阶 高阶 "});index.add({'id':55,'href':'/note-cs/docs/basic/pl/cpp/basic/practice/spec/baidu/','title':"百度",'content':"百度 C++ 编程规范 "});index.add({'id':56,'href':'/note-cs/docs/basic/pl/java/basic/practice/spec/baidu/','title':"百度",'content':"百度 Java 编码规范 V1.3 "});index.add({'id':57,'href':'/note-cs/docs/basic/pl/javascript/basic/practice/spec/baidu/','title':"百度",'content':"百度 JavaScript 编码规范 1 前言\n2 代码风格\n2.1 文件\n2.2 结构\n2.2.1 缩进\n2.2.2 空格\n2.2.3 换行\n2.2.4 语句\n2.3 命名\n2.4 注释\n2.4.1 单行注释\n2.4.2 多行注释\n2.4.3 文档化注释\n2.4.4 类型定义\n2.4.5 文件注释\n2.4.6 命名空间注释\n2.4.7 类注释\n2.4.8 函数/方法注释\n2.4.9 事件注释\n2.4.10 常量注释\n2.4.11 复杂类型注释\n2.4.12 AMD 模块注释\n2.4.13 细节注释\n3 语言特性\n3.1 变量\n3.2 条件\n3.3 循环\n3.4 类型\n3.4.1 类型检测\n3.4.2 类型转换\n3.5 字符串\n3.6 对象\n3.7 数组\n3.8 函数\n3.8.1 函数长度\n3.8.2 参数设计\n3.8.3 闭包\n3.8.4 空函数\n3.9 面向对象\n3.10 动态特性\n3.10.1 eval\n3.10.2 动态执行代码\n3.10.3 with\n3.10.4 delete\n3.10.5 对象属性\n4 浏览器环境\n4.1 模块化\n4.1.1 AMD\n4.1.2 define\n4.1.3 require\n4.2 DOM\n4.2.1 元素获取\n4.2.2 样式获取\n4.2.3 样式设置\n4.2.4 DOM 操作\n4.2.5 DOM 事件\n1 前言 JavaScript 在百度一直有着广泛的应用，特别是在浏览器端的行为管理。本文档的目标是使 JavaScript 代码风格保持一致，容易被理解和被维护。\n虽然本文档是针对 JavaScript 设计的，但是在使用各种 JavaScript 的预编译语言时(如 TypeScript 等)时，适用的部分也应尽量遵循本文档的约定。\n任何问题或建议，欢迎跟我们讨论: fe-styleguide@baidu.com\n2 代码风格 2.1 文件 [建议] JavaScript 文件使用无 BOM 的 UTF-8 编码。 解释：\nUTF-8 编码具有更广泛的适应性。BOM 在使用程序或工具处理文件时可能造成不必要的干扰。\n[建议] 在文件结尾处，保留一个空行。 2.2 结构 2.2.1 缩进 [强制] 使用 4 个空格做为一个缩进层级，不允许使用 2 个空格 或 tab 字符。 [强制] switch 下的 case 和 default 必须增加一个缩进层级。 示例：\n// good switch (variable) { case \u0026#34;1\u0026#34;: // do...  break; case \u0026#34;2\u0026#34;: // do...  break; default: // do... } // bad switch (variable) { case \u0026#34;1\u0026#34;: // do...  break; case \u0026#34;2\u0026#34;: // do...  break; default: // do... } 2.2.2 空格 [强制] 二元运算符两侧必须有一个空格，一元运算符与操作对象之间不允许有空格。 示例：\nvar a = !arr.length; a++; a = b + c; [强制] 用作代码块起始的左花括号 { 前必须有一个空格。 示例：\n// good if (condition) { } while (condition) {} function funcName() {} // bad if (condition) { } while (condition) {} function funcName() {} [强制] if / else / for / while / function / switch / do / try / catch / finally 关键字后，必须有一个空格。 示例：\n// good if (condition) { } while (condition) {} (function() {})(); // bad if (condition) { } while (condition) {} (function() {})(); [强制] 在对象创建时，属性中的 : 之后必须有空格，: 之前不允许有空格。 示例：\n// good var obj = { a: 1, b: 2, c: 3 }; // bad var obj = { a: 1, b: 2, c: 3 }; [强制] 函数声明、具名函数表达式、函数调用中，函数名和 ( 之间不允许有空格。 示例：\n// good function funcName() {} var funcName = function funcName() {}; funcName(); // bad function funcName() {} var funcName = function funcName() {}; funcName(); [强制] , 和 ; 前不允许有空格。如果不位于行尾，, 和 ; 后必须跟一个空格。 示例：\n// good callFunc(a, b); // bad callFunc(a, b); [强制] 在函数调用、函数声明、括号表达式、属性访问、if / for / while / switch / catch 等语句中，() 和 [] 内紧贴括号部分不允许有空格。 示例：\n// good  callFunc(param1, param2, param3); save(this.list[this.indexes[i]]); needIncream \u0026amp;\u0026amp; (variable += increament); if (num \u0026gt; list.length) { } while (len--) {} // bad  callFunc(param1, param2, param3); save(this.list[this.indexes[i]]); needIncreament \u0026amp;\u0026amp; (variable += increament); if (num \u0026gt; list.length) { } while (len--) {} [强制] 单行声明的数组与对象，如果包含元素，` 解释：\n声明包含元素的数组与对象，只有当内部元素的形式较为简单时，才允许写在一行。元素复杂的情况，还是应该换行书写。\n示例：\n// good var arr1 = []; var arr2 = [1, 2, 3]; var obj1 = {}; var obj2 = { name: \u0026#34;obj\u0026#34; }; var obj3 = { name: \u0026#34;obj\u0026#34;, age: 20, sex: 1 }; // bad var arr1 = []; var arr2 = [1, 2, 3]; var obj1 = {}; var obj2 = { name: \u0026#34;obj\u0026#34; }; var obj3 = { name: \u0026#34;obj\u0026#34;, age: 20, sex: 1 }; [强制] 行尾不得有多余的空格。 2.2.3 换行 [强制] 每个独立语句结束后必须换行。 [强制] 每行不得超过 120 个字符。 解释：\n超长的不可分割的代码允许例外，比如复杂的正则表达式。长字符串不在例外之列。\n[强制] 运算符处换行时，运算符必须在新行的行首。 示例：\n// good if ( (user.isAuthenticated() \u0026amp;\u0026amp; user.isInRole(\u0026#34;admin\u0026#34;) \u0026amp;\u0026amp; user.hasAuthority(\u0026#34;add-admin\u0026#34;)) || user.hasAuthority(\u0026#34;delete-admin\u0026#34;) ) { // Code } var result = number1 + number2 + number3 + number4 + number5; // bad if ( (user.isAuthenticated() \u0026amp;\u0026amp; user.isInRole(\u0026#34;admin\u0026#34;) \u0026amp;\u0026amp; user.hasAuthority(\u0026#34;add-admin\u0026#34;)) || user.hasAuthority(\u0026#34;delete-admin\u0026#34;) ) { // Code } var result = number1 + number2 + number3 + number4 + number5; [强制] 在函数声明、函数表达式、函数调用、对象创建、数组创建、for 语句等场景中，不允许在 , 或 ; 前换行。 示例：\n// good var obj = { a: 1, b: 2, c: 3 }; foo(aVeryVeryLongArgument, anotherVeryLongArgument, callback); // bad var obj = { a: 1, b: 2, c: 3 }; foo(aVeryVeryLongArgument, anotherVeryLongArgument, callback); [建议] 不同行为或逻辑的语句集，使用空行隔开，更易阅读。 示例：\n// 仅为按逻辑换行的示例，不代表setStyle的最优实现 function setStyle(element, property, value) { if (element == null) { return; } element.style[property] = value; } [建议] 在语句的行长度超过 120 时，根据逻辑条件合理缩进。 示例：\n// 较复杂的逻辑条件组合，将每个条件独立一行，逻辑运算符放置在行首进行分隔，或将部分逻辑按逻辑组合进行分隔。 // 建议最终将右括号 ) 与左大括号 { 放在独立一行，保证与 `if` 内语句块能容易视觉辨识。 if ( (user.isAuthenticated() \u0026amp;\u0026amp; user.isInRole(\u0026#34;admin\u0026#34;) \u0026amp;\u0026amp; user.hasAuthority(\u0026#34;add-admin\u0026#34;)) || user.hasAuthority(\u0026#34;delete-admin\u0026#34;) ) { // Code } // 按一定长度截断字符串，并使用 + 运算符进行连接。 // 分隔字符串尽量按语义进行，如不要在一个完整的名词中间断开。 // 特别的，对于 HTML 片段的拼接，通过缩进，保持和 HTML 相同的结构。 var html = \u0026#34;\u0026#34; + // 此处用一个空字符串，以便整个 HTML 片段都在新行严格对齐  \u0026#34;\u0026lt;article\u0026gt;\u0026#34; + \u0026#34;\u0026lt;h1\u0026gt;Title here\u0026lt;/h1\u0026gt;\u0026#34; + \u0026#34;\u0026lt;p\u0026gt;This is a paragraph\u0026lt;/p\u0026gt;\u0026#34; + \u0026#34;\u0026lt;footer\u0026gt;Complete\u0026lt;/footer\u0026gt;\u0026#34; + \u0026#34;\u0026lt;/article\u0026gt;\u0026#34;; // 也可使用数组来进行拼接，相对 `+` 更容易调整缩进。 var html = [ \u0026#34;\u0026lt;article\u0026gt;\u0026#34;, \u0026#34;\u0026lt;h1\u0026gt;Title here\u0026lt;/h1\u0026gt;\u0026#34;, \u0026#34;\u0026lt;p\u0026gt;This is a paragraph\u0026lt;/p\u0026gt;\u0026#34;, \u0026#34;\u0026lt;footer\u0026gt;Complete\u0026lt;/footer\u0026gt;\u0026#34;, \u0026#34;\u0026lt;/article\u0026gt;\u0026#34; ]; html = html.join(\u0026#34;\u0026#34;); // 当参数过多时，将每个参数独立写在一行上，并将结束的右括号 ) 独立一行。 // 所有参数必须增加一个缩进。 foo(aVeryVeryLongArgument, anotherVeryLongArgument, callback); // 也可以按逻辑对参数进行组合。 // 最经典的是 baidu.format 函数，调用时将参数分为“模板”和“数据”两块 baidu.format(dateFormatTemplate, year, month, date, hour, minute, second); // 当函数调用时，如果有一个或以上参数跨越多行，应当每一个参数独立一行。 // 这通常出现在匿名函数或者对象初始化等作为参数时，如 `setTimeout` 函数等。 setTimeout(function() { alert(\u0026#34;hello\u0026#34;); }, 200); order.data.read( \u0026#34;id=\u0026#34; + me.model.id, function(data) { me.attchToModel(data.result); callback(); }, 300 ); // 链式调用较长时采用缩进进行调整。 $(\u0026#34;#items\u0026#34;) .find(\u0026#34;.selected\u0026#34;) .highlight() .end(); // 三元运算符由3部分组成，因此其换行应当根据每个部分的长度不同，形成不同的情况。 var result = thisIsAVeryVeryLongCondition ? resultA : resultB; var result = condition ? thisIsAVeryVeryLongResult : resultB; // 数组和对象初始化的混用，严格按照每个对象的 `{` 和结束 `}` 在独立一行的风格书写。 var array = [ { // ...  }, { // ...  } ]; [建议] 对于 if...else...、try...catch...finally 等语句，推荐使用在 } 号后添加一个换行 的风格，使代码层次结构更清晰，阅读性更好。 示例：\nif (condition) { // some statements; } else { // some statements; } try { // some statements; } catch (ex) { // some statements; } 2.2.4 语句 [强制] 不得省略语句结束的分号。 [强制] 在 if / else / for / do / while 语句中，即使只有一行，也不得省略块 ` 示例：\n// good if (condition) { callFunc(); } // bad if (condition) callFunc(); if (condition) callFunc(); [强制] 函数定义结束不允许添加分号。 示例：\n// good function funcName() {} // bad function funcName() {} // 如果是函数表达式，分号是不允许省略的。 var funcName = function() {}; [强制] IIFE 必须在函数表达式外添加 (，非 IIFE 不得在函数表达式外添加 (。 解释：\nIIFE = Immediately-Invoked Function Expression.\n额外的 ( 能够让代码在阅读的一开始就能判断函数是否立即被调用，进而明白接下来代码的用途。而不是一直拖到底部才恍然大悟。\n示例：\n// good var task = (function() { // Code  return result; })(); var func = function() {}; // bad var task = (function() { // Code  return result; })(); var func = function() {}; 2.3 命名 [强制] 变量 使用 Camel命名法。 示例：\nvar loadingModules = {}; [强制] 常量 使用 全部字母大写，单词间下划线分隔 的命名方式。 示例：\nvar HTML_ENTITY = {}; [强制] 函数 使用 Camel命名法。 示例：\nfunction stringFormat(source) {} [强制] 函数的 参数 使用 Camel命名法。 示例：\nfunction hear(theBells) {} [强制] 类 使用 Pascal命名法。 示例：\nfunction TextNode(options) {} [强制] 类的 方法 / 属性 使用 Camel命名法。 示例：\nfunction TextNode(value, engine) { this.value = value; this.engine = engine; } TextNode.prototype.clone = function() { return this; }; [强制] 枚举变量 使用 Pascal命名法，枚举的属性 使用 全部字母大写，单词间下划线分隔 的命名方式。 示例：\nvar TargetState = { READING: 1, READED: 2, APPLIED: 3, READY: 4 }; [强制] 命名空间 使用 Camel命名法。 示例：\nequipments.heavyWeapons = {}; [强制] 由多个单词组成的缩写词，在命名中，根据当前命名法和出现的位置，所有字母的大小写与首字母的大小写保持一致。 示例：\nfunction XMLParser() {} function insertHTML(element, html) {} var httpRequest = new HTTPRequest(); [强制] 类名 使用 名词。 示例：\nfunction Engine(options) {} [建议] 函数名 使用 动宾短语。 示例：\nfunction getStyle(element) {} [建议] boolean 类型的变量使用 is 或 has 开头。 示例：\nvar isReady = false; var hasMoreCommands = false; [建议] Promise对象 用 动宾短语的进行时 表达。 示例：\nvar loadingData = ajax.get(\u0026#34;url\u0026#34;); loadingData.then(callback); 2.4 注释 2.4.1 单行注释 [强制] 必须独占一行。// 后跟一个空格，缩进与下一行被注释说明的代码一致。 2.4.2 多行注释 [建议] 避免使用 /*...*/ 这样的多行注释。有多行注释内容时，使用多个单行注释。 2.4.3 文档化注释 [强制] 为了便于代码阅读和自文档化，以下内容必须包含以 /**...*/ 形式的块注释中。 解释：\n 文件 namespace 类 函数或方法 类属性 事件 全局变量 常量 AMD 模块  [强制] 文档注释前必须空一行。 [建议] 自文档化的文档说明 what，而不是 how。 2.4.4 类型定义 [强制] 类型定义都是以 { 开始, 以 } 结束。 解释：\n常用类型如：{string}, {number}, {boolean}, {Object}, {Function}, {RegExp}, {Array}, {Date}。\n类型不仅局限于内置的类型，也可以是自定义的类型。比如定义了一个类 Developer，就可以使用它来定义一个参数和返回值的类型。\n[强制] 对于基本类型 {string}, {number}, {boolean}，首字母必须小写。    类型定义 语法示例 解释     String {string} \u0026ndash;   Number {number} \u0026ndash;   Boolean {boolean} \u0026ndash;   Object {Object} \u0026ndash;   Function {Function} \u0026ndash;   RegExp {RegExp} \u0026ndash;   Array {Array} \u0026ndash;   Date {Date} \u0026ndash;   单一类型集合 {Array.\u0026lt;string\u0026gt;} string 类型的数组   多类型 {(number ｜ boolean)} 可能是 number 类型, 也可能是 boolean 类型   允许为 null {?number} 可能是 number, 也可能是 null   不允许为 null {!Object} Object 类型, 但不是 null   Function 类型 {function(number, boolean)} 函数, 形参类型   Function 带返回值 {function(number, boolean):string} 函数, 形参, 返回值类型   Promise Promise.\u0026lt;resolveType, rejectType\u0026gt; Promise，成功返回的数据类型，失败返回的错误类型   参数可选 @param {string=} name 可选参数, =为类型后缀   可变参数 @param {\u0026hellip;number} args 变长参数, \u0026hellip;为类型前缀   任意类型 {*} 任意类型   可选任意类型 @param {*=} name 可选参数，类型不限   可变任意类型 @param {\u0026hellip;*} args 变长参数，类型不限    2.4.5 文件注释 [强制] 文件顶部必须包含文件注释，用 @file 标识文件说明。 示例：\n/** * @file Describe the file */ [建议] 文件注释中可以用 @author 标识开发者信息。 解释：\n开发者信息能够体现开发人员对文件的贡献，并且能够让遇到问题或希望了解相关信息的人找到维护人。通常情况文件在被创建时标识的是创建者。随着项目的进展，越来越多的人加入，参与这个文件的开发，新的作者应该被加入 @author 标识。\n@author 标识具有多人时，原则是按照 责任 进行排序。通常的说就是如果有问题，就是找第一个人应该比找第二个人有效。比如文件的创建者由于各种原因，模块移交给了其他人或其他团队，后来因为新增需求，其他人在新增代码时，添加 @author 标识应该把自己的名字添加在创建人的前面。\n@author 中的名字不允许被删除。任何劳动成果都应该被尊重。\n业务项目中，一个文件可能被多人频繁修改，并且每个人的维护时间都可能不会很长，不建议为文件增加 @author 标识。通过版本控制系统追踪变更，按业务逻辑单元确定模块的维护责任人，通过文档与 wiki 跟踪和查询，是更好的责任管理方式。\n对于业务逻辑无关的技术型基础项目，特别是开源的公共项目，应使用 @author 标识。\n示例：\n/** * @file Describe the file * @author author-name(mail-name@domain.com) * author-name2(mail-name2@domain.com) */ 2.4.6 命名空间注释 [建议] 命名空间使用 @namespace 标识。 示例：\n/** * @namespace */ var util = {}; 2.4.7 类注释 [建议] 使用 @class 标记类或构造函数。 解释：\n对于使用对象 constructor 属性来定义的构造函数，可以使用 @constructor 来标记。\n示例：\n/** * 描述 * * @class */ function Developer() { // constructor body } [建议] 使用 @extends 标记类的继承信息。 示例：\n/** * 描述 * * @class * @extends Developer */ function Fronteer() { Developer.call(this); // constructor body } util.inherits(Fronteer, Developer); [强制] 使用包装方式扩展类成员时， 必须通过 @lends 进行重新指向。 解释：\n没有 @lends 标记将无法为该类生成包含扩展类成员的文档。\n示例：\n/** * 类描述 * * @class * @extends Developer */ function Fronteer() { Developer.call(this); // constructor body } util.extend( Fronteer.prototype, /** @lends Fronteer.prototype */ { getLevel: function() { // TODO  } } ); [强制] 类的属性或方法等成员信息不是 public 的，应使用 @protected 或 @private 标识可访问性。 解释：\n生成的文档中将有可访问性的标记，避免用户直接使用非 public 的属性或方法。\n示例：\n/** * 类描述 * * @class * @extends Developer */ var Fronteer = function() { Developer.call(this); /** * 属性描述 * * @type {string} * @private */ this.level = \u0026#34;T12\u0026#34;; // constructor body }; util.inherits(Fronteer, Developer); /** * 方法描述 * * @private * @return {string} 返回值描述 */ Fronteer.prototype.getLevel = function() {}; 2.4.8 函数/方法注释 [强制] 函数/方法注释必须包含函数说明，有参数和返回值时必须使用注释标识。 解释：\n当 return 关键字仅作退出函数/方法使用时，无须对返回值作注释标识。\n[强制] 参数和返回值注释必须包含类型信息，且不允许省略参数的说明。 [建议] 当函数是内部函数，外部不可访问时，可以使用 @inner 标识。 示例：\n/** * 函数描述 * * @param {string} p1 参数1的说明 * @param {string} p2 参数2的说明，比较长 * 那就换行了. * @param {number=} p3 参数3的说明（可选） * @return {Object} 返回值描述 */ function foo(p1, p2, p3) { var p3 = p3 || 10; return { p1: p1, p2: p2, p3: p3 }; } [强制] 对 Object 中各项的描述， 必须使用 @param 标识。 示例：\n/** * 函数描述 * * @param {Object} option 参数描述 * @param {string} option.url option项描述 * @param {string=} option.method option项描述，可选参数 */ function foo(option) { // TODO } [建议] 重写父类方法时， 应当添加 @override 标识。如果重写的形参个数、类型、顺序和返回值类型均未发生变化，可省略 @param、@return，仅用 @override 标识，否则仍应作完整注释。 解释：\n简而言之，当子类重写的方法能直接套用父类的方法注释时可省略对参数与返回值的注释。\n2.4.9 事件注释 [强制] 必须使用 @event 标识事件，事件参数的标识与方法描述的参数标识相同。 示例：\n/** * 值变更时触发 * * @event Select#change * @param {Object} e e描述 * @param {string} e.before before描述 * @param {string} e.after after描述 */ this.fire(\u0026#34;change\u0026#34;, { before: \u0026#34;foo\u0026#34;, after: \u0026#34;bar\u0026#34; }); [强制] 在会广播事件的函数前使用 @fires 标识广播的事件，在广播事件代码前使用 @event 标识事件。 [建议] 对于事件对象的注释，使用 @param 标识，生成文档时可读性更好。 示例：\n/** * 点击处理 * * @fires Select#change * @private */ Select.prototype.clickHandler = function() { /** * 值变更时触发 * * @event Select#change * @param {Object} e e描述 * @param {string} e.before before描述 * @param {string} e.after after描述 */ this.fire(\u0026#34;change\u0026#34;, { before: \u0026#34;foo\u0026#34;, after: \u0026#34;bar\u0026#34; }); }; 2.4.10 常量注释 [强制] 常量必须使用 @const 标记，并包含说明和类型信息。 示例：\n/** * 常量说明 * * @const * @type {string} */ var REQUEST_URL = \u0026#34;myurl.do\u0026#34;; 2.4.11 复杂类型注释 [建议] 对于类型未定义的复杂结构的注释，可以使用 @typedef 标识来定义。 示例：\n// `namespaceA~` 可以换成其它 namepaths 前缀，目的是为了生成文档中能显示 `@typedef` 定义的类型和链接。 /** * 服务器 * * @typedef {Object} namespaceA~Server * @property {string} host 主机 * @property {number} port 端口 */ /** * 服务器列表 * * @type {Array.\u0026lt;namespaceA~Server\u0026gt;} */ var servers = [ { host: \u0026#34;1.2.3.4\u0026#34;, port: 8080 }, { host: \u0026#34;1.2.3.5\u0026#34;, port: 8081 } ]; 2.4.12 AMD 模块注释 [强制] AMD 模块使用 @module 或 @exports 标识。 解释：\n@exports 与 @module 都可以用来标识模块，区别在于 @module 可以省略模块名称。而只使用 @exports 时在 namepaths 中可以省略 module: 前缀。\n示例：\ndefine(function(require) { /** * foo description * * @exports Foo */ var foo = { // TODO  }; /** * baz description * * @return {boolean} return description */ foo.baz = function() { // TODO  }; return foo; }); 也可以在 exports 变量前使用 @module 标识：\ndefine(function(require) { /** * module description. * * @module foo */ var exports = {}; /** * bar description * */ exports.bar = function() { // TODO  }; return exports; }); 如果直接使用 factory 的 exports 参数，还可以：\n/** * module description. * * @module */ define(function(require, exports) { /** * bar description * */ exports.bar = function() { // TODO  }; return exports; }); [强制] 对于已使用 @module 标识为 AMD 模块 的引用，在 namepaths 中必须增加 module: 作前缀。 解释：\nnamepaths 没有 module: 前缀时，生成的文档中将无法正确生成链接。\n示例：\n/** * 点击处理 * * @fires module:Select#change * @private */ Select.prototype.clickHandler = function() { /** * 值变更时触发 * * @event module:Select#change * @param {Object} e e描述 * @param {string} e.before before描述 * @param {string} e.after after描述 */ this.fire(\u0026#34;change\u0026#34;, { before: \u0026#34;foo\u0026#34;, after: \u0026#34;bar\u0026#34; }); }; [建议] 对于类定义的模块，可以使用 @alias 标识构建函数。 示例：\n/** * A module representing a jacket. * @module jacket */ define(function() { /** * @class * @alias module:jacket */ var Jacket = function() {}; return Jacket; }); [建议] 多模块定义时，可以使用 @exports 标识各个模块。 示例：\n// one module define(\u0026#34;html/utils\u0026#34;, /** * Utility functions to ease working with DOM elements. * @exports html/utils */ function() { var exports = {}; return exports; }); // another module define(\u0026#34;tag\u0026#34;, /** @exports tag */ function() { var exports = {}; return exports; }); [建议] 对于 exports 为 Object 的模块，可以使用@namespace标识。 解释：\n使用 @namespace 而不是 @module 或 @exports 时，对模块的引用可以省略 module: 前缀。\n[建议] 对于 exports 为类名的模块，使用 @class 和 @exports 标识。 示例：\n// 只使用 @class Bar 时，类方法和属性都必须增加 @name Bar#methodName 来标识，与 @exports 配合可以免除这一麻烦，并且在引用时可以省去 module: 前缀。 // 另外需要注意类名需要使用 var 定义的方式。  /** * Bar description * * @see foo * @exports Bar * @class */ var Bar = function() { // TODO }; /** * baz description * * @return {(string|Array)} return description */ Bar.prototype.baz = function() { // TODO }; 2.4.13 细节注释 对于内部实现、不容易理解的逻辑说明、摘要信息等，我们可能需要编写细节注释。\n[建议] 细节注释遵循单行注释的格式。说明必须换行时，每行是一个单行注释的起始。 示例：\nfunction foo(p1, p2, opt_p3) { // 这里对具体内部逻辑进行说明  // 说明太长需要换行  for (...) { .... } } [强制] 有时我们会使用一些特殊标记进行说明。特殊标记必须使用单行注释的形式。下面列举了一些常用标记： 解释：\n TODO: 有功能待实现。此时需要对将要实现的功能进行简单说明。 FIXME: 该处代码运行没问题，但可能由于时间赶或者其他原因，需要修正。此时需要对如何修正进行简单说明。 HACK: 为修正某些问题而写的不太好或者使用了某些诡异手段的代码。此时需要对思路或诡异手段进行描述。 XXX: 该处存在陷阱。此时需要对陷阱进行描述。  3 语言特性 3.1 变量 [强制] 变量、函数在使用前必须先定义。 解释：\n不通过 var 定义变量将导致变量污染全局环境。\n示例：\n// good var name = \u0026#34;MyName\u0026#34;; // bad name = \u0026#34;MyName\u0026#34;; 原则上不建议使用全局变量，对于已有的全局变量或第三方框架引入的全局变量，需要根据检查工具的语法标识。\n示例：\n/* globals jQuery */ var element = jQuery(\u0026#34;#element-id\u0026#34;); [强制] 每个 var 只能声明一个变量。 解释：\n一个 var 声明多个变量，容易导致较长的行长度，并且在修改时容易造成逗号和分号的混淆。\n示例：\n// good var hangModules = []; var missModules = []; var visited = {}; // bad var hangModules = [], missModules = [], visited = {}; [强制] 变量必须 即用即声明，不得在函数或其它形式的代码块起始位置统一声明所有变量。 解释：\n变量声明与使用的距离越远，出现的跨度越大，代码的阅读与维护成本越高。虽然 JavaScript 的变量是函数作用域，还是应该根据编程中的意图，缩小变量出现的距离空间。\n示例：\n// good function kv2List(source) { var list = []; for (var key in source) { if (source.hasOwnProperty(key)) { var item = { k: key, v: source[key] }; list.push(item); } } return list; } // bad function kv2List(source) { var list = []; var key; var item; for (key in source) { if (source.hasOwnProperty(key)) { item = { k: key, v: source[key] }; list.push(item); } } return list; } 3.2 条件 [强制] 在 Equality Expression 中使用类型严格的 ===。仅当判断 null 或 undefined 时，允许使用 == null。 解释：\n使用 === 可以避免等于判断中隐式的类型转换。\n示例：\n// good if (age === 30) { // ...... } // bad if (age == 30) { // ...... } [建议] 尽可能使用简洁的表达式。 示例：\n// 字符串为空  // good if (!name) { // ...... } // bad if (name === \u0026#34;\u0026#34;) { // ...... } // 字符串非空  // good if (name) { // ...... } // bad if (name !== \u0026#34;\u0026#34;) { // ...... } // 数组非空  // good if (collection.length) { // ...... } // bad if (collection.length \u0026gt; 0) { // ...... } // 布尔不成立  // good if (!notTrue) { // ...... } // bad if (notTrue === false) { // ...... } // null 或 undefined  // good if (noValue == null) { // ...... } // bad if (noValue === null || typeof noValue === \u0026#34;undefined\u0026#34;) { // ...... } [建议] 按执行频率排列分支的顺序。 解释：\n按执行频率排列分支的顺序好处是：\n 阅读的人容易找到最常见的情况，增加可读性。 提高执行效率。  [建议] 对于相同变量或表达式的多值条件，用 switch 代替 if。 示例：\n// good switch (typeof variable) { case \u0026#34;object\u0026#34;: // ......  break; case \u0026#34;number\u0026#34;: case \u0026#34;boolean\u0026#34;: case \u0026#34;string\u0026#34;: // ......  break; } // bad var type = typeof variable; if (type === \u0026#34;object\u0026#34;) { // ...... } else if (type === \u0026#34;number\u0026#34; || type === \u0026#34;boolean\u0026#34; || type === \u0026#34;string\u0026#34;) { // ...... } [建议] 如果函数或全局中的 else 块后没有任何语句，可以删除 else。 示例：\n// good function getName() { if (name) { return name; } return \u0026#34;unnamed\u0026#34;; } // bad function getName() { if (name) { return name; } else { return \u0026#34;unnamed\u0026#34;; } } 3.3 循环 [建议] 不要在循环体中包含函数表达式，事先将函数提取到循环体外。 解释：\n循环体中的函数表达式，运行过程中会生成循环次数个函数对象。\n示例：\n// good function clicker() { // ...... } for (var i = 0, len = elements.length; i \u0026lt; len; i++) { var element = elements[i]; addListener(element, \u0026#34;click\u0026#34;, clicker); } // bad for (var i = 0, len = elements.length; i \u0026lt; len; i++) { var element = elements[i]; addListener(element, \u0026#34;click\u0026#34;, function() {}); } [建议] 对循环内多次使用的不变值，在循环外用变量缓存。 示例：\n// good var width = wrap.offsetWidth + \u0026#34;px\u0026#34;; for (var i = 0, len = elements.length; i \u0026lt; len; i++) { var element = elements[i]; element.style.width = width; // ...... } // bad for (var i = 0, len = elements.length; i \u0026lt; len; i++) { var element = elements[i]; element.style.width = wrap.offsetWidth + \u0026#34;px\u0026#34;; // ...... } [建议] 对有序集合进行遍历时，缓存 length。 解释：\n虽然现代浏览器都对数组长度进行了缓存，但对于一些宿主对象和老旧浏览器的数组对象，在每次 length 访问时会动态计算元素个数，此时缓存 length 能有效提高程序性能。\n示例：\nfor (var i = 0, len = elements.length; i \u0026lt; len; i++) { var element = elements[i]; // ...... } [建议] 对有序集合进行顺序无关的遍历时，使用逆序遍历。 解释：\n逆序遍历可以节省变量，代码比较优化。\n示例：\nvar len = elements.length; while (len--) { var element = elements[len]; // ...... } 3.4 类型 3.4.1 类型检测 [建议] 类型检测优先使用 typeof。对象类型检测使用 instanceof。null 或 undefined 的检测使用 == null。 示例：\n// string typeof variable === \u0026#34;string\u0026#34;; // number typeof variable === \u0026#34;number\u0026#34;; // boolean typeof variable === \u0026#34;boolean\u0026#34;; // Function typeof variable === \u0026#34;function\u0026#34;; // Object typeof variable === \u0026#34;object\u0026#34;; // RegExp variable instanceof RegExp; // Array variable instanceof Array; // null variable === null; // null or undefined variable == null; // undefined typeof variable === \u0026#34;undefined\u0026#34;; 3.4.2 类型转换 [建议] 转换成 string 时，使用 + ''。 示例：\n// good num + \u0026#34;\u0026#34;; // bad new String(num); num.toString(); String(num); [建议] 转换成 number 时，通常使用 +。 示例：\n// good +str; // bad Number(str); [建议] string 转换成 number，要转换的字符串结尾包含非数字并期望忽略时，使用 parseInt。 示例：\nvar width = \u0026#34;200px\u0026#34;; parseInt(width, 10); [强制] 使用 parseInt 时，必须指定进制。 示例：\n// good parseInt(str, 10); // bad parseInt(str); [建议] 转换成 boolean 时，使用 !!。 示例：\nvar num = 3.14; !!num; [建议] number 去除小数点，使用 Math.floor / Math.round / Math.ceil，不使用 parseInt。 示例：\n// good var num = 3.14; Math.ceil(num); // bad var num = 3.14; parseInt(num, 10); 3.5 字符串 [强制] 字符串开头和结束使用单引号 '。 解释：\n 输入单引号不需要按住 shift，方便输入。 实际使用中，字符串经常用来拼接 HTML。为方便 HTML 中包含双引号而不需要转义写法。  示例：\nvar str = \u0026#34;我是一个字符串\u0026#34;; var html = \u0026#39;\u0026lt;div class=\u0026#34;cls\u0026#34;\u0026gt;拼接HTML可以省去双引号转义\u0026lt;/div\u0026gt;\u0026#39;; [建议] 使用 数组 或 + 拼接字符串。 解释：\n 使用 + 拼接字符串，如果拼接的全部是 StringLiteral，压缩工具可以对其进行自动合并的优化。所以，静态字符串建议使用 + 拼接。 在现代浏览器下，使用 + 拼接字符串，性能较数组的方式要高。 如需要兼顾老旧浏览器，应尽量使用数组拼接字符串。  示例：\n// 使用数组拼接字符串 var str = [ // 推荐换行开始并缩进开始第一个字符串, 对齐代码, 方便阅读.  \u0026#39;\u0026lt;ul\u0026gt;\u0026#39;, \u0026#39;\u0026lt;li\u0026gt;第一项\u0026lt;/li\u0026gt;\u0026#39;, \u0026#39;\u0026lt;li\u0026gt;第二项\u0026lt;/li\u0026gt;\u0026#39;, \u0026#39;\u0026lt;/ul\u0026gt;\u0026#39; ].join(\u0026#39;\u0026#39;); // 使用 `+` 拼接字符串 var str2 = \u0026#39;\u0026#39; // 建议第一个为空字符串, 第二个换行开始并缩进开始, 对齐代码, 方便阅读  + \u0026#39;\u0026lt;ul\u0026gt;\u0026#39;, + \u0026#39;\u0026lt;li\u0026gt;第一项\u0026lt;/li\u0026gt;\u0026#39;, + \u0026#39;\u0026lt;li\u0026gt;第二项\u0026lt;/li\u0026gt;\u0026#39;, + \u0026#39;\u0026lt;/ul\u0026gt;\u0026#39;; [建议] 使用字符串拼接的方式生成 HTML，需要根据语境进行合理的转义。 解释：\n在 JavaScript 中拼接，并且最终将输出到页面中的字符串，需要进行合理转义，以防止安全漏洞。下面的示例代码为场景说明，不能直接运行。\n示例：\n// HTML 转义 var str = \u0026#34;\u0026lt;p\u0026gt;\u0026#34; + htmlEncode(content) + \u0026#34;\u0026lt;/p\u0026gt;\u0026#34;; // HTML 转义 var str = \u0026#39;\u0026lt;input type=\u0026#34;text\u0026#34; value=\u0026#34;\u0026#39; + htmlEncode(value) + \u0026#39;\u0026#34;\u0026gt;\u0026#39;; // URL 转义 var str = \u0026#39;\u0026lt;a href=\u0026#34;/?key=\u0026#39; + htmlEncode(urlEncode(value)) + \u0026#39;\u0026#34;\u0026gt;link\u0026lt;/a\u0026gt;\u0026#39;; // JavaScript字符串 转义 + HTML 转义 var str = \u0026#34;\u0026lt;button onclick=\\\u0026#34;check(\u0026#39;\u0026#34; + htmlEncode(strLiteral(name)) + \u0026#34;\u0026#39;)\\\u0026#34;\u0026gt;提交\u0026lt;/button\u0026gt;\u0026#34;; [建议] 复杂的数据到视图字符串的转换过程，选用一种模板引擎。 解释：\n使用模板引擎有如下好处：\n 在开发过程中专注于数据，将视图生成的过程由另外一个层级维护，使程序逻辑结构更清晰。 优秀的模板引擎，通过模板编译技术和高质量的编译产物，能获得比手工拼接字符串更高的性能。 模板引擎能方便的对动态数据进行相应的转义，部分模板引擎默认进行 HTML 转义，安全性更好。   artTemplate: 体积较小，在所有环境下性能高，语法灵活。 dot.js: 体积小，在现代浏览器下性能高，语法灵活。 etpl: 体积较小，在所有环境下性能高，模板复用性高，语法灵活。 handlebars: 体积大，在所有环境下性能高，扩展性高。 hogon: 体积小，在现代浏览器下性能高。 nunjucks: 体积较大，性能一般，模板复用性高。  3.6 对象 [强制] 使用对象字面量 ` 示例：\n// good var obj = {}; // bad var obj = new Object(); [建议] 对象创建时，如果一个对象的所有 属性 均可以不添加引号，建议所有 属性 不添加引号。 示例：\nvar info = { name: \u0026#34;someone\u0026#34;, age: 28 }; [建议] 对象创建时，如果任何一个 属性 需要添加引号，则所有 属性 建议添加 '。 解释：\n如果属性不符合 Identifier 和 NumberLiteral 的形式，就需要以 StringLiteral 的形式提供。\n示例：\n// good var info = { name: \u0026#34;someone\u0026#34;, age: 28, \u0026#34;more-info\u0026#34;: \u0026#34;...\u0026#34; }; // bad var info = { name: \u0026#34;someone\u0026#34;, age: 28, \u0026#34;more-info\u0026#34;: \u0026#34;...\u0026#34; }; [强制] 不允许修改和扩展任何原生对象和宿主对象的原型。 示例：\n// 以下行为绝对禁止 String.prototype.trim = function() {}; [建议] 属性访问时，尽量使用 .。 解释：\n属性名符合 Identifier 的要求，就可以通过 . 来访问，否则就只能通过 [expr] 方式访问。\n通常在 JavaScript 中声明的对象，属性命名是使用 Camel 命名法，用 . 来访问更清晰简洁。部分特殊的属性（比如来自后端的 JSON ），可能采用不寻常的命名方式，可以通过 [expr] 方式访问。\n示例：\ninfo.age; info[\u0026#34;more-info\u0026#34;]; [建议] for in 遍历对象时, 使用 hasOwnProperty 过滤掉原型中的属性。 示例：\nvar newInfo = {}; for (var key in info) { if (info.hasOwnProperty(key)) { newInfo[key] = info[key]; } } 3.7 数组 [强制] 使用数组字面量 [] 创建新数组，除非想要创建的是指定长度的数组。 示例：\n// good var arr = []; // bad var arr = new Array(); [强制] 遍历数组不使用 for in。 解释：\n数组对象可能存在数字以外的属性, 这种情况下 for in 不会得到正确结果。\n示例：\nvar arr = [\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;]; // 这里仅作演示, 实际中应使用 Object 类型 arr.other = \u0026#34;other things\u0026#34;; // 正确的遍历方式 for (var i = 0, len = arr.length; i \u0026lt; len; i++) { console.log(i); } // 错误的遍历方式 for (var i in arr) { console.log(i); } [建议] 不因为性能的原因自己实现数组排序功能，尽量使用数组的 sort 方法。 解释：\n自己实现的常规排序算法，在性能上并不优于数组默认的 sort 方法。以下两种场景可以自己实现排序：\n 需要稳定的排序算法，达到严格一致的排序结果。 数据特点鲜明，适合使用桶排。  [建议] 清空数组使用 .length = 0。 3.8 函数 3.8.1 函数长度 [建议] 一个函数的长度控制在 50 行以内。 解释：\n将过多的逻辑单元混在一个大函数中，易导致难以维护。一个清晰易懂的函数应该完成单一的逻辑单元。复杂的操作应进一步抽取，通过函数的调用来体现流程。\n特定算法等不可分割的逻辑允许例外。\n示例：\nfunction syncViewStateOnUserAction() { if (x.checked) { y.checked = true; z.value = \u0026#34;\u0026#34;; } else { y.checked = false; } if (a.value) { warning.innerText = \u0026#34;\u0026#34;; submitButton.disabled = false; } else { warning.innerText = \u0026#34;Please enter it\u0026#34;; submitButton.disabled = true; } } // 直接阅读该函数会难以明确其主线逻辑，因此下方是一种更合理的表达方式：  function syncViewStateOnUserAction() { syncXStateToView(); checkAAvailability(); } function syncXStateToView() { y.checked = x.checked; if (x.checked) { z.value = \u0026#34;\u0026#34;; } } function checkAAvailability() { if (a.value) { clearWarnignForA(); } else { displayWarningForAMissing(); } } 3.8.2 参数设计 [建议] 一个函数的参数控制在 6 个以内。 解释：\n除去不定长参数以外，函数具备不同逻辑意义的参数建议控制在 6 个以内，过多参数会导致维护难度增大。\n某些情况下，如使用 AMD Loader 的 require 加载多个模块时，其 callback 可能会存在较多参数，因此对函数参数的个数不做强制限制。\n[建议] 通过 options 参数传递非数据输入型参数。 解释：\n有些函数的参数并不是作为算法的输入，而是对算法的某些分支条件判断之用，此类参数建议通过一个 options 参数传递。\n如下函数：\n/** * 移除某个元素 * * @param {Node} element 需要移除的元素 * @param {boolean} removeEventListeners 是否同时将所有注册在元素上的事件移除 */ function removeElement(element, removeEventListeners) { element.parent.removeChild(element); if (removeEventListeners) { element.clearEventListeners(); } } 可以转换为下面的签名：\n/** * 移除某个元素 * * @param {Node} element 需要移除的元素 * @param {Object} options 相关的逻辑配置 * @param {boolean} options.removeEventListeners 是否同时将所有注册在元素上的事件移除 */ function removeElement(element, options) { element.parent.removeChild(element); if (options.removeEventListeners) { element.clearEventListeners(); } } 这种模式有几个显著的优势：\n boolean 型的配置项具备名称，从调用的代码上更易理解其表达的逻辑意义。 当配置项有增长时，无需无休止地增加参数个数，不会出现 removeElement(element, true, false, false, 3) 这样难以理解的调用代码。 当部分配置参数可选时，多个参数的形式非常难处理重载逻辑，而使用一个 options 对象只需判断属性是否存在，实现得以简化。  3.8.3 闭包 [建议] 在适当的时候将闭包内大对象置为 null。 解释：\n在 JavaScript 中，无需特别的关键词就可以使用闭包，一个函数可以任意访问在其定义的作用域外的变量。需要注意的是，函数的作用域是静态的，即在定义时决定，与调用的时机和方式没有任何关系。\n闭包会阻止一些变量的垃圾回收，对于较老旧的 JavaScript 引擎，可能导致外部所有变量均无法回收。\n首先一个较为明确的结论是，以下内容会影响到闭包内变量的回收：\n 嵌套的函数中是否有使用该变量。 嵌套的函数中是否有 直接调用 eval。 是否使用了 with 表达式。  Chakra、V8 和 SpiderMonkey 将受以上因素的影响，表现出不尽相同又较为相似的回收策略，而 JScript.dll 和 Carakan 则完全没有这方面的优化，会完整保留整个 LexicalEnvironment 中的所有变量绑定，造成一定的内存消耗。\n由于对闭包内变量有回收优化策略的 Chakra、V8 和 SpiderMonkey 引擎的行为较为相似，因此可以总结如下，当返回一个函数 fn 时：\n 如果 fn 的 [[Scope]] 是 ObjectEnvironment（with 表达式生成 ObjectEnvironment，函数和 catch 表达式生成 DeclarativeEnvironment），则：  如果是 V8 引擎，则退出全过程。 如果是 SpiderMonkey，则处理该 ObjectEnvironment 的外层 LexicalEnvironment。   获取当前 LexicalEnvironment 下的所有类型为 Function 的对象，对于每一个 Function 对象，分析其 FunctionBody：  如果 FunctionBody 中含有 直接调用 eval，则退出全过程。 否则得到所有的 Identifier。 对于每一个 Identifier，设其为 name，根据查找变量引用的规则，从 LexicalEnvironment 中找出名称为 name 的绑定 binding。 对 binding 添加 notSwap 属性，其值为 true。   检查当前 LexicalEnvironment 中的每一个变量绑定，如果该绑定有 notSwap 属性且值为 true，则：  如果是 V8 引擎，删除该绑定。 如果是 SpiderMonkey，将该绑定的值设为 undefined，将删除 notSwap 属性。    对于 Chakra 引擎，暂无法得知是按 V8 的模式还是按 SpiderMonkey 的模式进行。\n如果有 非常庞大 的对象，且预计会在 老旧的引擎 中执行，则使用闭包时，注意将闭包不需要的对象置为空引用。\n[建议] 使用 IIFE 避免 Lift 效应。 解释：\n在引用函数外部变量时，函数执行时外部变量的值由运行时决定而非定义时，最典型的场景如下：\nvar tasks = []; for (var i = 0; i \u0026lt; 5; i++) { tasks[tasks.length] = function() { console.log(\u0026#34;Current cursor is at \u0026#34; + i); }; } var len = tasks.length; while (len--) { tasks[len](); } 以上代码对 tasks 中的函数的执行均会输出 Current cursor is at 5，往往不符合预期。\n此现象称为 Lift 效应 。解决的方式是通过额外加上一层闭包函数，将需要的外部变量作为参数传递来解除变量的绑定关系：\nvar tasks = []; for (var i = 0; i \u0026lt; 5; i++) { // 注意有一层额外的闭包  tasks[tasks.length] = (function(i) { return function() { console.log(\u0026#34;Current cursor is at \u0026#34; + i); }; })(i); } var len = tasks.length; while (len--) { tasks[len](); } 3.8.4 空函数 [建议] 空函数不使用 new Function() 的形式。 示例：\nvar emptyFunction = function() {}; [建议] 对于性能有高要求的场合，建议存在一个空函数的常量，供多处使用共享。 示例：\nvar EMPTY_FUNCTION = function() {}; function MyClass() {} MyClass.prototype.abstractMethod = EMPTY_FUNCTION; MyClass.prototype.hooks.before = EMPTY_FUNCTION; MyClass.prototype.hooks.after = EMPTY_FUNCTION; 3.9 面向对象 [强制] 类的继承方案，实现时需要修正 constructor。 解释：\n通常使用其他 library 的类继承方案都会进行 constructor 修正。如果是自己实现的类继承方案，需要进行 constructor 修正。\n示例：\n/** * 构建类之间的继承关系 * * @param {Function} subClass 子类函数 * @param {Function} superClass 父类函数 */ function inherits(subClass, superClass) { var F = new Function(); F.prototype = superClass.prototype; subClass.prototype = new F(); subClass.prototype.constructor = subClass; } [建议] 声明类时，保证 constructor 的正确性。 示例：\nfunction Animal(name) { this.name = name; } // 直接prototype等于对象时，需要修正constructor Animal.prototype = { constructor: Animal, jump: function() { alert(\u0026#34;animal \u0026#34; + this.name + \u0026#34; jump\u0026#34;); } }; // 这种方式扩展prototype则无需理会constructor Animal.prototype.jump = function() { alert(\u0026#34;animal \u0026#34; + this.name + \u0026#34; jump\u0026#34;); }; [建议] 属性在构造函数中声明，方法在原型中声明。 解释：\n原型对象的成员被所有实例共享，能节约内存占用。所以编码时我们应该遵守这样的原则：原型对象包含程序不会修改的成员，如方法函数或配置项。\nfunction TextNode(value, engine) { this.value = value; this.engine = engine; } TextNode.prototype.clone = function() { return this; }; [强制] 自定义事件的 事件名 必须全小写。 解释：\n在 JavaScript 广泛应用的浏览器环境，绝大多数 DOM 事件名称都是全小写的。为了遵循大多数 JavaScript 开发者的习惯，在设计自定义事件时，事件名也应该全小写。\n[强制] 自定义事件只能有一个 event 参数。如果事件需要传递较多信息，应仔细设计事件对象。 解释：\n一个事件对象的好处有：\n 顺序无关，避免事件监听者需要记忆参数顺序。 每个事件信息都可以根据需要提供或者不提供，更自由。 扩展方便，未来添加事件信息时，无需考虑会破坏监听器参数形式而无法向后兼容。  [建议] 设计自定义事件时，应考虑禁止默认行为。 解释：\n常见禁止默认行为的方式有两种：\n 事件监听函数中 return false。 事件对象中包含禁止默认行为的方法，如 preventDefault。  3.10 动态特性 3.10.1 eval [强制] 避免使用直接 eval 函数。 解释：\n直接 eval，指的是以函数方式调用 eval 的调用方法。直接 eval 调用执行代码的作用域为本地作用域，应当避免。\n如果有特殊情况需要使用直接 eval，需在代码中用详细的注释说明为何必须使用直接 eval，不能使用其它动态执行代码的方式，同时需要其他资深工程师进行 Code Review。\n[建议] 尽量避免使用 eval 函数。 3.10.2 动态执行代码 [建议] 使用 new Function 执行动态代码。 解释：\n通过 new Function 生成的函数作用域是全局使用域，不会影响当当前的本地作用域。如果有动态代码执行的需求，建议使用 new Function。\n示例：\nvar handler = new Function(\u0026#34;x\u0026#34;, \u0026#34;y\u0026#34;, \u0026#34;return x + y;\u0026#34;); var result = handler($(\u0026#34;#x\u0026#34;).val(), $(\u0026#34;#y\u0026#34;).val()); 3.10.3 with [建议] 尽量不要使用 with。 解释：\n使用 with 可能会增加代码的复杂度，不利于阅读和管理；也会对性能有影响。大多数使用 with 的场景都能使用其他方式较好的替代。所以，尽量不要使用 with。\n3.10.4 delete [建议] 减少 delete 的使用。 解释：\n如果没有特别的需求，减少或避免使用 delete。delete 的使用会破坏部分 JavaScript 引擎的性能优化。\n[建议] 处理 delete 可能产生的异常。 解释：\n对于有被遍历需求，且值 null 被认为具有业务逻辑意义的值的对象，移除某个属性必须使用 delete 操作。\n在严格模式或 IE 下使用 delete 时，不能被删除的属性会抛出异常，因此在不确定属性是否可以删除的情况下，建议添加 try-catch 块。\n示例：\ntry { delete o.x; } catch (deleteError) { o.x = null; } 3.10.5 对象属性 [建议] 避免修改外部传入的对象。 解释：\nJavaScript 因其脚本语言的动态特性，当一个对象未被 seal 或 freeze 时，可以任意添加、删除、修改属性值。\n但是随意地对 非自身控制的对象 进行修改，很容易造成代码在不可预知的情况下出现问题。因此，设计良好的组件、函数应该避免对外部传入的对象的修改。\n下面代码的 selectNode 方法修改了由外部传入的 datasource 对象。如果 datasource 用在其它场合（如另一个 Tree 实例）下，会造成状态的混乱。\nfunction Tree(datasource) { this.datasource = datasource; } Tree.prototype.selectNode = function(id) { // 从datasource中找出节点对象  var node = this.findNode(id); if (node) { node.selected = true; this.flushView(); } }; 对于此类场景，需要使用额外的对象来维护，使用由自身控制，不与外部产生任何交互的 selectedNodeIndex 对象来维护节点的选中状态，不对 datasource 作任何修改。\nfunction Tree(datasource) { this.datasource = datasource; this.selectedNodeIndex = {}; } Tree.prototype.selectNode = function(id) { // 从datasource中找出节点对象  var node = this.findNode(id); if (node) { this.selectedNodeIndex[id] = true; this.flushView(); } }; 除此之外，也可以通过 deepClone 等手段将自身维护的对象与外部传入的分离，保证不会相互影响。\n[建议] 具备强类型的设计。 解释：\n 如果一个属性被设计为 boolean 类型，则不要使用 1 或 0 作为其值。对于标识性的属性，如对代码体积有严格要求，可以从一开始就设计为 number 类型且将 0 作为否定值。 从 DOM 中取出的值通常为 string 类型，如果有对象或函数的接收类型为 number 类型，提前作好转换，而不是期望对象、函数可以处理多类型的值。  4 浏览器环境 4.1 模块化 4.1.1 AMD [强制] 使用 AMD 作为模块定义。 解释：\nAMD 作为由社区认可的模块定义形式，提供多种重载提供灵活的使用方式，并且绝大多数优秀的 Library 都支持 AMD，适合作为规范。\n目前，比较成熟的 AMD Loader 有：\n 官方实现的 requirejs 百度自己实现的 esl  [强制] 模块 id 必须符合标准。 解释：\n模块 id 必须符合以下约束条件：\n 类型为 string，并且是由 / 分割的一系列 terms 来组成。例如：this/is/a/module。 term 应该符合 [a-zA-Z0-9_-:]+ 规则。 不应该有 .js 后缀。 跟文件的路径保持一致。  4.1.2 define [建议] 定义模块时不要指明 id 和 dependencies。 解释：\n在 AMD 的设计思想里，模块名称是和所在路径相关的，匿名的模块更利于封包和迁移。模块依赖应在模块定义内部通过 local require 引用。\n所以，推荐使用 define(factory) 的形式进行模块定义。\n示例：\ndefine(function(require) {}); [建议] 使用 return 来返回模块定义。 解释：\n使用 return 可以减少 factory 接收的参数（不需要接收 exports 和 module），在没有 AMD Loader 的场景下也更容易进行简单的处理来伪造一个 Loader。\n示例：\ndefine(function(require) { var exports = {}; // ...  return exports; }); 4.1.3 require [强制] 全局运行环境中，require 必须以 async require 形式调用。 解释：\n模块的加载过程是异步的，同步调用并无法保证得到正确的结果。\n示例：\n// good require([\u0026#34;foo\u0026#34;], function(foo) {}); // bad var foo = require(\u0026#34;foo\u0026#34;); [强制] 模块定义中只允许使用 local require，不允许使用 global require。 解释：\n 在模块定义中使用 global require，对封装性是一种破坏。 在 AMD 里，global require 是可以被重命名的。并且 Loader 甚至没有全局的 require 变量，而是用 Loader 名称做为 global require。模块定义不应该依赖使用的 Loader。  [强制] Package 在实现时，内部模块的 require 必须使用 relative id。 解释：\n对于任何可能通过 发布-引入 的形式复用的第三方库、框架、包，开发者所定义的名称不代表使用者使用的名称。因此不要基于任何名称的假设。在实现源码中，require 自身的其它模块时使用 relative id。\n示例：\ndefine(function(require) { var util = require(\u0026#34;./util\u0026#34;); }); [建议] 不会被调用的依赖模块，在 factory 开始处统一 require。 解释：\n有些模块是依赖的模块，但不会在模块实现中被直接调用，最为典型的是 css / js / tpl 等 Plugin 所引入的外部内容。此类内容建议放在模块定义最开始处统一引用。\n示例：\ndefine(function(require) { require(\u0026#34;css!foo.css\u0026#34;); require(\u0026#34;tpl!bar.tpl.html\u0026#34;); // ... }); 4.2 DOM 4.2.1 元素获取 [建议] 对于单个元素，尽可能使用 document.getElementById 获取，避免使用document.all。 [建议] 对于多个元素的集合，尽可能使用 context.getElementsByTagName 获取。其中 context 可以为 document 或其他元素。指定 tagName 参数为 * 可以获得所有子元素。 [建议] 遍历元素集合时，尽量缓存集合长度。如需多次操作同一集合，则应将集合转为数组。 解释：\n原生获取元素集合的结果并不直接引用 DOM 元素，而是对索引进行读取，所以 DOM 结构的改变会实时反映到结果中。\n示例：\n\u0026lt;div\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;span\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;script\u0026gt; var elements = document.getElementsByTagName(\u0026#34;*\u0026#34;); // 显示为 DIV  alert(elements[0].tagName); var div = elements[0]; var p = document.createElement(\u0026#34;p\u0026#34;); docpment.body.insertBefore(p, div); // 显示为 P  alert(elements[0].tagName); \u0026lt;/script\u0026gt; [建议] 获取元素的直接子元素时使用 children。避免使用childNodes，除非预期是需要包含文本、注释和属性类型的节点。 4.2.2 样式获取 [建议] 获取元素实际样式信息时，应使用 getComputedStyle 或 currentStyle。 解释：\n通过 style 只能获得内联定义或通过 JavaScript 直接设置的样式。通过 CSS class 设置的元素样式无法直接通过 style 获取。\n4.2.3 样式设置 [建议] 尽可能通过为元素添加预定义的 className 来改变元素样式，避免直接操作 style 设置。 [强制] 通过 style 对象设置元素样式时，对于带单位非 0 值的属性，不允许省略单位。 解释：\n除了 IE，标准浏览器会忽略不规范的属性值，导致兼容性问题。\n4.2.4 DOM 操作 [建议] 操作 DOM 时，尽量减少页面 reflow。 解释：\n页面 reflow 是非常耗时的行为，非常容易导致性能瓶颈。下面一些场景会触发浏览器的 reflow：\n DOM 元素的添加、修改（内容）、删除。 应用新的样式或者修改任何影响元素布局的属性。 Resize 浏览器窗口、滚动页面。 读取元素的某些属性（offsetLeft、offsetTop、offsetHeight、offsetWidth、scrollTop/Left/Width/Height、clientTop/Left/Width/Height、getComputedStyle()、currentStyle(in IE)) 。  [建议] 尽量减少 DOM 操作。 解释：\nDOM 操作也是非常耗时的一种操作，减少 DOM 操作有助于提高性能。举一个简单的例子，构建一个列表。我们可以用两种方式：\n 在循环体中 createElement 并 append 到父元素中。 在循环体中拼接 HTML 字符串，循环结束后写父元素的 innerHTML。  第一种方法看起来比较标准，但是每次循环都会对 DOM 进行操作，性能极低。在这里推荐使用第二种方法。\n4.2.5 DOM 事件 [建议] 优先使用 addEventListener / attachEvent 绑定事件，避免直接在 HTML 属性中或 DOM 的 expando 属性绑定事件处理。 解释：\nexpando 属性绑定事件容易导致互相覆盖。\n[建议] 使用 addEventListener 时第三个参数使用 false。 解释：\n标准浏览器中的 addEventListener 可以通过第三个参数指定两种时间触发模型：冒泡和捕获。而 IE 的 attachEvent 仅支持冒泡的事件触发。所以为了保持一致性，通常 addEventListener 的第三个参数都为 false。\n[建议] 在没有事件自动管理的框架支持下，应持有监听器函数的引用，在适当时候（元素释放、页面卸载等）移除添加的监听器。 "});index.add({'id':58,'href':'/note-cs/docs/basic/pl/objective-c/basic/practice/spec/baidu/','title':"百度",'content':"百度 Objective-C 编码规范 (2019 版) "});index.add({'id':59,'href':'/note-cs/docs/basic/pl/php/basic/practice/spec/baidu/','title':"百度",'content':"百度 PHP 编码规范 (201904 版) "});index.add({'id':60,'href':'/note-cs/docs/basic/pl/javascript/basic/practice/spec/baidu/','title':"百度前端编程规范",'content':"百度前端编程规范 "});index.add({'id':61,'href':'/note-cs/docs/basic/pl/rust/basic/','title':"第一部分 Rust 基础",'content':""});index.add({'id':62,'href':'/note-cs/docs/basic/','title':"第一部分 基础",'content':""});index.add({'id':63,'href':'/note-cs/docs/basic/db/mysql/basic/','title':"第一部分 基础入门",'content':""});index.add({'id':64,'href':'/note-cs/docs/basic/db/postgresql/basic/','title':"第一部分 基础入门",'content':""});index.add({'id':65,'href':'/note-cs/docs/basic/db/redis/basic/','title':"第一部分 基础入门",'content':""});index.add({'id':66,'href':'/note-cs/docs/basic/os/android/basic/','title':"第一部分 基础入门",'content':""});index.add({'id':67,'href':'/note-cs/docs/basic/os/ios/basic/','title':"第一部分 基础入门",'content':""});index.add({'id':68,'href':'/note-cs/docs/basic/os/macos/basic/','title':"第一部分 基础入门",'content':""});index.add({'id':69,'href':'/note-cs/docs/basic/os/unix/basic/','title':"第一部分 基础入门",'content':""});index.add({'id':70,'href':'/note-cs/docs/basic/os/windows/basic/','title':"第一部分 基础入门",'content':""});index.add({'id':71,'href':'/note-cs/docs/basic/pl/c/basic/','title':"第一部分 基础入门",'content':""});index.add({'id':72,'href':'/note-cs/docs/basic/pl/cpp/basic/','title':"第一部分 基础入门",'content':""});index.add({'id':73,'href':'/note-cs/docs/basic/pl/csharp/basic/','title':"第一部分 基础入门",'content':""});index.add({'id':74,'href':'/note-cs/docs/basic/pl/java/basic/','title':"第一部分 基础入门",'content':""});index.add({'id':75,'href':'/note-cs/docs/basic/pl/javascript/basic/','title':"第一部分 基础入门",'content':""});index.add({'id':76,'href':'/note-cs/docs/basic/pl/kotlin/basic/','title':"第一部分 基础入门",'content':""});index.add({'id':77,'href':'/note-cs/docs/basic/pl/lua/basic/','title':"第一部分 基础入门",'content':""});index.add({'id':78,'href':'/note-cs/docs/basic/pl/objective-c/basic/','title':"第一部分 基础入门",'content':""});index.add({'id':79,'href':'/note-cs/docs/basic/pl/php/basic/','title':"第一部分 基础入门",'content':""});index.add({'id':80,'href':'/note-cs/docs/basic/pl/ruby/basic/','title':"第一部分 基础入门",'content':""});index.add({'id':81,'href':'/note-cs/docs/basic/pl/scala/basic/','title':"第一部分 基础入门",'content':""});index.add({'id':82,'href':'/note-cs/docs/basic/pl/swift/basic/','title':"第一部分 基础入门",'content':""});index.add({'id':83,'href':'/note-cs/docs/direction/be/frame/nodejs/basic/','title':"第一部分 基础入门",'content':""});index.add({'id':84,'href':'/note-cs/docs/direction/client/android/basic/','title':"第一部分 基础入门",'content':""});index.add({'id':85,'href':'/note-cs/docs/direction/client/ios/basic/','title':"第一部分 基础入门",'content':""});index.add({'id':86,'href':'/note-cs/docs/direction/client/xiaochengxu/basic/','title':"第一部分 基础入门",'content':""});index.add({'id':87,'href':'/note-cs/docs/direction/embedded/basic/','title':"第一部分 基础入门",'content':""});index.add({'id':88,'href':'/note-cs/docs/direction/fe/frame/angular/basic/','title':"第一部分 基础入门",'content':""});index.add({'id':89,'href':'/note-cs/docs/direction/fe/frame/react/basic/','title':"第一部分 基础入门",'content':""});index.add({'id':90,'href':'/note-cs/docs/direction/fe/frame/vue/basic/','title':"第一部分 基础入门",'content':""});index.add({'id':91,'href':'/note-cs/docs/direction/security/basic/','title':"第一部分 基础入门",'content':""});index.add({'id':92,'href':'/note-cs/docs/domain/cc/knative/basic/','title':"第一部分 基础入门",'content':""});index.add({'id':93,'href':'/note-cs/docs/basic/db/mysql/basic/practice/spec/','title':"编程规范",'content':"编程规范 "});index.add({'id':94,'href':'/note-cs/docs/basic/db/postgresql/basic/practice/spec/','title':"编程规范",'content':"编程规范 "});index.add({'id':95,'href':'/note-cs/docs/basic/db/redis/basic/practice/spec/','title':"编程规范",'content':"编程规范 "});index.add({'id':96,'href':'/note-cs/docs/basic/pl/c/basic/practice/spec/','title':"编程规范",'content':"编程规范 "});index.add({'id':97,'href':'/note-cs/docs/basic/pl/cpp/basic/practice/spec/','title':"编程规范",'content':"编程规范 "});index.add({'id':98,'href':'/note-cs/docs/basic/pl/java/basic/practice/spec/','title':"编程规范",'content':"Java 编程规范 "});index.add({'id':99,'href':'/note-cs/docs/basic/pl/javascript/basic/practice/spec/','title':"编程规范",'content':"编程规范 "});index.add({'id':100,'href':'/note-cs/docs/basic/pl/objective-c/basic/practice/spec/','title':"编程规范",'content':"编程规范 "});index.add({'id':101,'href':'/note-cs/docs/basic/pl/php/basic/practice/spec/','title':"编程规范",'content':"编程规范 "});index.add({'id':102,'href':'/note-cs/docs/basic/pl/rust/basic/practice/spec/','title':"编程规范",'content':"编程规范 "});index.add({'id':103,'href':'/note-cs/docs/direction/be/frame/nodejs/basic/practice/spec/','title':"编程规范",'content':"编程规范 "});index.add({'id':104,'href':'/note-cs/docs/direction/client/android/basic/practice/spec/','title':"编程规范",'content':"编程规范 "});index.add({'id':105,'href':'/note-cs/docs/direction/client/ios/basic/practice/spec/','title':"编程规范",'content':"编程规范 "});index.add({'id':106,'href':'/note-cs/docs/direction/client/xiaochengxu/basic/practice/spec/','title':"编程规范",'content':"编程规范 "});index.add({'id':107,'href':'/note-cs/docs/direction/embedded/basic/practice/spec/','title':"编程规范",'content':"编程规范 "});index.add({'id':108,'href':'/note-cs/docs/direction/fe/frame/angular/basic/practice/spec/','title':"编程规范",'content':"编程规范 "});index.add({'id':109,'href':'/note-cs/docs/direction/fe/frame/react/basic/practice/spec/','title':"编程规范",'content':"编程规范 "});index.add({'id':110,'href':'/note-cs/docs/direction/fe/frame/vue/basic/practice/spec/','title':"编程规范",'content':"编程规范 "});index.add({'id':111,'href':'/note-cs/docs/direction/security/basic/practice/spec/','title':"编程规范",'content':"编程规范 "});index.add({'id':112,'href':'/note-cs/docs/domain/cc/knative/basic/practice/spec/','title':"编程规范",'content':"编程规范 "});index.add({'id':113,'href':'/note-cs/docs/basic/pl/c/basic/grammar/','title':"语法",'content':"C 语法 "});index.add({'id':114,'href':'/note-cs/docs/basic/pl/cpp/basic/grammar/','title':"语法",'content':"C++ 语法 "});index.add({'id':115,'href':'/note-cs/docs/direction/fe/css/','title':"CSS",'content':"CSS "});index.add({'id':116,'href':'/note-cs/docs/basic/compile/make/makefile/','title':"makefile",'content':"makefile 简介 Makefile 用于定义如何创建目标文件，比如如何从源码到可执行文件。创建这一工具的目标是 减少不必要的编译或者任务。传说 Stuart Feldman 在 1976 年花了一个周末写出来的， 而今仍然使用广泛，特别是在 Unix 和 Linux 系统上。\n基础 语法  注释：# 文件名： 必须是 Makefile  区分大小写   make \u0026lt;target\u0026gt; 生成 target  重命名：make -f \u0026quot;filename\u0026quot; \u0026lt;target\u0026gt;   只认识 TAB，不认识空格  但是在 GNU Make 3.82 之后, 可以通过设置参数 .RECIPEPREFIX 进行修改   shell 符号  @：不把命令打印到 stdout -：发生错误了也没关系    target 声明  创建一个 target： targets : prerequisites recipe  prerequisites(依赖) 是可选的, recipe(做法) 也可以多个或者不给 targets 和 prerequisites 都可以是多个, 以空格分割 file2.txt file3.txt: file0.txt file1.txt touch file2.txt touch file3.txt    target 的声明顺序并不重要  上面的依赖可以下面再声明   如果声明重复的 target，make 会给一个 warning，后面会覆盖前面的  但是如果不定义任何 recipe, 就不会冲突, 只是多了依赖关系 file2.txt: file0.txt file3.txt    Phony(假的) Targets  意思是 tagets 并不是文件, 可以想象成一个任务的名字而已 因为不是文件, 无法比对是否有更新, 所以每次 make 都会执行 依赖于 phony target 的 target 也会每次 make 都执行, 即使 target 是文件   .PHONY  如果定义的 phony target 与文件名重名, 可以用 .PHONY 显式地指明哪些 targets 是 phony    常用 phony target  all clean install uninstall  变量与通配符  $^: 代表 prerequisites # 即便分开定义依赖, $^ 依然能拿到 # 非常智能的, ex1.txt 会被找到, file0.txt 会被去重 process: ex1.txt file0.txt @echo $^  $@: 代表 target, 如果 target 为多个, $@ 代表当前执行的那个 $\u0026lt;: prerequisite 中的第一个 $?: 需要更新的 prerequisite 文件列表 $+: 所有依赖, 包括重复的 $|: 竖线后面的 order-only prerequisites $*: target % 那部分, 包括路径 a.%.b: # $* match 的target % 那部分, 包括路径, 比如 `make dir/a.foo.b` 会打出 `dir/foo` @echo $*   模式匹配  make 会找到最具体的匹配  make small/foo.png 则会匹配下面这个规则（在这之前要先有 small/foo.svg 这个文件） %.png: %.svg inkscape --export-png $^ small/%.png: %.svg inkscape --export-png --export-dpi 30 $^    make 已经有一些内置的规则, 比如从 *.c 到 *.o  变量   变量都是字符串类型\n# 这俩是一样一样的 name = Ted name2=\u0026#34;Sarah\u0026#34;   设置变量，按以下顺序由高到低:\n 命令行参数. 比如试试 make echo name3=JICHAO Makefile 里面的 shell 中的环境变量 make 预设的一些变量    ?=\n# 如果 name 被设置过了, 就不设置了 name ?= Jean   override\n# 用 override 可以防止命令行参数设置的覆盖 override name = David ``   +\n# 用加号可以连接 (中间用空格分割) name4 +=grey   内置的变量\necho_inbuilt: echo $(CC) echo ${CXX)} echo $(FC) echo ${CFLAGS)} echo $(CPPFLAGS) echo ${CXXFLAGS} echo $(LDFLAGS) echo ${LDLIBS}   :=\n 等号声明时 recursively expanded 递归扩展 加个冒号可以声明 Simply expanded variables 即时扩展变量, 即只在声明时扩展一次  # var3 声明时找不到 var4, var3 会扩展成 `and good luck`，直接忽视 var4 var3 := $(var4) and good luck # var5 是正常的，扩展为 `good night and good luck` var5 = $(var4) and good luck var4 := good night   函数   函数调用格式\n$(func arg0,arg1,arg2...)   wildcard：将后面的通配符变成一串文件路径\n  patsubst：做替换\n# 把所有 markdown 后缀的文件重命名为 md 后缀 substitue: * @echo $(patsubst %.markdown,%.md,$* $^)   指令  include：引入别的 Makefile 文件 流程控制语句顶格写 sport = tennis # 流程控制语句 (如if else 等等) 顶格写 report: ifeq ($(sport),tennis) @echo \u0026#39;game, set, match\u0026#39; else @echo \u0026#34;They think it\u0026#39;s all over; it is now\u0026#34; endif    分支和变体 GNU make  进阶  原理 "});index.add({'id':117,'href':'/note-cs/docs/basic/db/mysql/appendix/interview/basic/','title':"基础",'content':"基础面试题 "});index.add({'id':118,'href':'/note-cs/docs/basic/db/postgresql/appendix/interview/basic/','title':"基础",'content':"基础面试题 "});index.add({'id':119,'href':'/note-cs/docs/basic/db/redis/appendix/interview/basic/','title':"基础",'content':"基础面试题 "});index.add({'id':120,'href':'/note-cs/docs/basic/os/android/appendix/interview/basic/','title':"基础",'content':"基础面试题 "});index.add({'id':121,'href':'/note-cs/docs/basic/os/ios/appendix/interview/basic/','title':"基础",'content':"基础面试题 "});index.add({'id':122,'href':'/note-cs/docs/basic/os/macos/appendix/interview/basic/','title':"基础",'content':"基础面试题 "});index.add({'id':123,'href':'/note-cs/docs/basic/os/unix/appendix/interview/basic/','title':"基础",'content':"基础面试题 "});index.add({'id':124,'href':'/note-cs/docs/basic/os/windows/appendix/interview/basic/','title':"基础",'content':"基础面试题 "});index.add({'id':125,'href':'/note-cs/docs/basic/pl/c/appendix/interview/basic/','title':"基础",'content':"基础面试题 "});index.add({'id':126,'href':'/note-cs/docs/basic/pl/cpp/appendix/interview/basic/','title':"基础",'content':"基础面试题 "});index.add({'id':127,'href':'/note-cs/docs/basic/pl/csharp/appendix/interview/basic/','title':"基础",'content':"基础面试题 "});index.add({'id':128,'href':'/note-cs/docs/basic/pl/java/appendix/interview/basic/','title':"基础",'content':"Java 基础面试题 "});index.add({'id':129,'href':'/note-cs/docs/basic/pl/javascript/appendix/interview/basic/','title':"基础",'content':"基础面试题 "});index.add({'id':130,'href':'/note-cs/docs/basic/pl/kotlin/appendix/interview/basic/','title':"基础",'content':"基础面试题 "});index.add({'id':131,'href':'/note-cs/docs/basic/pl/lua/appendix/interview/basic/','title':"基础",'content':"基础面试题 "});index.add({'id':132,'href':'/note-cs/docs/basic/pl/objective-c/appendix/interview/basic/','title':"基础",'content':"基础面试题 "});index.add({'id':133,'href':'/note-cs/docs/basic/pl/php/appendix/interview/basic/','title':"基础",'content':"基础面试题 "});index.add({'id':134,'href':'/note-cs/docs/basic/pl/ruby/appendix/interview/basic/','title':"基础",'content':"基础面试题 "});index.add({'id':135,'href':'/note-cs/docs/basic/pl/rust/appendix/interview/basic/','title':"基础",'content':"基础面试题 "});index.add({'id':136,'href':'/note-cs/docs/basic/pl/scala/appendix/interview/basic/','title':"基础",'content':"基础面试题 "});index.add({'id':137,'href':'/note-cs/docs/basic/pl/swift/appendix/interview/basic/','title':"基础",'content':"基础面试题 "});index.add({'id':138,'href':'/note-cs/docs/direction/be/frame/nodejs/appendix/interview/basic/','title':"基础",'content':"基础面试题 "});index.add({'id':139,'href':'/note-cs/docs/direction/client/android/appendix/interview/basic/','title':"基础",'content':"基础面试题 "});index.add({'id':140,'href':'/note-cs/docs/direction/client/ios/appendix/interview/basic/','title':"基础",'content':"基础面试题 "});index.add({'id':141,'href':'/note-cs/docs/direction/client/xiaochengxu/appendix/interview/basic/','title':"基础",'content':"基础面试题 "});index.add({'id':142,'href':'/note-cs/docs/direction/embedded/appendix/interview/basic/','title':"基础",'content':"基础面试题 "});index.add({'id':143,'href':'/note-cs/docs/direction/fe/frame/angular/appendix/interview/basic/','title':"基础",'content':"基础面试题 "});index.add({'id':144,'href':'/note-cs/docs/direction/fe/frame/react/appendix/interview/basic/','title':"基础",'content':"基础面试题 "});index.add({'id':145,'href':'/note-cs/docs/direction/fe/frame/vue/appendix/interview/basic/','title':"基础",'content':"基础面试题 "});index.add({'id':146,'href':'/note-cs/docs/direction/security/appendix/interview/basic/','title':"基础",'content':"基础面试题 "});index.add({'id':147,'href':'/note-cs/docs/domain/cc/knative/appendix/interview/basic/','title':"基础",'content':"基础面试题 "});index.add({'id':148,'href':'/note-cs/docs/basic/pl/java/basic/practice/package/','title':"常用 package",'content':"Java 常用 package "});index.add({'id':149,'href':'/note-cs/docs/basic/pl/java/basic/grammar/datastruct/','title':"数据结构",'content':"Java 语言数据结构 "});index.add({'id':150,'href':'/note-cs/docs/basic/pl/rust/design/','title':"第二部分 Rust 设计",'content':""});index.add({'id':151,'href':'/note-cs/docs/basic/os/android/priciple/','title':"第二部分 原理",'content':""});index.add({'id':152,'href':'/note-cs/docs/basic/os/ios/priciple/','title':"第二部分 原理",'content':""});index.add({'id':153,'href':'/note-cs/docs/basic/os/macos/priciple/','title':"第二部分 原理",'content':""});index.add({'id':154,'href':'/note-cs/docs/basic/os/unix/priciple/','title':"第二部分 原理",'content':""});index.add({'id':155,'href':'/note-cs/docs/basic/os/windows/priciple/','title':"第二部分 原理",'content':""});index.add({'id':156,'href':'/note-cs/docs/basic/pl/csharp/priciple/','title':"第二部分 原理",'content':""});index.add({'id':157,'href':'/note-cs/docs/basic/pl/kotlin/priciple/','title':"第二部分 原理",'content':""});index.add({'id':158,'href':'/note-cs/docs/basic/pl/lua/priciple/','title':"第二部分 原理",'content':""});index.add({'id':159,'href':'/note-cs/docs/basic/pl/objective-c/priciple/','title':"第二部分 原理",'content':""});index.add({'id':160,'href':'/note-cs/docs/basic/pl/ruby/priciple/','title':"第二部分 原理",'content':""});index.add({'id':161,'href':'/note-cs/docs/basic/pl/scala/priciple/','title':"第二部分 原理",'content':""});index.add({'id':162,'href':'/note-cs/docs/basic/pl/swift/priciple/','title':"第二部分 原理",'content':""});index.add({'id':163,'href':'/note-cs/docs/direction/be/frame/nodejs/principle/','title':"第二部分 原理",'content':""});index.add({'id':164,'href':'/note-cs/docs/direction/','title':"第二部分 方向",'content':""});index.add({'id':165,'href':'/note-cs/docs/basic/db/mysql/design/','title':"第二部分 设计",'content':""});index.add({'id':166,'href':'/note-cs/docs/basic/db/postgresql/design/','title':"第二部分 设计",'content':""});index.add({'id':167,'href':'/note-cs/docs/basic/db/redis/design/','title':"第二部分 设计",'content':""});index.add({'id':168,'href':'/note-cs/docs/basic/pl/c/design/','title':"第二部分 设计",'content':""});index.add({'id':169,'href':'/note-cs/docs/basic/pl/cpp/design/','title':"第二部分 设计",'content':""});index.add({'id':170,'href':'/note-cs/docs/basic/pl/java/design/','title':"第二部分 设计",'content':""});index.add({'id':171,'href':'/note-cs/docs/basic/pl/javascript/design/','title':"第二部分 设计",'content':""});index.add({'id':172,'href':'/note-cs/docs/basic/pl/php/design/','title':"第二部分 设计",'content':""});index.add({'id':173,'href':'/note-cs/docs/direction/client/android/design/','title':"第二部分 设计",'content':""});index.add({'id':174,'href':'/note-cs/docs/direction/client/ios/design/','title':"第二部分 设计",'content':""});index.add({'id':175,'href':'/note-cs/docs/direction/client/xiaochengxu/design/','title':"第二部分 设计",'content':""});index.add({'id':176,'href':'/note-cs/docs/direction/embedded/design/','title':"第二部分 设计",'content':""});index.add({'id':177,'href':'/note-cs/docs/direction/fe/frame/angular/design/','title':"第二部分 设计",'content':""});index.add({'id':178,'href':'/note-cs/docs/direction/fe/frame/react/design/','title':"第二部分 设计",'content':""});index.add({'id':179,'href':'/note-cs/docs/direction/fe/frame/vue/design/','title':"第二部分 设计",'content':""});index.add({'id':180,'href':'/note-cs/docs/direction/security/design/','title':"第二部分 设计",'content':""});index.add({'id':181,'href':'/note-cs/docs/domain/cc/knative/design/','title':"第二部分 设计",'content':""});index.add({'id':182,'href':'/note-cs/docs/basic/db/mysql/appendix/interview/advanced/','title':"进阶",'content':"进阶面试题 "});index.add({'id':183,'href':'/note-cs/docs/basic/db/postgresql/appendix/interview/advanced/','title':"进阶",'content':"进阶面试题 "});index.add({'id':184,'href':'/note-cs/docs/basic/db/redis/appendix/interview/advanced/','title':"进阶",'content':"进阶面试题 "});index.add({'id':185,'href':'/note-cs/docs/basic/os/android/appendix/interview/advanced/','title':"进阶",'content':"进阶面试题 "});index.add({'id':186,'href':'/note-cs/docs/basic/os/ios/appendix/interview/advanced/','title':"进阶",'content':"进阶面试题 "});index.add({'id':187,'href':'/note-cs/docs/basic/os/macos/appendix/interview/advanced/','title':"进阶",'content':"进阶面试题 "});index.add({'id':188,'href':'/note-cs/docs/basic/os/unix/appendix/interview/advanced/','title':"进阶",'content':"进阶面试题 "});index.add({'id':189,'href':'/note-cs/docs/basic/os/windows/appendix/interview/advanced/','title':"进阶",'content':"进阶面试题 "});index.add({'id':190,'href':'/note-cs/docs/basic/pl/c/appendix/interview/advanced/','title':"进阶",'content':"进阶面试题 "});index.add({'id':191,'href':'/note-cs/docs/basic/pl/cpp/appendix/interview/advanced/','title':"进阶",'content':"进阶面试题 为什么 C++ 的 member function template 不能是 virtual 的 比如，下面的代码是不合法的：\nclass Animal{ public: template\u0026lt;typename T\u0026gt; virtual void make_sound(){ //...  } }; 因为 C++ 的编译与链接模型是 \u0026ldquo;分离\u0026rdquo; 的 (至少是部分原因吧)。\n从 Unix/C 开始，一个 C/C++ 程序就可以被分开编译，然后用一个 linker 链接起来。这种模型有一个问题，就是各个编译单元可能对另一个编译单元一无所知。 一个 function template 最后到底会被 instantiate 为多少个函数，要等整个程序 (所有的编译单元) 全部被编译完成才知道。 同时，virtual function 的实现大多利用了一个 \u0026ldquo;虚函数表\u0026rdquo; 的东西，这种实现中，一个类的内存布局 (或者说虚函数表的内存布局) 需要在这个类编译完成的时候就被完全确定。 所以，由上面的矛盾可知，C++ 的 member function 不能既是 template 又是 virtual 的。\n参考：https://www.zhihu.com/question/60911582/answer/182045051\n"});index.add({'id':192,'href':'/note-cs/docs/basic/pl/csharp/appendix/interview/advanced/','title':"进阶",'content':"进阶面试题 "});index.add({'id':193,'href':'/note-cs/docs/basic/pl/java/appendix/interview/advanced/','title':"进阶",'content':"Java 进阶面试题 "});index.add({'id':194,'href':'/note-cs/docs/basic/pl/javascript/appendix/interview/advanced/','title':"进阶",'content':"进阶面试题 "});index.add({'id':195,'href':'/note-cs/docs/basic/pl/kotlin/appendix/interview/advanced/','title':"进阶",'content':"进阶面试题 "});index.add({'id':196,'href':'/note-cs/docs/basic/pl/lua/appendix/interview/advanced/','title':"进阶",'content':"进阶面试题 "});index.add({'id':197,'href':'/note-cs/docs/basic/pl/objective-c/appendix/interview/advanced/','title':"进阶",'content':"进阶面试题 "});index.add({'id':198,'href':'/note-cs/docs/basic/pl/php/appendix/interview/advanced/','title':"进阶",'content':"进阶面试题 "});index.add({'id':199,'href':'/note-cs/docs/basic/pl/ruby/appendix/interview/advanced/','title':"进阶",'content':"进阶面试题 "});index.add({'id':200,'href':'/note-cs/docs/basic/pl/rust/appendix/interview/advanced/','title':"进阶",'content':"进阶面试题 "});index.add({'id':201,'href':'/note-cs/docs/basic/pl/scala/appendix/interview/advanced/','title':"进阶",'content':"进阶面试题 "});index.add({'id':202,'href':'/note-cs/docs/basic/pl/swift/appendix/interview/advanced/','title':"进阶",'content':"进阶面试题 "});index.add({'id':203,'href':'/note-cs/docs/direction/be/frame/nodejs/appendix/interview/advanced/','title':"进阶",'content':"进阶面试题 "});index.add({'id':204,'href':'/note-cs/docs/direction/client/android/appendix/interview/advanced/','title':"进阶",'content':"进阶面试题 "});index.add({'id':205,'href':'/note-cs/docs/direction/client/ios/appendix/interview/advanced/','title':"进阶",'content':"进阶面试题 "});index.add({'id':206,'href':'/note-cs/docs/direction/client/xiaochengxu/appendix/interview/advanced/','title':"进阶",'content':"进阶面试题 "});index.add({'id':207,'href':'/note-cs/docs/direction/embedded/appendix/interview/advanced/','title':"进阶",'content':"进阶面试题 "});index.add({'id':208,'href':'/note-cs/docs/direction/fe/frame/angular/appendix/interview/advanced/','title':"进阶",'content':"进阶面试题 "});index.add({'id':209,'href':'/note-cs/docs/direction/fe/frame/react/appendix/interview/advanced/','title':"进阶",'content':"进阶面试题 "});index.add({'id':210,'href':'/note-cs/docs/direction/fe/frame/vue/appendix/interview/advanced/','title':"进阶",'content':"进阶面试题 "});index.add({'id':211,'href':'/note-cs/docs/direction/security/appendix/interview/advanced/','title':"进阶",'content':"进阶面试题 "});index.add({'id':212,'href':'/note-cs/docs/domain/cc/knative/appendix/interview/advanced/','title':"进阶",'content':"进阶面试题 "});index.add({'id':213,'href':'/note-cs/docs/basic/db/mysql/appendix/interview/','title':"面试题",'content':"面试题 基础题 进阶题 高阶题 "});index.add({'id':214,'href':'/note-cs/docs/basic/db/postgresql/appendix/interview/','title':"面试题",'content':"面试题 基础题 进阶题 高阶题 "});index.add({'id':215,'href':'/note-cs/docs/basic/db/redis/appendix/interview/','title':"面试题",'content':"面试题 基础题 进阶题 高阶题 "});index.add({'id':216,'href':'/note-cs/docs/basic/os/android/appendix/interview/','title':"面试题",'content':"面试题 基础题 进阶题 高阶题 "});index.add({'id':217,'href':'/note-cs/docs/basic/os/ios/appendix/interview/','title':"面试题",'content':"面试题 基础题 进阶题 高阶题 "});index.add({'id':218,'href':'/note-cs/docs/basic/os/macos/appendix/interview/','title':"面试题",'content':"面试题 基础题 进阶题 高阶题 "});index.add({'id':219,'href':'/note-cs/docs/basic/os/unix/appendix/interview/','title':"面试题",'content':"面试题 基础题 进阶题 高阶题 "});index.add({'id':220,'href':'/note-cs/docs/basic/os/windows/appendix/interview/','title':"面试题",'content':"面试题 基础题 进阶题 高阶题 "});index.add({'id':221,'href':'/note-cs/docs/basic/pl/c/appendix/interview/','title':"面试题",'content':"面试题 基础题 进阶题 高阶题 "});index.add({'id':222,'href':'/note-cs/docs/basic/pl/java/appendix/interview/','title':"面试题",'content':"Java 面试题 基础题 参考：\n 拿下阿里、头条、滴滴的 offer 后谈谈面试经验（上）  进阶题 高阶题 "});index.add({'id':223,'href':'/note-cs/docs/basic/pl/javascript/appendix/interview/','title':"面试题",'content':"面试题 基础题 进阶题  如何衡量一个人的 JavaScript 水平？  高阶题 "});index.add({'id':224,'href':'/note-cs/docs/basic/pl/objective-c/appendix/interview/','title':"面试题",'content':"面试题 基础题 进阶题 高阶题 "});index.add({'id':225,'href':'/note-cs/docs/basic/pl/php/appendix/interview/','title':"面试题",'content':"面试题 基础题 进阶题 高阶题 "});index.add({'id':226,'href':'/note-cs/docs/basic/pl/rust/appendix/interview/','title':"面试题",'content':"面试题 基础题 进阶题 高阶题 "});index.add({'id':227,'href':'/note-cs/docs/basic/pl/scala/appendix/interview/','title':"面试题",'content':"面试题 基础题 进阶题 高阶题 "});index.add({'id':228,'href':'/note-cs/docs/direction/be/frame/nodejs/appendix/interview/','title':"面试题",'content':"面试题 基础题 进阶题 高阶题 "});index.add({'id':229,'href':'/note-cs/docs/direction/client/android/appendix/interview/','title':"面试题",'content':"面试题 基础题 进阶题 高阶题 "});index.add({'id':230,'href':'/note-cs/docs/direction/client/ios/appendix/interview/','title':"面试题",'content':"面试题 基础题 进阶题 高阶题 "});index.add({'id':231,'href':'/note-cs/docs/direction/client/xiaochengxu/appendix/interview/','title':"面试题",'content':"面试题 基础题 进阶题 高阶题 "});index.add({'id':232,'href':'/note-cs/docs/direction/embedded/appendix/interview/','title':"面试题",'content':"面试题 基础题 进阶题 高阶题 "});index.add({'id':233,'href':'/note-cs/docs/direction/fe/frame/angular/appendix/interview/','title':"面试题",'content':"面试题 基础题 进阶题 高阶题 "});index.add({'id':234,'href':'/note-cs/docs/direction/fe/frame/react/appendix/interview/','title':"面试题",'content':"面试题 基础题 进阶题 高阶题 "});index.add({'id':235,'href':'/note-cs/docs/direction/fe/frame/vue/appendix/interview/','title':"面试题",'content':"面试题 基础题 进阶题 高阶题 "});index.add({'id':236,'href':'/note-cs/docs/direction/security/appendix/interview/','title':"面试题",'content':"面试题 基础题 进阶题 高阶题 "});index.add({'id':237,'href':'/note-cs/docs/domain/cc/knative/appendix/interview/','title':"面试题",'content':"面试题 基础题 进阶题 高阶题 "});index.add({'id':238,'href':'/note-cs/docs/basic/compile/make/cmake/','title':"cmake",'content':"cmake "});index.add({'id':239,'href':'/note-cs/docs/book/be/Designing-Data-Intensive-Applications/','title':"Designing Data-Intensive Applications",'content':"Designing Data-Intensive Applications 简介 \npublished by O’Reilly in March 2017.\n作者 Martin Kleppmann\nMartin Kleppmann\u0026rsquo;s blog\n阅读笔记 "});index.add({'id':240,'href':'/note-cs/docs/basic/os/macos/','title':"MacOS",'content':"MacOS "});index.add({'id':241,'href':'/note-cs/docs/basic/os/windows/','title':"Windows",'content':"Windows "});index.add({'id':242,'href':'/note-cs/docs/basic/db/mysql/source/','title':"第三部分 源码实现",'content':""});index.add({'id':243,'href':'/note-cs/docs/basic/db/postgresql/source/','title':"第三部分 源码实现",'content':""});index.add({'id':244,'href':'/note-cs/docs/basic/db/redis/source/','title':"第三部分 源码实现",'content':""});index.add({'id':245,'href':'/note-cs/docs/basic/os/android/source/','title':"第三部分 源码实现",'content':""});index.add({'id':246,'href':'/note-cs/docs/basic/os/ios/source/','title':"第三部分 源码实现",'content':""});index.add({'id':247,'href':'/note-cs/docs/basic/os/macos/source/','title':"第三部分 源码实现",'content':""});index.add({'id':248,'href':'/note-cs/docs/basic/os/unix/source/','title':"第三部分 源码实现",'content':""});index.add({'id':249,'href':'/note-cs/docs/basic/os/windows/source/','title':"第三部分 源码实现",'content':""});index.add({'id':250,'href':'/note-cs/docs/basic/pl/c/source/','title':"第三部分 源码实现",'content':""});index.add({'id':251,'href':'/note-cs/docs/basic/pl/cpp/source/','title':"第三部分 源码实现",'content':""});index.add({'id':252,'href':'/note-cs/docs/basic/pl/csharp/source/','title':"第三部分 源码实现",'content':""});index.add({'id':253,'href':'/note-cs/docs/basic/pl/java/source/','title':"第三部分 源码实现",'content':""});index.add({'id':254,'href':'/note-cs/docs/basic/pl/javascript/source/','title':"第三部分 源码实现",'content':""});index.add({'id':255,'href':'/note-cs/docs/basic/pl/kotlin/source/','title':"第三部分 源码实现",'content':""});index.add({'id':256,'href':'/note-cs/docs/basic/pl/lua/source/','title':"第三部分 源码实现",'content':""});index.add({'id':257,'href':'/note-cs/docs/basic/pl/objective-c/source/','title':"第三部分 源码实现",'content':""});index.add({'id':258,'href':'/note-cs/docs/basic/pl/php/source/','title':"第三部分 源码实现",'content':""});index.add({'id':259,'href':'/note-cs/docs/basic/pl/ruby/source/','title':"第三部分 源码实现",'content':""});index.add({'id':260,'href':'/note-cs/docs/basic/pl/rust/source/','title':"第三部分 源码实现",'content':""});index.add({'id':261,'href':'/note-cs/docs/basic/pl/scala/source/','title':"第三部分 源码实现",'content':""});index.add({'id':262,'href':'/note-cs/docs/basic/pl/swift/source/','title':"第三部分 源码实现",'content':""});index.add({'id':263,'href':'/note-cs/docs/direction/be/frame/nodejs/source/','title':"第三部分 源码实现",'content':""});index.add({'id':264,'href':'/note-cs/docs/direction/client/android/source/','title':"第三部分 源码实现",'content':""});index.add({'id':265,'href':'/note-cs/docs/direction/client/ios/source/','title':"第三部分 源码实现",'content':""});index.add({'id':266,'href':'/note-cs/docs/direction/client/xiaochengxu/source/','title':"第三部分 源码实现",'content':""});index.add({'id':267,'href':'/note-cs/docs/direction/embedded/source/','title':"第三部分 源码实现",'content':""});index.add({'id':268,'href':'/note-cs/docs/direction/fe/frame/angular/source/','title':"第三部分 源码实现",'content':""});index.add({'id':269,'href':'/note-cs/docs/direction/fe/frame/react/source/','title':"第三部分 源码实现",'content':""});index.add({'id':270,'href':'/note-cs/docs/direction/fe/frame/vue/source/','title':"第三部分 源码实现",'content':""});index.add({'id':271,'href':'/note-cs/docs/direction/security/source/','title':"第三部分 源码实现",'content':""});index.add({'id':272,'href':'/note-cs/docs/domain/cc/knative/source/','title':"第三部分 源码实现",'content':""});index.add({'id':273,'href':'/note-cs/docs/domain/','title':"第三部分 领域",'content':""});index.add({'id':274,'href':'/note-cs/docs/basic/db/mysql/appendix/interview/expert/','title':"高阶",'content':"高阶面试题 "});index.add({'id':275,'href':'/note-cs/docs/basic/db/postgresql/appendix/interview/expert/','title':"高阶",'content':"高阶面试题 "});index.add({'id':276,'href':'/note-cs/docs/basic/db/redis/appendix/interview/expert/','title':"高阶",'content':"高阶面试题 "});index.add({'id':277,'href':'/note-cs/docs/basic/os/android/appendix/interview/expert/','title':"高阶",'content':"高阶面试题 "});index.add({'id':278,'href':'/note-cs/docs/basic/os/ios/appendix/interview/expert/','title':"高阶",'content':"高阶面试题 "});index.add({'id':279,'href':'/note-cs/docs/basic/os/macos/appendix/interview/expert/','title':"高阶",'content':"高阶面试题 "});index.add({'id':280,'href':'/note-cs/docs/basic/os/unix/appendix/interview/expert/','title':"高阶",'content':"高阶面试题 "});index.add({'id':281,'href':'/note-cs/docs/basic/os/windows/appendix/interview/expert/','title':"高阶",'content':"高阶面试题 "});index.add({'id':282,'href':'/note-cs/docs/basic/pl/c/appendix/interview/expert/','title':"高阶",'content':"高阶面试题 "});index.add({'id':283,'href':'/note-cs/docs/basic/pl/cpp/appendix/interview/expert/','title':"高阶",'content':"高阶面试题 "});index.add({'id':284,'href':'/note-cs/docs/basic/pl/csharp/appendix/interview/expert/','title':"高阶",'content':"高阶面试题 "});index.add({'id':285,'href':'/note-cs/docs/basic/pl/java/appendix/interview/expert/','title':"高阶",'content':"Java 高阶面试题 "});index.add({'id':286,'href':'/note-cs/docs/basic/pl/javascript/appendix/interview/expert/','title':"高阶",'content':"高阶面试题 "});index.add({'id':287,'href':'/note-cs/docs/basic/pl/kotlin/appendix/interview/expert/','title':"高阶",'content':"高阶面试题 "});index.add({'id':288,'href':'/note-cs/docs/basic/pl/lua/appendix/interview/expert/','title':"高阶",'content':"高阶面试题 "});index.add({'id':289,'href':'/note-cs/docs/basic/pl/objective-c/appendix/interview/expert/','title':"高阶",'content':"高阶面试题 "});index.add({'id':290,'href':'/note-cs/docs/basic/pl/php/appendix/interview/expert/','title':"高阶",'content':"高阶面试题 "});index.add({'id':291,'href':'/note-cs/docs/basic/pl/ruby/appendix/interview/expert/','title':"高阶",'content':"高阶面试题 "});index.add({'id':292,'href':'/note-cs/docs/basic/pl/rust/appendix/interview/expert/','title':"高阶",'content':"高阶面试题 "});index.add({'id':293,'href':'/note-cs/docs/basic/pl/scala/appendix/interview/expert/','title':"高阶",'content':"高阶面试题 "});index.add({'id':294,'href':'/note-cs/docs/basic/pl/swift/appendix/interview/expert/','title':"高阶",'content':"高阶面试题 "});index.add({'id':295,'href':'/note-cs/docs/direction/be/frame/nodejs/appendix/interview/expert/','title':"高阶",'content':"高阶面试题 "});index.add({'id':296,'href':'/note-cs/docs/direction/client/android/appendix/interview/expert/','title':"高阶",'content':"高阶面试题 "});index.add({'id':297,'href':'/note-cs/docs/direction/client/ios/appendix/interview/expert/','title':"高阶",'content':"高阶面试题 "});index.add({'id':298,'href':'/note-cs/docs/direction/client/xiaochengxu/appendix/interview/expert/','title':"高阶",'content':"高阶面试题 "});index.add({'id':299,'href':'/note-cs/docs/direction/embedded/appendix/interview/expert/','title':"高阶",'content':"高阶面试题 "});index.add({'id':300,'href':'/note-cs/docs/direction/fe/frame/angular/appendix/interview/expert/','title':"高阶",'content':"高阶面试题 "});index.add({'id':301,'href':'/note-cs/docs/direction/fe/frame/react/appendix/interview/expert/','title':"高阶",'content':"高阶面试题 "});index.add({'id':302,'href':'/note-cs/docs/direction/fe/frame/vue/appendix/interview/expert/','title':"高阶",'content':"高阶面试题 "});index.add({'id':303,'href':'/note-cs/docs/direction/security/appendix/interview/expert/','title':"高阶",'content':"高阶面试题 "});index.add({'id':304,'href':'/note-cs/docs/domain/cc/knative/appendix/interview/expert/','title':"高阶",'content':"高阶面试题 "});index.add({'id':305,'href':'/note-cs/docs/direction/be/mq/mqtt/mosquitto/','title':"mosquitto",'content':"mosquitto 物联网（Internet of Things，IoT）最近曝光率越来越高。虽然 HTTP 是网页的事实标准，不过机器之间（Machine-to-Machine，M2M）的大规模沟通需要不同的模式：之前的请求 / 回答（Request/Response）模式不再合适，取而代之的是发布 / 订阅（Publish/Subscribe）模式。这就是轻量级、可扩展的 MQTT（Message Queuing Telemetry Transport）可以施展拳脚的舞台。\nMQTT 是基于二进制消息的发布 / 订阅编程模式的消息协议，最早由 IBM 提出的，如今已经成为 OASIS 规范。由于规范很简单，非常适合需要低功耗和网络带宽有限的 IoT 场景，比如：\n 遥感数据 汽车 智能家居 智慧城市 医疗医护  安装 MacOS brew install mosquitto\n参考：https://mosquitto.org/download/\n"});index.add({'id':306,'href':'/note-cs/docs/basic/os/unix/','title':"Unix",'content':"Unix "});index.add({'id':307,'href':'/note-cs/docs/others/','title':"第四部分 其他",'content':""});index.add({'id':308,'href':'/note-cs/docs/basic/db/mysql/appendix/','title':"第四部分 附录",'content':""});index.add({'id':309,'href':'/note-cs/docs/basic/db/postgresql/appendix/','title':"第四部分 附录",'content':""});index.add({'id':310,'href':'/note-cs/docs/basic/db/redis/appendix/','title':"第四部分 附录",'content':""});index.add({'id':311,'href':'/note-cs/docs/basic/os/android/appendix/','title':"第四部分 附录",'content':""});index.add({'id':312,'href':'/note-cs/docs/basic/os/ios/appendix/','title':"第四部分 附录",'content':""});index.add({'id':313,'href':'/note-cs/docs/basic/os/macos/appendix/','title':"第四部分 附录",'content':""});index.add({'id':314,'href':'/note-cs/docs/basic/os/unix/appendix/','title':"第四部分 附录",'content':""});index.add({'id':315,'href':'/note-cs/docs/basic/os/windows/appendix/','title':"第四部分 附录",'content':""});index.add({'id':316,'href':'/note-cs/docs/basic/pl/c/appendix/','title':"第四部分 附录",'content':""});index.add({'id':317,'href':'/note-cs/docs/basic/pl/cpp/appendix/','title':"第四部分 附录",'content':""});index.add({'id':318,'href':'/note-cs/docs/basic/pl/csharp/appendix/','title':"第四部分 附录",'content':""});index.add({'id':319,'href':'/note-cs/docs/basic/pl/java/appendix/','title':"第四部分 附录",'content':""});index.add({'id':320,'href':'/note-cs/docs/basic/pl/javascript/appendix/','title':"第四部分 附录",'content':""});index.add({'id':321,'href':'/note-cs/docs/basic/pl/kotlin/appendix/','title':"第四部分 附录",'content':""});index.add({'id':322,'href':'/note-cs/docs/basic/pl/lua/appendix/','title':"第四部分 附录",'content':""});index.add({'id':323,'href':'/note-cs/docs/basic/pl/objective-c/appendix/','title':"第四部分 附录",'content':""});index.add({'id':324,'href':'/note-cs/docs/basic/pl/php/appendix/','title':"第四部分 附录",'content':""});index.add({'id':325,'href':'/note-cs/docs/basic/pl/ruby/appendix/','title':"第四部分 附录",'content':""});index.add({'id':326,'href':'/note-cs/docs/basic/pl/rust/appendix/','title':"第四部分 附录",'content':""});index.add({'id':327,'href':'/note-cs/docs/basic/pl/scala/appendix/','title':"第四部分 附录",'content':""});index.add({'id':328,'href':'/note-cs/docs/basic/pl/swift/appendix/','title':"第四部分 附录",'content':""});index.add({'id':329,'href':'/note-cs/docs/direction/be/frame/nodejs/appendix/','title':"第四部分 附录",'content':""});index.add({'id':330,'href':'/note-cs/docs/direction/client/android/appendix/','title':"第四部分 附录",'content':""});index.add({'id':331,'href':'/note-cs/docs/direction/client/ios/appendix/','title':"第四部分 附录",'content':""});index.add({'id':332,'href':'/note-cs/docs/direction/client/xiaochengxu/appendix/','title':"第四部分 附录",'content':""});index.add({'id':333,'href':'/note-cs/docs/direction/embedded/appendix/','title':"第四部分 附录",'content':""});index.add({'id':334,'href':'/note-cs/docs/direction/fe/frame/angular/appendix/','title':"第四部分 附录",'content':""});index.add({'id':335,'href':'/note-cs/docs/direction/fe/frame/react/appendix/','title':"第四部分 附录",'content':""});index.add({'id':336,'href':'/note-cs/docs/direction/fe/frame/vue/appendix/','title':"第四部分 附录",'content':""});index.add({'id':337,'href':'/note-cs/docs/direction/security/appendix/','title':"第四部分 附录",'content':""});index.add({'id':338,'href':'/note-cs/docs/domain/cc/knative/appendix/','title':"第四部分 附录",'content':""});index.add({'id':339,'href':'/note-cs/docs/basic/pl/c/','title':"C",'content':"C 学习笔记 "});index.add({'id':340,'href':'/note-cs/docs/basic/compile/gcc/','title':"gcc",'content':"gcc gcc 升级 升级到 gcc 6.3 yum -y install centos-release-scl yum -y install devtoolset-6-gcc devtoolset-6-gcc-c++ devtoolset-6-binutils # scl 命令启用只是临时的，退出 shell 或重启就会恢复原系统 gcc 版本 scl enable devtoolset-6 bash # 长期 echo \u0026#34;source /opt/rh/devtoolset-6/enable\u0026#34; \u0026gt;\u0026gt;/etc/profile 参考：\n 为 CentOS 6、7 升级 gcc 至 4.8、4.9、5.2、6.3、7.3 等高版本  "});index.add({'id':341,'href':'/note-cs/docs/others/skill/debug/gdb/','title':"GDB",'content':"GDB "});index.add({'id':342,'href':'/note-cs/docs/direction/be/frame/nodejs/basic/build/gulp/','title':"gulp",'content':"gulp 类似与 make 参考：https://learnxinyminutes.com/docs/zh-cn/make-cn/\n"});index.add({'id':343,'href':'/note-cs/docs/basic/compile/make/','title':"make",'content':"make 教程  learn make in y minutes 跟我一起写 Makefile GNU make manual  "});index.add({'id':344,'href':'/note-cs/docs/basic/db/mysql/basic/practice/snippet/','title':"代码片段",'content':"代码片段 "});index.add({'id':345,'href':'/note-cs/docs/basic/db/postgresql/basic/practice/snippet/','title':"代码片段",'content':"代码片段 "});index.add({'id':346,'href':'/note-cs/docs/basic/db/redis/basic/practice/snippet/','title':"代码片段",'content':"代码片段 "});index.add({'id':347,'href':'/note-cs/docs/basic/pl/c/basic/practice/snippet/','title':"代码片段",'content':"代码片段 "});index.add({'id':348,'href':'/note-cs/docs/basic/pl/javascript/basic/practice/snippet/','title':"代码片段",'content':"代码片段 "});index.add({'id':349,'href':'/note-cs/docs/basic/pl/objective-c/basic/practice/snippet/','title':"代码片段",'content':"代码片段 "});index.add({'id':350,'href':'/note-cs/docs/direction/be/frame/nodejs/basic/practice/snippet/','title':"代码片段",'content':"代码片段 "});index.add({'id':351,'href':'/note-cs/docs/direction/client/android/basic/practice/snippet/','title':"代码片段",'content':"代码片段 "});index.add({'id':352,'href':'/note-cs/docs/direction/client/ios/basic/practice/snippet/','title':"代码片段",'content':"代码片段 "});index.add({'id':353,'href':'/note-cs/docs/direction/client/xiaochengxu/basic/practice/snippet/','title':"代码片段",'content':"代码片段 "});index.add({'id':354,'href':'/note-cs/docs/direction/fe/frame/angular/basic/practice/snippet/','title':"代码片段",'content':"代码片段 "});index.add({'id':355,'href':'/note-cs/docs/direction/fe/frame/react/basic/practice/snippet/','title':"代码片段",'content':"代码片段 "});index.add({'id':356,'href':'/note-cs/docs/direction/fe/frame/vue/basic/practice/snippet/','title':"代码片段",'content':"代码片段 "});index.add({'id':357,'href':'/note-cs/docs/basic/pl/cpp/basic/grammar/keyword/','title':"关键字",'content':"C++ 关键字 这是 C++ 中的保留字列表。因为它们为语言所用，故这些关键词不可用于重定义或重载。\n注意 and、bitor、or、xor、compl、bitand、and_eq、or_eq、xor_eq、not 及 not_eq（还有双标符 \u0026lt;%、%\u0026gt;、\u0026lt;:、:\u0026gt;、%: 及 %:%:）提供标准记号的代用表示方法。\n参考：C++ 参考手册\n"});index.add({'id':358,'href':'/note-cs/docs/others/tool/dev/vscode/shortcuts/','title':"快捷键",'content':"VScode 快捷键 MacOS 选择  选中所有同一个词：cmd + shift + L  编辑  格式化：opt + shift + f Windows 选择  选中所有同一个词：ctrl + shift + L  "});index.add({'id':359,'href':'/note-cs/docs/basic/db/redis/basic/type/','title':"数据类型",'content':"数据类型 string Redis 规定了字符串的长度不得超过 512 MB。\nlist hash set zset "});index.add({'id':360,'href':'/note-cs/docs/direction/be/frame/nodejs/basic/build/','title':"构建",'content':"Node.js 构建 "});index.add({'id':361,'href':'/note-cs/docs/direction/be/frame/nodejs/basic/version/','title':"版本",'content':"Node.js 版本 版本控制 nvm-sh/nvm Node Version Manager - POSIX-compliant bash script to manage multiple active node.js versions\n安装 curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.35.3/install.sh | bash export NVM_DIR=\u0026#34;$([ -z \u0026#34;${XDG_CONFIG_HOME-}\u0026#34; ] \u0026amp;\u0026amp; printf %s \u0026#34;${HOME}/.nvm\u0026#34; || printf %s \u0026#34;${XDG_CONFIG_HOME}/nvm\u0026#34;)\u0026#34; [ -s \u0026#34;$NVM_DIR/nvm.sh\u0026#34; ] \u0026amp;\u0026amp; \\. \u0026#34;$NVM_DIR/nvm.sh\u0026#34; # This loads nvm 基础命令  install  nvm install node  \u0026ldquo;node\u0026rdquo; is an alias for the latest version   nvm install --lts    其他命令：\nnvm ls-remote nvm use node # get the path to the executable to where it was installed nvm which 5.0 "});index.add({'id':362,'href':'/note-cs/docs/basic/pl/scala/basic/spec/baidu/','title':"百度",'content':"百度 Scala 编码规范 前言 就目前 Baidu 内部情况 (2018.10)，Scala 这门语言主要用于计算团队内部的和 Spark 相关项目研发、社区贡献工作以及公司的 Spark 用户使用 Scala API 编写 Spark 作业三个用途，所以本文主体沿用如下两部分并稍作修改：\n Apache Spark 开源社区 Scala 编程指南:\nApache Spark 有超过 1000 位贡献者，就我们所知，应该是目前大数据领域里最大的开源项目且是最活跃的 Scala 项目，结合 Baidu 内部现状，本文主体沿用此部分中和 Spark 社区相关内容，去除部分项目专用细节。 scala 官方 style guide 里的格式部分已包含在 Spark 项目文档中，这里摘录部分官方 style guide 作为 Apache Spark 社区的编程指南补充。  "});index.add({'id':363,'href':'/note-cs/docs/book/','title':"第五部分 读书",'content':"读书 "});index.add({'id':364,'href':'/note-cs/docs/others/tool/study/tutorial/','title':"编程学习网站",'content':"编程学习网站 基础 Codecademy Programiz  算法 Codewars  进阶 Codeplace 通过实际应用来学习编程。\n"});index.add({'id':365,'href':'/note-cs/docs/book/basic/cc/sicp/','title':"计算机程序的构造和解释",'content':"计算机程序的构造和解释  豆瓣   黄健宏：SICP 解题集  "});index.add({'id':366,'href':'/note-cs/docs/course/','title':"第六部分 课程",'content':"课程 "});index.add({'id':367,'href':'/note-cs/docs/direction/be/frame/dotnet/','title':".NET",'content':".NET Framework "});index.add({'id':368,'href':'/note-cs/docs/direction/be/frame/dotnet/core/','title':".NET Core",'content':".NET Core "});index.add({'id':369,'href':'/note-cs/docs/direction/be/frame/nodejs/','title':"Node.js",'content':"Node.js "});index.add({'id':370,'href':'/note-cs/docs/domain/cc/container/','title':"容器运行时",'content':""});index.add({'id':371,'href':'/note-cs/docs/basic/db/redis/basic/cmd/','title':"命令",'content':"Redis 命令 key  DEL DUMP EXISTS EXPIRE EXPIREAT KEYS MOVE PERSIST PEXPIREAT PEXPIREAT PTTL RANDOMKEY RENAME RENAMENX TTL TYPE   string  APPEND DECR DECRBY DEL EXISTS GET GETRANGE GETSET INCR INCRBY INCRBYFLOAT MGET MSET MSETNX PSETEX SET SETBIT SETEX SETNX STRLEN   list  DEL DUMP EXISTS EXPIRE EXPIREAT KEYS MOVE PERSIST PEXPIREAT PEXPIREAT PTTL RANDOMKEY RENAME RENAMENX TTL TYPE   hash  HDEL HEXISTS HGET HGETALL HINCRBY HINCRBYFLOAT HKEYS HLEN HMGET HMSET HSET HSETNX HVALS   set  SADD SCARD SDIFF SDIFFSTORE SINTER SINTERSTORE SISMEMBER SMEMBERS SMOVE SPOP SRANDMEMBER SREM SSCAN SUNION SUNIONSTORE   zset  ZADD ZCARD ZCOUNT ZINCRBY ZINTERSTORE ZLEXCOUNT ZRANGE ZRANGEBYLEX ZRANGEBYSCORE ZRANK ZREM ZREMRANGEBYLEX ZREMRANGEBYRANK ZREMRANGEBYSCORE ZREVRANGE ZREVRANGEBYSCORE ZREVRANK ZSCAN ZSCORE ZUNIONSTORE   连接  AUTH ECHO PING QUIT SELECT   服务器  BGREWRITEAOF BGSAVE CLIENT GETNAME CLIENT KILL CLIENT LIST CLIENT PAUSE CLIENT SETNAME CLUSTER SLOTS COMMAND COMMAND COUNT COMMAND GETKEYS COMMAND INFO CONFIG GET CONFIG RESETSTAT CONFIG REWRITE CONFIG SET DBSIZE DEBUG OBJECT DEBUG SEGFAULT FLUSHALL FLUSHDB INFO LASTSAVE MONITOR ROLE SAVE SHOWLOG SHUTDOWN SLAVEOF SYNC TIME   脚本  EVAL EVALSHA SCRIPT EXISTS SCRIPT FLUSH SCRIPT KILL SCRIPT LOAD   事务  DISCARD EXEC MULTI UNWATCH WATCH   HyperLogLog  PFADD PFCOUNT PGMERGE   发布订阅  PSUBSCRIBE PUBLISH PUBSUB PUNSUBSCRIBE SUBSCRIBE UNSUBSCRIBE   地理位置 (geo)  GEOADD GEODIST GEOHASH GEOPOS GEORADIUS GEORADIUSBYMEMBER   参考  www.redis.net.cn/order 神奇的 HyperLogLog 算法  "});index.add({'id':372,'href':'/note-cs/docs/basic/db/redis/source/type/','title':"类型实现",'content':"Redis 类型实现 参考  5 种基本数据结构  "});index.add({'id':373,'href':'/note-cs/docs/basic/os/ios/','title':"iOS",'content':"iOS "});index.add({'id':374,'href':'/note-cs/docs/others/tool/dev/jetbrains/','title':"Jetbrains",'content':"Jetbrains 破解 https://zhile.io/\nJetbrains 系列产品最新激活方法 [持续更新]\n"});index.add({'id':375,'href':'/note-cs/docs/basic/computer-composition/','title':"1.1 计算机组成原理",'content':"计算机组成原理 "});index.add({'id':376,'href':'/note-cs/docs/direction/be/','title':"2.1 后端",'content':"后端开发  教程 xingshaocheng/architect-awesome  后端架构师技术图谱\n"});index.add({'id':377,'href':'/note-cs/docs/domain/cc/','title':"3.1 云计算",'content':"云计算 "});index.add({'id':378,'href':'/note-cs/docs/book/basic/','title':"5.1 计算机基础",'content':"计算机基础 计算机组成原理 操作系统 数据结构与算法 计算机网络 编程语言 数据库 编译原理 "});index.add({'id':379,'href':'/note-cs/docs/book/basic/cc/','title':"5.1.1 计算机组成原理",'content':"计算机组成原理 Computer Composition\n"});index.add({'id':380,'href':'/note-cs/docs/domain/cc/edge/5g-edge/','title':"5G 边缘计算",'content':"5G 边缘计算 5G 的 G 是英文 Generation 的缩写，也就是 “世代” 的意思\n简单说，5G 就是第五代移动通信系统\n5G 5G 速度 世界上最快的 4G 网速（挪威，63.13Mbps）\n最快的宽带网速（新加坡，189Mbps）\n2019 年 1 月 24 日，华为发布业界标杆 5G 多模终端芯片巴龙 5000\n在 5G 峰值下载速率是 4G LTE 可体验速率的 10 倍\n5G 应用场景 国际电信联盟无线电通信局（ITU-R）定义了 5G 的三大典型应用场景为：\n 增强型移动宽带（eMBB） 超可靠低时延通信（uRLLC） 海量大规模连接物联网（mMTC）  增强型移动宽带（eMBB） eMBB 主要面向虚拟现实（VR）/ 增强现实（AR）、在线 4K 视频等高带宽需求业务\n超可靠低时延通信（uRLLC） mMTC 主要面向智慧城市、智能交通等高连接密度需求的业务\n海量大规模连接物联网（mMTC） uRLLC 主要面向车联网、无人驾驶、无人机等时延敏感的业务。\n5G 技术 5G 承载网 在无线侧有大量新技术实现对不同应用场景的支撑，但传输网络侧，硬件技术提升有限的情况下，需要对网络架构进行革新。\n5G 承载整体要求 5G 承载组网架构 多样化网络需求 边缘计算技术就是解决不同应用带来的多样化网络需求的核心技术之一\n在靠近接入网的机房增加计算能力，将能够\n 大幅降低业务时延 减少对传输网的带宽压力降低传输成本 进一步提高内容分发效率提升用户体验  传统网络结构中，信息的处理主要位于核心网的数据中心机房内，所有信息必须从网络边缘传输到核心网进行处理之后再返回网络边缘。\n5G 时代，传输网架构中引入边缘计算技术，在靠近接入侧的边缘机房部署网关、服务器等设备，增加计算能力，将低时延业务、局域性数据、低价值量数据等数据在边缘机房进行处理和传输，不需要通过传输网返回核心网，进而降低时延、减少回传压力、提升用户体验。\n 5G 应用 底层网络进步带来应用和商业模式的升级\n 边缘计算 边缘计算在网络中的位置 为实现边缘计算，需要在更底层的网络节点增加计算和转发能力，运营商组网结构将逐步演进，边缘计算能力持续提升。\n边缘计算节点部署方式  5G 与边缘计算有什么关系？ 5G 通信网络更加去中心化，需要在网络边缘部署小规模或者便携式数据中心，进行终端请求的本地化处理，以满足 URLLC 和 mMTC 的超低延时需求，因此边缘计算是 5G 核心技术之一。\n5G 的三大典型应用场景对网络性能的要求有显著差异，但为控制成本，运营商必然选择一张承载网 + 网络切片 / 边缘计算技术，实现在最少的资本投入下最丰富的网络功能。\n在 5G 时代，承载网的带宽瓶颈、时延抖动等性能瓶颈难以突破，引入边缘计算后将大量业务在网络边缘终结。\n参考：\n 终于有人把 5G 和边缘计算的关系说清楚了 5G 边缘计算跟我们有什么关系？  "});index.add({'id':381,'href':'/note-cs/docs/course/basic/','title':"6.1 计算机基础",'content':"计算机基础 计算机组成原理 操作系统 数据结构与算法 计算机网络 编程语言 数据库 编译原理 "});index.add({'id':382,'href':'/note-cs/docs/course/basic/cc/','title':"6.1.1 计算机组成原理",'content':"计算机组成原理 Computer Composition\n"});index.add({'id':383,'href':'/note-cs/docs/basic/os/android/','title':"Android",'content':"Android "});index.add({'id':384,'href':'/note-cs/docs/direction/client/android/','title':"Android",'content':"Android "});index.add({'id':385,'href':'/note-cs/docs/basic/pl/csharp/','title':"C#",'content':"C# 学习笔记 "});index.add({'id':386,'href':'/note-cs/docs/direction/arch/principle/cap/','title':"CAP",'content':"CAP P 是前提 在理论计算机科学中，CAP 定理（CAP theorem），又被称作布鲁尔定理（Brewer\u0026rsquo;s theorem），它指出对于一个distributed data store 来说，不可能同时满足以下三点：\n 一致性（Consistency）  每次读取要么获得最近写入的数据，要么获得一个错误。   可用性（Availability）  每次请求都能获得一个非错误响应，但不保证返回的是最新写入的数据。   分区容错性（Partition tolerance）  以实际效果而言，分区相当于对通信的时限要求。系统如果不能在时限内达成数据一致性，就意味着发生了分区的情况，必须就当前操作在 C 和 A 之间做出选择。 尽管任意数量的消息被节点间的网络丢失（或延迟），系统仍继续运行。    一般选 AP 也就是说，在存在网络分区的情况下，一致性和可用性必须二选一。\n比如：A 服务器 B 服务器同步数据，现在 A B 之间网络断掉了，那么现在发来 A 一个写入请求，但是 B 却没有相关的请求，显然，\n 如果 A 不写，保持一致性，那么我们就失去了 A 的服务， 但是如果 A 写了，跟 B 的数据就不一致了，我们自然就丧失了一致性。  这里的一致性（Consistency）是强一致性，意思是 AB 的数据时刻都是同步的，\n如果我们放弃了强一致性，不代表我们的数据就是一定是不一致的了，我们可以让 A 先写入本地，等到通信恢复了再同步给 B，这就是所谓的最终一致性，长远的看我们的数据还是一致的，我们只是在某一个时间窗口里数据不一致罢了。\n如果这个时间窗口小过了用户逻辑处理的时间。那么其实对于用户来说根本感觉不到。\n现实中的 CAP CAP 对实际工作缺乏指导性。\n实际系统主要有三种：\n 强调 availability 的 eventual consistency 系统，  比如 Amazon Dynamo 及他们的复制品；   强调一致性的系统，  典型的是基于 Paxos 的系统；   强调性能不顾其他的系统，  典型的是 Async replication 的主从备份系统。    参考  CAP 理论常被解释为一种 “三选二” 定律，这是否是一种误解？ 分布式事务中的最终一致具体应该如何实现？ 分布式系统中的数据一致性和性能怎么权衡？ 如何浅显易懂地解说 Paxos 的算法？  "});index.add({'id':387,'href':'/note-cs/docs/direction/be/auth/sso/cas/','title':"CAS",'content':"CAS 简介 集中式认证服务（英语：Central Authentication Service，缩写 **CAS **）是一种针对万维网的单点登录协议。它的目的是允许一个用户访问多个应用程序，而只需提供一次凭证（如用户名和密码）。它还允许 web 应用程序在没有获得用户的安全凭据（如密码）的情况下对用户进行身份验证。\u0026ldquo;CAS\u0026rdquo; 也指实现了该协议的软件包。\nCAS 是由耶鲁大学 的 Shawn Bayern 创始的，后来由耶鲁大学的 Drew Mazurek 维护。CAS1.0 实现了单点登录。 CAS2.0 引入了多级代理认证（Multi-tier proxy authentication）。CAS 其他几个版本已经有了新的功能。\n2004 年 12 月，CAS 成为 Jasig（英语：Jasig）的一个项目，2008 年该组织负责 CAS 的维护和发展。CAS 原名 \u0026ldquo;耶鲁大学 CAS\u0026rdquo;，现在则被称为 \u0026ldquo;Jasig CAS\u0026rdquo;。\n原理 Cas Server  sequenceDiagram participant c as Client (The browser) participant ws as Web Server participant cs as CAS Server c-ws: 访问网站地址 Note over ws: 尝试从 cookie 获取 pToken 和 sToken alt pToken 和 sToken 同时存在 ws--cs: /validate 验证合法性 alt 正常登录 cs--ws: 返回用户信息 ws-c: 返回用户请求内容 else 不正常 cs--ws: 返回状态码 204 ws-c: 返回重定向到 CAS 登录接口 Note over c, cs: 后面流程参考底下 Loop 循环 end else 不同时存在 ws-c: 返回重定向到 CAS 登录接口 loop 访问 CAS 登录页面 c-cs: 登录 alt 登录成功 cs-c: 返回带 ticket 的重定向，并在浏览器写入 pToken 的 cookie c-ws: 带有 ticket 的请求 ws--cs: 使用 ticket 置换 sToken alt 合法 ticket cs--ws: 返回 sToken ws-c: 返回用户请求内容，并在浏览器写入 sToken 的 cookie else 非法 ticket ws-c: 返回重定向到 CAS 登录接口 end else 登录失败 cs-c: 返回错误提示页面 end end end Session Server + Cas Server sequenceDiagram participant c as Client (The browser) participant ws as Web Server participant cs as CAS Server participant ss as Session Server c-ws: 访问网站地址 Note over ws: 尝试从 cookie 获取 pToken 和 sToken alt pToken 和 sToken 同时存在 ws--ss: /validate 验证合法性 alt 正常登录 ss--ws: 返回用户信息 ws-c: 返回用户请求内容 else 不正常 ss--ws: 返回状态码 204 ws-c: 返回重定向到 CAS 登录接口 Note over c, ss: 后面流程参考底下 Loop 循环 end else 不同时存在 ws-c: 返回重定向到 CAS 登录接口 loop 访问 CAS 登录页面 c-cs: 登录 alt 登录成功 cs-c: 返回带 ticket 的重定向，并在浏览器写入 pToken 的 cookie c-ws: 带有 ticket 的请求 ws--cs: 使用 ticket 置换 sToken alt 合法 ticket cs--ws: 返回 sToken ws-c: 返回用户请求内容，并在浏览器写入 sToken 的 cookie else 非法 ticket ws-c: 返回重定向到 CAS 登录接口 end else 登录失败 ss-c: 返回错误提示页面 end end end 百度 UUAP   用户访问接入 uuap 的下游系统 xx.baidu.com，例如 family.baidu.com。\n  下游系统后端 server 从 cookie 中获取 pToken 及 sToken，校验是否同时存在，不同时存在直接重定向用户到 uuap 登录接口认证。\n pToken：存在于 baidu.com（baidu-int.com）域名下，cookie 的名字为 UUAP_P_TOKEN，线下环境统一为 UUAP_P_TOKEN_OFFLINE sToken：存在于下游系统的域名下面、该值为 uuap 认证成功后签发的 ticket 参数、下游系统获取后将其存入您的域名下，有效期 30 天、该值通用名称为 UUAP_S_TOKEN\n   pToken 与 sToken\n 如果 pToken 与 sToken 同时存在，则将 pToken、sToken 及您的 appKey 作为参数，发送 POST 请求到 UUAP-SESSION 的 Session 登录校验校验用户是否正常登录，如果正常登录返回登录用户的基本信息，未正常登录则返回状态码 204，重定向用户到 uuap 登录接口认证 如果 pToken 与 sToken 不是同时存在，下游系统直接重定向用户到 uuap 登录接口认证。    如果 UUAP-SESSION 返回用户登录成功并且返回登录用户的基本信息，下游系统可允许用户访问受保护的内容。\n  如果 UUAP-SESSION 返回状态码 204，则按照 3-2 的步骤，下游系统直接通知前端跳转 UUAP-SSO 认证服务器认证。\n  下游系统携带 service 及 appKey 参数，访问 UUAP-SSO 的 uuap 登录接口接口请求用户认证。\n service：第 1 步中用户访问的下游系统的 url，请对该 url 进行 urlencode appKey：uuap 签发的下游系统唯一 id\n   UUAP-SSO 认证服务器认证通过会在 baidu 的根域名下植入 pToken 的 cookie，并且会在用户传递的 service 回调地址后面追加 ticket 参数通知用户跳转，下游系统 server 可获取该参数，调用 SToken 置换接口获取 SToken，将其以 cookie 的形式存入你们的域名下，该值就是 sToken。\n cookie 植入成功后要在之前访问 url 的基础上去除 ticket 参数让用户重新 302 访问一次，这样就能防止 server 看到访问 url 中存在 ticket 参数关键字陷入反复植入 sToken 的死循环，跳转后用户重新从第 1 步执行。    认证失败，跳转错误页面。\n   参考  mermaid  "});index.add({'id':388,'href':'/note-cs/docs/others/tool/dev/ssh/config/','title':"config",'content':"config my config ################ vps ################ Host bcc HostName 106.13.4.39 User root IdentityFile ~/.ssh/id_rsa Host vultr HostName 149.28.142.246 User root IdentityFile ~/.ssh/id_rsa ################ baidu ################ Host baidu HostName relay.baidu-int.com User yewang ################ git ################ Host github HostName github.com User git IdentityFile ~/.ssh/id_rsa Host gitlab HostName gitlab.com User git IdentityFile ~/.ssh/id_rsa Host bitbucket HostName bitbucket.org User git IdentityFile ~/.ssh/id_rsa Host gitcafe HostName e.coding.net User git IdentityFile ~/.ssh/id_rsa Host gitee HostName gitee.com User git IdentityFile ~/.ssh/id_rsa ################ others ################ Host * # 复用之前已经建立的连接 ControlMaster auto # 在最后一个连接关闭之后也不真正的关掉连接 ControlPersist yes # 指定了这个连接的 socket 保存的路径 ControlPath ~/.ssh/connection-%r@%h:%p # 心跳 ServerAliveInterval 60 # ServerAliveCountMax 20 # ForwardAgent yes # KexAlgorithms +diffie-hellman-group1-sha1 # PreferredAuthentications publickey # TCPKeepAlive no # Compression yes "});index.add({'id':389,'href':'/note-cs/docs/domain/cc/others/saas/crm/','title':"CRM",'content':"CRM "});index.add({'id':390,'href':'/note-cs/docs/domain/cc/container/docker/network/','title':"Docker 网络",'content':"Docker 网络 网络模式  bridge 模式  使用 –net=bridge 指定，默认   host 模式  使用 –net=host 指定 一些对安全性有求高并且不需要联网的应用可以使用 none 网络   none 模式  使用 –net=none 指定   container 模式  使用 –net=container:NAMEorID 指定    host 模式 优势：\n host 网络最大的好处就是性能  劣势：\n host 网络不便之处就是考虑端口冲突问题  "});index.add({'id':391,'href':'/note-cs/docs/others/skill/debug/gdb/tutorial/','title':"GDB 教程",'content':"GDB 教程 "});index.add({'id':392,'href':'/note-cs/docs/others/tool/dev/git/','title':"git",'content':"git git module git submodule foreach git reset --hard HEAD git submodule update git submodule foreach \u0026#34;git checkout master; git pull\u0026#34; git submodule foreach git clean -f  merge vs squash vs rebase merge 不能保持 master 分支干净，但是保持了所有的 commit history，大多数情况下都是不好的，个别情况挺好 squash 也可以保持 master 分支干净，但是 master 中 author 都是 maintainer，而不是原 owner rebase 可以尽可能保持 master 分支干净整洁，并且易于识别 author\nsquash merge # 切换到目标分支 $ git checkout master # 以 squash 的形式 merge $ git merge --squash devel # it does not produce a commit right away: you need an additional commit $ git commit -m \u0026#34;squash branch\u0026#34;  你会发现，在 master 分支上居然有未提交的修改，然后你就需要在 master 上主动提交了修改， 注意，这里是你 commit 的，也就是改变了 commit 的 author。 git merge has a \u0026ndash;commit option, but it cannot be used with \u0026ndash;squash. It was never possible to use \u0026ndash;commit and \u0026ndash;squash together.  参考：\n In git, what is the difference between merge \u0026ndash;squash and rebase?  rebase merge # 先切换到 devel 分支（不一样咯） $ git checkout devel # 变基 $ git rebase -i master # 切换回目标分支 $ git checkout master # 合并 $ git merge  我们在 devel 里面对照 master 进行了变基  所谓的变基其实就是找到两个分支共同的祖先   然后在当前分支上合并从共同祖先到现在的所有 commit  会选择怎么处理这些 commit   然后我们就得到了一个从公共 commit 到现在的单个 commit 这个时候别人将我们这个 commit 合并到 master 也只会在 master 上留下一个 commit 记录   合并 git commit 参考：\n Trimming Git Commits/Squashing Git History  "});index.add({'id':393,'href':'/note-cs/docs/direction/be/web-service/rpc/grpc/','title':"gRPC",'content':"gRPC "});index.add({'id':394,'href':'/note-cs/docs/domain/cc/virtual/hyperkit/','title':"HyperKit",'content':"HyperKit "});index.add({'id':395,'href':'/note-cs/docs/domain/cc/others/iaas/','title':"IaaS",'content':"IaaS "});index.add({'id':396,'href':'/note-cs/docs/direction/fe/lib/jquery/','title':"Jquery",'content':"Jquery "});index.add({'id':397,'href':'/note-cs/docs/direction/be/proxy/envoy/xds/lds/','title':"LDS",'content':"LDS 监听器发现服务（LDS）是一个可选的 API，Envoy 将调用它来动态获取监听器。Envoy 将协调 API 响应，并根据需要添加、修改或删除已知的监听器。\n监听器更新的语义如下：\n 每个监听器必须有一个独特的名字。如果没有提供名称，Envoy 将创建一个 UUID。要动态更新的监听器，管理服务必须提供监听器的唯一名称。 当一个监听器被添加，在参与连接处理之前，会先进入 “预热” 阶段。例如，如果监听器引用 RDS 配置，那么在监听器迁移到 “active” 之前，将会解析并提取该配置。 监听器一旦创建，实际上就会保持不变。因此，更新监听器时，会创建一个全新的监听器（使用相同的侦听套接字）。新增加的监听者都会通过上面所描述的相同 “预热” 过程。 当更新或删除监听器时，旧的监听器将被置于 “draining（逐出）” 状态，就像整个服务重新启动时一样。监听器移除之后，该监听器所拥有的连接，经过一段时间优雅地关闭（如果可能的话）剩余的连接。逐出时间通过 --drain-time-s 选项设置。  注意\n 任何在 Envoy 配置中静态定义的监听器都不能通过 LDS API 进行修改或删除。\n "});index.add({'id':398,'href':'/note-cs/docs/others/skill/debug/lldb/','title':"LLDB",'content':"LLDB "});index.add({'id':399,'href':'/note-cs/docs/others/skill/debug/lldb/tutorial/','title':"LLDB 教程",'content':"LLDB 教程 "});index.add({'id':400,'href':'/note-cs/docs/basic/db/mysql/','title':"Mysql",'content':"Mysql "});index.add({'id':401,'href':'/note-cs/docs/others/skill/lorawan/chirpstack/network/','title':"Network",'content':"ChirpStack Network Server ChirpStack Network Server is an open-source LoRaWAN network-server. https://www.chirpstack.io\n数据库    Schema Name Type Owner     public code_migration table chirpstack_ns   public device table chirpstack_ns   public device_activation table chirpstack_ns   public device_activation_id_seq sequence chirpstack_ns   public device_multicast_group table chirpstack_ns   public device_profile table chirpstack_ns   public device_queue table chirpstack_ns   public device_queue_id_seq sequence chirpstack_ns   public gateway table chirpstack_ns   public gateway_board table chirpstack_ns   public gateway_profile table chirpstack_ns   public gateway_profile_extra_channel table chirpstack_ns   public gateway_profile_extra_channel_id_seq sequence chirpstack_ns   public gateway_stats table chirpstack_ns   public gateway_stats_id_seq sequence chirpstack_ns   public gorp_migrations table chirpstack_ns   public multicast_group table chirpstack_ns   public multicast_queue table chirpstack_ns   public multicast_queue_id_seq sequence chirpstack_ns   public routing_profile table chirpstack_ns   public service_profile table chirpstack_ns    (21 rows)\n"});index.add({'id':402,'href':'/note-cs/docs/direction/be/proxy/nginx/','title':"Nginx",'content':"Nginx "});index.add({'id':403,'href':'/note-cs/docs/direction/be/auth/oauth/','title':"OAuth",'content':"OAuth 2.0 OAuth 2.0 协议参考 rfc6749\n1.0  问答 为什么需要 Refresh Token 这样的处理是为了职责的分离：\n refresh token 负责身份认证 access token 负责请求资源。   参考  Choosing an SSO Strategy: SAML vs OAuth2  rfc6749 百度 UUAP OAuth "});index.add({'id':404,'href':'/note-cs/docs/direction/be/auth/openid/','title':"OpenID",'content':"OpenID OpenID vs OAuth  OpenID 只用于身份认证（Authentication），允许你以同一个账户在多个网站登陆。它仅仅是为你的合法身份背书，当你以 Facebook 账号登陆某个站点之后，该站点无权访问你的在 Facebook 上的数据 OAuth 用于授权（Authorisation），允许被授权方访问授权方的用户数据  "});index.add({'id':405,'href':'/note-cs/docs/direction/arch/scene/distributed/paxos/','title':"Paxos",'content':"Paxos "});index.add({'id':406,'href':'/note-cs/docs/direction/be/web-service/rest/','title':"REST",'content':"REST Representational state transfer (REST) is a software architectural style that defines a set of constraints to be used for creating Web services.\n"});index.add({'id':407,'href':'/note-cs/docs/domain/cc/others/saas/crm/salesforce/','title':"Salesforce",'content':"Salesforce "});index.add({'id':408,'href':'/note-cs/docs/others/tool/dev/ssh/','title':"ssh",'content':"ssh ssh-keygen "});index.add({'id':409,'href':'/note-cs/docs/basic/db/redis/source/type/string/','title':"String 实现",'content':"Redis String 类型实现 Redis 中的字符串是一种 动态字符串，这意味着使用者可以修改，它的底层实现有点类似于 Java 中的 ArrayList，有一个字符数组，从源码的 sds.h/sdshdr 文件 中可以看到 Redis 底层对于字符串的定义 SDS，即 Simple Dynamic String 结构：\n/* Note: sdshdr5 is never used, we just access the flags byte directly. * However is here to document the layout of type 5 SDS strings. */ struct __attribute__ ((__packed__)) sdshdr5 { unsigned char flags; /* 3 lsb of type, and 5 msb of string length */ char buf[]; }; struct __attribute__ ((__packed__)) sdshdr8 { uint8_t len; /* used */ uint8_t alloc; /* excluding the header and null terminator */ unsigned char flags; /* 3 lsb of type, 5 unused bits */ char buf[]; }; struct __attribute__ ((__packed__)) sdshdr16 { uint16_t len; /* used */ uint16_t alloc; /* excluding the header and null terminator */ unsigned char flags; /* 3 lsb of type, 5 unused bits */ char buf[]; }; struct __attribute__ ((__packed__)) sdshdr32 { uint32_t len; /* used */ uint32_t alloc; /* excluding the header and null terminator */ unsigned char flags; /* 3 lsb of type, 5 unused bits */ char buf[]; }; struct __attribute__ ((__packed__)) sdshdr64 { uint64_t len; /* used */ uint64_t alloc; /* excluding the header and null terminator */ unsigned char flags; /* 3 lsb of type, 5 unused bits */ char buf[]; }; 你会发现同样一组结构 Redis 使用泛型定义了好多次，为什么不直接使用 int 类型呢？\n因为当字符串比较短的时候，len 和 alloc 可以使用 byte 和 short 来表示，Redis 为了对内存做极致的优化，不同长度的字符串使用不同的结构体来表示。\nSDS 与 C 字符串的区别 为什么不考虑直接使用 C 语言的字符串呢？\nC 字符串太简单 因为 C 语言这种简单的字符串表示方式 不符合 Redis 对字符串在安全性、效率以及功能方面的要求。\nC 语言使用了一个长度为 N+1 的字符数组来表示长度为 N 的字符串，并且字符数组最后一个元素总是 \u0026lsquo;\\0\u0026rsquo;。\n这样简单的数据结构可能会造成以下一些问题：\n 获取字符串长度为 O (N) 级别的操作 → 因为 C 不保存数组的长度，每次都需要遍历一遍整个数组； 不能很好的杜绝 缓冲区溢出 / 内存泄漏 的问题 → 跟上述问题原因一样，如果执行拼接 or 缩短字符串的操作，如果操作不当就很容易造成上述问题； C 字符串 只能保存文本数据 → 因为 C 语言中的字符串必须符合某种编码（比如 ASCII），例如中间出现的 \u0026lsquo;\\0\u0026rsquo; 可能会被判定为提前结束的字符串而识别不了；  以追加字符串的操作举例，Redis 源码如下：\n/* Append the specified binary-safe string pointed by \u0026#39;t\u0026#39; of \u0026#39;len\u0026#39; bytes to the * end of the specified sds string \u0026#39;s\u0026#39;. * * After the call, the passed sds string is no longer valid and all the * references must be substituted with the new pointer returned by the call. */ sds sdscatlen(sds s, const void *t, size_t len) { // 获取原字符串的长度  size_t curlen = sdslen(s); // 按需调整空间，如果容量不够容纳追加的内容，就会重新分配字节数组并复制原字符串的内容到新数组中  s = sdsMakeRoomFor(s,len); if (s == NULL) return NULL; // 内存不足  memcpy(s+curlen, t, len); // 追加目标字符串到字节数组中  sdssetlen(s, curlen+len); // 设置追加后的长度  s[curlen+len] = \u0026#39;\\0\u0026#39;; // 让字符串以 \\0 结尾，便于调试打印  return s; }  参考  5 种基本数据结构  "});index.add({'id':410,'href':'/note-cs/docs/domain/cc/virtual/vmware/','title':"VMware Fusion",'content':"VMware Fusion "});index.add({'id':411,'href':'/note-cs/docs/others/tool/dev/vscode/debug/','title':"VSCode Debug",'content':"VSCode Debug 参考：\n  USER GUIDE - Debugging\n  Debug C++ in Visual Studio Code\n  "});index.add({'id':412,'href':'/note-cs/docs/direction/fe/frame/vue/','title':"Vue",'content':"Vue "});index.add({'id':413,'href':'/note-cs/docs/direction/be/proxy/envoy/xds/','title':"xDS",'content':"xDS "});index.add({'id':414,'href':'/note-cs/docs/direction/be/web-service/standard/xml/','title':"XML",'content':"XML "});index.add({'id':415,'href':'/note-cs/docs/basic/pl/cpp/basic/grammar/vs-c/','title':"与 C 的差异",'content':"C++ 与 C 语言的差异  字符字面量的大小 // 在C++中，字符字面量的大小是一个字节。 sizeof(\u0026#39;c\u0026#39;) == 1 // 在C语言中，字符字面量的大小与int相同。 sizeof(\u0026#39;c\u0026#39;) == sizeof(10)  函数原型与函数定义匹配 // C++ 的函数原型与函数定义是严格匹配的 void func(); // 这个函数不能接受任何参数  // 而在C语言中 void func(); // 这个函数能接受任意数量的参数  NULL vs nullptr // 在 C++ 中，用 nullptr 代替 C 语言中的 NULL int* ip = nullptr;  同文件 // C++ 也可以使用 C 语言的标准头文件， // 但是需要加上前缀 “c” 并去掉末尾的 “.h”。 #include \u0026lt;cstdio\u0026gt;  "});index.add({'id':416,'href':'/note-cs/docs/basic/pl/c/basic/grammar/vs-cpp/','title':"与 C++ 的差异",'content':"C 语言与 C++ 的差异 参考：C++ 学习笔记\n"});index.add({'id':417,'href':'/note-cs/docs/domain/cc/cn/','title':"云原生",'content':"云原生 "});index.add({'id':418,'href':'/note-cs/docs/basic/pl/csharp/appendix/attention/','title':"关注",'content':"关注 其他 octocat/Spoon-Knife "});index.add({'id':419,'href':'/note-cs/docs/basic/pl/kotlin/appendix/attention/','title':"关注",'content':"关注 其他 octocat/Spoon-Knife "});index.add({'id':420,'href':'/note-cs/docs/basic/pl/lua/appendix/attention/','title':"关注",'content':"关注 其他 octocat/Spoon-Knife "});index.add({'id':421,'href':'/note-cs/docs/basic/pl/ruby/appendix/attention/','title':"关注",'content':"关注 其他 octocat/Spoon-Knife "});index.add({'id':422,'href':'/note-cs/docs/basic/pl/swift/appendix/attention/','title':"关注",'content':"关注 其他 octocat/Spoon-Knife "});index.add({'id':423,'href':'/note-cs/docs/direction/arch/scene/circuit-breaker/attention/','title':"关注",'content':"关注 其他 resilience4j/resilience4j Netflix/Hystrix "});index.add({'id':424,'href':'/note-cs/docs/domain/cc/container/docker/attention/','title':"关注",'content':"关注 moby/moby  Moby Project - a collaborative project for the container ecosystem to assemble container-based systems https://mobyproject.org/\ndocker/docker-ce  Docker CE https://www.docker.com/community-edition\nplay-with-docker/play-with-docker  Play With Docker gives you the experience of having a free Alpine Linux Virtual Machine in the cloud where you can build and run Docker containers and even create clusters with Docker features like Swarm Mode.\nUnder the hood DIND or Docker-in-Docker is used to give the effect of multiple VMs/PCs.\nA live version is available at: http://play-with-docker.com/\n"});index.add({'id':425,'href':'/note-cs/docs/basic/pl/cpp/basic/grammar/function/','title':"函数",'content':"函数 函数参数 参数默认值\n// 你可以为函数的参数指定默认值， // 默认参数必须放在所有的常规参数之后。 void doSomethingWithInts(int a, int b = 1, int c = 4) { } 函数重载 // C++支持函数重载，你可以定义一组名称相同而参数不同的函数 void print(char const* myString) { printf(\u0026#34;String %s\\n\u0026#34;, myString); } void print(int myInt) { printf(\u0026#34;My int is %d\u0026#34;, myInt); } int main() { print(\u0026#34;Hello\u0026#34;); // 解析为 void print(const char*)  print(15); // 解析为 void print(int) } "});index.add({'id':426,'href':'/note-cs/docs/direction/arch/principle/','title':"原则",'content':"架构设计原则 "});index.add({'id':427,'href':'/note-cs/docs/domain/cc/container/docker/command/','title':"命令",'content':"Docker 命令 docker ps docker ps vs docker container ls Management Commands vs Commands\nDocker 1.13+ introduced grouped commands to help organize a bunch of Docker commands. Both commands do the same thing.\nFor example docker container ls is the new way to do docker ps.\nSure it’s more typing, but it’s a lot more clear on what it does. Likewise, now you can run docker image ls, docker network ls or docker volume ls. There’s consistency across all of these commands.\n参考：\n Difference between docker ps vs docker container ls   docker attach vs docker exec $ sudo docker attach 665b4a1e17b6 #by ID or $ sudo docker attach loving_heisenberg #by Name $ root@665b4a1e17b6:/# $ sudo docker exec -i -t 665b4a1e17b6 /bin/bash #by ID or $ sudo docker exec -i -t loving_heisenberg /bin/bash #by Name $ root@665b4a1e17b6:/#  docker attach isn\u0026rsquo;t for running an extra thing in a container, it\u0026rsquo;s for attaching to the running process.  attach 只有一个实例   docker exec is specifically for running new things in a already started container, be it a shell or some other process.  exec 可以启动多个    参考：\n difference between docker attach and docker exec How to get bash or ssh into a running container in background mode?  "});index.add({'id':428,'href':'/note-cs/docs/basic/db/redis/basic/practice/','title':"实践",'content':"实践 "});index.add({'id':429,'href':'/note-cs/docs/basic/pl/cpp/basic/practice/','title':"实践",'content':"实践 "});index.add({'id':430,'href':'/note-cs/docs/basic/pl/php/basic/practice/','title':"实践",'content':"实践 "});index.add({'id':431,'href':'/note-cs/docs/basic/pl/rust/basic/practice/','title':"实践",'content':"实践 "});index.add({'id':432,'href':'/note-cs/docs/direction/embedded/basic/practice/','title':"实践",'content':"实践 "});index.add({'id':433,'href':'/note-cs/docs/direction/security/basic/practice/','title':"实践",'content':"实践 "});index.add({'id':434,'href':'/note-cs/docs/domain/cc/knative/basic/practice/','title':"实践",'content':"实践 "});index.add({'id':435,'href':'/note-cs/docs/basic/pl/cpp/basic/grammar/pointer/','title':"指针",'content':"C++ 指针 智能指针    指针类别 支持 备注     unique_ptr C++ 11 拥有独有对象所有权语义的智能指针   shared_ptr C++ 11 拥有共享对象所有权语义的智能指针   weak_ptr C++ 11 到 std::shared_ptr 所管理对象的弱引用   auto_ptr C++ 17 中移除 拥有严格对象所有权语义的智能指针    unique_ptr std::unique_ptr 是通过指针占有并管理另一对象，并在 unique_ptr 离开作用域时释放该对象的智能指针。在下列两者之一发生时用关联的删除器释放对象：\n 销毁了管理的 unique_ptr 对象 通过 operator= 或 reset () 赋值另一指针给管理的 unique_ptr 对象。  shared_ptr std::shared_ptr 是通过指针保持对象共享所有权的智能指针。多个 shared_ptr 对象可占有同一对象。下列情况之一出现时销毁对象并解分配其内存：\n 最后剩下的占有对象的 shared_ptr 被销毁； 最后剩下的占有对象的 shared_ptr 被通过 operator= 或 reset () 赋值为另一指针。  有两种方式创建 shared_ptr ：\nvoid main( ) { shared_ptr\u0026lt;int\u0026gt; sptr1( new int ); // 使用 make_shared 宏可以加速创建的过程  // 因为 shared_ptr 主动分配内存并且保存引用计数 (reference count)  shared_ptr\u0026lt;int\u0026gt; sptr2 = make_shared\u0026lt;int\u0026gt;(100); } 参考：C++ 智能指针 - 内存泄露的惨痛经历\n "});index.add({'id':436,'href':'/note-cs/docs/others/tool/recommend/','title':"推荐软件",'content':"推荐软件 MacOS 开发 iTerm Keyboard Maestro  参考  jaywcjlove/awesome-mac  Windows todoiOS todoAndroid todoLinux todo "});index.add({'id':437,'href':'/note-cs/docs/basic/pl/cpp/design/standard/','title':"标准",'content':"C++ 标准 参考：https://www.cnblogs.com/xuyaowen/p/c-cxx-standards.html\n"});index.add({'id':438,'href':'/note-cs/docs/direction/fe/frame/','title':"框架",'content':"框架 "});index.add({'id':439,'href':'/note-cs/docs/direction/arch/scene/circuit-breaker/','title':"熔断",'content':"熔断 断路器\n参考 "});index.add({'id':440,'href':'/note-cs/docs/basic/pl/cpp/basic/version/','title':"版本",'content':"C++ 版本 "});index.add({'id':441,'href':'/note-cs/docs/basic/os/android/basic/spec/','title':"编程规范",'content':"编程规范 "});index.add({'id':442,'href':'/note-cs/docs/basic/os/ios/basic/spec/','title':"编程规范",'content':"编程规范 "});index.add({'id':443,'href':'/note-cs/docs/basic/os/macos/basic/spec/','title':"编程规范",'content':"编程规范 "});index.add({'id':444,'href':'/note-cs/docs/basic/os/unix/basic/spec/','title':"编程规范",'content':"编程规范 "});index.add({'id':445,'href':'/note-cs/docs/basic/os/windows/basic/spec/','title':"编程规范",'content':"编程规范 "});index.add({'id':446,'href':'/note-cs/docs/basic/pl/csharp/basic/spec/','title':"编程规范",'content':"编程规范 "});index.add({'id':447,'href':'/note-cs/docs/basic/pl/kotlin/basic/spec/','title':"编程规范",'content':"编程规范 "});index.add({'id':448,'href':'/note-cs/docs/basic/pl/lua/basic/spec/','title':"编程规范",'content':"编程规范 "});index.add({'id':449,'href':'/note-cs/docs/basic/pl/ruby/basic/spec/','title':"编程规范",'content':"编程规范 "});index.add({'id':450,'href':'/note-cs/docs/basic/pl/scala/basic/spec/','title':"编程规范",'content':"编程规范 "});index.add({'id':451,'href':'/note-cs/docs/basic/pl/swift/basic/spec/','title':"编程规范",'content':"编程规范 "});index.add({'id':452,'href':'/note-cs/docs/others/tool/study/','title':"计算机学习",'content':"计算机学习 "});index.add({'id':453,'href':'/note-cs/docs/others/skill/onvif/discovery/','title':"设备发现",'content':"设备发现 我们传统的 Web Services 服务调用的模式都是这样的：客户端在设计时就预先知道目标服务的地址（IP 地址或者域名），客户端基于这个地址进行服务调用。\n那如果客户端预先不知道目标服务的地址该怎么办？\nWS-Discovery（全称为 Web Services Dynamic Discovery）标准就是用于解决该问题的，遵循该标准，客户端预先不知道目标服务地址的情况下，可以动态地探测到可用的目标服务，以便进行服务调用。这个过程就是「设备发现」的过程。\nWS-Discovery 模式 WS-Discovery 定义了两种模式：Ad hoc 模式和 Managed 模式。\nAd hoc 模式  Ad hoc 模式：客户端以多播 (multicast) 的形式往多播组 (multicast group) 发送一个 Probe（探测）消息搜寻目标服务，在该探测消息中，包含相应的搜寻条件。如果目标服务满足该条件，则直接将响应 ProbeMatch 消息（服务自身相关的信息，包括地址）回复给客户端。  Message Exchanges in an ad hoc mode. Message exchanges in an ad hoc mode in the presence of a Discovery Proxy. Managed 模式  Managed 模式：即代理模式。Ad hoc 模式有个局限性，只能局限于一个较小的网络。Managed 模式就是为了解决这个问题的，在 Managed 模式下，一个维护所有可用目标服务的中心发现代理（Discovery Proxy）被建立起来，客户端只需要将探测消息发送到该发现代理就可以得到相应的目标服务信息。  Message exchanges in a managed mode. 官方技术规范：http://docs.oasis-open.org/ws-dd/discovery/1.1/os/wsdd-discovery-1.1-spec-os.html\n 传输方式 TCP/IP 有三种传输方式：单播 (Unicast)、多播 (Multicast) 和广播 (Broadcast)，在 IPv6 领域还有另一种方式：任播 (Anycast)。\n单播 Unicast 单播 (Unicast)：一对一，双向通信，目的地址是对方主机地址。网络上绝大部分的数据都是以单播的形式传输的。如收发邮件、浏览网页等。\n多播 Multicast 多播 (Multicast)：也叫组播，一对多，单向通信，目的地址是多播地址，主机可以通过 IGMP 协议请求加入或退出某个多播组 (multicast group)，数据只会转发给有需要（已加入组）的主机，不影响其他不需要（未加入组）的主机。如网上视频会议、网上视频点播、IPTV 等。\n多播地址（Multicast Address）有很多，各个行业都不一样，IPC 摄像头用的是 239.255.255.250（端口 3702）。\n多播地址的范围和分类可以见官方 IANA（互联网地址分配机构） 的说明：IPv4 Multicast Address Space Registry。\nWS-Discovery 协议用到了多播。\n广播 Broadcast 广播 (Broadcast)：一对所有，单向通信，目的地址是广播地址，整个网络中所有主机均可以收到（不管你是否需要），如 ARP 地址解析、GARP 数据包等。广播会被限制在局域网范围内，禁止广播数据穿过路由器，防止广播数据影响大面积的主机。\n参考：单播、多播（组播）和广播的区别\n IPC 搜索实现 实现 socket 编程（UDP），通过 sendto 往多播地址发送探测消息（Probe），再使用 recvfrom 接收 IPC 的应答消息（ProbeMatch）\n组播 IP 地址 组播也是一种 IP 包，也有源 IP 地址，目的 IP 地址，\n 源 IP 地址为组播源的服务器 IP 地址， 目的地址为一个特殊的 IP 地址， 它位于 224.0.0.0 - 239.255.255.255 中，  由于 224.0.0.0/24 用于本地链路，即一跳的组播， 239.0.0.0/8 为私有组播地址， 所以实际的可用于在互联网上组播地址是 225.0.0.0/8 - 238.0.0.0/8    参考：\n 组播 IP 地址到底是谁的 IP？  "});index.add({'id':454,'href':'/note-cs/docs/basic/pl/csharp/basic/grammar/','title':"语法",'content':"语法 "});index.add({'id':455,'href':'/note-cs/docs/basic/pl/kotlin/basic/grammar/','title':"语法",'content':"语法 "});index.add({'id':456,'href':'/note-cs/docs/basic/pl/lua/basic/grammar/','title':"语法",'content':"语法 "});index.add({'id':457,'href':'/note-cs/docs/basic/pl/ruby/basic/grammar/','title':"语法",'content':"语法 "});index.add({'id':458,'href':'/note-cs/docs/basic/pl/swift/basic/grammar/','title':"语法",'content':"语法 "});index.add({'id':459,'href':'/note-cs/docs/domain/cc/edge/','title':"边缘计算",'content':"边缘计算 "});index.add({'id':460,'href':'/note-cs/docs/domain/cc/knative/','title':"Knative",'content':"Knative "});index.add({'id':461,'href':'/note-cs/docs/domain/cc/others/paas/','title':"PaaS",'content':"PaaS "});index.add({'id':462,'href':'/note-cs/docs/domain/cc/others/saas/','title':"SaaS",'content':"SaaS "});index.add({'id':463,'href':'/note-cs/docs/basic/pl/cpp/','title':"C++",'content':"C++ 学习笔记 "});index.add({'id':464,'href':'/note-cs/docs/domain/cc/others/paas/gae/','title':"GAE",'content':"Google App Engine "});index.add({'id':465,'href':'/note-cs/docs/book/basic/pl/go-advanced-programming/','title':"Go 语言高级编程",'content':"Go 语言实战 \n作者 柴树杉 国内第一批的 Go 语言爱好者，Go 语言代码贡献者，CGO 资深用户。同时对 WebAssembly 技术有一定研究，著有《WebAssembly 标准入门》。Github 账号为 chai2010。\n曹春晖 在 Web 领域工作多年，开源爱好者。对大型网站系统的架构和相关工具的实现很感兴趣，并且有一些研究成果。目前在滴滴平台技术部工作。\n 学习参考 "});index.add({'id':466,'href':'/note-cs/docs/direction/be/proxy/haproxy/','title':"HAProxy",'content':"HAProxy "});index.add({'id':467,'href':'/note-cs/docs/direction/be/web-service/rpc/spring-cloud/','title':"Spring Cloud",'content':"Spring Cloud 国外 Pivotal 公司 2014 年对外开源的 RPC 框架，仅支持 Java 语言。\n"});index.add({'id':468,'href':'/note-cs/docs/others/tool/dev/','title':"开发者工具",'content':"开发者工具 "});index.add({'id':469,'href':'/note-cs/docs/basic/os/','title':"1.2 操作系统",'content':"操作系统 "});index.add({'id':470,'href':'/note-cs/docs/direction/fe/','title':"2.2 前端",'content':"前端开发 "});index.add({'id':471,'href':'/note-cs/docs/domain/bigdata/','title':"3.2 大数据",'content':"大数据 "});index.add({'id':472,'href':'/note-cs/docs/others/skill/','title':"4.2 技能树",'content':"技能树 "});index.add({'id':473,'href':'/note-cs/docs/book/basic/os/','title':"5.1.2 操作系统",'content':"操作系统 "});index.add({'id':474,'href':'/note-cs/docs/book/be/','title':"5.2 后端",'content':"后端 "});index.add({'id':475,'href':'/note-cs/docs/course/basic/os/','title':"6.1.2 操作系统",'content':"操作系统 "});index.add({'id':476,'href':'/note-cs/docs/course/be/','title':"6.2 后端",'content':"后端 "});index.add({'id':477,'href':'/note-cs/docs/direction/arch/principle/acid/','title':"ACID",'content':"ACID  In computer science, ACID (atomicity, consistency, isolation, durability) is a set of properties of database transactions intended to guarantee validity even in the event of errors, power failures, etc. In the context of databases, a sequence of database operations that satisfies the ACID properties (and these can be perceived as a single logical operation on the data) is called a transaction.\n  ACID，是指数据库管理系统（DBMS）在写入或更新资料的过程中，为保证事务（transaction）是正确可靠的，所必须具备的四个特性：\n 原子性（Atomicity 又称不可分割性）  一个事务（transaction）中的所有操作，或者全部完成，或者全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。即，事务不可分割、不可约简。   一致性（Consistency）  在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设约束、触发器、级联回滚等。   隔离性（isolation，又称独立性）  数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括未提交读（Read uncommitted）、提交读（read committed）、可重复读（repeatable read）和串行化（Serializable）。   持久性（Durability）  事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。     ACID 是追求 CAP 的一致性 "});index.add({'id':478,'href':'/note-cs/docs/others/skill/lorawan/chirpstack/application/','title':"Application",'content':"ChirpStack Application Server ChirpStack Application Server is an open-source LoRaWAN application-server. https://www.chirpstack.io\n数据库    Schema Name Type Owner     public application table chirpstack_as   public application_id_seq sequence chirpstack_as   public code_migration table chirpstack_as   public device table chirpstack_as   public device_activation table chirpstack_as   public device_activation_id_seq sequence chirpstack_as   public device_keys table chirpstack_as   public device_multicast_group table chirpstack_as   public device_profile table chirpstack_as   public fuota_deployment table chirpstack_as   public fuota_deployment_device table chirpstack_as   public gateway table chirpstack_as   public gateway_ping table chirpstack_as   public gateway_ping_id_seq sequence chirpstack_as   public gateway_ping_rx table chirpstack_as   public gateway_ping_rx_id_seq sequence chirpstack_as   public gateway_profile table chirpstack_as   public gorp_migrations table chirpstack_as   public integration table chirpstack_as   public integration_id_seq sequence chirpstack_as   public multicast_group table chirpstack_as   public network_server table chirpstack_as   public network_server_id_seq sequence chirpstack_as   public organization table chirpstack_as   public organization_id_seq sequence chirpstack_as   public organization_user table chirpstack_as   public organization_user_id_seq sequence chirpstack_as   public remote_fragmentation_session table chirpstack_as   public remote_multicast_class_c_session table chirpstack_as   public remote_multicast_setup table chirpstack_as   public service_profile table chirpstack_as   public user table chirpstack_as   public user_id_seq sequence chirpstack_as    (33 rows)\n"});index.add({'id':479,'href':'/note-cs/docs/direction/arch/principle/base/','title':"BASE",'content':"BASE Basically Available, Soft state, Eventual consistency\nBASE 理论是 CAP 理论中的 AP 的延伸，是对互联网大规模分布式系统的实践总结，强调可用性。\n基本可用  流量削峰  在不同的时间，出售不同区域的票，将访问请求错开，削弱请求峰值   延迟响应  在春运期间，自己提交的购票请求，往往会在队列中排队等待处理，可能几分钟或十几分钟后，系统才开始处理，然后响应处理结果   体验降级  比如用小图片来替代原始图片，通过降低图片的清晰度和大小，提升系统的处理能力。   过载保护  把接收到的请求放在指定的队列中排队处理，如果请求等待时间超时了（假设是 100ms），这个时候直接拒绝超时请求；再比如队列满了之后，就清除队列中一定数量的排队请求，保护系统不过载，实现系统的基本可用。    最终的一致  读时修复：在读取数据时，检测数据的不一致，进行修复。  比如 Cassandra 的 Read Repair 实现，具体来说，在向 Cassandra 系统查询数据的时候，如果检测到不同节点的副本数据不一致，系统就自动修复数据。   写时修复：在写入数据，检测数据的不一致时，进行修复。  比如 Cassandra 的 Hinted Handoff 实现。具体来说，Cassandra 集群的节点之间远程写数据的时候，如果写失败就将数据缓存下来，然后定时重传，修复数据的不一致性。 写时修复不需要做数据一致性对比，性能消耗比较低，对系统运行影响也不大，推荐在实现最终一致性时优先实现这种方式。   异步修复：这个是最常用的方式，通过定时对账检测副本数据的一致性，并修复。   BASE 是追求 CAP 的可用性 "});index.add({'id':480,'href':'/note-cs/docs/direction/be/rpc/brpc/','title':"brpc",'content':"brpc  "});index.add({'id':481,'href':'/note-cs/docs/direction/be/proxy/envoy/xds/cds/','title':"CDS",'content':"CDS "});index.add({'id':482,'href':'/note-cs/docs/domain/cc/container/docker/tutorial/','title':"Docker 教程",'content':"Docker 教程 play-with-docker/play-with-docker  Play With Docker gives you the experience of having a free Alpine Linux Virtual Machine in the cloud where you can build and run Docker containers and even create clusters with Docker features like Swarm Mode.\nUnder the hood DIND or Docker-in-Docker is used to give the effect of multiple VMs/PCs.\nA live version is available at: http://play-with-docker.com/\n"});index.add({'id':483,'href':'/note-cs/docs/direction/be/web-service/rpc/dubbo/','title':"Dubbo",'content':"Dubbo 国内最早开源的 RPC 框架，由阿里巴巴公司开发并于 2011 年末对外开源，仅支持 Java 语言\n"});index.add({'id':484,'href':'/note-cs/docs/direction/be/proxy/envoy/','title':"Envoy",'content':"Envoy "});index.add({'id':485,'href':'/note-cs/docs/basic/pl/go/','title':"Go",'content':"Go 学习笔记 见：Go 学习笔记\n"});index.add({'id':486,'href':'/note-cs/docs/direction/be/rpc/grpc/','title':"grpc",'content':"grpc  quick start "});index.add({'id':487,'href':'/note-cs/docs/domain/cc/others/paas/heroku/','title':"Heroku",'content':"Heroku "});index.add({'id':488,'href':'/note-cs/docs/direction/be/web-service/standard/http/','title':"HTTP",'content':"HTTP "});index.add({'id':489,'href':'/note-cs/docs/direction/client/ios/','title':"iOS",'content':"iOS "});index.add({'id':490,'href':'/note-cs/docs/direction/be/auth/jwt/','title':"JWT",'content':"JWT JSON Web Tokens\n背景  JWT 原理 JWT 结构 JWT 由 Header, Payload, Signature 三部分组成\nconst token = base64urlEncoding(header) + '.' + base64urlEncoding(payload) + '.' + base64urlEncoding(signature)\neyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJsb2dnZWRJbkFzIjoiYWRtaW4iLCJpYXQiOjE0MjI3Nzk2Mzh9.gzSraSYS8EXBxLN_oWnFSRgCzcmJmMjLiuyu5CSpyHI\n  Header\n{ \u0026quot;alg\u0026quot; : \u0026quot;HS256\u0026quot;, \u0026quot;typ\u0026quot; : \u0026quot;JWT\u0026quot; }   Payload\n{ \u0026quot;loggedInAs\u0026quot; : \u0026quot;admin\u0026quot;, \u0026quot;iat\u0026quot; : 1422779638 }   Signature\nHMAC-SHA256( base64urlEncoding(header) + '.' + base64urlEncoding(payload), secret )   Authorization: Bearer eyJhbGci...\u0026lt;snip\u0026gt;...yu5CSpyHI\n JWT 优缺点 优点  JWT 把数据存储在客户端，服务端不需要存储  缺点  JWT 的 Token 无法主动失效   JWT 适用场景  参考  阮一峰：JSON Web Token 入门教程  "});index.add({'id':491,'href':'/note-cs/docs/direction/be/frame/web/laravel/','title':"Laravel",'content':"Laravel "});index.add({'id':492,'href':'/note-cs/docs/basic/db/redis/source/type/list/','title':"List 实现",'content':"Redis List 类型实现  参考  5 种基本数据结构  "});index.add({'id':493,'href':'/note-cs/docs/domain/cc/virtual/parallels/','title':"Parallels",'content':"Parallels "});index.add({'id':494,'href':'/note-cs/docs/basic/db/postgresql/','title':"PostgreSQL",'content':"PostgreSQL "});index.add({'id':495,'href':'/note-cs/docs/direction/be/rpc/protobuf/','title':"protobuf",'content':"protobuf  "});index.add({'id':496,'href':'/note-cs/docs/direction/arch/scene/distributed/raft/','title':"Raft",'content':"Raft "});index.add({'id':497,'href':'/note-cs/docs/direction/be/ds/raft/','title':"raft 算法",'content':"raft 算法 "});index.add({'id':498,'href':'/note-cs/docs/direction/fe/frame/react/','title':"React",'content':"React "});index.add({'id':499,'href':'/note-cs/docs/direction/be/db/redis/','title':"Redis",'content':"Redis "});index.add({'id':500,'href':'/note-cs/docs/direction/be/mq/redis/','title':"Redis",'content':"Redis Kafka 是 linkedin 开源的 MQ 系统，主要特点是基于 Pull 的模式来处理消息消费，追求高吞吐量，一开始的目的就是用于日志收集和传输，0.8 开始支持复制，不支持事务，适合产生大量数据的互联网服务的数据收集业务。\n"});index.add({'id':501,'href':'/note-cs/docs/direction/be/web-service/rpc/','title':"RPC",'content':"RPC "});index.add({'id':502,'href':'/note-cs/docs/direction/be/rpc/','title':"rpc",'content':"rpc "});index.add({'id':503,'href':'/note-cs/docs/domain/cc/virtual/virtualbox/','title':"VirtualBox",'content':"VirtualBox "});index.add({'id':504,'href':'/note-cs/docs/direction/be/web-service/','title':"Web Service",'content':"Web Service "});index.add({'id':505,'href':'/note-cs/docs/direction/be/frame/web/','title':"Web 框架",'content':"Web 框架 "});index.add({'id':506,'href':'/note-cs/docs/direction/be/proxy/','title':"代理",'content':"代理 "});index.add({'id':507,'href':'/note-cs/docs/basic/pl/cpp/basic/grammar/namespace/','title':"命名空间",'content':"C++ 命名空间 // 命名空间为变量、函数和其他声明提供了分离的的作用域。 // 命名空间可以嵌套使用。  namespace First { namespace Nested { void foo() { printf(\u0026#34;This is First::Nested::foo\\n\u0026#34;); } } // 结束嵌套的命名空间Nested } // 结束命名空间First  namespace Second { void foo() { printf(\u0026#34;This is Second::foo\\n\u0026#34;) } } void foo() { printf(\u0026#34;This is global foo\\n\u0026#34;); } int main() { // 如果没有特别指定，就从“Second”中取得所需的内容。  using namespace Second; foo(); // 显示“This is Second::foo”  First::Nested::foo(); // 显示“This is First::Nested::foo”  ::foo(); // 显示“This is global foo” } "});index.add({'id':508,'href':'/note-cs/docs/basic/os/android/basic/practice/','title':"实践",'content':"实践 "});index.add({'id':509,'href':'/note-cs/docs/basic/os/ios/basic/practice/','title':"实践",'content':"实践 "});index.add({'id':510,'href':'/note-cs/docs/basic/os/macos/basic/practice/','title':"实践",'content':"实践 "});index.add({'id':511,'href':'/note-cs/docs/basic/os/unix/basic/practice/','title':"实践",'content':"实践 "});index.add({'id':512,'href':'/note-cs/docs/basic/os/windows/basic/practice/','title':"实践",'content':"实践 "});index.add({'id':513,'href':'/note-cs/docs/basic/pl/csharp/basic/practice/','title':"实践",'content':"实践 "});index.add({'id':514,'href':'/note-cs/docs/basic/pl/kotlin/basic/practice/','title':"实践",'content':"实践 "});index.add({'id':515,'href':'/note-cs/docs/basic/pl/lua/basic/practice/','title':"实践",'content':"实践 "});index.add({'id':516,'href':'/note-cs/docs/basic/pl/ruby/basic/practice/','title':"实践",'content':"实践 "});index.add({'id':517,'href':'/note-cs/docs/basic/pl/scala/basic/practice/','title':"实践",'content':"Scala 实践 "});index.add({'id':518,'href':'/note-cs/docs/basic/pl/swift/basic/practice/','title':"实践",'content':"实践 "});index.add({'id':519,'href':'/note-cs/docs/basic/db/postgresql/basic/practice/error/','title':"常见错误",'content':"PostgreSQL 常见错误 权限 permission denied for relation 解决 1:\n 以 superUser 进入数据库  psql -U postgres -d postgres   切换到 mydb 数据库  \\c mydb   赋予所有表的所有权限给 xiaoming  GRANT ALL PRIVILEGES ON ALL TABLES IN SCHEMA public TO xiaoming;   赋予 wechart 用户，tuser 表的所有权限  GRANT ALL PRIVILEGES ON tuser TO wechart;    解决 2：\nERROR: permission denied for relation hycom 权限被拒绝\n 检查数据库连接 检查数据库拥有者和配置的是否一样 访问不同的数据库分区 @TableName (\u0026ldquo;分区名。表名\u0026rdquo;) @TableField (exist = false) 取消数据库映射  "});index.add({'id':520,'href':'/note-cs/docs/basic/pl/cpp/basic/grammar/reference/','title':"引用",'content':"C++ 引用   引用是一种特殊的指针类型，一旦被定义就不能重新赋值，并且不能被设置为空值。\n  使用引用时的语法与原变量相同\n 对引用类型进行解引用时，不需要使用 * 赋值时也不需要用 \u0026amp; 来取地址  using namespace std; string foo = \u0026#34;I am foo\u0026#34;; string bar = \u0026#34;I am bar\u0026#34;; string\u0026amp; fooRef = foo; // 建立了一个对foo的引用。 fooRef += \u0026#34;. Hi!\u0026#34;; // 通过引用来修改foo的值 cout \u0026lt;\u0026lt; fooRef; // \u0026#34;I am foo. Hi!\u0026#34; // 这句话的并不会改变fooRef的指向，其效果与“foo = bar”相同。 // 也就是说，在执行这条语句之后，foo == \u0026#34;I am bar\u0026#34;。 fooRef = bar;   不能修改一个常量引用的值\nconst string\u0026amp; barRef = bar; // 建立指向bar的常量引用。 // 和C语言中一样，（指针和引用）声明为常量时，对应的值不能被修改。 barRef += \u0026#34;. Hi!\u0026#34;; // 这是错误的，不能修改一个常量引用的值。   "});index.add({'id':521,'href':'/note-cs/docs/basic/db/postgresql/basic/version/','title':"版本",'content':"PostgreSQL 版本 12 12.2  "});index.add({'id':522,'href':'/note-cs/docs/domain/cc/virtual/network/','title':"虚拟机网络",'content':"虚拟机网络 在 VMware 的 3 中网络模式中，NAT 模式是最简单的，基本不需要手动配置 IP 地址等相关参数。至于桥接模式则需要额外的 IP 地址，如果是在内网环境中还很容易，如果是 ADSL 宽带就比较麻烦了，ISP 一般是不会大方的多提供一个公网 IP 的。\n三种网络模式 桥接 桥接网络是指本地物理网卡和虚拟网卡通过 VMnet0 虚拟交换机进行桥接，物理网卡和虚拟网卡在拓扑图上处于同等地位，那么物理网卡和虚拟网卡就相当于处于同一个网段，虚拟交换机就相当于一台现实网络中的交换机，所以两个网卡的 IP 地址也要设置为同一网段。\n所以当我们要在局域网使用虚拟机，对局域网其他 pc 提供服务时，例如提供 ftp，提供 ssh，提供 http 服务，那么就要选择桥接模式。\n例如大学宿舍里有一个路由器，宿舍里四个人连接这个路由器，路由器的 wanip 就不理会了，这个 ip 是动态获取的，而 lanip 默认是 192.168.1.1, 子网掩码是 255.255.255.0。而其他四个人是自动获取 ip，假设四个人的 ip 是:\nA:192.168.1.100/255.255.255.0, B:192.168.1.101/255.255.255.0, C:192.168.1.102/255.255.255.0, D:192.168.1.103/255.255.255.0\n那么虚拟机的 ip 可以设置的 ip 地址是 192.168.1.2-192.168.1.99,192.168.1.104-192.168.1.254 (网络地址全 0 和全 1 的除外，再除去 ABCD 四个人的 ip 地址)\n那么虚拟机的 ip 地址可以设置为 192.168.1.98/255.255.255.0, 设置了这个 ip 地址，ABCD 这四个人就可以通过 192.168.1.98 访问虚拟机了，如果虚拟机需要上外网，那么还需要配置虚拟机的路由地址，就是 192.168.1.1 了，这样，虚拟机就可以上外网了，但是，上网我们一般是通过域名去访问外网的，所以我们还需要为虚拟机配置一个 dns 服务器，我们可以简单点，把 dns 服务器地址配置为 google 的 dns 服务器：8.8.8.8, 到此，虚拟机就可以上网了。\nNAT NAT 模式中，就是让虚拟机借助 NAT (网络地址转换) 功能，通过宿主机器所在的网络来访问公网。\nNAT 模式中，虚拟机的网卡和物理网卡的网络，不在同一个网络，虚拟机的网卡，是在 vmware 提供的一个虚拟网络。\nNAT 和桥接的比较:\n(1) NAT 模式和桥接模式虚拟机都可以上外网。\n(2) 由于 NAT 的网络在 vmware 提供的一个虚拟网络里，所以局域网其他主机是无法访问虚拟机的，而宿主机可以访问虚拟机，虚拟机可以访问局域网的所有主机，因为真实的局域网相对于 NAT 的虚拟网络，就是 NAT 的虚拟网络的外网，不懂的人可以查查 NAT 的相关知识。\n(3) 桥接模式下，多个虚拟机之间可以互相访问；NAT 模式下，多个虚拟机之间也可以相互访问。\n如果你建一个虚拟机，只是给自己用，不需要给局域网其他人用，那么可以选择 NAT，毕竟 NAT 模式下的虚拟系统的 TCP/IP 配置信息是由 VMnet8 (NAT) 虚拟网络的 DHCP 服务器提供的，只要虚拟机的网路配置是 DHCP，那么你不需要进行任何其他的配置，只需要宿主机器能访问互联网即可，就可以让虚拟机联网了。\n例如你想建多个虚拟机集群，作为测试使用，而宿主机可能是一个笔记本，ip 不固定。这种应用场景，我们需要采用 nat 模式了，但是我们要考虑一个问题，虚拟机之间是需要互访的，默认采用 dhcp，虚拟机的 ip 每次重启，ip 都是不固定的，所以我们需要手工设置虚拟机的 ip 地址。\n但是我们对虚拟机网卡所在的虚拟网络的信息还一无所知，例如虚拟机网络的路由地址，子网掩码，所以我们需要先查下 nat 虚拟网络的信息。\n使用 vmware, 在 Edit-\u0026gt;Virtual Network Editor 中配置好虚拟网络信息后看到下图所示，注意 VMnet8，VMnet8 相当于是本机的一个路由，虚拟机设置 NAT 后就通过这个路由进行上网的，可以查看其网络地址，路由地址，子网掩码。\n选择 VMnet8-\u0026gt;NAT 设置，可以看到子网 ip 显示为 192.168.233.0，子网掩码是 255.255.255.0，那路由地址呢，其实就是网关 IP 了，都是同个东西，这里是 192.168.233.2。\n接下来就好办了，在对应的虚拟机设置好 ip，子网掩码，路由地址就可以上外网了，至于 dns 可以设置为 8.8.8.8.\nHost-Only 在 Host-Only 模式下，虚拟网络是一个全封闭的网络，它唯一能够访问的就是主机。其实 Host-Only 网络和 NAT 网络很相似，不同的地方就是 Host-Only 网络没有 NAT 服务，所以虚拟网络不能连接到 Internet。主机和虚拟机之间的通信是通过 VMware Network Adepter VMnet1 虚拟网卡来实现的。\nHost-Only 的宗旨就是建立一个与外界隔绝的内部网络，来提高内网的安全性。这个功能或许对普通用户来说没有多大意义，但大型服务商会常常利用这个功能。如果你想为 VMnet1 网段提供路由功能，那就需要使用 RRAS，而不能使用 XP 或 2000 的 ICS，因为 ICS 会把内网的 IP 地址改为 192.168.0.1，但虚拟机是不会给 VMnet1 虚拟网卡分配这个地址的，那么主机和虚拟机之间就不能通信了。\n"});index.add({'id':523,'href':'/note-cs/docs/basic/pl/cpp/appendix/interview/','title':"面试题",'content':"面试题 基础题 进阶题 高阶题 综合  你遇到过哪些高质量的 C++ 面试？ What is the best C++ interview question? [closed]  "});index.add({'id':524,'href':'/note-cs/docs/basic/pl/csharp/appendix/interview/','title':"面试题",'content':"面试题 基础题 进阶题 高阶题 "});index.add({'id':525,'href':'/note-cs/docs/basic/pl/kotlin/appendix/interview/','title':"面试题",'content':"面试题 基础题 进阶题 高阶题 "});index.add({'id':526,'href':'/note-cs/docs/basic/pl/lua/appendix/interview/','title':"面试题",'content':"面试题 基础题 进阶题 高阶题 "});index.add({'id':527,'href':'/note-cs/docs/basic/pl/ruby/appendix/interview/','title':"面试题",'content':"面试题 基础题 进阶题 高阶题 "});index.add({'id':528,'href':'/note-cs/docs/basic/pl/swift/appendix/interview/','title':"面试题",'content':"面试题 基础题 进阶题 高阶题 "});index.add({'id':529,'href':'/note-cs/docs/direction/be/proxy/mosn/','title':"MOSN",'content':"MOSN "});index.add({'id':530,'href':'/note-cs/docs/direction/be/web-service/rpc/thrift/','title':"Thrift",'content':"Thrift 最初是由 Facebook 开发的内部系统跨语言的 RPC 框架，2007 年贡献给了 Apache 基金，成为 Apache 开源项目之一，支持多种语言。\n"});index.add({'id':531,'href':'/note-cs/docs/book/basic/pl/go-in-action/','title':"Go in Action",'content':"Go in Action \n作者 William Kennedy\n"});index.add({'id':532,'href':'/note-cs/docs/basic/algs/','title':"1.3 数据结构与算法",'content':"数据结构与算法 见：算法学习笔记\n"});index.add({'id':533,'href':'/note-cs/docs/direction/client/','title':"2.3 客户端",'content':"客户端 "});index.add({'id':534,'href':'/note-cs/docs/domain/ai/','title':"3.3 人工智能",'content':"人工智能 "});index.add({'id':535,'href':'/note-cs/docs/others/tool/','title':"4.3 工具",'content':"工具 "});index.add({'id':536,'href':'/note-cs/docs/book/basic/algs/','title':"5.1.3 数据结构与算法",'content':"数据结构与算法 "});index.add({'id':537,'href':'/note-cs/docs/book/fe/','title':"5.3 前端",'content':"前端 "});index.add({'id':538,'href':'/note-cs/docs/course/basic/algs/','title':"6.1.3 数据结构与算法",'content':"数据结构与算法 "});index.add({'id':539,'href':'/note-cs/docs/course/fe/','title':"6.3 前端",'content':"前端 "});index.add({'id':540,'href':'/note-cs/docs/direction/arch/scene/release/ab-testing/','title':"A/B 测试",'content':"A/B 测试 A/B testing\n 参考 "});index.add({'id':541,'href':'/note-cs/docs/direction/be/mq/activemq/','title':"ActiveMQ",'content':"ActiveMQ "});index.add({'id':542,'href':'/note-cs/docs/direction/fe/frame/angular/','title':"Angular",'content':"Angular "});index.add({'id':543,'href':'/note-cs/docs/others/skill/debug/','title':"Debug",'content':"Debug "});index.add({'id':544,'href':'/note-cs/docs/direction/be/proxy/envoy/xds/eds/','title':"EDS",'content':"EDS "});index.add({'id':545,'href':'/note-cs/docs/domain/cc/istio/','title':"Istio",'content':"Istio 见：Istio 学习笔记\n"});index.add({'id':546,'href':'/note-cs/docs/basic/pl/java/','title':"Java",'content':"Java "});index.add({'id':547,'href':'/note-cs/docs/domain/cc/kubernetes/','title':"Kubernetes",'content':"Kubernetes 见：Kubernetes 学习笔记\n"});index.add({'id':548,'href':'/note-cs/docs/basic/pl/php/appendix/snippet/simple-php-github-toc/','title':"Markdown 文件生成 TOC",'content':"生成 Github Readme 文件 TOC 目录 的简单脚本 \u0026lt;?php /** * site: https://github.com/xingshaocheng/simple-php-github-toc */ if(count($argv) \u0026lt; 2){ exit(\u0026#34;Please input github file url, eg \u0026#39;php github-toc.php https://github.com/xingshaocheng/architect-awesome/blob/master/README.md\u0026#39;.\\n\u0026#34;); } $url = $argv[1]; #$url = \u0026#34;https://github.com/xingshaocheng/architect-awesome/blob/master/README.md\u0026#34;;  function get_anchor($content){ preg_match_all(\u0026#34;/href=\\\u0026#34;(.*)\\\u0026#34;\u0026gt;/iUs\u0026#34;, $content, $anchor_arr); if(count($anchor_arr) \u0026gt; 0){ return $anchor_arr[1][0]; } return \u0026#34;\u0026#34;; } function get_title($content){ preg_match_all(\u0026#34;/a\\\u0026gt;(.*)$/iUs\u0026#34;, $content, $title_arr); if(count($title_arr) \u0026gt; 0){ return trim($title_arr[1][0]); } return \u0026#34;\u0026#34;; } $content = file_get_contents($url); preg_match_all(\u0026#34;/\u0026lt;article(.*)\u0026lt;\\/article\u0026gt;/iUs\u0026#34;, $content, $article); $article_html = $article[0][0]; preg_match_all(\u0026#34;/\u0026lt;h([1-6])\u0026gt;(.*)\u0026lt;\\/h[1-6]{1}\u0026gt;/iUs\u0026#34;, $article_html, $each_head); $len = count($each_head[0]); for($i = 0;$i \u0026lt; $len; $i++){ $level = $each_head[1][$i]; $each_content = $each_head[2][$i]; $anchor = get_anchor($each_content); $title = get_title($each_content); echo str_repeat(\u0026#34;\\t\u0026#34;,($level-1)),\u0026#34;* \u0026#34;,\u0026#34;[${title}](${url}${anchor})\\n\u0026#34;; } echo \u0026#34;\\nTOC generated by [simple-php-github-toc](https://github.com/xingshaocheng/simple-php-github-toc) \\n\\n\u0026#34;; 参考 xingshaocheng/simple-php-github-toc  "});index.add({'id':549,'href':'/note-cs/docs/direction/be/db/mysql/','title':"Mysql",'content':"Mysql "});index.add({'id':550,'href':'/note-cs/docs/domain/cc/others/paas/openshift/','title':"OpenShift",'content':"OpenShift Red Hat OpenShift is a leading hybrid cloud, enterprise Kubernetes application platform. OpenShift 在 Kubernetes 的基础上整合了应用的生命周期管理，包括 image 的编译，持续集成，部署以及更新。\nOpenshift 以前是 IaaS，现在 Openshift 自己宣称自己搭配 LXC 已经是 PaaS 了，VPS 不是云服务但可以类比为 IaaS。\nOpenshift 没有 root 权限 参考：openshift 和普通 vps 的区别在哪儿？\n"});index.add({'id':551,'href':'/note-cs/docs/domain/ai/frame/paddlepaddle/','title':"PaddlePaddle",'content':"PaddlePaddle  PArallel Distributed Deep LEarning: Machine Learning Framework from Industrial Practice （『飞桨』核心框架，深度学习 \u0026amp; 机器学习高性能单机、分布式训练和跨平台部署） http://www.paddlepaddle.org/\n"});index.add({'id':552,'href':'/note-cs/docs/direction/be/mq/rocketmq/','title':"RocketMQ",'content':"RocketMQ "});index.add({'id':553,'href':'/note-cs/docs/direction/be/web-service/soa/','title':"SOA",'content':"SOA "});index.add({'id':554,'href':'/note-cs/docs/direction/be/web-service/standard/soap/','title':"SOAP",'content':"SOAP "});index.add({'id':555,'href':'/note-cs/docs/direction/be/auth/sso/','title':"SSO",'content':"SSO (Single sign-on) "});index.add({'id':556,'href':'/note-cs/docs/domain/ai/frame/tensorflow/','title':"Tensorflow",'content':"Tensorflow  PArallel Distributed Deep LEarning: Machine Learning Framework from Industrial Practice （『飞桨』核心框架，深度学习 \u0026amp; 机器学习高性能单机、分布式训练和跨平台部署） http://www.paddlepaddle.org/\n教程 lyhue1991/eat_tensorflow2_in_30_days  "});index.add({'id':557,'href':'/note-cs/docs/basic/os/android/basic/snippet/','title':"代码片段",'content':"代码片段 "});index.add({'id':558,'href':'/note-cs/docs/basic/os/ios/basic/snippet/','title':"代码片段",'content':"代码片段 "});index.add({'id':559,'href':'/note-cs/docs/basic/os/macos/basic/snippet/','title':"代码片段",'content':"代码片段 "});index.add({'id':560,'href':'/note-cs/docs/basic/os/unix/basic/snippet/','title':"代码片段",'content':"代码片段 "});index.add({'id':561,'href':'/note-cs/docs/basic/os/windows/basic/snippet/','title':"代码片段",'content':"代码片段 "});index.add({'id':562,'href':'/note-cs/docs/basic/pl/c/appendix/snippet/','title':"代码片段",'content':"代码片段 "});index.add({'id':563,'href':'/note-cs/docs/basic/pl/cpp/appendix/snippet/','title':"代码片段",'content':"代码片段 "});index.add({'id':564,'href':'/note-cs/docs/basic/pl/csharp/basic/snippet/','title':"代码片段",'content':"代码片段 "});index.add({'id':565,'href':'/note-cs/docs/basic/pl/java/appendix/snippet/','title':"代码片段",'content':"代码片段 "});index.add({'id':566,'href':'/note-cs/docs/basic/pl/kotlin/basic/snippet/','title':"代码片段",'content':"代码片段 "});index.add({'id':567,'href':'/note-cs/docs/basic/pl/lua/basic/snippet/','title':"代码片段",'content':"代码片段 "});index.add({'id':568,'href':'/note-cs/docs/basic/pl/php/appendix/snippet/','title':"代码片段",'content':"代码片段 "});index.add({'id':569,'href':'/note-cs/docs/basic/pl/ruby/basic/snippet/','title':"代码片段",'content':"代码片段 "});index.add({'id':570,'href':'/note-cs/docs/basic/pl/rust/appendix/snippet/','title':"代码片段",'content':"代码片段 "});index.add({'id':571,'href':'/note-cs/docs/basic/pl/scala/basic/snippet/','title':"代码片段",'content':"代码片段 "});index.add({'id':572,'href':'/note-cs/docs/basic/pl/swift/basic/snippet/','title':"代码片段",'content':"代码片段 "});index.add({'id':573,'href':'/note-cs/docs/direction/client/xiaochengxu/','title':"小程序",'content':"小程序 "});index.add({'id':574,'href':'/note-cs/docs/direction/be/db/','title':"数据库",'content':"数据库 "});index.add({'id':575,'href':'/note-cs/docs/domain/ai/frame/','title':"框架",'content':"框架 "});index.add({'id':576,'href':'/note-cs/docs/basic/pl/scala/basic/practice/baidu/','title':"百度",'content':"百度 Scala 最佳实践 "});index.add({'id':577,'href':'/note-cs/docs/domain/cc/virtual/','title':"虚拟化",'content':"虚拟化 "});index.add({'id':578,'href':'/note-cs/docs/direction/arch/scene/release/canary-rollouts/','title':"金丝雀发布",'content':"金丝雀发布 canary rollouts\n 参考 "});index.add({'id':579,'href':'/note-cs/docs/basic/pl/javascript/','title':"JavaScript",'content':"JavaScript "});index.add({'id':580,'href':'/note-cs/docs/basic/pl/kotlin/','title':"Kotlin",'content':"Kotlin 学习笔记 "});index.add({'id':581,'href':'/note-cs/docs/basic/pl/lua/','title':"Lua",'content':"Lua 学习笔记 "});index.add({'id':582,'href':'/note-cs/docs/basic/network/','title':"1.4 计算机网络",'content':"计算机网络 见：网络学习笔记\n"});index.add({'id':583,'href':'/note-cs/docs/direction/embedded/','title':"2.4 嵌入式",'content':"嵌入式开发 "});index.add({'id':584,'href':'/note-cs/docs/book/basic/network/','title':"5.1.4 计算机网络",'content':"计算机网络 "});index.add({'id':585,'href':'/note-cs/docs/book/security/','title':"5.4 安全",'content':"安全 "});index.add({'id':586,'href':'/note-cs/docs/course/basic/network/','title':"6.1.4 计算机网络",'content':"计算机网络 "});index.add({'id':587,'href':'/note-cs/docs/course/security/','title':"6.4 安全",'content':"安全 "});index.add({'id':588,'href':'/note-cs/docs/domain/cc/others/paas/cloud-foundry/','title':"Cloud Foundry",'content':"Cloud Foundry "});index.add({'id':589,'href':'/note-cs/docs/basic/pl/objective-c/','title':"Objective-C",'content':"Objective-C 学习笔记 "});index.add({'id':590,'href':'/note-cs/docs/direction/be/proxy/envoy/xds/rds/','title':"RDS",'content':"RDS "});index.add({'id':591,'href':'/note-cs/docs/direction/be/web-service/rpc/tars/','title':"Tars",'content':"Tars - Total Application Framework 腾讯内部使用的 RPC 框架，于 2017 年对外开源。\n目前支持 C++, Java 和 NodeJs 三种语言。\n"});index.add({'id':592,'href':'/note-cs/docs/direction/be/web-service/standard/wsdl/','title':"WSDL",'content':"WSDL "});index.add({'id':593,'href':'/note-cs/docs/direction/be/mq/','title':"消息队列",'content':"消息队列 ZeroMQ 和 RabbitMQ/Kafka 不同，它只是一个异步消息库，在套接字的基础上提供了类似于消息代理的机制。使用 ZeroMQ 的话，需要对自己的业务代码进行改造，不利于服务解耦。\nRabbitMQ 支持 AMQP（二进制），STOMP（文本），MQTT（二进制），HTTP（里面包装其他协议）等协议。Kafka 使用自己的协议。\nKafka 自身服务和消费者都需要依赖 Zookeeper。\nRabbitMQ 在有大量消息堆积的情况下性能会下降，Kafka 不会。毕竟 AMQP 设计的初衷不是用来持久化海量消息的，而 Kafka 一开始是用来处理海量日志的。\n参考  RabbitMQ, ZeroMQ, Kafka 是一个层级的东西吗？  "});index.add({'id':594,'href':'/note-cs/docs/direction/be/proxy/envoy/version/1.13/','title':"1.13",'content':"1.13 "});index.add({'id':595,'href':'/note-cs/docs/basic/pl/','title':"1.5 编程语言",'content':"编程语言 函数式编程 教程 MostlyAdequate/mostly-adequate-guide  Mostly adequate guide to FP (in javascript)\n中文版 llh911001/mostly-adequate-guide-chinese 点击阅读\n"});index.add({'id':596,'href':'/note-cs/docs/direction/security/','title':"2.5 安全",'content':"安全 "});index.add({'id':597,'href':'/note-cs/docs/book/basic/pl/','title':"5.1.5 编程语言",'content':"编程语言 Go    书名 作者 / 译者 出版时间 语言版本 豆瓣评分 其他说明     Go in Action         参考：\n golang/go/wiki/Books dariubs/GoBooks  List of Golang books    "});index.add({'id':598,'href':'/note-cs/docs/book/se/','title':"5.5 软件工程",'content':"软件工程 "});index.add({'id':599,'href':'/note-cs/docs/course/basic/pl/','title':"6.1.5 编程语言",'content':"编程语言 "});index.add({'id':600,'href':'/note-cs/docs/course/se/','title':"6.5 软件工程",'content':"软件工程 "});index.add({'id':601,'href':'/note-cs/docs/domain/cc/others/paas/appfog/','title':"AppFog",'content':"AppFog "});index.add({'id':602,'href':'/note-cs/docs/direction/be/web-service/rpc/motan/','title':"Motan",'content':"Motan 微博内部使用的 RPC 框架，于 2016 年对外开源，仅支持 Java 语言。\n"});index.add({'id':603,'href':'/note-cs/docs/basic/pl/php/','title':"PHP",'content':"PHP "});index.add({'id':604,'href':'/note-cs/docs/direction/be/mq/rabbitmq/','title':"RabbitMQ",'content':"RabbitMQ RabbitMQ 是一个 AMQP 实现，传统的 messaging queue 系统实现，基于 Erlang。老牌 MQ 产品了。AMQP 协议更多用在企业系统内，对数据一致性、稳定性和可靠性要求很高的场景，对性能和吞吐量还在其次。\n"});index.add({'id':605,'href':'/note-cs/docs/basic/db/redis/','title':"Redis",'content':"Redis "});index.add({'id':606,'href':'/note-cs/docs/direction/be/web-service/standard/uudi/','title':"UUDI",'content':"UUDI "});index.add({'id':607,'href':'/note-cs/docs/direction/be/ds/consistent-hashing/','title':"一致性哈希",'content':"一致性哈希 这篇论文中提出了一致性 hash 的概念。\nincubator-brpc doc - 一致性哈希\n一致性 hash 满足以下四个性质：\n 平衡性 (Balance) : 每个节点被选到的概率是 O (1/n)。 单调性 (Monotonicity) : 当新节点加入时， 不会有请求在老节点间移动， 只会从老节点移动到新节点。当有节点被删除时，也不会影响落在别的节点上的请求。 分散性 (Spread) : 当上游的机器看到不同的下游列表时 (在上线时及不稳定的网络中比较常见), 同一个请求尽量映射到少量的节点中。 负载 (Load) : 当上游的机器看到不同的下游列表的时候， 保证每台下游分到的请求数量尽量一致。  "});index.add({'id':608,'href':'/note-cs/docs/direction/be/ds/','title':"分布式系统",'content':"分布式系统 Distributed System\n问答 分布式与集群的区别 参考：\n 知乎：分布式与集群的区别是什么？ 分布式架构（1） - 大白话讲解：分布式与集群的区别是什么？  "});index.add({'id':609,'href':'/note-cs/docs/others/tool/study/coding-online/','title':"在线编程",'content':"在线编程 "});index.add({'id':610,'href':'/note-cs/docs/direction/fe/lib/','title':"库",'content':"库 "});index.add({'id':611,'href':'/note-cs/docs/direction/be/proxy/envoy/version/','title':"版本",'content':"版本 "});index.add({'id':612,'href':'/note-cs/docs/basic/pl/python/','title':"Python",'content':"Python 见：Python 学习笔记\n"});index.add({'id':613,'href':'/note-cs/docs/basic/pl/ruby/','title':"Ruby",'content':"Ruby 学习笔记 "});index.add({'id':614,'href':'/note-cs/docs/basic/db/','title':"1.6 数据库",'content':"数据库 "});index.add({'id':615,'href':'/note-cs/docs/direction/mp/','title':"2.6 中台",'content':"中台 "});index.add({'id':616,'href':'/note-cs/docs/book/basic/db/','title':"5.1.6 数据库",'content':"数据库 "});index.add({'id':617,'href':'/note-cs/docs/book/cc/','title':"5.6 云计算",'content':"云计算 "});index.add({'id':618,'href':'/note-cs/docs/course/basic/db/','title':"6.1.6 数据库",'content':"数据库 "});index.add({'id':619,'href':'/note-cs/docs/course/cc/','title':"6.6 云计算",'content':"云计算 "});index.add({'id':620,'href':'/note-cs/docs/basic/pl/rust/','title':"Rust",'content':"Rust "});index.add({'id':621,'href':'/note-cs/docs/direction/be/mq/zeromq/','title':"ZeroMQ",'content':"ZeroMQ ZeroMQ 只是一个网络编程的 Pattern 库，将常见的网络请求形式（分组管理，链接管理，发布订阅等）模式化、组件化，简而言之 socket 之上、MQ 之下。对于 MQ 来说，网络传输只是它的一部分，更多需要处理的是消息存储、路由、Broker 服务发现和查找、事务、消费模式（ack、重投等）、集群服务等。\n"});index.add({'id':622,'href':'/note-cs/docs/direction/arch/scene/release/','title':"发布形式",'content':"发布形式  参考 "});index.add({'id':623,'href':'/note-cs/docs/domain/ai/tutorial/','title':"教程",'content':"教程 基础 视频 shuhuai007/Machine-Learning-Session  【机器学习】【白板推导系列】【合集 1 ～ 23】\n视频内容电子化  tsyw/MachineLearningNotes  Bilibili - 机器学习白板系列   机器学习教程（小象学院）  josephmisiti/awesome-machine-learning   ZuzooVn/machine-learning-for-software-engineers  A complete daily plan for studying to become a machine learning engineer.\n ageron/handson-ml  A series of Jupyter notebooks that walk you through the fundamentals of Machine Learning and Deep Learning in python using Scikit-Learn and TensorFlow.\n fighting41love/funNLP  NLP 民工的乐园：几乎最全的中文 NLP 资源库\n eriklindernoren/ML-From-Scratch  Machine Learning From Scratch. Bare bones NumPy implementations of machine learning models and algorithms with a focus on accessibility. Aims to cover everything from linear regression to deep learning.\n trekhleb/homemade-machine-learning  Python examples of popular machine learning algorithms with interactive Jupyter demos and math being explained.\n kailashahirwar/cheatsheets-ai  Essential Cheat Sheets for deep learning and machine learning researchers\nhttps://medium.com/@kailashahirwar/essential-cheat-sheets-for-machine-learning-and-deep-learning-researchers-efb6a8ebd2e5\nhttps://aicheatsheets.com\n rasbt/python-machine-learning-book  The \u0026ldquo;Python Machine Learning (1st edition)\u0026rdquo; book code repository and info resource\n afshinea/stanford-cs-229-machine-learning !Github stars[](https://img.shields.io/github/stars/afshinea/stanford-cs-229-machine-learning.svg)\nVIP cheatsheets for Stanford\u0026rsquo;s CS 229 Machine Learning https://stanford.edu/~shervine/teaching/cs-229/\n ujjwalkarn/Machine-Learning-Tutorials  machine learning and deep learning tutorials, articles and other resources http://ujjwalkarn.github.io/Machine-Learning-Tutorials/\n janishar/mit-deep-learning-book-pdf  MIT Deep Learning Book in PDF format (complete and parts) by Ian Goodfellow, Yoshua Bengio and Aaron Courville\n 进阶 hangtwenty/dive-into-machine-learning  Dive into Machine Learning with Python Jupyter notebook and scikit-learn! http://hangtwenty.github.io/dive-into-machine-learning/\n RedditSota/state-of-the-art-result-for-machine-learning-problems  This repository provides state of the art (SoTA) results for all machine learning problems.\n rushter/MLAlgorithms  Minimal and clean examples of machine learning algorithms implementations\n 高阶 "});index.add({'id':624,'href':'/note-cs/docs/direction/arch/scene/seckill/','title':"秒杀",'content':"秒杀  参考 codingXiaxw/seckill  Java 高并发秒杀系统 API\n"});index.add({'id':625,'href':'/note-cs/docs/basic/compile/','title':"1.7 编译原理",'content':"编译原理 "});index.add({'id':626,'href':'/note-cs/docs/direction/arch/','title':"2.7 架构设计",'content':"架构设计 "});index.add({'id':627,'href':'/note-cs/docs/book/basic/compile/','title':"5.1.7 编译原理",'content':"编译原理 "});index.add({'id':628,'href':'/note-cs/docs/book/bigdata/','title':"5.7 大数据",'content':"大数据 "});index.add({'id':629,'href':'/note-cs/docs/course/basic/compile/','title':"6.1.7 编译原理",'content':"编译原理 "});index.add({'id':630,'href':'/note-cs/docs/course/bigdata/','title':"6.7 大数据",'content':"大数据 "});index.add({'id':631,'href':'/note-cs/docs/basic/pl/scala/','title':"Scala",'content':"Scala 学习笔记 "});index.add({'id':632,'href':'/note-cs/docs/basic/pl/javascript/appendix/attention/','title':"关注",'content':"关注 octokit/rest.js  GitHub REST API client for JavaScript https://octokit.github.io/rest.js/\n"});index.add({'id':633,'href':'/note-cs/docs/basic/pl/scala/appendix/attention/','title':"关注",'content':"关注 akka/akka  Build highly concurrent, distributed, and resilient message-driven applications on the JVM https://akka.io\n"});index.add({'id':634,'href':'/note-cs/docs/domain/ai/attention/','title':"关注",'content':"关注 机器学习 tensorflow/tensorflow  scikit-learn/scikit-learn  scikit-learn: machine learning in Python https://scikit-learn.org\nphp-ai/php-ml  PHP-ML - Machine Learning library for PHP https://php-ml.org/\n 深度学习 paddlepaddle/paddle   机器人 gunthercox/ChatterBot  ChatterBot is a machine learning, conversational dialog engine for creating chat bots https://chatterbot.readthedocs.io\n"});index.add({'id':635,'href':'/note-cs/docs/direction/arch/scene/distributed/','title':"分布式",'content':"分布式 "});index.add({'id':636,'href':'/note-cs/docs/direction/arch/scene/','title':"场景",'content':"场景 "});index.add({'id':637,'href':'/note-cs/docs/basic/pl/swift/','title':"Swift",'content':"Swift 学习笔记 "});index.add({'id':638,'href':'/note-cs/docs/direction/se/','title':"2.8 软件工程",'content':"软件工程  参考 "});index.add({'id':639,'href':'/note-cs/docs/book/ai/','title':"5.8 人工智能",'content':"人工智能 "});index.add({'id':640,'href':'/note-cs/docs/course/ai/','title':"6.8 人工智能",'content':"人工智能 "});index.add({'id':641,'href':'/note-cs/docs/direction/be/auth/','title':"认证与授权",'content':"认证与授权 "});index.add({'id':642,'href':'/note-cs/docs/book/others/','title':"5.9 其他",'content':"其他 "});index.add({'id':643,'href':'/note-cs/docs/course/others/','title':"6.9 其他",'content':"其他 "});index.add({'id':644,'href':'/note-cs/docs/direction/arch/tutorial/','title':"教程",'content':"教程 基础 系统设计入门  学习如何设计可扩展的系统将会有助于你成为一个更好的工程师。\n系统设计是一个很宽泛的话题。在互联网上，关于系统设计原则的资源也是多如牛毛。\n这个仓库就是这些资源的组织收集，它可以帮助你学习如何构建可扩展的系统。\n 进阶 "});index.add({'id':645,'href':'/note-cs/docs/direction/be/frame/','title':"框架",'content':"后端框架 "});index.add({'id':646,'href':'/note-cs/docs/direction/be/mq/mqtt/','title':"MQTT",'content':"MQTT mqtt 各种 broker 如何选择？\nAgent 和 Broker 的差别是什么？\n 经纪人（Broker）：是为促成他人交易，充当订约居间人，为委托方提供订约的信息、机会和条件的主体。  Broker 是一个独立主体，但没有自主决策能力，只负责订约过程。   代理人（Agent）：是行使被代理者的权力，完成相关的使命或者任务主体。  Agent 是一个独立主体，负责完成任务但不负责执行任务，Agent 具有一定的自主决策能力，如对服务请求的选择。   代理（Proxy）是指行为代理，不是一个主体。  Proxy 是完全的传递者，如请求和响应的转发，操作控制的传递。    "});index.add({'id':647,'href':'/note-cs/docs/direction/be/auth/sso/saml/','title':"SAML",'content':"SAML 1.0 2.0 参考  How SAML Authentication Works  "});index.add({'id':648,'href':'/note-cs/docs/domain/cc/others/','title':"其他",'content':"其他 "});index.add({'id':649,'href':'/note-cs/docs/basic/pl/java/basic/practice/','title':"实践",'content':"Java 实践 "});index.add({'id':650,'href':'/note-cs/docs/direction/se/tutorial/','title':"教程",'content':"教程 基础 系统设计入门  学习如何设计可扩展的系统将会有助于你成为一个更好的工程师。\n系统设计是一个很宽泛的话题。在互联网上，关于系统设计原则的资源也是多如牛毛。\n这个仓库就是这些资源的组织收集，它可以帮助你学习如何构建可扩展的系统。\n 进阶 "});index.add({'id':651,'href':'/note-cs/docs/direction/be/web-service/standard/','title':"相关标准",'content':"相关标准 "});index.add({'id':652,'href':'/note-cs/docs/others/skill/lorawan/chirpstack/','title':"ChirpStack",'content':"ChirpStack ChirpStack Network Server ChirpStack Network Server is an open-source LoRaWAN network-server. https://www.chirpstack.io\n ChirpStack Application Server ChirpStack Application Server is an open-source LoRaWAN application-server. https://www.chirpstack.io\n"});index.add({'id':653,'href':'/note-cs/docs/others/skill/lorawan/','title':"LoRaWan",'content':"LoRaWan "});index.add({'id':654,'href':'/note-cs/docs/others/skill/onvif/','title':"ONVIF",'content':"ONVIF 官网：www.onvif.org\n"});index.add({'id':655,'href':'/note-cs/docs/basic/pl/javascript/basic/practice/spec/baidu/css/','title':"Css",'content':"CSS 编码规范 1 前言\n2 代码风格\n2.1 文件\n2.2 缩进\n2.3 空格\n2.4 行长度\n2.5 选择器\n2.6 属性\n3 通用\n3.1 选择器\n3.2 属性缩写\n3.3 属性书写顺序\n3.4 清除浮动\n3.5 !important\n3.6 z-index\n4 值与单位\n4.1 文本\n4.2 数值\n4.3 url()\n4.4 长度\n4.5 颜色\n4.6 2D 位置\n5 文本编排\n5.1 字体族\n5.2 字号\n5.3 字体风格\n5.4 字重\n5.5 行高\n6 变换与动画\n7 响应式\n8 兼容性\n8.1 属性前缀\n8.2 Hack\n8.3 Expression\n1 前言 CSS 作为网页样式的描述语言，在百度一直有着广泛的应用。本文档的目标是使 CSS 代码风格保持一致，容易被理解和被维护。\n虽然本文档是针对 CSS 设计的，但是在使用各种 CSS 的预编译器(如 less、sass、stylus 等)时，适用的部分也应尽量遵循本文档的约定。\n任何问题或建议，欢迎跟我们讨论: fe-styleguide@baidu.com\n2 代码风格 2.1 文件 [建议] CSS 文件使用无 BOM 的 UTF-8 编码。 解释：\nUTF-8 编码具有更广泛的适应性。BOM 在使用程序或工具处理文件时可能造成不必要的干扰。\n2.2 缩进 [强制] 使用 4 个空格做为一个缩进层级，不允许使用 2 个空格 或 tab 字符。 示例：\n.selector {\rmargin: 0;\rpadding: 0;\r}\r2.3 空格 [强制] 选择器 与 { 之间必须包含空格。 示例：\n.selector {\r}\r[强制] 属性名 与之后的 : 之间不允许包含空格， : 与 属性值 之间必须包含空格。 示例：\nmargin: 0;\r[强制] 列表型属性值 书写在单行时，, 后必须跟一个空格。 示例：\nfont-family: Arial, sans-serif;\r2.4 行长度 [强制] 每行不得超过 120 个字符，除非单行不可分割。 解释：\n常见不可分割的场景为 URL 超长。\n[建议] 对于超长的样式，在样式值的 空格 处或 , 后换行，建议按逻辑分组。 示例：\n/* 不同属性值按逻辑分组 */\rbackground: transparent url(aVeryVeryVeryLongUrlIsPlacedHere) no-repeat 0 0;\r/* 可重复多次的属性，每次重复一行 */\rbackground-image: url(aVeryVeryVeryLongUrlIsPlacedHere)\rurl(anotherVeryVeryVeryLongUrlIsPlacedHere);\r/* 类似函数的属性值可以根据函数调用的缩进进行 */\rbackground-image: -webkit-gradient(\rlinear,\rleft bottom,\rleft top,\rcolor-stop(0.04, rgb(88, 94, 124)),\rcolor-stop(0.52, rgb(115, 123, 162))\r);\r2.5 选择器 [强制] 当一个 rule 包含多个 selector 时，每个选择器声明必须独占一行。 示例：\n/* good */\r.post,\r.page,\r.comment {\rline-height: 1.5;\r}\r/* bad */\r.post,\r.page,\r.comment {\rline-height: 1.5;\r}\r[强制] \u0026gt;、+、~ 选择器的两边各保留一个空格。 示例：\n/* good */\rmain \u0026gt; nav {\rpadding: 10px;\r}\rlabel + input {\rmargin-left: 5px;\r}\rinput:checked ~ button {\rbackground-color: #69c;\r}\r/* bad */\rmain \u0026gt; nav {\rpadding: 10px;\r}\rlabel + input {\rmargin-left: 5px;\r}\rinput:checked ~ button {\rbackground-color: #69c;\r}\r[强制] 属性选择器中的值必须用双引号包围。 解释：\n不允许使用单引号，不允许不使用引号。\n示例：\n/* good */\rarticle[character=\u0026#34;juliet\u0026#34;] {\rvoice-family: \u0026#34;Vivien Leigh\u0026#34;, victoria, female;\r}\r/* bad */\rarticle[character=\u0026#34;juliet\u0026#34;] {\rvoice-family: \u0026#34;Vivien Leigh\u0026#34;, victoria, female;\r}\r2.6 属性 [强制] 属性定义必须另起一行。 示例：\n/* good */\r.selector {\rmargin: 0;\rpadding: 0;\r}\r/* bad */\r.selector {\rmargin: 0;\rpadding: 0;\r}\r[强制] 属性定义后必须以分号结尾。 示例：\n/* good */\r.selector {\rmargin: 0;\r}\r/* bad */\r.selector {\rmargin: 0;\r}\r3 通用 3.1 选择器 [强制] 如无必要，不得为 id、class 选择器添加类型选择器进行限定。 解释：\n在性能和维护性上，都有一定的影响。\n示例：\n/* good */\r#error,\r.danger-message {\rfont-color: #c00;\r}\r/* bad */\rdialog#error,\rp.danger-message {\rfont-color: #c00;\r}\r[建议] 选择器的嵌套层级应不大于 3 级，位置靠后的限定条件应尽可能精确。 示例：\n/* good */\r#username input {\r}\r.comment .avatar {\r}\r/* bad */\r.page .header .login #username input {\r}\r.comment div * {\r}\r3.2 属性缩写 [建议] 在可以使用缩写的情况下，尽量使用属性缩写。 示例：\n/* good */\r.post {\rfont: 12px/1.5 arial, sans-serif;\r}\r/* bad */\r.post {\rfont-family: arial, sans-serif;\rfont-size: 12px;\rline-height: 1.5;\r}\r[建议] 使用 border / margin / padding 等缩写时，应注意隐含值对实际数值的影响，确实需要设置多个方向的值时才使用缩写。 解释：\nborder / margin / padding 等缩写会同时设置多个属性的值，容易覆盖不需要覆盖的设定。如某些方向需要继承其他声明的值，则应该分开设置。\n示例：\n/* centering \u0026lt;article class=\u0026#34;page\u0026#34;\u0026gt; horizontally and highlight featured ones */\rarticle {\rmargin: 5px;\rborder: 1px solid #999;\r}\r/* good */\r.page {\rmargin-right: auto;\rmargin-left: auto;\r}\r.featured {\rborder-color: #69c;\r}\r/* bad */\r.page {\rmargin: 5px auto; /* introducing redundancy */\r}\r.featured {\rborder: 1px solid #69c; /* introducing redundancy */\r}\r3.3 属性书写顺序 [建议] 同一 rule set 下的属性在书写时，应按功能进行分组，并以 Formatting Model（布局方式、位置） \u0026gt; Box Model（尺寸） \u0026gt; Typographic（文本相关） \u0026gt; Visual（视觉效果） 的顺序书写，以提高代码的可读性。 解释：\n Formatting Model 相关属性包括：position / top / right / bottom / left / float / display / overflow 等 Box Model 相关属性包括：border / margin / padding / width / height 等 Typographic 相关属性包括：font / line-height / text-align / word-wrap 等 Visual 相关属性包括：background / color / transition / list-style 等  另外，如果包含 content 属性，应放在最前面。\n示例：\n.sidebar {\r/* formatting model: positioning schemes / offsets / z-indexes / display / ... */\rposition: absolute;\rtop: 50px;\rleft: 0;\roverflow-x: hidden;\r/* box model: sizes / margins / paddings / borders / ... */\rwidth: 200px;\rpadding: 5px;\rborder: 1px solid #ddd;\r/* typographic: font / aligns / text styles / ... */\rfont-size: 14px;\rline-height: 20px;\r/* visual: colors / shadows / gradients / ... */\rbackground: #f5f5f5;\rcolor: #333;\r-webkit-transition: color 1s;\r-moz-transition: color 1s;\rtransition: color 1s;\r}\r3.4 清除浮动 [建议] 当元素需要撑起高度以包含内部的浮动元素时，通过对伪类设置 clear 或触发 BFC 的方式进行 clearfix。尽量不使用增加空标签的方式。 解释：\n触发 BFC 的方式很多，常见的有：\n float 非 none position 非 static overflow 非 visible  如希望使用更小副作用的清除浮动方法，参见 A new micro clearfix hack 一文。\n另需注意，对已经触发 BFC 的元素不需要再进行 clearfix。\n3.5 !important [建议] 尽量不使用 !important 声明。 [建议] 当需要强制指定样式且不允许任何场景覆盖时，通过标签内联和 !important 定义样式。 解释：\n必须注意的是，仅在设计上 确实不允许任何其它场景覆盖样式 时，才使用内联的 !important 样式。通常在第三方环境的应用中使用这种方案。下面的 z-index 章节是其中一个特殊场景的典型样例。\n3.6 z-index [建议] 将 z-index 进行分层，对文档流外绝对定位元素的视觉层级关系进行管理。 解释：\n同层的多个元素，如多个由用户输入触发的 Dialog，在该层级内使用相同的 z-index 或递增 z-index。\n建议每层包含 100 个 z-index 来容纳足够的元素，如果每层元素较多，可以调整这个数值。\n[建议] 在可控环境下，期望显示在最上层的元素，z-index 指定为 999999。 解释：\n可控环境分成两种，一种是自身产品线环境；还有一种是可能会被其他产品线引用，但是不会被外部第三方的产品引用。\n不建议取值为 2147483647。以便于自身产品线被其他产品线引用时，当遇到层级覆盖冲突的情况，留出向上调整的空间。\n[建议] 在第三方环境下，期望显示在最上层的元素，通过标签内联和 !important，将 z-index 指定为 2147483647。 解释：\n第三方环境对于开发者来说完全不可控。在第三方环境下的元素，为了保证元素不被其页面其他样式定义覆盖，需要采用此做法。\n4 值与单位 4.1 文本 [强制] 文本内容必须用双引号包围。 解释：\n文本类型的内容可能在选择器、属性值等内容中。\n示例：\n/* good */\rhtml[lang|=\u0026#34;zh\u0026#34;] q:before {\rfont-family: \u0026#34;Microsoft YaHei\u0026#34;, sans-serif;\rcontent: \u0026#34;“\u0026#34;;\r}\rhtml[lang|=\u0026#34;zh\u0026#34;] q:after {\rfont-family: \u0026#34;Microsoft YaHei\u0026#34;, sans-serif;\rcontent: \u0026#34;”\u0026#34;;\r}\r/* bad */\rhtml[lang|=\u0026#34;zh\u0026#34;] q:before {\rfont-family: \u0026#34;Microsoft YaHei\u0026#34;, sans-serif;\rcontent: \u0026#34;“\u0026#34;;\r}\rhtml[lang|=\u0026#34;zh\u0026#34;] q:after {\rfont-family: \u0026#34;Microsoft YaHei\u0026#34;, sans-serif;\rcontent: \u0026#34;”\u0026#34;;\r}\r4.2 数值 [强制] 当数值为 0 - 1 之间的小数时，省略整数部分的 0。 示例：\n/* good */\rpanel {\ropacity: 0.8;\r}\r/* bad */\rpanel {\ropacity: 0.8;\r}\r4.3 url() [强制] url() 函数中的路径不加引号。 示例：\nbody {\rbackground: url(bg.png);\r}\r[建议] url() 函数中的绝对路径可省去协议名。 示例：\nbody {\rbackground: url(//baidu.com/img/bg.png) no-repeat 0 0;\r}\r4.4 长度 [强制] 长度为 0 时须省略单位。 (也只有长度单位可省) 示例：\n/* good */\rbody {\rpadding: 0 5px;\r}\r/* bad */\rbody {\rpadding: 0px 5px;\r}\r4.5 颜色 [强制] RGB 颜色值必须使用十六进制记号形式 #rrggbb。不允许使用 rgb()。 解释：\n带有 alpha 的颜色信息可以使用 rgba()。使用 rgba() 时每个逗号后必须保留一个空格。\n示例：\n/* good */\r.success {\rbox-shadow: 0 0 2px rgba(0, 128, 0, 0.3);\rborder-color: #008000;\r}\r/* bad */\r.success {\rbox-shadow: 0 0 2px rgba(0, 128, 0, 0.3);\rborder-color: rgb(0, 128, 0);\r}\r[强制] 颜色值可以缩写时，必须使用缩写形式。 示例：\n/* good */\r.success {\rbackground-color: #aca;\r}\r/* bad */\r.success {\rbackground-color: #aaccaa;\r}\r[强制] 颜色值不允许使用命名色值。 示例：\n/* good */\r.success {\rcolor: #90ee90;\r}\r/* bad */\r.success {\rcolor: lightgreen;\r}\r[建议] 颜色值中的英文字符采用小写。如不用小写也需要保证同一项目内保持大小写一致。 示例：\n/* good */\r.success {\rbackground-color: #aca;\rcolor: #90ee90;\r}\r/* good */\r.success {\rbackground-color: #aca;\rcolor: #90ee90;\r}\r/* bad */\r.success {\rbackground-color: #aca;\rcolor: #90ee90;\r}\r4.6 2D 位置 [强制] 必须同时给出水平和垂直方向的位置。 解释：\n2D 位置初始值为 0% 0%，但在只有一个方向的值时，另一个方向的值会被解析为 center。为避免理解上的困扰，应同时给出两个方向的值。background-position 属性值的定义\n示例：\n/* good */\rbody {\rbackground-position: center top; /* 50% 0% */\r}\r/* bad */\rbody {\rbackground-position: top; /* 50% 0% */\r}\r5 文本编排 5.1 字体族 [强制] font-family 属性中的字体族名称应使用字体的英文 Family Name，其中如有空格，须放置在引号中。 解释：\n所谓英文 Family Name，为字体文件的一个元数据，常见名称如下：\n   字体 操作系统 Family Name     宋体 (中易宋体) Windows SimSun   黑体 (中易黑体) Windows SimHei   微软雅黑 Windows Microsoft YaHei   微软正黑 Windows Microsoft JhengHei   华文黑体 Mac/iOS STHeiti   冬青黑体 Mac/iOS Hiragino Sans GB   文泉驿正黑 Linux WenQuanYi Zen Hei   文泉驿微米黑 Linux WenQuanYi Micro Hei    示例：\nh1 {\rfont-family: \u0026#34;Microsoft YaHei\u0026#34;;\r}\r[强制] font-family 按「西文字体在前、中文字体在后」、「效果佳 (质量高/更能满足需求) 的字体在前、效果一般的字体在后」的顺序编写，最后必须指定一个通用字体族( serif / sans-serif )。 解释：\n更详细说明可参考本文。\n示例：\n/* Display according to platform */\r.article {\rfont-family: Arial, sans-serif;\r}\r/* Specific for most platforms */\rh1 {\rfont-family: \u0026#34;Helvetica Neue\u0026#34;, Arial, \u0026#34;Hiragino Sans GB\u0026#34;,\r\u0026#34;WenQuanYi Micro Hei\u0026#34;, \u0026#34;Microsoft YaHei\u0026#34;, sans-serif;\r}\r[强制] font-family 不区分大小写，但在同一个项目中，同样的 Family Name 大小写必须统一。 示例：\n/* good */\rbody {\rfont-family: Arial, sans-serif;\r}\rh1 {\rfont-family: Arial, \u0026#34;Microsoft YaHei\u0026#34;, sans-serif;\r}\r/* bad */\rbody {\rfont-family: arial, sans-serif;\r}\rh1 {\rfont-family: Arial, \u0026#34;Microsoft YaHei\u0026#34;, sans-serif;\r}\r5.2 字号 [强制] 需要在 Windows 平台显示的中文内容，其字号应不小于 12px。 解释：\n由于 Windows 的字体渲染机制，小于 12px 的文字显示效果极差、难以辨认。\n5.3 字体风格 [建议] 需要在 Windows 平台显示的中文内容，不要使用除 normal 外的 font-style。其他平台也应慎用。 解释：\n由于中文字体没有 italic 风格的实现，所有浏览器下都会 fallback 到 obilique 实现 (自动拟合为斜体)，小字号下 (特别是 Windows 下会在小字号下使用点阵字体的情况下) 显示效果差，造成阅读困难。\n5.4 字重 [强制] font-weight 属性必须使用数值方式描述。 解释：\nCSS 的字重分 100 – 900 共九档，但目前受字体本身质量和浏览器的限制，实际上支持 400 和 700 两档，分别等价于关键词 normal 和 bold。\n浏览器本身使用一系列启发式规则来进行匹配，在 \u0026lt;700 时一般匹配字体的 Regular 字重，\u0026gt;=700 时匹配 Bold 字重。\n但已有浏览器开始支持 =600 时匹配 Semibold 字重 (见此表)，故使用数值描述增加了灵活性，也更简短。\n示例：\n/* good */\rh1 {\rfont-weight: 700;\r}\r/* bad */\rh1 {\rfont-weight: bold;\r}\r5.5 行高 [建议] line-height 在定义文本段落时，应使用数值。 解释：\n将 line-height 设置为数值，浏览器会基于当前元素设置的 font-size 进行再次计算。在不同字号的文本段落组合中，能达到较为舒适的行间间隔效果，避免在每个设置了 font-size 都需要设置 line-height。\n当 line-height 用于控制垂直居中时，还是应该设置成与容器高度一致。\n示例：\n.container {\rline-height: 1.5;\r}\r6 变换与动画 [强制] 使用 transition 时应指定 transition-property。 示例：\n/* good */\r.box {\rtransition: color 1s, border-color 1s;\r}\r/* bad */\r.box {\rtransition: all 1s;\r}\r[建议] 尽可能在浏览器能高效实现的属性上添加过渡和动画。 解释：\n见 本文，在可能的情况下应选择这样四种变换：\n transform: translate(npx, npx); transform: scale(n); transform: rotate(ndeg); opacity: 0..1;  典型的，可以使用 translate 来代替 left 作为动画属性。\n示例：\n/* good */\r.box {\rtransition: transform 1s;\r}\r.box:hover {\rtransform: translate(20px); /* move right for 20px */\r}\r/* bad */\r.box {\rleft: 0;\rtransition: left 1s;\r}\r.box:hover {\rleft: 20px; /* move right for 20px */\r}\r7 响应式 [强制] Media Query 不得单独编排，必须与相关的规则一起定义。 示例：\n/* Good */\r/* header styles */\r@media (...) {\r/* header styles */\r}\r/* main styles */\r@media (...) {\r/* main styles */\r}\r/* footer styles */\r@media (...) {\r/* footer styles */\r}\r/* Bad */\r/* header styles */\r/* main styles */\r/* footer styles */\r@media (...) {\r/* header styles */\r/* main styles */\r/* footer styles */\r}\r[强制] Media Query 如果有多个逗号分隔的条件时，应将每个条件放在单独一行中。 示例：\n@media (-webkit-min-device-pixel-ratio: 2),\r/* Webkit-based browsers */ (min--moz-device-pixel-ratio: 2),\r/* Older Firefox browsers (prior to firefox 16) */ (min-resolution: 2dppx),\r/* The standard way */ (min-resolution: 192dpi) {\r/* dppx fallback */\r/* Retina-specific stuff here */\r}\r[建议] 尽可能给出在高分辨率设备 (Retina) 下效果更佳的样式。 8 兼容性 8.1 属性前缀 [强制] 带私有前缀的属性由长到短排列，按冒号位置对齐。 解释：\n标准属性放在最后，按冒号对齐方便阅读，也便于在编辑器内进行多行编辑。\n示例：\n.box {\r-webkit-box-sizing: border-box;\r-moz-box-sizing: border-box;\rbox-sizing: border-box;\r}\r8.2 Hack [建议] 需要添加 hack 时应尽可能考虑是否可以采用其他方式解决。 解释：\n如果能通过合理的 HTML 结构或使用其他的 CSS 定义达到理想的样式，则不应该使用 hack 手段解决问题。通常 hack 会导致维护成本的增加。\n[建议] 尽量使用 选择器 hack 处理兼容性，而非 属性 hack。 解释：\n尽量使用符合 CSS 语法的 selector hack，可以避免一些第三方库无法识别 hack 语法的问题。\n示例：\n/* IE 7 */\r*:first-child + html #header {\rmargin-top: 3px;\rpadding: 5px;\r}\r/* IE 6 */\r* html #header {\rmargin-top: 5px;\rpadding: 4px;\r}\r[建议] 尽量使用简单的 属性 hack。 示例：\n.box {\r_display: inline; /* fix double margin */\rfloat: left;\rmargin-left: 20px;\r}\r.container {\roverflow: hidden;\r*zoom: 1; /* triggering hasLayout */\r}\r8.3 Expression [强制] 禁止使用 Expression。 "});index.add({'id':656,'href':'/note-cs/docs/basic/pl/javascript/basic/practice/spec/baidu/es-next/','title':"Es Next",'content':"JavaScript 编码规范 - ESNext 补充篇（草案） 1 前言\n2 代码风格\n2.1 文件\n2.2 结构\n2.2.1 缩进\n2.2.2 空格\n2.2.3 语句\n3 语言特性\n3.1 变量\n3.2 解构\n3.3 模板字符串\n3.4 函数\n3.5 箭头函数\n3.6 对象\n3.7 类\n3.8 模块\n3.9 集合\n3.10 异步\n4 环境\n4.1 运行环境\n4.2 预编译\n1 前言 随着 ECMAScript 的不断发展，越来越多更新的语言特性将被使用，给应用的开发带来方便。本文档的目标是使 ECMAScript 新特性的代码风格保持一致，并给予一些实践建议。\n本文档仅包含新特性部分。基础部分请遵循 JavaScript Style Guide。\n由于 ECMAScript 依然在快速的不断发展，本文档也将可能随时保持更新。更新内容主要涉及对新增的语言特性的格式规范化、实践指导，引擎与编译器环境变化的使用指导。\n虽然本文档是针对 ECMAScript 设计的，但是在使用各种基于 ECMAScript 扩展的语言时(如 JSX、TypeScript 等)，适用的部分也应尽量遵循本文档的约定。\n任何问题或建议，欢迎跟我们讨论: fe-styleguide@baidu.com\n2 代码风格 2.1 文件 [建议] ESNext 语法的 JavaScript 文件使用 .js 扩展名。 [强制] 当文件无法使用 .js 扩展名时，使用 .es 扩展名。 解释：\n某些应用开发时，可能同时包含 ES 5 和 ESNext 文件，运行环境仅支持 ES5，ESNext 文件需要经过预编译。部分场景下，编译工具的选择可能需要通过扩展名区分，需要重新定义 ESNext 文件的扩展名。此时，ESNext 文件必须使用 .es 扩展名。\n但是，更推荐使用其他条件作为是否需要编译的区分：\n 基于文件内容。 不同类型文件放在不同目录下。  2.2 结构 2.2.1 缩进 [建议] 使用多行模板字符串时遵循缩进原则。当空行与空白字符敏感时，不使用多行模板字符串。 解释：\n4 空格为一个缩进，换行后添加一层缩进。将起始和结束的 ` 符号单独放一行，有助于生成 HTML 时的标签对齐。\n为避免破坏缩进的统一，当空行与空白字符敏感时，建议使用 多个模板字符串 或 普通字符串 进行连接运算，也可使用数组 join 生成字符串。\n示例：\n// good function foo() { let html = ` \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; `; } // Good function greeting(name) { return \u0026#34;Hello, \\n\u0026#34; + `${name.firstName}${name.lastName}`; } // Bad function greeting(name) { return `Hello, ${name.firstName}${name.lastName}`; } 2.2.2 空格 [强制] 使用 generator 时，* 前面不允许有空格，* 后面必须有一个空格。 示例：\n// good function* caller() { yield \u0026#34;a\u0026#34;; yield* callee(); yield \u0026#34;d\u0026#34;; } // bad function* caller() { yield \u0026#34;a\u0026#34;; yield* callee(); yield \u0026#34;d\u0026#34;; } 2.2.3 语句 [强制] 类声明结束不允许添加分号。 解释：\n与函数声明保持一致。\n[强制] 类成员定义中，方法定义后不允许添加分号，成员属性定义后必须添加分号。 解释：\n成员属性是当前 Stage 0 的标准，如果使用的话，则定义后加上分号。\n示例：\n// good class Foo { foo = 3; bar() {} } // bad class Foo { foo = 3; bar() {} } [强制] export 语句后，不允许出现表示空语句的分号。 解释：\nexport 关键字不影响后续语句类型。\n示例：\n// good export function foo() {} export default function bar() {} // bad export function foo() {} export default function bar() {} [强制] 属性装饰器后，可以不加分号的场景，不允许加分号。 解释：\n只有一种场景是必须加分号的：当属性 key 是 computed property key 时，其装饰器必须加分号，否则修饰 key 的 [] 会做为之前表达式的 property accessor。\n上面描述的场景，装饰器后需要加分号。其余场景下的属性装饰器后不允许加分号。\n示例：\n// good class Foo { @log(\u0026#39;INFO\u0026#39;) bar() { } @log(\u0026#39;INFO\u0026#39;); [\u0026#39;bar\u0026#39; + 2]() { } } // bad class Foo { @log(\u0026#39;INFO\u0026#39;); bar() { } @log(\u0026#39;INFO\u0026#39;) [\u0026#39;bar\u0026#39; + 2]() { } } [强制] 箭头函数的参数只有一个，并且不包含解构时，参数部分的括号必须省略。 示例：\n// good list.map(item =\u0026gt; item * 2); // good let fetchName = async id =\u0026gt; { let user = await request(`users/${id}`); return user.fullName; }; // bad list.map(item =\u0026gt; item * 2); // bad let fetchName = async id =\u0026gt; { let user = await request(`users/${id}`); return user.fullName; }; [建议] 箭头函数的函数体只有一个单行表达式语句，且作为返回值时，省略 ` 如果单个表达式过长，可以使用 () 进行包裹。\n示例：\n// good list.map(item =\u0026gt; item * 2); let foo = () =\u0026gt; (condition ? returnValueA() : returnValueB()); // bad list.map(item =\u0026gt; { return item * 2; }); [建议] 箭头函数的函数体只有一个 Object Literal，且作为返回值时，使用 () 包裹。 示例：\n// good list.map(item =\u0026gt; ({ name: item[0], email: item[1] })); [强制] 解构多个变量时，如果超过行长度限制，每个解构的变量必须单独一行。 解释：\n太多的变量解构会让一行的代码非常长，极有可能超过单行长度控制，使代码可读性下降。\n示例：\n// good let { name: personName, email: personEmail, sex: personSex, age: personAge } = person; // bad let { name: personName, email: personEmail, sex: personSex, age: personAge } = person; [强制] 对于对象初始化、数组初始化、import及export语句，当其多个子元素占用多行时，最后一个元素后必须保留逗号。 解释：\nES Next 允许以上语法最后保留逗号，多行时保留逗号有助于快速添加或删除子元素。\n本条规则不适用于函数调用和声明的参数，函数最后一个参数不得包含逗号。\n示例：\n// good const array = [foo, bar]; const array = [foo, bar]; // 单行的最后没有逗号  const object = { foo: bar, x: y }; const object = { foo: bar }; // 单行的最后没有逗号  import { foo, bar } from \u0026#34;module\u0026#34;; import { foo, bar } from \u0026#34;module\u0026#34;; // 单行的最后没有逗号  export { foo, bar }; export { foo, bar }; // 单行的最后没有逗号  // bad  const array = [foo, bar]; const object = { foo: bar, x: y }; 3 语言特性 3.1 变量 [强制] 使用 let 和 const 定义变量，不使用 var。 解释：\n使用 let 和 const 定义时，变量作用域范围更明确。\n示例：\n// good for (let i = 0; i \u0026lt; 10; i++) {} // bad for (var i = 0; i \u0026lt; 10; i++) {} 3.2 解构 [强制] 不要使用 3 层及以上的解构。 解释：\n过多层次的解构会让代码变得难以阅读。\n示例：\n// bad let { documentElement: { firstElementChild: { nextSibling } } } = window; [建议] 使用解构减少中间变量。 解释：\n常见场景如变量值交换，可能产生中间变量。这种场景推荐使用解构。\n示例：\n// good [x, y] = [y, x]; // bad let temp = x; x = y; y = temp; [强制] 如果不节省编写时产生的中间变量，解构表达式 = 号右边不允许是 ObjectLiteral 和 ArrayLiteral。 解释：\n在这种场景下，使用解构将降低代码可读性，通常也并无收益。\n示例：\n// good let { first: firstName, last: lastName } = person; let one = 1; let two = 2; // bad let [one, two] = [1, 2]; [强制] 使用剩余运算符时，剩余运算符之前的所有元素必需具名。 解释：\n剩余运算符之前的元素省略名称可能带来较大的程序阅读障碍。如果仅仅为了取数组后几项，请使用 slice 方法。\n示例：\n// good let [one, two, ...anyOther] = myArray; let other = myArray.slice(3); // bad let [, , , ...other] = myArray; 3.3 模板字符串 [强制] 字符串内变量替换时，不要使用 2 次及以上的函数调用。 解释：\n在变量替换符内有太多的函数调用等复杂语法会导致可读性下降。\n示例：\n// good let fullName = getFullName(getFirstName(), getLastName()); let s = `Hello ${fullName}`; // bad let s = `Hello ${getFullName(getFirstName(), getLastName())}`; 3.4 函数 [建议] 使用变量默认语法代替基于条件判断的默认值声明。 解释：\n添加默认值有助于引擎的优化，在未来 strong mode 下也会有更好的效果。\n示例：\n// good function foo(text = \u0026#34;hello\u0026#34;) {} // bad function foo(text) { text = text || \u0026#34;hello\u0026#34;; } [强制] 不要使用 arguments 对象，应使用 ...args 代替。 解释：\n在未来 strong mode 下 arguments 将被禁用。\n示例：\n// good function foo(...args) { console.log(args.join(\u0026#34;\u0026#34;)); } // bad function foo() { console.log([].join.call(arguments)); } 3.5 箭头函数 [强制] 一个函数被设计为需要 call 和 apply 的时候，不能是箭头函数。 解释：\n箭头函数会强制绑定当前环境下的 this。\n3.6 对象 [强制] 定义方法时使用 MethodDefinition 语法，不使用 PropertyName: FunctionExpression 语法。 解释：\nMethodDefinition 语法更清晰简洁。\n示例：\n// good let foo = { bar(x, y) { return x + y; } }; // bad let foo = { bar: function(x, y) { return x + y; } }; [建议] 使用 Object.keys 或 Object.entries 进行对象遍历。 解释：\n不建议使用 for .. in 进行对象的遍历，以避免遗漏 hasOwnProperty 产生的错误。\n示例：\n// good for (let key of Object.keys(foo)) { let value = foo[key]; } // good for (let [key, value] of Object.entries(foo)) { // ... } [建议] 定义对象的方法不应使用箭头函数。 解释：\n箭头函数将 this 绑定到当前环境，在 obj.method() 调用时容易导致不期待的 this。除非明确需要绑定 this，否则不应使用箭头函数。\n示例：\n// good let foo = { bar(x, y) { return x + y; } }; // bad let foo = { bar: (x, y) =\u0026gt; x + y }; [建议] 尽量使用计算属性键在一个完整的字面量中完整地定义一个对象，避免对象定义后直接增加对象属性。 解释：\n在一个完整的字面量中声明所有的键值，而不需要将代码分散开来，有助于提升代码可读性。\n示例：\n// good const MY_KEY = \u0026#34;bar\u0026#34;; let foo = { [MY_KEY + \u0026#34;Hash\u0026#34;]: 123 }; // bad const MY_KEY = \u0026#34;bar\u0026#34;; let foo = {}; foo[MY_KEY + \u0026#34;Hash\u0026#34;] = 123; 3.7 类 [强制] 使用 class 关键字定义一个类。 解释：\n直接使用 class 定义类更清晰。不要再使用 function 和 prototype 形式的定义。\n// good class TextNode { constructor(value, engine) { this.value = value; this.engine = engine; } clone() { return this; } } // bad function TextNode(value, engine) { this.value = value; this.engine = engine; } TextNode.prototype.clone = function() { return this; }; [强制] 使用 super 访问父类成员，而非父类的 prototype。 解释：\n使用 super 和 super.foo 可以快速访问父类成员，而不必硬编码父类模块而导致修改和维护的不便，同时更节省代码。\n// good class TextNode extends Node { constructor(value, engine) { super(value); this.engine = engine; } setNodeValue(value) { super.setNodeValue(value); this.textContent = value; } } // bad class TextNode extends Node { constructor(value, engine) { Node.apply(this, arguments); this.engine = engine; } setNodeValue(value) { Node.prototype.setNodeValue.call(this, value); this.textContent = value; } } 3.8 模块 [建议] 相互之间无关联的内容使用命名导出。 解释：\n举个例子，工具对象中的各个方法，相互之间并没有强关联，通常外部会选择几个使用，则应该使用命名导出。\n简而言之，当一个模块只扮演命名空间的作用时，使用命名导出。\n[强制] 所有 import 语句写在模块开始处。 示例：\n// good import { bar } from \u0026#34;./bar\u0026#34;; function foo() { bar.work(); } // bad function foo() { import { bar } from \u0026#34;./bar\u0026#34;; bar.work(); } 3.9 集合 [建议] 对数组进行连接操作时，使用数组展开语法。 解释：\n用数组展开代替 concat 方法，数组展开对 Iterable 有更好的兼容性。\n示例：\n// good let foo = [...foo, newValue]; let bar = [...bar, ...newValues]; // bad let foo = foo.concat(newValue); let bar = bar.concat(newValues); [建议] 不要使用数组展开进行数组的复制操作。 解释：\n使用数组展开语法进行复制，代码可读性较差。推荐使用 Array.from 方法进行复制操作。\n示例：\n// good let otherArr = Array.from(arr); // bad let otherArr = [...arr]; [建议] 尽可能使用 for .. of 进行遍历。 解释：\n使用 for .. of 可以更好地接受任何的 Iterable 对象，如 Map#values 生成的迭代器，使得方法的通用性更强。\n以下情况除外：\n 遍历确实成为了性能瓶颈，需要使用原生 for 循环提升性能。 需要遍历过程中的索引。  [强制] 当键值有可能不是字符串时，必须使用 Map；当元素有可能不是字符串时，必须使用 Set。 解释：\n使用普通 Object，对非字符串类型的 key，需要自己实现序列化。并且运行过程中的对象变化难以通知 Object。\n[建议] 需要一个不可重复的集合时，应使用 Set。 解释：\n不要使用 {foo: true} 这样的普通 Object。\n示例：\n// good let members = new Set([\u0026#34;one\u0026#34;, \u0026#34;two\u0026#34;, \u0026#34;three\u0026#34;]); // bad let members = { one: true, two: true, three: true }; [建议] 当需要遍历功能时，使用 Map 和 Set。 解释：\nMap 和 Set 是可遍历对象，能够方便地使用 for...of 遍历。不要使用使用普通 Object。\n示例：\n// good let membersAge = new Map([ [\u0026#34;one\u0026#34;, 10], [\u0026#34;two\u0026#34;, 20], [\u0026#34;three\u0026#34;, 30] ]); for (let [key, value] of map) { } // bad let membersAge = { one: 10, two: 20, three: 30 }; for (let key in membersAge) { if (membersAge.hasOwnProperty(key)) { let value = membersAge[key]; } } [建议] 程序运行过程中有添加或移除元素的操作时，使用 Map 和 Set。 解释：\n使用 Map 和 Set，程序的可理解性更好；普通 Object 的语义更倾向于表达固定的结构。\n示例：\n// good let membersAge = new Map(); membersAge.set(\u0026#34;one\u0026#34;, 10); membersAge.set(\u0026#34;two\u0026#34;, 20); membersAge.set(\u0026#34;three\u0026#34;, 30); membersAge.delete(\u0026#34;one\u0026#34;); // bad let membersAge = {}; membersAge.one = 10; membersAge.two = 20; membersAge.three = 30; delete membersAge[\u0026#34;one\u0026#34;]; 3.10 异步 [强制] 回调函数的嵌套不得超过 3 层。 解释：\n深层次的回调函数的嵌套会让代码变得难以阅读。\n示例：\n// bad getUser(userId, function(user) { validateUser(user, function(isValid) { if (isValid) { saveReport(report, user, function() { notice(\u0026#34;Saved!\u0026#34;); }); } }); }); [建议] 使用 Promise 代替 callback。 解释：\n相比 callback，使用 Promise 能够使复杂异步过程的代码更清晰。\n示例：\n// good let user; getUser(userId) .then(function(userObj) { user = userObj; return validateUser(user); }) .then(function(isValid) { if (isValid) { return saveReport(report, user); } return Promise.reject(\u0026#34;Invalid!\u0026#34;); }) .then( function() { notice(\u0026#34;Saved!\u0026#34;); }, function(message) { notice(message); } ); [强制] 使用标准的 Promise API。 解释：\n 不允许使用非标准的 Promise API，如 jQuery 的 Deferred、Q.js 的 defer 等。 不允许使用非标准的 Promise 扩展 API，如 bluebird 的 Promise.any 等。  使用标准的 Promise API，当运行环境都支持时，可以把 Promise Lib 直接去掉。\n[强制] 不允许直接扩展 Promise 对象的 prototype。 解释：\n理由和 不允许修改和扩展任何原生对象和宿主对象的原型 是一样的。如果想要使用更方便，可以用 utility 函数的形式。\n[强制] 不得为了编写的方便，将可以并行的 IO 过程串行化。 解释：\n并行 IO 消耗时间约等于 IO 时间最大的那个过程，串行的话消耗时间将是所有过程的时间之和。\n示例：\nrequestData().then(function(data) { renderTags(data.tags); renderArticles(data.articles); }); // good async function requestData() { const [tags, articles] = await Promise.all([ requestTags(), requestArticles() ]); return { tags, articles }; } // bad async function requestData() { let tags = await requestTags(); let articles = await requestArticles(); return Promise.resolve({ tags, articles }); } [建议] 使用 async/await 代替 generator + co。 解释：\n使用语言自身的能力可以使代码更清晰，也无需引入 co 库。\n示例：\naddReport(report, userId).then( function() { notice(\u0026#34;Saved!\u0026#34;); }, function(message) { notice(message); } ); // good async function addReport(report, userId) { let user = await getUser(userId); let isValid = await validateUser(user); if (isValid) { let savePromise = saveReport(report, user); return savePromise(); } return Promise.reject(\u0026#34;Invalid\u0026#34;); } // bad function addReport(report, userId) { return co(function*() { let user = yield getUser(userId); let isValid = yield validateUser(user); if (isValid) { let savePromise = saveReport(report, user); return savePromise(); } return Promise.reject(\u0026#34;Invalid\u0026#34;); }); } 4 环境 4.1 运行环境 [建议] 持续跟进与关注运行环境对语言特性的支持程度。 解释：\n查看环境对语言特性的支持程度\nES 标准的制定还在不断进行中，各种环境对语言特性的支持也日新月异。了解项目中用到了哪些 ESNext 的特性，了解项目的运行环境，并持续跟进这些特性在运行环境中的支持程度是很有必要的。这意味着：\n 如果有任何一个运行环境（比如 chrome）支持了项目里用到的所有特性，你可以在开发时抛弃预编译。 如果所有环境都支持了某一特性（比如 Promise），你可以抛弃相关的 shim，或无需在预编译时进行转换。 如果所有环境都支持了项目里用到的所有特性，你可以完全抛弃预编译。  无论如何，在选择预编译工具时，你都需要清晰的知道你现阶段将在项目里使用哪些语言特性，然后了解预编译工具对语言特性的支持程度，做出选择。\n[强制] 在运行环境中没有 Promise 时，将 Promise 的实现 shim 到 global 中。 解释：\n当前运行环境下没有 Promise 时，可以引入 shim 的扩展。如果自己实现，需要实现在 global 下，并且与标准 API 保持一致。\n这样，未来运行环境支持时，可以随时把 Promise 扩展直接扔掉，而应用代码无需任何修改。\n4.2 预编译 [建议] 使用 babel 做为预编译工具时，建议使用 5.x 版本。 解释：\n由于 babel 最新的 6 暂时还不稳定，建议暂时使用 5.x。不同的产品，对于浏览器支持的情况不同，使用 babel 的时候，需要设置的参数也有一些区别。下面在示例中给出一些建议的参数。\n示例：\n＃ 建议的参数 --loose all --modules amd --blacklist strict ＃ 如果需要使用 es7.classProperties、es7.decorators 等一些特性，需要额外的 --stage 0 参数 --loose all --modules amd --blacklist strict --stage 0 [建议] 使用 babel 做为预编译工具时，通过 external-helpers 减少生成文件的大小。 解释：\n当 babel 在转换代码的过程中发现需要一些特性时，会在该文件头部生成对应的 helper 代码。默认情况下，对于每一个经由 babel 处理的文件，均会在文件头部生成对应需要的辅助函数，多份文件辅助函数存在重复，占用了不必要的代码体积。\n因此推荐打开externalHelpers: true选项，使 babel 在转换后内容中不写入 helper 相关的代码，而是使用一个外部的 .js统一提供所有的 helper。对于external-helpers的使用，可以有两种方式：\n 默认方式：需要通过 \u0026lt;script\u0026gt; 自行引入babel-polyfill.js 和 babel-external-helpers.js。 定制方式：自己实现 babel-runtime。  示例：\n# 默认方式 --loose all --modules amd --external-helpers # `babelHelpers` 的代码可以通过执行 `babel-external-helpers -t var` 得到所有相关API的实现 # 定制方式 --loose all --modules amd --optional runtime [建议] 使用 TypeScript 做为预编译工具时，建议使用 1.6+ 版本。 解释：\nTypeScript 1.6 之后，基本摒弃了之前的与 ESNext 相冲突的地方。目前 TypeScript 的思路就是遵循标准，将 stage 已经足够成熟的功能纳入，并提供静态类型和类型检查，所以其在 stage 0/1 的支持上不如 babel。另外，TypeScript 不能指定关闭某个 transform，但其编译速度比 babel 更高。\nTypeScript 的常用参数在下面给出了示例。\n示例：\n--module amd --target ES3 --module commonjs --target ES6 [建议] 使用 TypeScript 做为预编译工具时，不使用 tsc 命令。 解释：\nTypeScript 提供的 tsc 命令只支持后缀名 .ts、.tsx、.d.ts 的文件编译，对于 JavaScript 来说，保持后缀名为 .js 是原则，本文档的 文件 章节也有所要求。\n如果要使用 TypeScript 做为预编译工具，可基于其 Compiler API 开发自己的预编译工具。如果你是 FIS 用户，可以使用 FIS TypeScript 插件。\n[建议] 生成的代码在浏览器环境运行时，应生成 AMD 模块化代码。 解释：\nAMD 在浏览器环境应用较为成熟。\n[建议] 浏览器端项目中如果 ESNext 代码和 ES3/5 代码混合，不要使用 TypeScript 做为预编译工具。 解释：\nTypeScript 产生的 module 代码使用 exports.default 导出默认的 export，但是没有直接为 module.exports 赋值，导致在另外一个普通文件中使用 require(\u0026lsquo;moduleName\u0026rsquo;) 是拿不到东西的。\n需要使用 TypeScript 的话，建议整个项目所有文件都是 ESNext module 的，采用混合的 module 容易出现不可预期的结果。\n[建议] AMD/CommonJS 模块依赖 ESNext 模块时，AMD/CommonJS 模块对 default export 的 require 需要改造。 解释：\nESNext 模块经过编译后，named export 会挂载在 exports 对象上，default export 也会挂载在 exports 对象上名称为 default 的属性。同时 exports 对象会包含一个值为 true 的 __esModule 属性。那么问题来了，当 AMD/CommonJS 模块依赖了 ESNext 模块时，require 期望拿到的是 exports.default，但你实际上拿到的是 exports。\n所以，老的 AMD/CommonJS 模块依赖了 default export 的 ESNext 模块时，对 default export 的 require 需要改造成 require('name').default。\n另外，如果是 ESNext 模块之间的互相依赖，transpiler 会通过加入中间对象和引入 interop 方法，所以不会产生这个问题。\n"});index.add({'id':657,'href':'/note-cs/docs/basic/pl/javascript/basic/practice/spec/baidu/html/','title':"Html",'content':"HTML 编码规范 1 前言\n2 代码风格\n2.1 缩进与换行\n2.2 命名\n2.3 标签\n2.4 属性\n3 通用\n3.1 DOCTYPE\n3.2 编码\n3.3 CSS 和 JavaScript 引入\n4 head\n4.1 title\n4.2 favicon\n4.3 viewport\n5 图片\n6 表单\n6.1 控件标题\n6.2 按钮\n6.3 可访问性 (A11Y)\n7 多媒体\n8 模板中的 HTML\n1 前言 HTML 作为描述网页结构的超文本标记语言，在百度一直有着广泛的应用。本文档的目标是使 HTML 代码风格保持一致，容易被理解和被维护。\n任何问题或建议，欢迎跟我们讨论: fe-styleguide@baidu.com\n2 代码风格 2.1 缩进与换行 [强制] 使用 4 个空格做为一个缩进层级，不允许使用 2 个空格 或 tab 字符。 解释： 对于非 HTML 标签之间的缩进，比如 script 或 style 标签内容缩进，与 script 或 style 标签的缩进同级。\n示例：\n\u0026lt;style\u0026gt;\r/* 样式内容的第一级缩进与所属的 style 标签对齐 */\rul {\rpadding: 0;\r}\r\u0026lt;/style\u0026gt;\r\u0026lt;ul\u0026gt;\r\u0026lt;li\u0026gt;first\u0026lt;/li\u0026gt;\r\u0026lt;li\u0026gt;second\u0026lt;/li\u0026gt;\r\u0026lt;/ul\u0026gt;\r\u0026lt;script\u0026gt;\r// 脚本代码的第一级缩进与所属的 script 标签对齐\r require([\u0026#34;app\u0026#34;], function (app) {\rapp.init();\r});\r\u0026lt;/script\u0026gt;\r[建议] 每行不得超过 120 个字符。 解释：\n过长的代码不容易阅读与维护。但是考虑到 HTML 的特殊性，不做硬性要求。\n2.2 命名 [强制] class 必须单词全字母小写，单词间以 - 分隔。 [强制] class 必须代表相应模块或部件的内容或功能，不得以样式信息进行命名。 示例：\n\u0026lt;!-- good --\u0026gt;\r\u0026lt;div class=\u0026#34;sidebar\u0026#34;\u0026gt;\u0026lt;/div\u0026gt;\r\u0026lt;!-- bad --\u0026gt;\r\u0026lt;div class=\u0026#34;left\u0026#34;\u0026gt;\u0026lt;/div\u0026gt;\r[强制] 元素 id 必须保证页面唯一。 解释：\n同一个页面中，不同的元素包含相同的 id，不符合 id 的属性含义。并且使用 document.getElementById 时可能导致难以追查的问题。\n[建议] id 建议单词全字母小写，单词间以 - 分隔。同项目必须保持风格一致。 [建议] id、class 命名，在避免冲突并描述清楚的前提下尽可能短。 示例：\n\u0026lt;!-- good --\u0026gt;\r\u0026lt;div id=\u0026#34;nav\u0026#34;\u0026gt;\u0026lt;/div\u0026gt;\r\u0026lt;!-- bad --\u0026gt;\r\u0026lt;div id=\u0026#34;navigation\u0026#34;\u0026gt;\u0026lt;/div\u0026gt;\r\u0026lt;!-- good --\u0026gt;\r\u0026lt;p class=\u0026#34;comment\u0026#34;\u0026gt;\u0026lt;/p\u0026gt;\r\u0026lt;!-- bad --\u0026gt;\r\u0026lt;p class=\u0026#34;com\u0026#34;\u0026gt;\u0026lt;/p\u0026gt;\r\u0026lt;!-- good --\u0026gt;\r\u0026lt;span class=\u0026#34;author\u0026#34;\u0026gt;\u0026lt;/span\u0026gt;\r\u0026lt;!-- bad --\u0026gt;\r\u0026lt;span class=\u0026#34;red\u0026#34;\u0026gt;\u0026lt;/span\u0026gt;\r[强制] 禁止为了 hook 脚本，创建无样式信息的 class。 解释：\n不允许 class 只用于让 JavaScript 选择某些元素，class 应该具有明确的语义和样式。否则容易导致 CSS class 泛滥。\n使用 id、属性选择作为 hook 是更好的方式。\n[强制] 同一页面，应避免使用相同的 name 与 id。 解释：\nIE 浏览器会混淆元素的 id 和 name 属性， document.getElementById 可能获得不期望的元素。所以在对元素的 id 与 name 属性的命名需要非常小心。\n一个比较好的实践是，为 id 和 name 使用不同的命名法。\n示例：\n\u0026lt;input name=\u0026#34;foo\u0026#34; /\u0026gt;\r\u0026lt;div id=\u0026#34;foo\u0026#34;\u0026gt;\u0026lt;/div\u0026gt;\r\u0026lt;script\u0026gt;\r// IE6 将显示 INPUT\r alert(document.getElementById(\u0026#34;foo\u0026#34;).tagName);\r\u0026lt;/script\u0026gt;\r2.3 标签 [强制] 标签名必须使用小写字母。 示例：\n\u0026lt;!-- good --\u0026gt;\r\u0026lt;p\u0026gt;Hello StyleGuide!\u0026lt;/p\u0026gt;\r\u0026lt;!-- bad --\u0026gt;\r\u0026lt;p\u0026gt;Hello StyleGuide!\u0026lt;/p\u0026gt;\r[强制] 对于无需自闭合的标签，不允许自闭合。 解释：\n常见无需自闭合标签有 input、br、img、hr 等。\n示例：\n\u0026lt;!-- good --\u0026gt;\r\u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;title\u0026#34; /\u0026gt;\r\u0026lt;!-- bad --\u0026gt;\r\u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;title\u0026#34; /\u0026gt;\r[强制] 对 HTML5 中规定允许省略的闭合标签，不允许省略闭合标签。 解释：\n对代码体积要求非常严苛的场景，可以例外。比如：第三方页面使用的投放系统。\n示例：\n\u0026lt;!-- good --\u0026gt;\r\u0026lt;ul\u0026gt;\r\u0026lt;li\u0026gt;first\u0026lt;/li\u0026gt;\r\u0026lt;li\u0026gt;second\u0026lt;/li\u0026gt;\r\u0026lt;/ul\u0026gt;\r\u0026lt;!-- bad --\u0026gt;\r\u0026lt;ul\u0026gt;\r\u0026lt;li\u0026gt;first\u0026lt;/li\u0026gt;\r\u0026lt;li\u0026gt;second\u0026lt;/li\u0026gt;\r\u0026lt;/ul\u0026gt;\r[强制] 标签使用必须符合标签嵌套规则。 解释：\n比如 div 不得置于 p 中，tbody 必须置于 table 中。\n详细的标签嵌套规则参见HTML DTD中的 Elements 定义部分。\n[建议] HTML 标签的使用应该遵循标签的语义。 解释：\n下面是常见标签语义\n p - 段落 h1,h2,h3,h4,h5,h6 - 层级标题 strong,em - 强调 ins - 插入 del - 删除 abbr - 缩写 code - 代码标识 cite - 引述来源作品的标题 q - 引用 blockquote - 一段或长篇引用 ul - 无序列表 ol - 有序列表 dl,dt,dd - 定义列表  示例：\n\u0026lt;!-- good --\u0026gt;\r\u0026lt;p\u0026gt;\rEsprima serves as an important \u0026lt;strong\u0026gt;building block\u0026lt;/strong\u0026gt; for some\rJavaScript language tools.\r\u0026lt;/p\u0026gt;\r\u0026lt;!-- bad --\u0026gt;\r\u0026lt;div\u0026gt;\rEsprima serves as an important \u0026lt;span class=\u0026#34;strong\u0026#34;\u0026gt;building block\u0026lt;/span\u0026gt; for\rsome JavaScript language tools.\r\u0026lt;/div\u0026gt;\r[建议] 在 CSS 可以实现相同需求的情况下不得使用表格进行布局。 解释：\n在兼容性允许的情况下应尽量保持语义正确性。对网格对齐和拉伸性有严格要求的场景允许例外，如多列复杂表单。\n[建议] 标签的使用应尽量简洁，减少不必要的标签。 示例：\n\u0026lt;!-- good --\u0026gt;\r\u0026lt;img class=\u0026#34;avatar\u0026#34; src=\u0026#34;image.png\u0026#34; /\u0026gt;\r\u0026lt;!-- bad --\u0026gt;\r\u0026lt;span class=\u0026#34;avatar\u0026#34;\u0026gt;\r\u0026lt;img src=\u0026#34;image.png\u0026#34; /\u0026gt;\r\u0026lt;/span\u0026gt;\r2.4 属性 [强制] 属性名必须使用小写字母。 示例：\n\u0026lt;!-- good --\u0026gt;\r\u0026lt;table cellspacing=\u0026#34;0\u0026#34;\u0026gt;\r...\r\u0026lt;/table\u0026gt;\r\u0026lt;!-- bad --\u0026gt;\r\u0026lt;table cellspacing=\u0026#34;0\u0026#34;\u0026gt;\r...\r\u0026lt;/table\u0026gt;\r[强制] 属性值必须用双引号包围。 解释：\n不允许使用单引号，不允许不使用引号。\n示例：\n\u0026lt;!-- good --\u0026gt;\r\u0026lt;script src=\u0026#34;esl.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt;\r\u0026lt;!-- bad --\u0026gt;\r\u0026lt;script src=\u0026#34;esl.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt;\r\u0026lt;script src=\u0026#34;esl.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt;\r[强制] 属性名与属性值中间不得存在空格。 解释：\n按 HTML 规范 = 两边可以存在空格，但为了保持一致不允许添加空格。\n示例：\n\u0026lt;!-- good --\u0026gt;\r\u0026lt;input type=\u0026#34;text\u0026#34; /\u0026gt;\r\u0026lt;!-- bad --\u0026gt;\r\u0026lt;input type=\u0026#34;text\u0026#34; /\u0026gt;\r[建议] 布尔类型的属性，建议不添加属性值。 示例：\n\u0026lt;input type=\u0026#34;text\u0026#34; disabled /\u0026gt; \u0026lt;input type=\u0026#34;checkbox\u0026#34; value=\u0026#34;1\u0026#34; checked /\u0026gt;\r[建议] 自定义属性建议以 xxx- 为前缀，推荐使用 data-。 解释：\n使用前缀有助于区分自定义属性和标准定义的属性。\n示例：\n\u0026lt;ol data-ui-type=\u0026#34;Select\u0026#34;\u0026gt;\u0026lt;/ol\u0026gt;\r3 通用 3.1 DOCTYPE [强制] 使用 HTML5 的 doctype 来启用标准模式，建议使用大写的 DOCTYPE。 示例：\n\u0026lt;!DOCTYPE html\u0026gt;\r[建议] 启用 IE Edge 模式。 示例：\n\u0026lt;meta http-equiv=\u0026#34;X-UA-Compatible\u0026#34; content=\u0026#34;IE=Edge\u0026#34; /\u0026gt;\r[建议] 在 html 标签上设置正确的 lang 属性。 解释：\n有助于提高页面的可访问性，如：让语音合成工具确定其所应该采用的发音，令翻译工具确定其翻译语言等。\n示例：\n\u0026lt;html lang=\u0026#34;zh-CN\u0026#34;\u0026gt;\u0026lt;/html\u0026gt;\r3.2 编码 [强制] 页面必须使用精简形式，明确指定字符编码。指定字符编码的 meta 必须是 head 的第一个直接子元素。 解释：\n见 HTML5 Charset 能用吗 一文。\n示例：\n\u0026lt;html\u0026gt;\r\u0026lt;head\u0026gt;\r\u0026lt;meta charset=\u0026#34;UTF-8\u0026#34; /\u0026gt;\r......\r\u0026lt;/head\u0026gt;\r\u0026lt;body\u0026gt;\r......\r\u0026lt;/body\u0026gt;\r\u0026lt;/html\u0026gt;\r[建议] HTML 文件使用无 BOM 的 UTF-8 编码。 解释：\nUTF-8 编码具有更广泛的适应性。BOM 在使用程序或工具处理文件时可能造成不必要的干扰。\n3.3 CSS 和 JavaScript 引入 [强制] 引入 CSS 时必须指明 rel=\u0026quot;stylesheet\u0026quot;。 示例：\n\u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;page.css\u0026#34; /\u0026gt;\r[建议] 引入 CSS 和 JavaScript 时无须指明 type 属性。 解释：\ntext/css 和 text/javascript 是 type 的默认值。\n[建议] 展现定义放置于外部 CSS 中，行为定义放置于外部 JavaScript 中。 解释：\n结构-样式-行为的代码分离，对于提高代码的可阅读性和维护性都有好处。\n[建议] 在 head 中引入页面需要的所有 CSS 资源。 解释：\n在页面渲染的过程中，新的 CSS 可能导致元素的样式重新计算和绘制，页面闪烁。\n[建议] JavaScript 应当放在页面末尾，或采用异步加载。 解释：\n将 script 放在页面中间将阻断页面的渲染。出于性能方面的考虑，如非必要，请遵守此条建议。\n示例：\n\u0026lt;body\u0026gt;\r\u0026lt;!-- a lot of elements --\u0026gt;\r\u0026lt;script src=\u0026#34;init-behavior.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt;\r\u0026lt;/body\u0026gt;\r[建议] 移动环境或只针对现代浏览器设计的 Web 应用，如果引用外部资源的 URL 协议部分与页面相同，建议省略协议前缀。 解释：\n使用 protocol-relative URL 引入 CSS，在 IE7/8 下，会发两次请求。是否使用 protocol-relative URL 应充分考虑页面针对的环境。\n示例：\n\u0026lt;script src=\u0026#34;//s1.bdstatic.com/cache/static/jquery-1.10.2.min_f2fb5194.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt;\r4 head 4.1 title [强制] 页面必须包含 title 标签声明标题。 [强制] title 必须作为 head 的直接子元素，并紧随 charset 声明之后。 解释：\ntitle 中如果包含 ASCII 之外的字符，浏览器需要知道字符编码类型才能进行解码，否则可能导致乱码。\n示例：\n\u0026lt;head\u0026gt;\r\u0026lt;meta charset=\u0026#34;UTF-8\u0026#34; /\u0026gt;\r\u0026lt;title\u0026gt;页面标题\u0026lt;/title\u0026gt;\r\u0026lt;/head\u0026gt;\r4.2 favicon [强制] 保证 favicon 可访问。 解释：\n在未指定 favicon 时，大多数浏览器会请求 Web Server 根目录下的 favicon.ico 。为了保证 favicon 可访问，避免 404，必须遵循以下两种方法之一：\n 在 Web Server 根目录放置 favicon.ico 文件。 使用 link 指定 favicon。  示例：\n\u0026lt;link rel=\u0026#34;shortcut icon\u0026#34; href=\u0026#34;path/to/favicon.ico\u0026#34; /\u0026gt;\r4.3 viewport [建议] 若页面欲对移动设备友好，需指定页面的 viewport。 解释：\nviewport meta tag 可以设置可视区域的宽度和初始缩放大小，避免在移动设备上出现页面展示不正常。\n比如，在页面宽度小于 980px 时，若需 iOS 设备友好，应当设置 viewport 的 width 值来适应你的页面宽度。同时因为不同移动设备分辨率不同，在设置时，应当使用 device-width 和 device-height 变量。\n另外，为了使 viewport 正常工作，在页面内容样式布局设计上也要做相应调整，如避免绝对定位等。关于 viewport 的更多介绍，可以参见 Safari Web Content Guide 的介绍\n5 图片 [强制] 禁止 img 的 src 取值为空。延迟加载的图片也要增加默认的 src。 解释：\nsrc 取值为空，会导致部分浏览器重新加载一次当前页面，参考：https://developer.yahoo.com/performance/rules.html#emptysrc\n[建议] 避免为 img 添加不必要的 title 属性。 解释：\n多余的 title 影响看图体验，并且增加了页面尺寸。\n[建议] 为重要图片添加 alt 属性。 解释：\n可以提高图片加载失败时的用户体验。\n[建议] 添加 width 和 height 属性，以避免页面抖动。 [建议] 有下载需求的图片采用 img 标签实现，无下载需求的图片采用 CSS 背景图实现。 解释：\n 产品 logo、用户头像、用户产生的图片等有潜在下载需求的图片，以 img 形式实现，能方便用户下载。 无下载需求的图片，比如：icon、背景、代码使用的图片等，尽可能采用 CSS 背景图实现。  6 表单 6.1 控件标题 [强制] 有文本标题的控件必须使用 label 标签将其与其标题相关联。 解释：\n有两种方式：\n 将控件置于 label 内。 label 的 for 属性指向控件的 id。  推荐使用第一种，减少不必要的 id。如果 DOM 结构不允许直接嵌套，则应使用第二种。\n示例：\n\u0026lt;label\r\u0026gt;\u0026lt;input type=\u0026#34;checkbox\u0026#34; name=\u0026#34;confirm\u0026#34; value=\u0026#34;on\u0026#34; /\u0026gt; 我已确认上述条款\u0026lt;/label\r\u0026gt;\r\u0026lt;label for=\u0026#34;username\u0026#34;\u0026gt;用户名：\u0026lt;/label\u0026gt;\r\u0026lt;input type=\u0026#34;textbox\u0026#34; name=\u0026#34;username\u0026#34; id=\u0026#34;username\u0026#34; /\u0026gt;\r6.2 按钮 [强制] 使用 button 元素时必须指明 type 属性值。 解释：\nbutton 元素的默认 type 为 submit，如果被置于 form 元素中，点击后将导致表单提交。为显示区分其作用方便理解，必须给出 type 属性。\n示例：\n\u0026lt;button type=\u0026#34;submit\u0026#34;\u0026gt;提交\u0026lt;/button\u0026gt; \u0026lt;button type=\u0026#34;button\u0026#34;\u0026gt;取消\u0026lt;/button\u0026gt;\r[建议] 尽量不要使用按钮类元素的 name 属性。 解释：\n由于浏览器兼容性问题，使用按钮的 name 属性会带来许多难以发现的问题。具体情况可参考此文。\n6.3 可访问性 (A11Y) [建议] 负责主要功能的按钮在 DOM 中的顺序应靠前。 解释：\n负责主要功能的按钮应相对靠前，以提高可访问性。如果在 CSS 中指定了 float: right 则可能导致视觉上主按钮在前，而 DOM 中主按钮靠后的情况。\n示例：\n\u0026lt;!-- good --\u0026gt;\r\u0026lt;style\u0026gt;\r.buttons .button-group {\rfloat: right;\r}\r\u0026lt;/style\u0026gt;\r\u0026lt;div class=\u0026#34;buttons\u0026#34;\u0026gt;\r\u0026lt;div class=\u0026#34;button-group\u0026#34;\u0026gt;\r\u0026lt;button type=\u0026#34;submit\u0026#34;\u0026gt;提交\u0026lt;/button\u0026gt;\r\u0026lt;button type=\u0026#34;button\u0026#34;\u0026gt;取消\u0026lt;/button\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;!-- bad --\u0026gt;\r\u0026lt;style\u0026gt;\r.buttons button {\rfloat: right;\r}\r\u0026lt;/style\u0026gt;\r\u0026lt;div class=\u0026#34;buttons\u0026#34;\u0026gt;\r\u0026lt;button type=\u0026#34;button\u0026#34;\u0026gt;取消\u0026lt;/button\u0026gt;\r\u0026lt;button type=\u0026#34;submit\u0026#34;\u0026gt;提交\u0026lt;/button\u0026gt;\r\u0026lt;/div\u0026gt;\r[建议] 当使用 JavaScript 进行表单提交时，如果条件允许，应使原生提交功能正常工作。 解释：\n当浏览器 JS 运行错误或关闭 JS 时，提交功能将无法工作。如果正确指定了 form 元素的 action 属性和表单控件的 name 属性时，提交仍可继续进行。\n示例：\n\u0026lt;form action=\u0026#34;/login\u0026#34; method=\u0026#34;post\u0026#34;\u0026gt;\r\u0026lt;p\u0026gt;\u0026lt;input name=\u0026#34;username\u0026#34; type=\u0026#34;text\u0026#34; placeholder=\u0026#34;用户名\u0026#34; /\u0026gt;\u0026lt;/p\u0026gt;\r\u0026lt;p\u0026gt;\u0026lt;input name=\u0026#34;password\u0026#34; type=\u0026#34;password\u0026#34; placeholder=\u0026#34;密码\u0026#34; /\u0026gt;\u0026lt;/p\u0026gt;\r\u0026lt;/form\u0026gt;\r[建议] 在针对移动设备开发的页面时，根据内容类型指定输入框的 type 属性。 解释：\n根据内容类型指定输入框类型，能获得能友好的输入体验。\n示例：\n\u0026lt;input type=\u0026#34;date\u0026#34; /\u0026gt;\r7 多媒体 [建议] 当在现代浏览器中使用 audio 以及 video 标签来播放音频、视频时，应当注意格式。 解释：\n音频应尽可能覆盖到如下格式：\n MP3 WAV Ogg  视频应尽可能覆盖到如下格式：\n MP4 WebM Ogg  [建议] 在支持 HTML5 的浏览器中优先使用 audio 和 video 标签来定义音视频元素。 [建议] 使用退化到插件的方式来对多浏览器进行支持。 示例：\n\u0026lt;audio controls\u0026gt;\r\u0026lt;source src=\u0026#34;audio.mp3\u0026#34; type=\u0026#34;audio/mpeg\u0026#34; /\u0026gt;\r\u0026lt;source src=\u0026#34;audio.ogg\u0026#34; type=\u0026#34;audio/ogg\u0026#34; /\u0026gt;\r\u0026lt;object width=\u0026#34;100\u0026#34; height=\u0026#34;50\u0026#34; data=\u0026#34;audio.mp3\u0026#34;\u0026gt;\r\u0026lt;embed width=\u0026#34;100\u0026#34; height=\u0026#34;50\u0026#34; src=\u0026#34;audio.swf\u0026#34; /\u0026gt;\r\u0026lt;/object\u0026gt;\r\u0026lt;/audio\u0026gt;\r\u0026lt;video width=\u0026#34;100\u0026#34; height=\u0026#34;50\u0026#34; controls\u0026gt;\r\u0026lt;source src=\u0026#34;video.mp4\u0026#34; type=\u0026#34;video/mp4\u0026#34; /\u0026gt;\r\u0026lt;source src=\u0026#34;video.ogg\u0026#34; type=\u0026#34;video/ogg\u0026#34; /\u0026gt;\r\u0026lt;object width=\u0026#34;100\u0026#34; height=\u0026#34;50\u0026#34; data=\u0026#34;video.mp4\u0026#34;\u0026gt;\r\u0026lt;embed width=\u0026#34;100\u0026#34; height=\u0026#34;50\u0026#34; src=\u0026#34;video.swf\u0026#34; /\u0026gt;\r\u0026lt;/object\u0026gt;\r\u0026lt;/video\u0026gt;\r[建议] 只在必要的时候开启音视频的自动播放。 [建议] 在 object 标签内部提供指示浏览器不支持该标签的说明。 示例：\n\u0026lt;object width=\u0026#34;100\u0026#34; height=\u0026#34;50\u0026#34; data=\u0026#34;something.swf\u0026#34;\r\u0026gt;DO NOT SUPPORT THIS TAG\u0026lt;/object\r\u0026gt;\r8 模板中的 HTML [建议] 模板代码的缩进优先保证 HTML 代码的缩进规则。 示例：\n\u0026lt;!-- good --\u0026gt;\r{if $display == true}\r\u0026lt;div\u0026gt;\r\u0026lt;ul\u0026gt;\r{foreach $item_list as $item}\r\u0026lt;li\u0026gt;{$item.name}\u0026lt;/li\u0026gt;\r\u0026lt;li\u0026gt;\r{/foreach}\r\u0026lt;/li\u0026gt;\r\u0026lt;/ul\u0026gt;\r\u0026lt;/div\u0026gt;\r{/if}\r\u0026lt;!-- bad --\u0026gt;\r{if $display == true}\r\u0026lt;div\u0026gt;\r\u0026lt;ul\u0026gt;\r{foreach $item_list as $item}\r\u0026lt;li\u0026gt;{$item.name}\u0026lt;/li\u0026gt;\r\u0026lt;li\u0026gt;\r{/foreach}\r\u0026lt;/li\u0026gt;\r\u0026lt;/ul\u0026gt;\r\u0026lt;/div\u0026gt;\r{/if}\r[建议] 模板代码应以保证 HTML 单个标签语法的正确性为基本原则。 示例：\n\u0026lt;!-- good --\u0026gt;\r\u0026lt;li class=\u0026#34;{if $item.type_id == $current_type}focus{/if}\u0026#34;\u0026gt;{ $item.type_name }\u0026lt;/li\u0026gt;\r\u0026lt;!-- bad --\u0026gt;\r\u0026lt;li {if $item.type_id == $current_type} class=\u0026#34;focus\u0026#34;{/if}\u0026gt;{ $item.type_name }\u0026lt;/li\u0026gt;\r[建议] 在循环处理模板数据构造表格时，若要求每行输出固定的个数，建议先将数据分组，之后再循环输出。 示例：\n\u0026lt;!-- good --\u0026gt;\r\u0026lt;table\u0026gt;\r{foreach $item_list as $item_group}\r\u0026lt;tr\u0026gt;\r{foreach $item_group as $item}\r\u0026lt;td\u0026gt;{ $item.name }\u0026lt;/td\u0026gt;\r{/foreach}\r\u0026lt;/tr\u0026gt;\r\u0026lt;tr\u0026gt;\r{/foreach}\r\u0026lt;/tr\u0026gt;\r\u0026lt;/table\u0026gt;\r\u0026lt;!-- bad --\u0026gt;\r\u0026lt;table\u0026gt;\r\u0026lt;tr\u0026gt;\r{foreach $item_list as $item}\r\u0026lt;td\u0026gt;{ $item.name }\u0026lt;/td\u0026gt;\r{if $item@iteration is div by 5}\r\u0026lt;/tr\u0026gt;\r\u0026lt;tr\u0026gt;\r{/if} {/foreach}\r\u0026lt;/tr\u0026gt;\r\u0026lt;/table\u0026gt;\r[建议] 新窗口/标签页打开的链接需要按业务需要添加安全相关的 rel 属性值 noopener。 解释：\n新窗口/标签页打开的网页可以通过 window.opener 访问原网页的上下文，会引入安全问题。例如从搜索结果页打开的网页可以通过 window.opener 将结果页篡改为钓鱼网页，用户返回时将访问恶意网页内容。详见 4.8.6.8. Link type \u0026ldquo;noopener\u0026rdquo; - HTML 5.2。\n示例：\n\u0026lt;!-- good --\u0026gt;\r\u0026lt;a href=\u0026#34;//external.website/\u0026#34; target=\u0026#34;_blank\u0026#34; rel=\u0026#34;noopener\u0026#34;\u0026gt;外部链接\u0026lt;/a\u0026gt;\r\u0026lt;!-- bad --\u0026gt;\r\u0026lt;a href=\u0026#34;//external.website/\u0026#34; target=\u0026#34;_blank\u0026#34;\u0026gt;外部链接\u0026lt;/a\u0026gt;\r"});index.add({'id':658,'href':'/note-cs/docs/basic/pl/javascript/basic/practice/spec/baidu/react/','title':"React",'content':"React 编码规范 1 版本限制\n1.1 法律要求\n2 文件组织\n2.1 命名\n2.2 模块化\n3 命名规则\n3.1 组件\n3.2 属性\n3.3 高阶组件\n4 组件声明\n4.1 组件\n4.2 属性\n4.3 生命周期\n4.4 高阶组件\n5 组件实现\n5.1 更新机制\n5.2 纯函数应用\n6 JSX\n6.1 标签\n6.2 属性\n6.2.1 层级\n1 版本限制 1.1 法律要求 [强制] 使用 React \u0026gt;=15.6.2版本 解释\n在15.6.2以前的版本协议带有 Facebook Patents，依据法务风险，严禁使用。\n2 文件组织 2.1 命名 [强制] 同一目录下不得拥有同名的.js和.jsx文件。 解释：\n在使用模块导入时，倾向于不添加后缀，如果存在同名但不同后缀的文件，构建工具将无法决定哪一个是需要引入的模块。\n[强制] 组件文件使用一致的.js或 .jsx后缀。 解释：\n所有组件文件的后缀名从.js或.jsx中任选其一。\n不应在项目中出现部分组件为.js文件，部分为.jsx的情况。\n2.2 模块化 [建议] 实现单个组件的文件以export default的形式暴露一个组件。 解释：\n允许一个文件中存在多个不同的组件，但仅允许通过export default暴露一个组件，其它组件均定义为内部组件。\n[建议] 组织多个组件的目录使用一个index.js以命名导出的形式暴露所有组件。 解释：\n同目录内的组件相互引用使用import Foo from './Foo';进行。\n引用其它目录的组件使用import {Foo} from '../component';进行。\n建议使用VSCode 的 export-index 插件等插件自动生成index.js的内容。\n3 命名规则 3.1 组件 [强制] 组件名为 PascalCase。 包括函数组件，名称均为 PascalCase。\n[强制] 组件名称与文件名称保持相同。 同时组件名称应当能体现出组件的功能，以便通过观察文件名即确定使用哪一个组件。\n3.2 属性 [强制] 使用onXxx形式作为props中用于回调的属性名称。 解释：\n使用统一的命名规则用以区分props中回调和非回调部分的属性，在 JSX 上可以清晰地看到一个组件向上和向下的逻辑交互。\n对于不用于回调的函数类型的属性，使用动词作为属性名称。\n示例：\n// onClick作为回调以on开头，renderText非回调函数则使用动词 let Label = ({ onClick, renderText }) =\u0026gt; ( \u0026lt;span onClick={onClick}\u0026gt;{renderText()}\u0026lt;/span\u0026gt; ); [建议] 作为组件方法的事件处理函数以具备业务含义的词作为名称，不使用onXxx形式命名。 示例：\n// Good class Form { @bind() collectAndSubmitData() { let data = { name: this.state.name, age: this.state.age }; this.props.onSubmit(data); } @bind() syncName() { // ...  } @bind() syncAge() { // ...  } render() { return ( \u0026lt;div\u0026gt; \u0026lt;label\u0026gt; 姓名： \u0026lt;input type=\u0026#34;text\u0026#34; onChange={this.syncName} /\u0026gt; \u0026lt;/label\u0026gt; \u0026lt;label\u0026gt; 年龄： \u0026lt;input type=\u0026#34;number\u0026#34; onChange={this.syncAge} /\u0026gt; \u0026lt;/label\u0026gt; \u0026lt;button type=\u0026#34;button\u0026#34; onClick={this.collectAndSubmit}\u0026gt; 提交 \u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } } 3.3 高阶组件 [强制] 高阶组件使用 camelCase 命名。 解释：\n高阶组件事实上并非一个组件，而是一个“生成组件类型”的函数，因此遵守 JavaScript 函数命名的规范，使用 camelCase 命名。\n[建议] 使用withXxx或xxxable形式的词作为高阶组件的名称。 解释：\n高阶组件是为组件添加行为和功能的函数，因此使用如上形式的词有助于对其功能进行理解。\n4 组件声明 4.1 组件 [强制] 使用 ES Class 声明组件，禁止使用React.createClass。 解释：\nReact v15.5.0已经弃用了React.createClass函数。\n示例：\n// Bad let Message = React.createClass({ render() { return \u0026lt;span\u0026gt;{this.state.message}\u0026lt;/span\u0026gt;; } }); // Good class Message extends PureComponent { render() { return \u0026lt;span\u0026gt;{this.state.message}\u0026lt;/span\u0026gt;; } } [强制] 尽量使用无状态函数组件。 解释：\n函数组件在 React 中有着特殊的地位，在将来也有可能得到更多的内部优化。\n示例：\n// Bad class NextNumber { render() { return \u0026lt;span\u0026gt;{this.props.value + 1}\u0026lt;/span\u0026gt;; } } // Good let NextNumber = ({ value }) =\u0026gt; \u0026lt;span\u0026gt;{value + 1}\u0026lt;/span\u0026gt;; [建议] 无需显式引入 React 对象。 解释：\n使用 JSX 隐式地依赖当前环境下有React这一对象，但在源码上并没有显式使用，这种情况下添加import React from 'react';会造成一个没有使用的变量存在。\n使用babel-plugin-react-require插件可以很好地解决这一问题，因此无需显式地编写import React from 'react';这一语句。\n[建议] 使用箭头函数声明函数组件。 解释：\n箭头函数具备更简洁的语法（无需function关键字），且可以在仅有一个语句时省去return造成的额外缩进。\n4.2 属性 [强制] 对于所有非isRequired的属性，在defaultProps中声明对应的值。 解释：\n声明初始值有助于对组件初始状态的理解，也可以减少propTypes对类型进行校验产生的开销。\n对于初始没有值的属性，应当声明初始值为null而非undefined。\n[强制] 如无必要，使用属性语法声明propsTypes、contextTypes、defaultProps和state。 解释：\n仅当初始state需要从props计算得到的时候，才将state的声明放在构造函数中，其它情况下均使用属性声明进行。\n4.3 生命周期 [强制] 禁止使用componentWillMount。 解释：\n使用constructor代替。\n[强制] 依照规定顺序编排组件中的方法和属性。 按照以下顺序编排组件中的方法和属性：\n static displayName static propTypes state defaultProps 其它静态的属性 state 其它实例属性 用于事件处理并且以属性的方式（onClick = e =\u0026gt; {...}）声明的方法 constructor componentDidMount shouldComponentUpdate static getDerivedStateFromProps componentDidUpdate componentWillUnmount 事件处理方法 其它方法 render  4.4 高阶组件 [建议] 高阶组件返回新的组件类型时，添加displayName属性。 同时在displayName上声明高阶组件的存在。\n// Good let asPureComponent = Component =\u0026gt; { let componentName = Component.displayName || Component.name || \u0026#39;UnknownComponent\u0026#39;; return class extends PureComponent { static displayName = `asPure(${componentName})` render() { return \u0026lt;Component {..this.props} /\u0026gt;; } }; }; 5 组件实现 5.1 更新机制 [强制] 禁止为继承自PureComponent的组件编写shouldComponentUpdate实现。 参考React 的相关 Issue，在 React 的实现中，PureComponent并不直接实现shouldComponentUpdate，而是添加一个isReactPureComponent的标记，由CompositeComponent通过识别这个标记实现相关的逻辑。因此在PureComponent上自定义shouldComponentUpdate并无法享受super.shouldComponentUpdate的逻辑复用，也会使得这个继承关系失去意义。\n5.2 纯函数应用 [强制] 禁止在componentWillReceiveProps中包含除setState外的副作用。 解释：\ncomponentWillReceiveProps应当且仅应当用于props和state的数据同步，不得用于获取远程数据、更新外部状态、执行回调函数等逻辑。\n新版 React 使用getDerivedStateFromProps代替componentWillReceiveProps。\n[建议] 除顶层或路由级组件以外，所有组件均在概念上实现为纯组件（Pure Component）。 本条规则并非要求组件继承自PureComponent，“概念上的纯组件”的意思为一个组件在props和state没有变化（shallowEqual）的情况下，渲染的结果应保持一致。\n一个典型的非纯组件是使用了随机数或日期等函数：\nlet RandomNumber = () =\u0026gt; \u0026lt;span\u0026gt;{Math.random()}\u0026lt;/span\u0026gt;; let Clock = () =\u0026gt; \u0026lt;span\u0026gt;{Date.time()}\u0026lt;/span\u0026gt;; 非纯组件具备向上的“传染性”，即一个包含非纯组件的组件也必须是非纯组件，依次沿组件树结构向上。由于非纯组件无法通过shouldComponentUpdate优化渲染性能且具备传染性，因此要避免在非顶层或路由组件中使用。\n如果需要在组件树的某个节点使用随机数、日期等非纯的数据，应当由顶层组件生成这个值并通过props传递下来。对于使用 Redux 等应用状态管理的系统，可以在应用状态中存放相关值（如 Redux 使用 Action Creator 生成这些值并通过 Action 和 reducer 更新到 store 中）。\n6 JSX 6.1 标签 [强制] 没有子节点的组件使用自闭合语法。 解释：\nJSX 与 HTML 不同，所有元素均可以自闭合。\n示例：\n// Bad \u0026lt;Foo\u0026gt;\u0026lt;/Foo\u0026gt; \u0026lt;div\u0026gt;\u0026lt;/div\u0026gt; // Good \u0026lt;Foo /\u0026gt; \u0026lt;div /\u0026gt; [强制] 保持起始和结束标签在同一层缩进。 解释：\n对于标签前面有其它语句（如return的情况，使用括号进行换行和缩进）。\n对于直接return的函数组件，可以直接使用括号而省去大括号和return关键字：\nlet Message = () =\u0026gt; ( \u0026lt;div\u0026gt; \u0026lt;span\u0026gt;Hello World\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; ); 示例：\n// Bad class Message { render() { return \u0026lt;div\u0026gt; \u0026lt;span\u0026gt;Hello World\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt;; } } // Good class Message { render() { return ( \u0026lt;div\u0026gt; \u0026lt;span\u0026gt;Hello World\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt;; ); } } [强制] 自闭合标签的/\u0026gt;前添加一个空格。 示例：\n// Bad \u0026lt;Foo bar=\u0026#34;bar\u0026#34;/\u0026gt; \u0026lt;Foo bar=\u0026#34;bar\u0026#34; /\u0026gt; // Good \u0026lt;Foo bar=\u0026#34;bar\u0026#34; /\u0026gt; 6.2 属性 [强制] 对于多属性需要换行，从第一个属性开始，每个属性一行。 示例：\n// 没有子节点 \u0026lt;SomeComponent longProp={longProp} anotherLongProp={anotherLongProp} /\u0026gt; // 有子节点 \u0026lt;SomeComponent longProp={longProp} anotherLongProp={anotherLongProp} \u0026gt; \u0026lt;SomeChild /\u0026gt; \u0026lt;SomeChild /\u0026gt; \u0026lt;/SomeComponent\u0026gt; [强制] 以字符串字面量作为值的属性使用双引号（\u0026quot;），在其它类型表达式中的字符串使用单引号（'）。 示例：\n// Bad \u0026lt;Foo bar=\u0026#39;bar\u0026#39; /\u0026gt; \u0026lt;Foo style={{width: \u0026#34;20px\u0026#34;}} /\u0026gt; // Good \u0026lt;Foo bar=\u0026#34;bar\u0026#34; /\u0026gt; \u0026lt;Foo style={{width: \u0026#39;20px\u0026#39;}} /\u0026gt; [强制] 对于值为true的属性，省去值部分。 示例：\n// Bad \u0026lt;Foo visible={true} /\u0026gt; // Good \u0026lt;Foo visible /\u0026gt; [强制] 值为true的属性放在其它属性前面。 解释：\n将true类的值放在前面使得组件的声明更接近自然语言，提高可读性。\n示例：\n// Bad \u0026lt;Foo data={data} visible requireValidation /\u0026gt; // Good \u0026lt;Foo visible requireValidation data={data} /\u0026gt; [强制] 对于需要使用key的场合，提供一个唯一标识作为key属性的值，禁止使用可能会变化的属性（如索引）。 解释：\nkey属性是 React 在进行列表更新时的重要属性，如该属性会发生变化，渲染的性能和正确性都无法得到保证。\n示例：\n// Bad { list.map((item, index) =\u0026gt; \u0026lt;Foo key={index} {...item} /\u0026gt;); } // Good { list.map(item =\u0026gt; \u0026lt;Foo key={item.id} {...item} /\u0026gt;); } [建议] 避免在 JSX 的属性值中直接使用对象和函数表达式。 解释：\nPureComponent使用shallowEqual对props和state进行比较来决定是否需要渲染，而在 JSX 的属性值中使用对象、函数表达式会造成每一次的对象引用不同，从而shallowEqual会返回false，导致不必要的渲染。\n示例：\n// Bad class WarnButton { alertMessage(message) { alert(message); } render() { return ( \u0026lt;button type=\u0026#34;button\u0026#34; onClick={() =\u0026gt; this.alertMessage(this.props.message)} \u0026gt; 提示 \u0026lt;/button\u0026gt; ); } } // Good class WarnButton { @bind() alertMessage() { alert(this.props.message); } render() { return ( \u0026lt;button type=\u0026#34;button\u0026#34; onClick={this.alertMessage}\u0026gt; 提示 \u0026lt;/button\u0026gt; ); } } 6.2.1 层级 [建议] 将 JSX 的层级控制在 5 层以内。 解释：\nJSX 提供了基于组件的便携的复用形式，因此可以通过将结构中的一部分封装为一个函数组件来很好地拆分大型复杂的结构。层次过深的结构会带来过多缩进、可读性下降等缺点。如同控制函数内代码行数和分支层级一样，对 JSX 的层级进行控制可以有效提升代码的可维护性。\n示例：\n// Bad let List = ({ items }) =\u0026gt; ( \u0026lt;ul\u0026gt; {items.map(item =\u0026gt; ( \u0026lt;li\u0026gt; \u0026lt;header\u0026gt; \u0026lt;h3\u0026gt;{item.title}\u0026lt;/h3\u0026gt; \u0026lt;span\u0026gt;{item.subtitle}\u0026lt;/span\u0026gt; \u0026lt;/header\u0026gt; \u0026lt;section\u0026gt;{item.content}\u0026lt;/section\u0026gt; \u0026lt;footer\u0026gt; \u0026lt;span\u0026gt;{item.author}\u0026lt;/span\u0026gt;@\u0026lt;time\u0026gt;{item.postTime}\u0026lt;/time\u0026gt; \u0026lt;/footer\u0026gt; \u0026lt;/li\u0026gt; ))} \u0026lt;/ul\u0026gt; ); // Good let Header = ({ title, subtitle }) =\u0026gt; ( \u0026lt;header\u0026gt; \u0026lt;h3\u0026gt;{title}\u0026lt;/h3\u0026gt; \u0026lt;span\u0026gt;{subtitle}\u0026lt;/span\u0026gt; \u0026lt;/header\u0026gt; ); let Content = ({ content }) =\u0026gt; \u0026lt;section\u0026gt;{content}\u0026lt;/section\u0026gt;; let Footer = ({ author, postTime }) =\u0026gt; ( \u0026lt;footer\u0026gt; \u0026lt;span\u0026gt;{author}\u0026lt;/span\u0026gt;@\u0026lt;time\u0026gt;{postTime}\u0026lt;/time\u0026gt; \u0026lt;/footer\u0026gt; ); let Item = item =\u0026gt; ( \u0026lt;div\u0026gt; \u0026lt;Header {...item} /\u0026gt; \u0026lt;Content {...item} /\u0026gt; \u0026lt;Footer {...item} /\u0026gt; \u0026lt;/div\u0026gt; ); let List = ({ items }) =\u0026gt; \u0026lt;ul\u0026gt;{items.map(Item)}\u0026lt;/ul\u0026gt;; "});index.add({'id':659,'href':'/note-cs/docs/basic/pl/javascript/basic/practice/spec/baidu/typescript/','title':"Typescript",'content':"TypeScript 编码规范 1 前言\n2 代码风格\n2.1 环境\n2.2 文件\n2.3 命名\n3 语言特性\n3.1 变量\n3.2 类型\n3.3 条件\n3.4 循环\n3.5 数组\n3.6 对象\n3.7 函数\n3.8 类\n3.9 模块\n1 前言 随着 TypeScript 的不断发展，越来越多的开发者认可并使用 TypeScript 开发应用。本文档的目标是使 TypeScript 新特性的代码风格保持一致，并给予一些实践建议。\n本文档基本遵循 JavaScript Style Guide 与 \u0010ES-Next Style Guide。\n由于 TypeScript 依然在快速发展，本文档也将随时保持更新。更新内容主要涉及对新增的语言特性的格式规范化、实践指导，引擎与编译器环境变化的使用指导。\n任何问题或建议，欢迎跟我们讨论: fe-styleguide@baidu.com\n2 代码风格 2.1 环境 [强制] TypeScript 文件使用 .ts 扩展名。含 JSX 语法的 TypeScript 文件使用 .tsx 扩展名。 [建议] tsconfig.json 配置文件应开启 strict、noImplicitReturns、noUnusedLocals 选项。 [建议] tsconfig.json 配置文件应开启 allowSyntheticDefaultImports 选项。 示例：\n// good import React, { PureComponent } from \u0026#34;react\u0026#34;; // bad import * as React from \u0026#34;react\u0026#34;; [建议] 使用 VS Code 编写 TypeScript。 2.2 文件 [强制] 在文件结尾处，保留一个空行。 2.3 命名 [强制] 接口 使用 Pascal 命名法。 [强制] 接口名 不使用 I 作为前缀。 示例：\n// good interface ButtonProps { // ... } // bad interface IButtonProps { // ... } [强制] 类型别名 使用 Pascal 命名法。 示例：\n// good interface HeaderStateProps { // ... } interface HeaderDispatchProps { // ... } type HeaderProps = HeaderStateProps \u0026amp; HeaderDispatchProps; 3 语言特性 3.1 变量 [强制] 使用 const 声明 枚举 。 示例：\n// good const enum Directions { UP, DOWM, LEFT, RIGHT } // bad enum Directions { UP, DOWN, LEFT, RIGHT } 3.2 类型 [强制] 不应显式声明可以自动推导的类型。 示例：\n// good let shouldUpdate = false; // bad let shouldUpdate: boolean = false; [强制] 使用 string / number / boolean 声明基本类型，不使用 String / Number / Boolean。 示例：\n// good let str: string; // bad let str: String; [强制] 不使用 Object / Function 声明类型。 [强制] 数组元素为简单类型（非匿名且不含泛型）时，使用 T[] 声明类型，否则应使用 Array\u0026lt;T\u0026gt;。 [建议] 数组元素为不可变数据时，使用 ReadonlyArray\u0026lt;T\u0026gt; 声明类型。 示例：\n// good let files: string[]; let tokens: Array\u0026lt;string | number\u0026gt;; let buffer: Buffer[]; let responses: Array\u0026lt;Promise\u0026lt;number\u0026gt;\u0026gt;; // bad let files: Array\u0026lt;string\u0026gt;; let tokens: (string | number)[]; let buffer: Array\u0026lt;Buffer\u0026gt;; let responses: Promise\u0026lt;number\u0026gt;[]; [强制] 不使用 ! 声明对象属性非空。 示例：\n// good if (foo.bar \u0026amp;\u0026amp; foo.bar.baz) { // ... } // bad if (foo!.bar!.baz) { // ... } [建议] 不使用 any 声明类型。 示例：\n// good const identity = \u0026lt;T\u0026gt;(x: T) =\u0026gt; x; // bad const identity = (x: any) =\u0026gt; x; [强制] 使用 as 进行类型声明转换，不使用 \u0026lt;\u0026gt; 。 示例：\n// good const root = document.getElementById(\u0026#34;root\u0026#34;) as HTMLDivElement; // bad const root = \u0026lt;HTMLDivElement\u0026gt;document.getElementById(\u0026#34;root\u0026#34;); [强制] 接口不应为空。 [强制] 接口中同一函数重载的类型声明需相邻。 示例：\n// good interface AnyInterface { foo(); foo(x: string); bar(); bar(x: number); } // bad interface AnyInterface { foo(); bar(); foo(x: string); bar(x: number); } 3.3 条件 [强制] 使用 === 或 !== 判断相等性，不使用 == 或 !=。 示例：\n// good if (foo !== null \u0026amp;\u0026amp; foo !== undefined) { // ... } // bad if (foo != null) { // ... } 3.4 循环 [建议] 使用 Object.keys / Object.values / Object.entries / Object.getOwnPropertyNames 遍历对象，不使用 for .. in 。 示例：\n// good Object.keys(obj).forEach(key =\u0026gt; /* ... */); // bad for (const key in obj) { if (obj.hasOwnProperty(key)) { // ...  } } [建议] 索引仅用于获取数组当前被迭代的项时，使用 for .. of 遍历数组，不使用 for 。 示例：\n// good for (const item of items) { // ... } // bad for (let i = 0; i \u0026lt; items.length; i++) { const item = items[i]; // ... } 3.5 数组 [建议] 使用 ... 进行数组浅拷贝，不使用 Array.from / Array.prototype.slice 。 示例：\n// good const copies = [...items]; // bad const copies = items.slice(); // worst let copies = []; for (let i = 0; i \u0026lt; items.length; i++) { copies.push(items[i]); } [建议] 使用 ... 将类数组对象转化为数组，不使用 Array.from / Array.prototype.slice 。 示例：\n// good const elements = [...document.querySelectorAll(\u0026#34;.foo\u0026#34;)]; // bad const element = Array.from(document.querySelectorAll(\u0026#34;.foo\u0026#34;)); // worst const element = Array.prototype.slice.call(document.querySelectorAll(\u0026#34;.foo\u0026#34;)); 3.6 对象 [强制] 使用 ... 进行对象浅拷贝，不使用 Object.assign 。 示例：\n// good this.setState(state =\u0026gt; ({ ...state, clicked: true })); // bad this.setState(state =\u0026gt; Object.assign({}, state, { clicked: true })); 3.7 函数 [强制] 避免 return undefined ，应直接 return。 示例：\n// good function foo(bar: boolean) { if (!bar) { return; } } // bad function foo(bar: boolean) { if (!bar) { return undefined; } } 3.8 类 [建议] 每个文件中最多声明一个类。 [强制] 类成员的可访问性为 public 时，不应显式声明。 [建议] 构造函数可忽略时，应忽略。 [建议] 类成员之间使用空行隔开。 示例：\n// good class Button extends PureComponent\u0026lt;ButtonProps, ButtonState\u0026gt; { readonly state: ButtonState = { clicked: false }; render() { // ...  } } // bad class Button extends PureComponent\u0026lt;ButtonProps, ButtonState\u0026gt; { public state: ButtonState = { clicked: false }; constructor(props: ButtonProps) { super(props); } public render() { // ...  } } [建议] 构造函数初始化实例属性时，应尽量使用参数属性。 [建议] 构造函数的参数中，作为属性的参数应排列于其他参数前。 示例：\n// good class AppComponent { constructor(private readonly heroService: HeroService) {} } // bad class AppComponent { private readonly heroService: HeroService; constructor(heroService: HeroService) { this.heroService = heroService; } } 3.9 模块 [强制] 使用 ECMAScript 2015 标准的模块系统。 [强制] 除类型声明文件外，不使用 module / namespace 关键字。 [强制] 不使用 /// \u0026lt;reference path= \u0026gt; 。 示例：\n// good import foo from \u0026#34;foo\u0026#34;; // bad import foo = require(\u0026#34;foo\u0026#34;); [强制] 对于同一个模块路径，仅 import 一次。 示例：\n// good import React, { PureComponent } from \u0026#34;react\u0026#34;; // bad import React from \u0026#34;react\u0026#34;; import { PureComponent } from \u0026#34;react\u0026#34;; [建议] 对于使用 webpack 等构建工具的项目，在模块中引入其他资源（如样式、图片等）时，为资源编写类型声明文件，或使用合适的 loader 生成类型声明文件。 示例：\n// good  // Button.scss.d.ts export clicked: string; // logo.png.d.ts declare const logo: string; export default logo; // Button.tsx import styles from \u0026#39;./Button.scss\u0026#39;; import logo from \u0026#39;./logo.png\u0026#39;; // bad const styles = require\u0026lt;any\u0026gt;(\u0026#39;./Button.scss\u0026#39;); const logo = require\u0026lt;string\u0026gt;(\u0026#39;./logo.png\u0026#39;); "});index.add({'id':660,'href':'/note-cs/docs/basic/pl/javascript/basic/practice/spec/baidu/vue/','title':"Vue",'content':"Vue 组件代码规范 1 前言\n2 代码风格\n2.1 缩进\n2.2 单行最长限制\n2.3 模块书写顺序\n3 template 部分\n3.1 根节点\n3.2 标签\n3.3 属性\n3.4 指令\n3.5 插值（Mustache）\n3.6 空格\n3.7 变量\n4 javascript 部分\n4.1 props\n4.2 data\n4.3 变量\n4.4 其他\n5 style 部分\n6 参考\n1 前言 任何问题或建议，欢迎跟我们讨论: fe-styleguide@baidu.com\n2 代码风格 2.1 缩进 [强制] 使用 4 个空格做为一个缩进层级，不允许使用 2 个空格或 tab 字符 2.2 单行最长限制 [强制] 每行不得超过 120 个字符 2.3 模块书写顺序 [建议] template -\u0026gt; script -\u0026gt; style 3 template 部分 3.1 根节点 [强制] template 根节点只允许包含一个直接子节点，以下情况都是不允许的：  根结点为空； 根结点是文字； 根结点有多个元素； 在根结点使用循环； 在根结点使用 template 和 slot； 在根结点使用 v-if，但是没有 v-else；  // bad \u0026lt;template\u0026gt;\u0026lt;/template\u0026gt; \u0026lt;template\u0026gt;hello\u0026lt;/template\u0026gt; \u0026lt;template \u0026gt;\u0026lt;div\u0026gt;one\u0026lt;/div\u0026gt; \u0026lt;div\u0026gt;two\u0026lt;/div\u0026gt;\u0026lt;/template \u0026gt; \u0026lt;template\u0026gt;\u0026lt;div v-for=\u0026#34;x in list\u0026#34;\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/template\u0026gt; \u0026lt;template\u0026gt;\u0026lt;template\u0026gt;hello\u0026lt;/template\u0026gt;\u0026lt;/template\u0026gt; \u0026lt;template\u0026gt;\u0026lt;div v-if=\u0026#34;title\u0026#34;\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/template\u0026gt; // good \u0026lt;template\u0026gt;\u0026lt;div\u0026gt;one\u0026lt;/div\u0026gt;\u0026lt;/template\u0026gt; 3.2 标签 [强制] 自定义组件的标签名不得使用 HTML 中默认已定义的标签（reserved HTML elements），要求至少由两个单词组成，并且符合 kebab-case 解释：\n避免和 HTML 保留字段冲突导致错误。\n// bad \u0026lt;template\u0026gt; \u0026lt;sub /\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import OtherComponent from \u0026#34;./OtherComponent.vue\u0026#34;; export default { components: { sub: OtherComponent } }; \u0026lt;/script\u0026gt; // good \u0026lt;template\u0026gt; \u0026lt;other-component /\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import OtherComponent from \u0026#34;./OtherComponent.vue\u0026#34;; export default { components: { OtherComponent } }; \u0026lt;/script\u0026gt; // bad \u0026lt;component /\u0026gt; \u0026lt;mycomponent /\u0026gt; \u0026lt;myComponent /\u0026gt; \u0026lt;MyComponent /\u0026gt; // good \u0026lt;my-component /\u0026gt;  预留的 html 标签包括：\n  html,body,base,head,link,meta,style,title,address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,menuitem,summary,content,element,shadow,template,blockquote,iframe,tfoot；\n  预留的 SVG 标签包括：\n  svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,foreignObject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view\n [强制]html void element 不需要闭合，其它类型标签都需要闭合 // bad \u0026lt;input\u0026gt;\u0026lt;/input\u0026gt; \u0026lt;br\u0026gt;\u0026lt;/br\u0026gt; // good \u0026lt;input\u0026gt; \u0026lt;br\u0026gt; [强制] 非根结点的 template 标签里必须有一个以上的子结点 // bad \u0026lt;ul\u0026gt; \u0026lt;template\u0026gt; \u0026lt;li\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;/ul\u0026gt; // good \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; // good \u0026lt;ul\u0026gt; \u0026lt;template\u0026gt; \u0026lt;li\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;/ul\u0026gt; [强制] template 标签上不能带有 key 属性 // bad \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;template key=\u0026#34;x\u0026#34;\u0026gt;\u0026lt;/template\u0026gt; \u0026lt;template v-bind:key=\u0026#34;y\u0026#34;\u0026gt;\u0026lt;/template\u0026gt; \u0026lt;template :key=\u0026#34;z\u0026#34;\u0026gt;\u0026lt;/template\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; // good \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;div key=\u0026#34;x\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;template\u0026gt;\u0026lt;/template\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; [强制] 如果自定义标签中没有内容，需要以自闭合标签形式出现 // bad \u0026lt;c-title :url=\u0026#34;url\u0026#34; :label-type=\u0026#34;type\u0026#34;\u0026gt;\u0026lt;/c-title\u0026gt; // good \u0026lt;c-title :url=\u0026#34;url\u0026#34; :label-type=\u0026#34;type\u0026#34; /\u0026gt; [强制] 标签右括号 \u0026gt; 的位置：  元素只有一行时，右括号与元素保持在同一行。 多行元素（元素最后一个属性与左括号 \u0026lt; 不在同一行）时，右括号 \u0026gt; 需要另起一行，缩进与左括号 \u0026lt; 保持对齐。  // bad \u0026lt;div id=\u0026#34;foo\u0026#34; class=\u0026#34;bar\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; // good \u0026lt;div id=\u0026#34;foo\u0026#34; class=\u0026#34;bar\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; // bad \u0026lt;div id=\u0026#34;foo\u0026#34; class=\u0026#34;bar\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; // good \u0026lt;div id=\u0026#34;foo\u0026#34; class=\u0026#34;bar\u0026#34;\u0026gt; some message \u0026lt;/div\u0026gt; // bad \u0026lt;c-title :text=\u0026#34;text\u0026#34; :url=\u0026#34;url\u0026#34; :label-type=\u0026#34;type\u0026#34; /\u0026gt; // good \u0026lt;c-title :text=\u0026#34;text\u0026#34; :url=\u0026#34;url\u0026#34; :label-type=\u0026#34;type\u0026#34; /\u0026gt; [建议] 自闭合标签的 /\u0026gt; 前不用添加空格 // bad \u0026lt;c-title :url=\u0026#34;url\u0026#34; :label-type=\u0026#34;type\u0026#34; /\u0026gt; // good \u0026lt;div\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;c-title :url=\u0026#34;url\u0026#34; :label-type=\u0026#34;type\u0026#34; /\u0026gt; 3.3 属性 [强制] 属性值必须用双引号包围 // bad \u0026lt;div class=\u0026#34;c-color\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; // good \u0026lt;div class=\u0026#34;c-color\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; [强制] 模板中的属性命名需要符合 kebab-case // bad \u0026lt;my-component greetingText=\u0026#34;hi\u0026#34; /\u0026gt; // good \u0026lt;my-component greeting-text=\u0026#34;hi\u0026#34; /\u0026gt; [强制] class / style 属性值不能设置空字符串 // bad \u0026lt;div class=\u0026#34;\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div style=\u0026#34;\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; // good \u0026lt;div\u0026gt;\u0026lt;/div\u0026gt; [建议] 布尔类型的属性值为 true 时，建议不添加属性值 // bad \u0026lt;c-title text=\u0026#34;带箭头标题\u0026#34; :arrow=\u0026#34;true\u0026#34; /\u0026gt; // good \u0026lt;input type=\u0026#34;text\u0026#34; disabled /\u0026gt; \u0026lt;c-title text=\u0026#34;带箭头标题\u0026#34; arrow /\u0026gt; \u0026lt;c-title text=\u0026#34;带箭头标题\u0026#34; :arrow=\u0026#34;false\u0026#34; /\u0026gt; [强制] 当组件的属性多于 2 个时，必须分成多行，每行写一个属性；只有属性个数小于或等于 2 个时，可以写在一行内 // bad \u0026lt;c-title :text=\u0026#34;text\u0026#34; :url=\u0026#34;url\u0026#34; :label-type=\u0026#34;type\u0026#34; /\u0026gt; // good \u0026lt;c-title :text=\u0026#34;text\u0026#34; :url=\u0026#34;url\u0026#34; /\u0026gt; \u0026lt;c-title :text=\u0026#34;text\u0026#34; :url=\u0026#34;url\u0026#34; :label-type=\u0026#34;type\u0026#34; /\u0026gt; [建议] 当元素有多个属性时，应该按照统一的顺序书写 优先级顺序：\n 定义（提供组件的选项）  is   列表渲染（创建多个变化的相同元素）  v-for   条件渲染（元素是否渲染/显示）  v-if v-else-if v-else v-show v-cloak   渲染方式（改变元素的渲染方式）  v-pre/v-once   全局感知（需要超越组件的知识）  id   唯一的特性（需要唯一值的特性）  ref key slot   双向绑定（把绑定和事件结合起来）  v-model   未绑定的属性 其它绑定（所有普通的绑定）  v-bind   事件（组件事件监听器）  v-on   内容（覆写元素的内容）  v-html v-text    [强制] 不能有重复的属性，class 和 style 除外 解释：\n这里重复的属性包括以下两种情况：\n 属性名完全一样：如有多个 foo 或者有多个 :foo 有一个普通属性和一个 v-bind 动态绑定的属性，动态绑定的属性名与普通属性名重复  // bad \u0026lt;c-title foo=\u0026#34;abc\u0026#34; :foo=\u0026#34;def\u0026#34; /\u0026gt; \u0026lt;c-title foo=\u0026#34;def\u0026#34; foo=\u0026#34;abc\u0026#34; /\u0026gt; \u0026lt;c-title class=\u0026#34;def\u0026#34; class=\u0026#34;abc\u0026#34; /\u0026gt; \u0026lt;c-title style=\u0026#34;def\u0026#34; style=\u0026#34;abc\u0026#34; /\u0026gt; // good \u0026lt;c-title :foo=\u0026#34;def\u0026#34; /\u0026gt; \u0026lt;c-title foo=\u0026#34;abc\u0026#34; /\u0026gt; \u0026lt;c-title class=\u0026#34;c-color\u0026#34; :class=\u0026#34;{\u0026#39;c-selected\u0026#39;: selected}\u0026#34; /\u0026gt; \u0026lt;c-title style=\u0026#34;color: #000;\u0026#34; :style=\u0026#34;{width: \u0026#39;100px\u0026#39;}\u0026#34; /\u0026gt; [建议] slot 命名采用 kebab-case \u0026lt;slot name=\u0026#34;header-left\u0026#34;\u0026gt;\u0026lt;/slot\u0026gt; \u0026lt;div slot=\u0026#34;header-left\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; [建议] ref 命名采用 PascalCase \u0026lt;div ref=\u0026#34;userInfo\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; 3.4 指令 [强制] 在使用 v-for 的元素上添加 key，以便维护内部组件及其子树的状态 \u0026lt;ul\u0026gt; \u0026lt;li v-for=\u0026#34;todo in todos\u0026#34; :key=\u0026#34;todo.id\u0026#34;\u0026gt; {{ todo.text }} \u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; [建议] 不要把 v-if 和 v-for 同时用在同一个元素上 解释：\n当 Vue 处理指令时，v-for 比 v-if 具有更高的优先级。所以如果想要使用 v-if 判断 v-for 元素列表是否显示，将两个指令同时应用在同一个元素的方法就是错误的。引入这个规则是为了避免引起困惑。\n// bad \u0026lt;ul\u0026gt; \u0026lt;li v-for=\u0026#34;user in users\u0026#34; v-if=\u0026#34;user.isActive\u0026#34; :key=\u0026#34;user.id\u0026#34;\u0026gt; {{ user.name }} \u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; // good \u0026lt;template\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li v-for=\u0026#34;user in activeUsers\u0026#34; :key=\u0026#34;user.id\u0026#34;\u0026gt; {{ user.name }} \u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; export default { computed: { activeUsers: function() { return this.users.filter(function(user) { return user.isActive; }); } } }; \u0026lt;/script\u0026gt; [建议] 以下指令统一使用缩写  使用 : 表示 v-bind: 使用 @ 表示 v-on:  3.5 插值（Mustache） [建议] 插值左右添加一个空格 // bad \u0026lt;div\u0026gt;{{ text }}\u0026lt;/div\u0026gt; \u0026lt;div\u0026gt;{{text}}\u0026lt;/div\u0026gt; // good \u0026lt;div\u0026gt;{{ text }}\u0026lt;/div\u0026gt; 3.6 空格 [强制] 不能有多余空格 // bad \u0026lt;div class=\u0026#34;foo\u0026#34; :style=\u0026#34;bar\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; // good \u0026lt;div class=\u0026#34;foo\u0026#34; :style=\u0026#34;bar\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; 3.7 变量 [强制] 不能有多余的变量 // bad \u0026lt;ol\u0026gt; \u0026lt;!-- \u0026#34;i\u0026#34; is defined but never used. --\u0026gt; \u0026lt;li v-for=\u0026#34;i in 5\u0026#34;\u0026gt;item\u0026lt;/li\u0026gt; \u0026lt;/ol\u0026gt; // good \u0026lt;ol\u0026gt; \u0026lt;li v-for=\u0026#34;i in 5\u0026#34;\u0026gt;{{ i }}\u0026lt;/li\u0026gt; \u0026lt;/ol\u0026gt; [强制] 禁止在插值中使用 this // bad \u0026lt;a :href=\u0026#34;this.url\u0026#34;\u0026gt; {{ this.text }} \u0026lt;/a\u0026gt; // good \u0026lt;a :href=\u0026#34;url\u0026#34;\u0026gt; {{ text }} \u0026lt;/a\u0026gt; 4 javascript 部分 4.1 props [强制] 指定 props 类型 // bad \u0026lt;script\u0026gt; export default { props: [\u0026#39;status\u0026#39;] }; \u0026lt;/script\u0026gt; // good \u0026lt;script\u0026gt; export default { props: { status: String } }; [强制] 如果 props 没有指定为 required 或者 required 为 false，则需要指定默认值 // bad \u0026lt;script\u0026gt; export default { props: { a: Number, b: [Number, String], c: { type: Number }, d: { type: Number, required: false } } }; \u0026lt;/script\u0026gt; // good \u0026lt;script\u0026gt; export default { props: { a: { type: Number, required: true }, b: { type: [Number, String], default: 0 }, c: { type: Number, default: 0, required: false } } }; \u0026lt;/script\u0026gt; [强制] props 提供的默认值必须满足校验条件 // bad \u0026lt;script\u0026gt; export default { props: { propA: { type: String, default: {} }, propB: { type: String, default: [] }, propC: { type: Object, default: [] }, propD: { type: Array, default: [] }, propE: { type: Object, default: { message: \u0026#39;hello\u0026#39; } } } }; \u0026lt;/script\u0026gt; // good \u0026lt;script\u0026gt; export default { props: { propA: Number, propB: [String, Number], propD: { type: Number, default: 100 }, propE: { type: Object, default() { return { message: \u0026#39;hello\u0026#39; }; } } } }; [强制] 在 props 中声明的属性，其属性名应该始终符合 camelCase // bad \u0026lt;script\u0026gt; export default { props: { \u0026#34;greeting-text\u0026#34;: String } }; \u0026lt;/script\u0026gt; // good \u0026lt;script\u0026gt; export default { props: { greetingText: String } }; \u0026lt;/script\u0026gt; 4.2 data [强制] data 必须是一个函数 // bad \u0026lt;script\u0026gt; export default { data: { b: 1 } }; \u0026lt;/script\u0026gt; // good \u0026lt;script\u0026gt; export default { data() { return { b: 1 }; } }; \u0026lt;/script\u0026gt; [强制] data 中禁止使用 computed 中的变量 // bad \u0026lt;script\u0026gt; export default { props: { a: { type: String, default: 0 } }, data() { return { d: this.f }; }, computed: { f() { return this.a * 10; } } }; \u0026lt;/script\u0026gt; [强制] props, data, computed, methods 中不能有重复的 key // bad \u0026lt;script\u0026gt; export default { props: { foo: String }, data() { return { foo: null }; }, computed: { foo() { return \u0026#34;foo\u0026#34;; } } }; \u0026lt;/script\u0026gt; // good \u0026lt;script\u0026gt; export default { props: { foo: String }, data() { return { bar: null }; }, computed: { baz() { return foo + bar; } } }; \u0026lt;/script\u0026gt; 4.3 变量 [强制] 不能使用 Vue 中的保留字段命名变量 解释：\nVue 使用 _ 前缀来定义其自身的私有属性，所以使用相同的前缀 (比如 _update) 有覆写实例属性的风险。即便你检查确认 Vue 当前版本没有用到这个属性名，也不能保证和将来的版本没有冲突。\n对于 $ 前缀来说，其在 Vue 生态系统中的目的是暴露给用户的一个特殊的实例属性，所以把它用于私有属性并不合适。\n不过，我们推荐把这两个前缀结合为 $_，作为一个用户定义的私有属性的约定，以确保不会和 Vue 自身相冲突。\n// bad \u0026lt;script\u0026gt; export default { props: { $el: String }, data() { return { _foo: null }; }, computed: { $on() { return 2; } }, methods: { $nextTick() {} } }; \u0026lt;/script\u0026gt; 4.4 其它 [建议] 组件中使用 $emit 事件时携带的参数，个数不应该超过 2 个。建议将数据参数以 Object 形式传递，将事件参数 event 放在最后 // bad onClick(event) { this.$emit(\u0026#39;click\u0026#39;, this.value1, this.value2, event); } // good onClick(event) { this.$emit( \u0026#39;click\u0026#39;, { value1: this.value1, value2: this.value2 }, event ); } // good onClick(event) { this.$emit(\u0026#39;click\u0026#39;, event); } 5 style 部分 [建议] 为组件样式设置作用域 \u0026lt;style scoped\u0026gt; .button { border: none; border-radius: 2px; } \u0026lt;/style\u0026gt; 6 参考  vue 代码风格指南 ecomfe HTML 编码规范 ecomfe JavaScript 编码规范 ecomfe JavaScript 编码规范 - ESNext 补充篇（草案） ecomfe CSS 编码规范 ecomfe less 编码规范  "});index.add({'id':661,'href':'/note-cs/docs/','title':"Docs",'content':""});})();